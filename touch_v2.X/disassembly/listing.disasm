Disassembly Listing for touch_v2
Generated From:
/root/MPLABXProjects/vtouch_v2/touch_v2.X/dist/default/production/touch_v2.X.production.elf
Dec 27, 2019 9:30:31 AM

---  /tmp/xcXTdbBvO.s  ----------------------------------------------------------------------------------
19FEA  0E62     MOVLW 0x62
19FEC  6EF6     MOVWF 0xFF6, ACCESS
19FEE  0E68     MOVLW 0x68
19FF0  6EF7     MOVWF 0xFF7, ACCESS
19FF2  0E01     MOVLW 0x1
19FF4  6EF8     MOVWF 0xFF8, ACCESS
19FF6  EE01     LFSR 0, 0x4FF
19FFA  EE20     LFSR 2, 0x327
19FFE  0009     TBLRD*+
1A006  50DD     MOVF 0xFDD, W, ACCESS
1A008  50D9     MOVF 0xFD9, W, ACCESS
1A00A  E1F9     BNZ 0x9FFE
1A00C  50DA     MOVF 0xFDA, W, ACCESS
1A00E  E1F7     BNZ 0x9FFE
1A010  0E48     MOVLW 0x48
1A012  6EF6     MOVWF 0xFF6, ACCESS
1A014  0E9C     MOVLW 0x9C
1A016  6EF7     MOVWF 0xFF7, ACCESS
1A018  0E01     MOVLW 0x1
1A01A  6EF8     MOVWF 0xFF8, ACCESS
1A01C  EE00     LFSR 0, 0x100
1A020  EE20     LFSR 2, 0xEF
1A024  0009     TBLRD*+
1A02C  50DD     MOVF 0xFDD, W, ACCESS
1A02E  50D9     MOVF 0xFD9, W, ACCESS
1A030  E1F9     BNZ 0xA024
1A032  0E16     MOVLW 0x16
1A034  6EF6     MOVWF 0xFF6, ACCESS
1A036  0EBD     MOVLW 0xBD
1A038  6EF7     MOVWF 0xFF7, ACCESS
1A03A  0E01     MOVLW 0x1
1A03C  6EF8     MOVWF 0xFF8, ACCESS
1A03E  EE00     LFSR 0, 0xF0
1A042  EE20     LFSR 2, 0xE
1A046  0009     TBLRD*+
1A04E  50DD     MOVF 0xFDD, W, ACCESS
1A050  50D9     MOVF 0xFD9, W, ACCESS
1A052  E1F9     BNZ 0xA046
1A054  EE02     LFSR 0, 0x826
1A058  EE20     LFSR 2, 0x1E2
1A05C  6AEE     CLRF 0xFEE, ACCESS
1A05E  50DD     MOVF 0xFDD, W, ACCESS
1A060  50D9     MOVF 0xFD9, W, ACCESS
1A062  E1FC     BNZ 0xA05C
1A064  50DA     MOVF 0xFDA, W, ACCESS
1A066  E1FA     BNZ 0xA05C
1A068  EE01     LFSR 0, 0x400
1A06C  EE20     LFSR 2, 0xFF
1A070  6AEE     CLRF 0xFEE, ACCESS
1A072  50DD     MOVF 0xFDD, W, ACCESS
1A074  50D9     MOVF 0xFD9, W, ACCESS
1A076  E1FC     BNZ 0xA070
1A078  50DA     MOVF 0xFDA, W, ACCESS
1A07A  E1FA     BNZ 0xA070
1A07C  EE00     LFSR 0, 0x300
1A080  0EC6     MOVLW 0xC6
1A082  6AEE     CLRF 0xFEE, ACCESS
1A084  06E8     DECF 0xFE8, F, ACCESS
1A086  E1FD     BNZ 0xA082
1A088  EE00     LFSR 0, 0x200
1A08C  0EE7     MOVLW 0xE7
1A08E  6AEE     CLRF 0xFEE, ACCESS
1A090  06E8     DECF 0xFE8, F, ACCESS
1A092  E1FD     BNZ 0xA08E
1A094  EE00     LFSR 0, 0x60
1A098  0E77     MOVLW 0x77
1A09A  6AEE     CLRF 0xFEE, ACCESS
1A09C  06E8     DECF 0xFE8, F, ACCESS
1A09E  E1FD     BNZ 0xA09A
1A0A0  EE00     LFSR 0, 0x3A
1A0A4  0E0E     MOVLW 0xE
1A0A6  6AEE     CLRF 0xFEE, ACCESS
1A0A8  06E8     DECF 0xFE8, F, ACCESS
1A0AA  E1FD     BNZ 0xA0A6
1A0AC  0E08     MOVLW 0x8
1A0AE  6ED5     MOVWF 0xFD5, ACCESS
1A0B0  0E00     MOVLW 0x0
1A0B2  6ED6     MOVWF 0xFD6, ACCESS
1A0B4  0E00     MOVLW 0x0
1A0B6  6ED7     MOVWF 0xFD7, ACCESS
1A0B8  0100     MOVLB 0x0
1A0BA  EF22     GOTO 0x11244
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/timers.c  ------------------------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "vconfig.h"
5:             #include "timers.h"
6:             
7:             extern volatile uint16_t tickCount[TMR_COUNT];
8:             
9:             //**********************************************************************************************************************
10:            // Start one of the software timers
11:            
12:            void StartTimer(const uint8_t timer, const uint16_t count)
13:            {
14:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
1B2D4  0EFD     MOVLW 0xFD
1B2D8  FF8C     NOP
1B2DA  F00B     NOP
1B2DC  0EFE     MOVLW 0xFE
1B2E0  FF8C     NOP
1B2E2  F00C     NOP
1B2E4  90D8     BCF 0xFD8, 0, ACCESS
1B2E6  340B     RLCF wtemp5, W, ACCESS
1B2E8  6E09     MOVWF ltemp2, ACCESS
1B2EA  340C     RLCF 0xC, W, ACCESS
1B2EC  6E0A     MOVWF ttemp3, ACCESS
1B2EE  0EFF     MOVLW 0xFF
1B2F0  50E3     MOVF 0xFE3, W, ACCESS
1B2F2  0D02     MULLW 0x2
1B2F4  0E7D     MOVLW 0x7D
1B2F6  24F3     ADDWF 0xFF3, W, ACCESS
1B2F8  6ED9     MOVWF 0xFD9, ACCESS
1B2FA  0E02     MOVLW 0x2
1B2FC  20F4     ADDWFC 0xFF4, W, ACCESS
1B2FE  6EDA     MOVWF 0xFDA, ACCESS
1B302  F027     NOP
1B304  FFDE     NOP
1B308  F02B     NOP
1B30A  FFDD     NOP
15:            }
1B30C  52E5     MOVF 0xFE5, F, ACCESS
1B30E  52E5     MOVF 0xFE5, F, ACCESS
1B310  52E5     MOVF 0xFE5, F, ACCESS
1B312  0012     RETURN 0
16:            
17:            //**********************************************************************************************************************
18:            // Check if one of the software software timers has timed out
19:            
20:            bool TimerDone(const uint8_t timer)
21:            {
22:            	ClrWdt(); // reset the WDT timer
1B7E6  0004     CLRWDT
23:            	if (tickCount[timer] == 0) { //Check if counted down to zero
1B7E8  0EFF     MOVLW 0xFF
1B7EA  50E3     MOVF 0xFE3, W, ACCESS
1B7EC  0D02     MULLW 0x2
1B7EE  0E7D     MOVLW 0x7D
1B7F0  24F3     ADDWF 0xFF3, W, ACCESS
1B7F2  6ED9     MOVWF 0xFD9, ACCESS
1B7F4  0E02     MOVLW 0x2
1B7F6  20F4     ADDWFC 0xFF4, W, ACCESS
1B7F8  6EDA     MOVWF 0xFDA, ACCESS
1B7FA  50DE     MOVF 0xFDE, W, ACCESS
1B7FC  10DE     IORWF 0xFDE, W, ACCESS
1B7FE  A4D8     BTFSS 0xFD8, 2, ACCESS
1B800  D002     BRA 0xB806
24:            		return true; //then return true
1B802  0E01     MOVLW 0x1
1B804  D001     BRA 0xB808
25:            	}
26:            	return false; //else return false
1B806  0E00     MOVLW 0x0
1B808  6E01     MOVWF ltemp0, ACCESS
27:            }
1B80A  52E5     MOVF 0xFE5, F, ACCESS
1B80C  0012     RETURN 0
28:            
29:            //**********************************************************************************************************************
30:            // Simple delay for n milliseconds (blocking)
31:            
32:            void WaitMs(const uint16_t numMilliseconds)
33:            {
34:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
1B4FC  0EFE     MOVLW 0xFE
1B500  FF8F     NOP
1B502  FFE6     NOP
1B506  FF8F     NOP
1B508  FFE6     NOP
1B50A  0E00     MOVLW 0x0
1B50C  6EE6     MOVWF 0xFE6, ACCESS
1B50E  EC6A     CALL 0x1B2D4, 0
1B510  F0D9     NOP
35:            	while (!TimerDone(TMR_INTERNAL)) {
1B512  D005     BRA 0xB51E
1B51E  0E00     MOVLW 0x0
1B520  6EE6     MOVWF 0xFE6, ACCESS
1B522  ECF3     CALL 0x1B7E6, 0
1B524  F0DB     NOP
1B526  5001     MOVF ltemp0, W, ACCESS
1B528  B4D8     BTFSC 0xFD8, 2, ACCESS
1B52A  D7F4     BRA 0xB514
36:            		Nop();
1B514  F000     NOP
37:            		Nop();
1B516  F000     NOP
38:            		Nop();
1B518  F000     NOP
39:            		Nop();
1B51A  F000     NOP
40:            		ClrWdt(); // reset the WDT timer
1B51C  0004     CLRWDT
41:            		//		Idle();
42:            	} //Enter idle mode to reduce power while waiting
43:            } //(timer interrupt will wake part from idle)
1B52C  52E5     MOVF 0xFE5, F, ACCESS
1B52E  52E5     MOVF 0xFE5, F, ACCESS
1B530  0012     RETURN 0
44:            
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/ringbufs.c  ----------------------------------------------
1:             #include  <string.h>
2:             #include  "ringbufs.h"
3:             
4:             /*
5:              * general ring buffer fuctions from the internet
6:              */
7:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
8:             {
9:             	uint8_t my_value = value + 1;
10:            	if (my_value >= modulus) {
11:            		my_value = 0;
12:            	}
13:            	return my_value;
14:            }
15:            
16:            uint8_t modulo_dec(const uint8_t value, const uint8_t modulus)
17:            {
18:            	uint8_t my_value = (0 == value) ? (modulus - 1) : (value - 1);
19:            	return my_value;
20:            }
21:            
22:            void ringBufS_init(volatile ringBufS_t *_this)
23:            {
24:            	/*****
25:            	  The following clears:
26:            	    -> buf
27:            	    -> head
28:            	    -> tail
29:            	    -> count
30:            	  and sets head = tail
31:            	 ***/
32:            	memset((void*)_this, 0, sizeof(*_this));
1B7BE  0E43     MOVLW 0x43
1B7C0  6EE6     MOVWF 0xFE6, ACCESS
1B7C2  0E00     MOVLW 0x0
1B7C4  6EE6     MOVWF 0xFE6, ACCESS
1B7C6  0E00     MOVLW 0x0
1B7C8  6EE6     MOVWF 0xFE6, ACCESS
1B7CA  0E00     MOVLW 0x0
1B7CC  6EE6     MOVWF 0xFE6, ACCESS
1B7CE  0EFA     MOVLW 0xFA
1B7D2  FF8F     NOP
1B7D4  FFE6     NOP
1B7D8  FF8F     NOP
1B7DA  FFE6     NOP
1B7DC  ECC5     CALL 0x16B8A, 0
1B7DE  F0B5     NOP
33:            }
1B7E0  52E5     MOVF 0xFE5, F, ACCESS
1B7E2  52E5     MOVF 0xFE5, F, ACCESS
1B7E4  0012     RETURN 0
34:            
35:            int8_t ringBufS_empty(ringBufS_t *_this)
36:            {
37:            	return(0 == _this->count);
38:            }
39:            
40:            int8_t ringBufS_full(ringBufS_t *_this)
41:            {
42:            	return(_this->count >= RBUF_SIZE);
43:            }
44:            
45:            uint8_t ringBufS_get(ringBufS_t *_this)
46:            {
47:            	uint8_t c;
48:            	if (_this->count > 0) {
49:            		c = _this->buf[_this->tail];
50:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
51:            		--_this->count;
52:            	} else {
53:            		c = 0; // return null with empty buffer
54:            	}
55:            	return(c);
56:            }
57:            
58:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
59:            {
60:            	if (_this->count < RBUF_SIZE) {
61:            		_this->buf[_this->head] = c;
62:            		_this->head = modulo_inc(_this->head, RBUF_SIZE);
63:            		++_this->count;
64:            	}
65:            }
66:            
67:            void ringBufS_put_dma(ringBufS_t *_this, const uint8_t c)
68:            {
69:            	if (_this->count < RBUF_SIZE) {
1A468  0EFE     MOVLW 0xFE
1A46C  FF8C     NOP
1A46E  F00B     NOP
1A470  0EFF     MOVLW 0xFF
1A474  FF8C     NOP
1A476  F00C     NOP
1A478  0E42     MOVLW 0x42
1A47A  240B     ADDWF wtemp5, W, ACCESS
1A47C  6ED9     MOVWF 0xFD9, ACCESS
1A47E  0E00     MOVLW 0x0
1A480  200C     ADDWFC 0xC, W, ACCESS
1A482  6EDA     MOVWF 0xFDA, ACCESS
1A484  0E40     MOVLW 0x40
1A486  60DF     CPFSLT 0xFDF, ACCESS
1A488  D040     BRA 0xA50A
70:            		_this->buf[_this->head] = c;
1A48A  0EFE     MOVLW 0xFE
1A48E  FF8C     NOP
1A490  F00B     NOP
1A492  0EFF     MOVLW 0xFF
1A496  FF8C     NOP
1A498  F00C     NOP
1A49A  0E40     MOVLW 0x40
1A49C  240B     ADDWF wtemp5, W, ACCESS
1A49E  6ED9     MOVWF 0xFD9, ACCESS
1A4A0  0E00     MOVLW 0x0
1A4A2  200C     ADDWFC 0xC, W, ACCESS
1A4A4  6EDA     MOVWF 0xFDA, ACCESS
1A4A6  50DF     MOVF 0xFDF, W, ACCESS
1A4A8  6E0C     MOVWF 0xC, ACCESS
1A4AA  0EFE     MOVLW 0xFE
1A4AE  FF8C     NOP
1A4B0  F009     NOP
1A4B2  0EFF     MOVLW 0xFF
1A4B6  FF8C     NOP
1A4B8  F00A     NOP
1A4BA  500C     MOVF 0xC, W, ACCESS
1A4BC  2409     ADDWF ltemp2, W, ACCESS
1A4BE  6ED9     MOVWF 0xFD9, ACCESS
1A4C0  0E00     MOVLW 0x0
1A4C2  200A     ADDWFC ttemp3, W, ACCESS
1A4C4  6EDA     MOVWF 0xFDA, ACCESS
1A4C6  0EFD     MOVLW 0xFD
1A4CA  FF8F     NOP
1A4CC  FFDF     NOP
71:            		++_this->head;
1A4CE  0EFE     MOVLW 0xFE
1A4D2  FF8C     NOP
1A4D4  F00B     NOP
1A4D6  0EFF     MOVLW 0xFF
1A4DA  FF8C     NOP
1A4DC  F00C     NOP
1A4DE  0E40     MOVLW 0x40
1A4E0  240B     ADDWF wtemp5, W, ACCESS
1A4E2  6ED9     MOVWF 0xFD9, ACCESS
1A4E4  0E00     MOVLW 0x0
1A4E6  200C     ADDWFC 0xC, W, ACCESS
1A4E8  6EDA     MOVWF 0xFDA, ACCESS
1A4EA  2ADF     INCF 0xFDF, F, ACCESS
72:            		++_this->count;
1A4EC  0EFE     MOVLW 0xFE
1A4F0  FF8C     NOP
1A4F2  F00B     NOP
1A4F4  0EFF     MOVLW 0xFF
1A4F8  FF8C     NOP
1A4FA  F00C     NOP
1A4FC  0E42     MOVLW 0x42
1A4FE  240B     ADDWF wtemp5, W, ACCESS
1A500  6ED9     MOVWF 0xFD9, ACCESS
1A502  0E00     MOVLW 0x0
1A504  200C     ADDWFC 0xC, W, ACCESS
1A506  6EDA     MOVWF 0xFDA, ACCESS
1A508  2ADF     INCF 0xFDF, F, ACCESS
73:            	}
74:            }
1A50A  52E5     MOVF 0xFE5, F, ACCESS
1A50C  52E5     MOVF 0xFE5, F, ACCESS
1A50E  52E5     MOVF 0xFE5, F, ACCESS
1A510  0012     RETURN 0
75:            
76:            void ringBufS_flush(ringBufS_t *_this, const int8_t clearBuffer)
77:            {
78:            	_this->count = 0;
1A786  0EFE     MOVLW 0xFE
1A78A  FF8C     NOP
1A78C  F00B     NOP
1A78E  0EFF     MOVLW 0xFF
1A792  FF8C     NOP
1A794  F00C     NOP
1A796  0E42     MOVLW 0x42
1A798  240B     ADDWF wtemp5, W, ACCESS
1A79A  6ED9     MOVWF 0xFD9, ACCESS
1A79C  0E00     MOVLW 0x0
1A79E  200C     ADDWFC 0xC, W, ACCESS
1A7A0  6EDA     MOVWF 0xFDA, ACCESS
1A7A2  0E00     MOVLW 0x0
1A7A4  6EDF     MOVWF 0xFDF, ACCESS
79:            	_this->head = 0;
1A7A6  0EFE     MOVLW 0xFE
1A7AA  FF8C     NOP
1A7AC  F00B     NOP
1A7AE  0EFF     MOVLW 0xFF
1A7B2  FF8C     NOP
1A7B4  F00C     NOP
1A7B6  0E40     MOVLW 0x40
1A7B8  240B     ADDWF wtemp5, W, ACCESS
1A7BA  6ED9     MOVWF 0xFD9, ACCESS
1A7BC  0E00     MOVLW 0x0
1A7BE  200C     ADDWFC 0xC, W, ACCESS
1A7C0  6EDA     MOVWF 0xFDA, ACCESS
1A7C2  0E00     MOVLW 0x0
1A7C4  6EDF     MOVWF 0xFDF, ACCESS
80:            	_this->tail = 0;
1A7C6  0EFE     MOVLW 0xFE
1A7CA  FF8C     NOP
1A7CC  F00B     NOP
1A7CE  0EFF     MOVLW 0xFF
1A7D2  FF8C     NOP
1A7D4  F00C     NOP
1A7D6  0E41     MOVLW 0x41
1A7D8  240B     ADDWF wtemp5, W, ACCESS
1A7DA  6ED9     MOVWF 0xFD9, ACCESS
1A7DC  0E00     MOVLW 0x0
1A7DE  200C     ADDWFC 0xC, W, ACCESS
1A7E0  6EDA     MOVWF 0xFDA, ACCESS
1A7E2  0E00     MOVLW 0x0
1A7E4  6EDF     MOVWF 0xFDF, ACCESS
81:            	if (clearBuffer) {
1A7E6  0EFD     MOVLW 0xFD
1A7E8  50E3     MOVF 0xFE3, W, ACCESS
1A7EA  B4D8     BTFSC 0xFD8, 2, ACCESS
1A7EC  D011     BRA 0xA810
82:            		memset(_this->buf, 0, sizeof(_this->buf));
1A7EE  0E40     MOVLW 0x40
1A7F0  6EE6     MOVWF 0xFE6, ACCESS
1A7F2  0E00     MOVLW 0x0
1A7F4  6EE6     MOVWF 0xFE6, ACCESS
1A7F6  0E00     MOVLW 0x0
1A7F8  6EE6     MOVWF 0xFE6, ACCESS
1A7FA  0E00     MOVLW 0x0
1A7FC  6EE6     MOVWF 0xFE6, ACCESS
1A7FE  0EFA     MOVLW 0xFA
1A802  FF8F     NOP
1A804  FFE6     NOP
1A808  FF8F     NOP
1A80A  FFE6     NOP
1A80C  ECC5     CALL 0x16B8A, 0
1A80E  F0B5     NOP
83:            	}
84:            }
1A810  52E5     MOVF 0xFE5, F, ACCESS
1A812  52E5     MOVF 0xFE5, F, ACCESS
1A814  52E5     MOVF 0xFE5, F, ACCESS
1A816  0012     RETURN 0
85:            
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mconfig.c  -----------------------------------------------
1:             #include "mconfig.h"
2:             #include "mydisplay.h"
3:             #include "msg_text.h"
4:             
5:             extern V_data V;
6:             static D_data D = {0};
7:             
8:             static const char *build_date = __DATE__, *build_time = __TIME__;
9:             
10:            /*
11:             * hardware specific routines
12:             */
13:            void mode_lamp_dim(const uint16_t level)
14:            {
15:            	PWM8_LoadDutyValue(level);
1BC3E  0EFE     MOVLW 0xFE
1BC42  FF8F     NOP
1BC44  FFE6     NOP
1BC48  FF8F     NOP
1BC4A  FFE6     NOP
1BC4C  EC49     CALL 0x1B292, 0
1BC4E  F0D9     NOP
16:            }
1BC50  52E5     MOVF 0xFE5, F, ACCESS
1BC52  52E5     MOVF 0xFE5, F, ACCESS
1BC54  0012     RETURN 0
17:            
18:            void mode_lamp_bright(void)
19:            {
20:            	PWM8_LoadDutyValue(300);
1BD32  0E2C     MOVLW 0x2C
1BD34  6EE6     MOVWF 0xFE6, ACCESS
1BD36  0E01     MOVLW 0x1
1BD38  6EE6     MOVWF 0xFE6, ACCESS
1BD3A  EC49     CALL 0x1B292, 0
1BD3C  F0D9     NOP
21:            }
1BD3E  0012     RETURN 0
22:            
23:            /*
24:             * mode button help mode select
25:             */
26:            bool help_button(void)
27:            {
28:            	if (!RB0_GetValue()) { // debounce and delay for button press
1B48C  B0CB     BTFSC 0xFCB, 0, ACCESS
1B48E  D00C     BRA 0xB4A8
29:            		V.help = true;
1B490  0101     MOVLB 0x1
1B492  85CB     BSF uart2RxCount, 2, BANKED
30:            		if (TimerDone(TMR_HELP))
1B494  0E08     MOVLW 0x8
1B496  6EE6     MOVWF 0xFE6, ACCESS
1B498  ECF3     CALL 0x1B7E6, 0
1B49A  F0DB     NOP
1B49C  5001     MOVF ltemp0, W, ACCESS
1B49E  B4D8     BTFSC 0xFD8, 2, ACCESS
1B4A0  D003     BRA 0xB4A8
31:            			return true;
1B4A2  0E01     MOVLW 0x1
1B4A4  6E01     MOVWF ltemp0, ACCESS
1B4A6  0012     RETURN 0
32:            	}
33:            
34:            	if (!V.help)
1B4A8  0101     MOVLB 0x1
1B4AA  B5CB     BTFSC uart2RxCount, 2, BANKED
1B4AC  D008     BRA 0xB4BE
35:            		StartTimer(TMR_HELP, BDELAY);
1B4AE  0E2C     MOVLW 0x2C
1B4B0  6EE6     MOVWF 0xFE6, ACCESS
1B4B2  0E01     MOVLW 0x1
1B4B4  6EE6     MOVWF 0xFE6, ACCESS
1B4B6  0E08     MOVLW 0x8
1B4B8  6EE6     MOVWF 0xFE6, ACCESS
1B4BA  EC6A     CALL 0x1B2D4, 0
1B4BC  F0D9     NOP
36:            
37:            	return false;
1B4BE  0E00     MOVLW 0x0
1B4C0  6E01     MOVWF ltemp0, ACCESS
38:            }
1B4C2  0012     RETURN 0
39:            
40:            bool check_help(const bool flipper)
41:            {
42:            	bool estatus=false;
43:            	/*
44:            	 * show help display
45:            	 */
46:            	if (help_button() && display_info() != DIS_HELP) {
17F82  EC46     CALL 0x1B48C, 0
17F84  F0DA     NOP
17F86  5001     MOVF ltemp0, W, ACCESS
17F88  B4D8     BTFSC 0xFD8, 2, ACCESS
17F8A  D0D0     BRA 0x812C
17F8C  ECDB     CALL 0x1BDB6, 0
17F8E  F0DE     NOP
17F90  0401     DECF ltemp0, W, ACCESS
17F92  B4D8     BTFSC 0xFD8, 2, ACCESS
17F94  D0CB     BRA 0x812C
47:            		StartTimer(TMR_FLIPPER, DFLIP);
17F96  0EDC     MOVLW 0xDC
17F98  6EE6     MOVWF 0xFE6, ACCESS
17F9A  0E05     MOVLW 0x5
17F9C  6EE6     MOVWF 0xFE6, ACCESS
17F9E  0E0B     MOVLW 0xB
17FA0  6EE6     MOVWF 0xFE6, ACCESS
17FA2  EC6A     CALL 0x1B2D4, 0
17FA4  F0D9     NOP
48:            		if (V.debug)
17FA6  0101     MOVLB 0x1
17FA8  B3CB     BTFSC uart2RxCount, 1, BANKED
49:            			vterm_dump();
17FAA  ECCA     CALL 0x19394, 0
17FAC  F0C9     NOP
50:            
51:            		set_vterm(1);
17FAE  0E01     MOVLW 0x1
17FB0  6EE6     MOVWF 0xFE6, ACCESS
17FB2  ECC9     CALL 0x1BB92, 0
17FB4  F0DD     NOP
52:            		set_temp_display_help(display_info());
17FB6  ECDB     CALL 0x1BDB6, 0
17FB8  F0DE     NOP
17FBA  5001     MOVF ltemp0, W, ACCESS
17FBC  6EE6     MOVWF 0xFE6, ACCESS
17FBE  EC7B     CALL 0x1BCF6, 0
17FC0  F0DE     NOP
53:            		set_display_info(DIS_HELP);
17FC2  0E01     MOVLW 0x1
17FC4  6EE6     MOVWF 0xFE6, ACCESS
17FC6  ECD8     CALL 0x1BBB0, 0
17FC8  F0DD     NOP
54:            		if (flipper) {
17FCA  0EFF     MOVLW 0xFF
17FCC  50E3     MOVF 0xFE3, W, ACCESS
17FCE  B4D8     BTFSC 0xFD8, 2, ACCESS
17FD0  D019     BRA 0x8004
55:            			sprintf(get_vterm_ptr(0, 1), "HELP %s           ", build_date);
17FD2  0EB1     MOVLW 0xB1
17FD4  6EE6     MOVWF 0xFE6, ACCESS
17FD6  0EFF     MOVLW 0xFF
17FD8  6EE6     MOVWF 0xFE6, ACCESS
17FDA  0E27     MOVLW 0x27
17FDC  6EE6     MOVWF 0xFE6, ACCESS
17FDE  0EFE     MOVLW 0xFE
17FE0  6EE6     MOVWF 0xFE6, ACCESS
17FE2  0E01     MOVLW 0x1
17FE4  6EE6     MOVWF 0xFE6, ACCESS
17FE6  0E00     MOVLW 0x0
17FE8  6EE6     MOVWF 0xFE6, ACCESS
17FEA  EC48     CALL 0x1B690, 0
17FEC  F0DB     NOP
17FF0  F007     NOP
17FF2  FFE6     NOP
17FF6  F00B     NOP
17FF8  FFE6     NOP
17FFA  0E06     MOVLW 0x6
17FFC  6EE6     MOVWF 0xFE6, ACCESS
17FFE  EC1E     CALL 0x19A3C, 0
18000  F0CD     NOP
56:            		} else {
18002  D018     BRA 0x8034
57:            			sprintf(get_vterm_ptr(0, 1), "HELP %s           ", build_time);
18004  0EC7     MOVLW 0xC7
18006  6EE6     MOVWF 0xFE6, ACCESS
18008  0EFF     MOVLW 0xFF
1800A  6EE6     MOVWF 0xFE6, ACCESS
1800C  0E27     MOVLW 0x27
1800E  6EE6     MOVWF 0xFE6, ACCESS
18010  0EFE     MOVLW 0xFE
18012  6EE6     MOVWF 0xFE6, ACCESS
18014  0E01     MOVLW 0x1
18016  6EE6     MOVWF 0xFE6, ACCESS
18018  0E00     MOVLW 0x0
1801A  6EE6     MOVWF 0xFE6, ACCESS
1801C  EC48     CALL 0x1B690, 0
1801E  F0DB     NOP
18022  F007     NOP
18024  FFE6     NOP
18028  F00B     NOP
1802A  FFE6     NOP
1802C  0E06     MOVLW 0x6
1802E  6EE6     MOVWF 0xFE6, ACCESS
18030  EC1E     CALL 0x19A3C, 0
18032  F0CD     NOP
58:            		}
59:            		sprintf(get_vterm_ptr(1, 1), "%s       ", T[V.help_id].display);
18034  0101     MOVLB 0x1
18036  39CB     SWAPF uart2RxCount, W, BANKED
18038  32E8     RRCF 0xFE8, F, ACCESS
1803A  32E8     RRCF 0xFE8, F, ACCESS
1803C  0B03     ANDLW 0x3
1803E  0D24     MULLW 0x24
18040  0E12     MOVLW 0x12
18042  26F3     ADDWF 0xFF3, F, ACCESS
18044  0E00     MOVLW 0x0
18046  22F4     ADDWFC 0xFF4, F, ACCESS
18048  0E37     MOVLW 0x37
1804A  6E0B     MOVWF wtemp5, ACCESS
1804C  0EFB     MOVLW 0xFB
1804E  6E0C     MOVWF 0xC, ACCESS
18050  50F3     MOVF 0xFF3, W, ACCESS
18052  260B     ADDWF wtemp5, F, ACCESS
18054  50F4     MOVF 0xFF4, W, ACCESS
18056  220C     ADDWFC 0xC, F, ACCESS
1805A  F02F     NOP
1805C  FFE6     NOP
18060  F033     NOP
18062  FFE6     NOP
18064  0EBD     MOVLW 0xBD
18066  6EE6     MOVWF 0xFE6, ACCESS
18068  0EFF     MOVLW 0xFF
1806A  6EE6     MOVWF 0xFE6, ACCESS
1806C  0E01     MOVLW 0x1
1806E  6EE6     MOVWF 0xFE6, ACCESS
18070  0E01     MOVLW 0x1
18072  6EE6     MOVWF 0xFE6, ACCESS
18074  EC48     CALL 0x1B690, 0
18076  F0DB     NOP
1807A  F007     NOP
1807C  FFE6     NOP
18080  F00B     NOP
18082  FFE6     NOP
18084  0E06     MOVLW 0x6
18086  6EE6     MOVWF 0xFE6, ACCESS
18088  EC1E     CALL 0x19A3C, 0
1808A  F0CD     NOP
60:            		sprintf(get_vterm_ptr(2, 1), "%s       ", T[V.help_id].message);
1808C  0101     MOVLB 0x1
1808E  39CB     SWAPF uart2RxCount, W, BANKED
18090  32E8     RRCF 0xFE8, F, ACCESS
18092  32E8     RRCF 0xFE8, F, ACCESS
18094  0B03     ANDLW 0x3
18096  0D24     MULLW 0x24
18098  0E37     MOVLW 0x37
1809A  6E0B     MOVWF wtemp5, ACCESS
1809C  0EFB     MOVLW 0xFB
1809E  6E0C     MOVWF 0xC, ACCESS
180A0  50F3     MOVF 0xFF3, W, ACCESS
180A2  260B     ADDWF wtemp5, F, ACCESS
180A4  50F4     MOVF 0xFF4, W, ACCESS
180A6  220C     ADDWFC 0xC, F, ACCESS
180AA  F02F     NOP
180AC  FFE6     NOP
180B0  F033     NOP
180B2  FFE6     NOP
180B4  0EBD     MOVLW 0xBD
180B6  6EE6     MOVWF 0xFE6, ACCESS
180B8  0EFF     MOVLW 0xFF
180BA  6EE6     MOVWF 0xFE6, ACCESS
180BC  0E01     MOVLW 0x1
180BE  6EE6     MOVWF 0xFE6, ACCESS
180C0  0E02     MOVLW 0x2
180C2  6EE6     MOVWF 0xFE6, ACCESS
180C4  EC48     CALL 0x1B690, 0
180C6  F0DB     NOP
180CA  F007     NOP
180CC  FFE6     NOP
180D0  F00B     NOP
180D2  FFE6     NOP
180D4  0E06     MOVLW 0x6
180D6  6EE6     MOVWF 0xFE6, ACCESS
180D8  EC1E     CALL 0x19A3C, 0
180DA  F0CD     NOP
61:            		V.help_id++; // cycle help text messages to LCD
180DC  EE20     LFSR 2, 0x1CB
180DE  F1CB     NOP
180E0  38DF     SWAPF 0xFDF, W, ACCESS
180E2  6E0C     MOVWF 0xC, ACCESS
180E4  320C     RRCF 0xC, F, ACCESS
180E6  300C     RRCF 0xC, W, ACCESS
180E8  0B03     ANDLW 0x3
180EA  6E0C     MOVWF 0xC, ACCESS
180EC  2A0C     INCF 0xC, F, ACCESS
180EE  3A0C     SWAPF 0xC, F, ACCESS
180F0  360C     RLCF 0xC, F, ACCESS
180F2  360C     RLCF 0xC, F, ACCESS
180F4  50DF     MOVF 0xFDF, W, ACCESS
180F6  180C     XORWF 0xC, W, ACCESS
180F8  0B3F     ANDLW 0x3F
180FA  180C     XORWF 0xC, W, ACCESS
180FC  6EDF     MOVWF 0xFDF, ACCESS
62:            		StartTimer(TMR_HELPDIS, TDELAY);
180FE  0EB8     MOVLW 0xB8
18100  6EE6     MOVWF 0xFE6, ACCESS
18102  0E0B     MOVLW 0xB
18104  6EE6     MOVWF 0xFE6, ACCESS
18106  0E09     MOVLW 0x9
18108  6EE6     MOVWF 0xFE6, ACCESS
1810A  EC6A     CALL 0x1B2D4, 0
1810C  F0D9     NOP
63:            		StartTimer(TMR_INFO, TDELAY);
1810E  0EB8     MOVLW 0xB8
18110  6EE6     MOVWF 0xFE6, ACCESS
18112  0E0B     MOVLW 0xB
18114  6EE6     MOVWF 0xFE6, ACCESS
18116  0E07     MOVLW 0x7
18118  6EE6     MOVWF 0xFE6, ACCESS
1811A  EC6A     CALL 0x1B2D4, 0
1811C  F0D9     NOP
64:            		mode_lamp_bright(); // mode switch indicator lamp 'button' level
1811E  EC99     CALL 0x1BD32, 0
18120  F0DE     NOP
65:            		update_lcd(1);
18122  0E01     MOVLW 0x1
18124  6EE6     MOVWF 0xFE6, ACCESS
18126  EC96     CALL 0x1992C, 0
18128  F0CC     NOP
66:            		estatus=true;
67:            	} else {
1812A  D032     BRA 0x8190
68:            		if (TimerDone(TMR_HELPDIS)) {
1812C  0E09     MOVLW 0x9
1812E  6EE6     MOVWF 0xFE6, ACCESS
18130  ECF3     CALL 0x1B7E6, 0
18132  F0DB     NOP
18134  5001     MOVF ltemp0, W, ACCESS
18136  B4D8     BTFSC 0xFD8, 2, ACCESS
18138  D02B     BRA 0x8190
69:            			set_vterm(0);
1813A  0E00     MOVLW 0x0
1813C  6EE6     MOVWF 0xFE6, ACCESS
1813E  ECC9     CALL 0x1BB92, 0
18140  F0DD     NOP
70:            			V.help = false;
18142  0101     MOVLB 0x1
18144  95CB     BCF uart2RxCount, 2, BANKED
71:            			set_display_info(display_help());
18146  ECDF     CALL 0x1BDBE, 0
18148  F0DE     NOP
1814A  5001     MOVF ltemp0, W, ACCESS
1814C  6EE6     MOVWF 0xFE6, ACCESS
1814E  ECD8     CALL 0x1BBB0, 0
18150  F0DD     NOP
72:            			mode_lamp_dim(V.mode_pwm);
18154  F717     NOP
18156  FFE6     NOP
1815A  F71B     NOP
1815C  FFE6     NOP
1815E  EC1F     CALL 0x1BC3E, 0
18160  F0DE     NOP
73:            			if (TimerDone(TMR_FLIPPER)) {
18162  0E0B     MOVLW 0xB
18164  6EE6     MOVWF 0xFE6, ACCESS
18166  ECF3     CALL 0x1B7E6, 0
18168  F0DB     NOP
1816A  5001     MOVF ltemp0, W, ACCESS
1816C  B4D8     BTFSC 0xFD8, 2, ACCESS
1816E  D010     BRA 0x8190
74:            				V.flipper = !V.flipper;
18170  0101     MOVLB 0x1
18172  51DB     MOVF 0xDB, W, BANKED
18174  A4D8     BTFSS 0xFD8, 2, ACCESS
18176  D002     BRA 0x817C
18178  0E01     MOVLW 0x1
1817A  D001     BRA 0x817E
1817C  0E00     MOVLW 0x0
1817E  6FDB     MOVWF 0xDB, BANKED
75:            				StartTimer(TMR_FLIPPER, DFLIP);
18180  0EDC     MOVLW 0xDC
18182  6EE6     MOVWF 0xFE6, ACCESS
18184  0E05     MOVLW 0x5
18186  6EE6     MOVWF 0xFE6, ACCESS
18188  0E0B     MOVLW 0xB
1818A  6EE6     MOVWF 0xFE6, ACCESS
1818C  EC6A     CALL 0x1B2D4, 0
1818E  F0D9     NOP
76:            			}
77:            		}
78:            	}
79:            	return estatus;
80:            }
18190  52E5     MOVF 0xFE5, F, ACCESS
18192  0012     RETURN 0
81:            
82:            /*
83:             * write character data to vterm
84:             */
85:            uint8_t update_lcd(uint8_t vterm)
86:            {
87:            	vterm = vterm & 0x03;
1992C  0EFF     MOVLW 0xFF
19930  FF8C     NOP
19932  F001     NOP
19934  0E03     MOVLW 0x3
19936  1601     ANDWF ltemp0, F, ACCESS
19938  0EFF     MOVLW 0xFF
1993C  F007     NOP
1993E  FFE3     NOP
88:            
89:            	if (D.vterm >= 1 && vterm == 0)
19940  EE22     LFSR 2, 0xA06
19942  F206     NOP
19944  A0DF     BTFSS 0xFDF, 0, ACCESS
19946  D004     BRA 0x9950
19948  0EFF     MOVLW 0xFF
1994A  50E3     MOVF 0xFE3, W, ACCESS
1994C  B4D8     BTFSC 0xFD8, 2, ACCESS
1994E  D074     BRA 0x9A38
90:            		return D.vterm;
91:            
92:            	D.lcd[vterm][0][MAX_LINE] = 0;
19950  0EFF     MOVLW 0xFF
19952  50E3     MOVF 0xFE3, W, ACCESS
19954  0D78     MULLW 0x78
19956  0E36     MOVLW 0x36
19958  24F3     ADDWF 0xFF3, W, ACCESS
1995A  6ED9     MOVWF 0xFD9, ACCESS
1995C  0E08     MOVLW 0x8
1995E  20F4     ADDWFC 0xFF4, W, ACCESS
19960  6EDA     MOVWF 0xFDA, ACCESS
19962  0E00     MOVLW 0x0
19964  6EDF     MOVWF 0xFDF, ACCESS
93:            	D.lcd[vterm][1][MAX_LINE] = 0;
19966  0EFF     MOVLW 0xFF
19968  50E3     MOVF 0xFE3, W, ACCESS
1996A  0D78     MULLW 0x78
1996C  0E5E     MOVLW 0x5E
1996E  24F3     ADDWF 0xFF3, W, ACCESS
19970  6ED9     MOVWF 0xFD9, ACCESS
19972  0E08     MOVLW 0x8
19974  20F4     ADDWFC 0xFF4, W, ACCESS
19976  6EDA     MOVWF 0xFDA, ACCESS
19978  0E00     MOVLW 0x0
1997A  6EDF     MOVWF 0xFDF, ACCESS
94:            	D.lcd[vterm][2][MAX_LINE] = 0;
1997C  0EFF     MOVLW 0xFF
1997E  50E3     MOVF 0xFE3, W, ACCESS
19980  0D78     MULLW 0x78
19982  0E86     MOVLW 0x86
19984  24F3     ADDWF 0xFF3, W, ACCESS
19986  6ED9     MOVWF 0xFD9, ACCESS
19988  0E08     MOVLW 0x8
1998A  20F4     ADDWFC 0xFF4, W, ACCESS
1998C  6EDA     MOVWF 0xFDA, ACCESS
1998E  0E00     MOVLW 0x0
19990  6EDF     MOVWF 0xFDF, ACCESS
95:            	wait_lcd_done();
19992  ECF6     CALL 0x1BBEC, 0
19994  F0DD     NOP
96:            	eaDogM_WriteStringAtPos(0, 0, D.lcd[vterm][0]);
19996  0EFF     MOVLW 0xFF
19998  50E3     MOVF 0xFE3, W, ACCESS
1999A  0D78     MULLW 0x78
1999C  0E26     MOVLW 0x26
1999E  6E0B     MOVWF wtemp5, ACCESS
199A0  0E08     MOVLW 0x8
199A2  6E0C     MOVWF 0xC, ACCESS
199A4  50F3     MOVF 0xFF3, W, ACCESS
199A6  260B     ADDWF wtemp5, F, ACCESS
199A8  50F4     MOVF 0xFF4, W, ACCESS
199AA  220C     ADDWFC 0xC, F, ACCESS
199AE  F02F     NOP
199B0  FFE6     NOP
199B4  F033     NOP
199B6  FFE6     NOP
199B8  0E00     MOVLW 0x0
199BA  6EE6     MOVWF 0xFE6, ACCESS
199BC  0E00     MOVLW 0x0
199BE  6EE6     MOVWF 0xFE6, ACCESS
199C0  EC99     CALL 0x1B532, 0
199C2  F0DA     NOP
97:            	wait_lcd_done();
199C4  ECF6     CALL 0x1BBEC, 0
199C6  F0DD     NOP
98:            	eaDogM_WriteStringAtPos(1, 0, D.lcd[vterm][1]);
199C8  0EFF     MOVLW 0xFF
199CA  50E3     MOVF 0xFE3, W, ACCESS
199CC  0D78     MULLW 0x78
199CE  0E26     MOVLW 0x26
199D0  6E0B     MOVWF wtemp5, ACCESS
199D2  0E08     MOVLW 0x8
199D4  6E0C     MOVWF 0xC, ACCESS
199D6  0E28     MOVLW 0x28
199D8  260B     ADDWF wtemp5, F, ACCESS
199DA  0E00     MOVLW 0x0
199DC  220C     ADDWFC 0xC, F, ACCESS
199DE  50F3     MOVF 0xFF3, W, ACCESS
199E0  260B     ADDWF wtemp5, F, ACCESS
199E2  50F4     MOVF 0xFF4, W, ACCESS
199E4  220C     ADDWFC 0xC, F, ACCESS
199E8  F02F     NOP
199EA  FFE6     NOP
199EE  F033     NOP
199F0  FFE6     NOP
199F2  0E00     MOVLW 0x0
199F4  6EE6     MOVWF 0xFE6, ACCESS
199F6  0E01     MOVLW 0x1
199F8  6EE6     MOVWF 0xFE6, ACCESS
199FA  EC99     CALL 0x1B532, 0
199FC  F0DA     NOP
99:            	wait_lcd_done();
199FE  ECF6     CALL 0x1BBEC, 0
19A00  F0DD     NOP
100:           	eaDogM_WriteStringAtPos(2, 0, D.lcd[vterm][2]);
19A02  0EFF     MOVLW 0xFF
19A04  50E3     MOVF 0xFE3, W, ACCESS
19A06  0D78     MULLW 0x78
19A08  0E26     MOVLW 0x26
19A0A  6E0B     MOVWF wtemp5, ACCESS
19A0C  0E08     MOVLW 0x8
19A0E  6E0C     MOVWF 0xC, ACCESS
19A10  0E50     MOVLW 0x50
19A12  260B     ADDWF wtemp5, F, ACCESS
19A14  0E00     MOVLW 0x0
19A16  220C     ADDWFC 0xC, F, ACCESS
19A18  50F3     MOVF 0xFF3, W, ACCESS
19A1A  260B     ADDWF wtemp5, F, ACCESS
19A1C  50F4     MOVF 0xFF4, W, ACCESS
19A1E  220C     ADDWFC 0xC, F, ACCESS
19A22  F02F     NOP
19A24  FFE6     NOP
19A28  F033     NOP
19A2A  FFE6     NOP
19A2C  0E00     MOVLW 0x0
19A2E  6EE6     MOVWF 0xFE6, ACCESS
19A30  0E02     MOVLW 0x2
19A32  6EE6     MOVWF 0xFE6, ACCESS
19A34  EC99     CALL 0x1B532, 0
19A36  F0DA     NOP
101:           	return D.vterm;
102:           }
19A38  52E5     MOVF 0xFE5, F, ACCESS
19A3A  0012     RETURN 0
103:           
104:           /*
105:            * set terminal window to 0..3
106:            */
107:           uint8_t set_vterm(const uint8_t vterm)
108:           {
109:           	D.vterm = vterm & 0x03;
1BB92  0EFF     MOVLW 0xFF
1BB96  FF8C     NOP
1BB98  F00C     NOP
1BB9A  0E03     MOVLW 0x3
1BB9C  160C     ANDWF 0xC, F, ACCESS
1BB9E  EE22     LFSR 2, 0xA06
1BBA0  F206     NOP
1BBA2  50DF     MOVF 0xFDF, W, ACCESS
1BBA4  180C     XORWF 0xC, W, ACCESS
1BBA6  0BFE     ANDLW 0xFE
1BBA8  180C     XORWF 0xC, W, ACCESS
1BBAA  6EDF     MOVWF 0xFDF, ACCESS
110:           	return D.vterm;
111:           }
1BBAC  52E5     MOVF 0xFE5, F, ACCESS
1BBAE  0012     RETURN 0
112:           
113:           /*
114:            * return pointer to vterm line buffer
115:            */
116:           char * get_vterm_ptr(const uint8_t line, const uint8_t vterm)
117:           {
118:           	return D.lcd[vterm & 0x03][line & 0x03];
1B690  0EFE     MOVLW 0xFE
1B692  50E3     MOVF 0xFE3, W, ACCESS
1B694  0B03     ANDLW 0x3
1B696  0D78     MULLW 0x78
1B698  0E26     MOVLW 0x26
1B69A  6E01     MOVWF ltemp0, ACCESS
1B69C  0E08     MOVLW 0x8
1B69E  6E02     MOVWF ttemp5, ACCESS
1B6A0  50F3     MOVF 0xFF3, W, ACCESS
1B6A2  2601     ADDWF ltemp0, F, ACCESS
1B6A4  50F4     MOVF 0xFF4, W, ACCESS
1B6A6  2202     ADDWFC ttemp5, F, ACCESS
1B6A8  0EFF     MOVLW 0xFF
1B6AA  50E3     MOVF 0xFE3, W, ACCESS
1B6AC  0B03     ANDLW 0x3
1B6AE  0D28     MULLW 0x28
1B6B0  50F3     MOVF 0xFF3, W, ACCESS
1B6B2  2601     ADDWF ltemp0, F, ACCESS
1B6B4  50F4     MOVF 0xFF4, W, ACCESS
1B6B6  2202     ADDWFC ttemp5, F, ACCESS
119:           }
1B6B8  52E5     MOVF 0xFE5, F, ACCESS
1B6BA  52E5     MOVF 0xFE5, F, ACCESS
1B6BC  0012     RETURN 0
120:           
121:           void vterm_dump(void)
122:           {
123:           	sprintf(V.buf, "vterm %x:%x   ", get_vterm_ptr(0, 0), get_vterm_ptr(0, 1));
19394  0E01     MOVLW 0x1
19396  6EE6     MOVWF 0xFE6, ACCESS
19398  0E00     MOVLW 0x0
1939A  6EE6     MOVWF 0xFE6, ACCESS
1939C  EC48     CALL 0x1B690, 0
1939E  F0DB     NOP
193A2  F007     NOP
193A4  FFE6     NOP
193A8  F00B     NOP
193AA  FFE6     NOP
193AC  0E00     MOVLW 0x0
193AE  6EE6     MOVWF 0xFE6, ACCESS
193B0  0E00     MOVLW 0x0
193B2  6EE6     MOVWF 0xFE6, ACCESS
193B4  EC48     CALL 0x1B690, 0
193B6  F0DB     NOP
193BA  F007     NOP
193BC  FFE6     NOP
193C0  F00B     NOP
193C2  FFE6     NOP
193C4  0E93     MOVLW 0x93
193C6  6EE6     MOVWF 0xFE6, ACCESS
193C8  0EFF     MOVLW 0xFF
193CA  6EE6     MOVWF 0xFE6, ACCESS
193CC  0E31     MOVLW 0x31
193CE  6EE6     MOVWF 0xFE6, ACCESS
193D0  0E01     MOVLW 0x1
193D2  6EE6     MOVWF 0xFE6, ACCESS
193D4  0E08     MOVLW 0x8
193D6  6EE6     MOVWF 0xFE6, ACCESS
193D8  EC1E     CALL 0x19A3C, 0
193DA  F0CD     NOP
124:           	wait_lcd_done();
193DC  ECF6     CALL 0x1BBEC, 0
193DE  F0DD     NOP
125:           	eaDogM_WriteStringAtPos(0, 0, V.buf);
193E0  0E31     MOVLW 0x31
193E2  6EE6     MOVWF 0xFE6, ACCESS
193E4  0E01     MOVLW 0x1
193E6  6EE6     MOVWF 0xFE6, ACCESS
193E8  0E00     MOVLW 0x0
193EA  6EE6     MOVWF 0xFE6, ACCESS
193EC  0E00     MOVLW 0x0
193EE  6EE6     MOVWF 0xFE6, ACCESS
193F0  EC99     CALL 0x1B532, 0
193F2  F0DA     NOP
126:           	sprintf(V.buf, "vterm %x:%x   ", get_vterm_ptr(1, 0), get_vterm_ptr(1, 1));
193F4  0E01     MOVLW 0x1
193F6  6EE6     MOVWF 0xFE6, ACCESS
193F8  0E01     MOVLW 0x1
193FA  6EE6     MOVWF 0xFE6, ACCESS
193FC  EC48     CALL 0x1B690, 0
193FE  F0DB     NOP
19402  F007     NOP
19404  FFE6     NOP
19408  F00B     NOP
1940A  FFE6     NOP
1940C  0E00     MOVLW 0x0
1940E  6EE6     MOVWF 0xFE6, ACCESS
19410  0E01     MOVLW 0x1
19412  6EE6     MOVWF 0xFE6, ACCESS
19414  EC48     CALL 0x1B690, 0
19416  F0DB     NOP
1941A  F007     NOP
1941C  FFE6     NOP
19420  F00B     NOP
19422  FFE6     NOP
19424  0E93     MOVLW 0x93
19426  6EE6     MOVWF 0xFE6, ACCESS
19428  0EFF     MOVLW 0xFF
1942A  6EE6     MOVWF 0xFE6, ACCESS
1942C  0E31     MOVLW 0x31
1942E  6EE6     MOVWF 0xFE6, ACCESS
19430  0E01     MOVLW 0x1
19432  6EE6     MOVWF 0xFE6, ACCESS
19434  0E08     MOVLW 0x8
19436  6EE6     MOVWF 0xFE6, ACCESS
19438  EC1E     CALL 0x19A3C, 0
1943A  F0CD     NOP
127:           	wait_lcd_done();
1943C  ECF6     CALL 0x1BBEC, 0
1943E  F0DD     NOP
128:           	eaDogM_WriteStringAtPos(1, 0, V.buf);
19440  0E31     MOVLW 0x31
19442  6EE6     MOVWF 0xFE6, ACCESS
19444  0E01     MOVLW 0x1
19446  6EE6     MOVWF 0xFE6, ACCESS
19448  0E00     MOVLW 0x0
1944A  6EE6     MOVWF 0xFE6, ACCESS
1944C  0E01     MOVLW 0x1
1944E  6EE6     MOVWF 0xFE6, ACCESS
19450  EC99     CALL 0x1B532, 0
19452  F0DA     NOP
129:           	sprintf(V.buf, "vterm %x:%x   ", get_vterm_ptr(2, 0), get_vterm_ptr(2, 1));
19454  0E01     MOVLW 0x1
19456  6EE6     MOVWF 0xFE6, ACCESS
19458  0E02     MOVLW 0x2
1945A  6EE6     MOVWF 0xFE6, ACCESS
1945C  EC48     CALL 0x1B690, 0
1945E  F0DB     NOP
19462  F007     NOP
19464  FFE6     NOP
19468  F00B     NOP
1946A  FFE6     NOP
1946C  0E00     MOVLW 0x0
1946E  6EE6     MOVWF 0xFE6, ACCESS
19470  0E02     MOVLW 0x2
19472  6EE6     MOVWF 0xFE6, ACCESS
19474  EC48     CALL 0x1B690, 0
19476  F0DB     NOP
1947A  F007     NOP
1947C  FFE6     NOP
19480  F00B     NOP
19482  FFE6     NOP
19484  0E93     MOVLW 0x93
19486  6EE6     MOVWF 0xFE6, ACCESS
19488  0EFF     MOVLW 0xFF
1948A  6EE6     MOVWF 0xFE6, ACCESS
1948C  0E31     MOVLW 0x31
1948E  6EE6     MOVWF 0xFE6, ACCESS
19490  0E01     MOVLW 0x1
19492  6EE6     MOVWF 0xFE6, ACCESS
19494  0E08     MOVLW 0x8
19496  6EE6     MOVWF 0xFE6, ACCESS
19498  EC1E     CALL 0x19A3C, 0
1949A  F0CD     NOP
130:           	wait_lcd_done();
1949C  ECF6     CALL 0x1BBEC, 0
1949E  F0DD     NOP
131:           	eaDogM_WriteStringAtPos(2, 0, V.buf);
194A0  0E31     MOVLW 0x31
194A2  6EE6     MOVWF 0xFE6, ACCESS
194A4  0E01     MOVLW 0x1
194A6  6EE6     MOVWF 0xFE6, ACCESS
194A8  0E00     MOVLW 0x0
194AA  6EE6     MOVWF 0xFE6, ACCESS
194AC  0E02     MOVLW 0x2
194AE  6EE6     MOVWF 0xFE6, ACCESS
194B0  EC99     CALL 0x1B532, 0
194B2  F0DA     NOP
132:           	WaitMs(3000);
194B4  0EB8     MOVLW 0xB8
194B6  6EE6     MOVWF 0xFE6, ACCESS
194B8  0E0B     MOVLW 0xB
194BA  6EE6     MOVWF 0xFE6, ACCESS
194BC  EC7E     CALL 0x1B4FC, 0
194BE  F0DA     NOP
133:           }
194C0  0012     RETURN 0
134:           
135:           void vterm_sequence(void)
136:           {
137:           	sprintf(get_vterm_ptr(2, 2), " Mesg %d Stack %d      ", V.msg_error, V.stack);
138:           	switch (V.response.info) {
139:           	case DIS_HELP:
140:           		sprintf(get_vterm_ptr(0, 1), "HELP %s           ", build_date);
141:           		sprintf(get_vterm_ptr(1, 1), "DISPLAY %s        ", build_time);
142:           		break;
143:           	case DIS_CLEAR:
144:           	default:
145:           		sprintf(get_vterm_ptr(0, 0), "                  ");
146:           		sprintf(get_vterm_ptr(1, 0), "                  ");
147:           		sprintf(get_vterm_ptr(0, 2), "                  ");
148:           		sprintf(get_vterm_ptr(1, 2), "                  ");
149:           		break;
150:           	}
151:           }
152:           
153:           /*
154:            * update possible command messages
155:            */
156:           void MyeaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
157:           {
158:           
159:           	wait_lcd_done();
160:           	if (V.response.info == DIS_STR) {
161:           		eaDogM_WriteStringAtPos(r, c, strPtr);
162:           	} else {
163:           		if (V.response.info == DIS_HELP) {
164:           			sprintf(get_vterm_ptr(2, 1), "%s", V.info);
165:           			update_lcd(1);
166:           		} else {
167:           			if ((V.response.info != DIS_STR)) {
168:           				update_lcd(2);
169:           			} else {
170:           				sprintf(get_vterm_ptr(2, 0), "%s", V.info);
171:           				update_lcd(0);
172:           			}
173:           		}
174:           
175:           		if ((V.response.info != DIS_STR) && TimerDone(TMR_INFO))
176:           			V.response.info = DIS_STR;
177:           	}
178:           
179:           	/*
180:           	 * this is for possible message flipping with the HELP button
181:           	 */
182:           	if (D.last_info == DIS_HELP && V.response.info != DIS_HELP) {
183:           		// show some stuff, maybe
184:           	}
185:           
186:           	D.last_info = V.response.info;
187:           	//	DLED = false;
188:           }
189:           
190:           inline D_CODES display_info(void)
191:           {
192:           	return V.response.info;
1BDB8  F750     NOP
1BDBA  F001     NOP
193:           }
1BDBC  0012     RETURN 0
194:           
195:           inline D_CODES display_help(void)
196:           {
197:           	return V.response.help_temp;
1BDC0  F754     NOP
1BDC2  F001     NOP
198:           }
1BDC4  0012     RETURN 0
199:           
200:           D_CODES set_display_info(const D_CODES new_response_info)
201:           {
202:           	static D_CODES old_info = DIS_STR;
203:           
204:           	if (TimerDone(TMR_INFO)) {
1BBB0  0E07     MOVLW 0x7
1BBB2  6EE6     MOVWF 0xFE6, ACCESS
1BBB4  ECF3     CALL 0x1B7E6, 0
1BBB6  F0DB     NOP
1BBB8  5001     MOVF ltemp0, W, ACCESS
1BBBA  B4D8     BTFSC 0xFD8, 2, ACCESS
1BBBC  D006     BRA 0xBBCA
205:           		old_info = V.response.info;
1BBBE  0101     MOVLB 0x1
1BBC0  51D4     MOVF 0xD4, W, BANKED
206:           		V.response.info = new_response_info;
1BBC2  0EFF     MOVLW 0xFF
1BBC6  FF8C     NOP
1BBC8  F1D4     NOP
207:           	}
208:           	return old_info;
209:           }
1BBCA  52E5     MOVF 0xFE5, F, ACCESS
1BBCC  0012     RETURN 0
210:           
211:           D_CODES set_temp_display_help(const D_CODES new_response_info)
212:           {
213:           	static D_CODES old_info;
214:           
215:           	old_info = V.response.help_temp;
1BCF6  0101     MOVLB 0x1
1BCF8  51D5     MOVF 0xD5, W, BANKED
216:           	V.response.help_temp = new_response_info;
1BCFA  0EFF     MOVLW 0xFF
1BCFE  FF8C     NOP
1BD00  F1D5     NOP
217:           	return old_info;
218:           }
1BD02  52E5     MOVF 0xFE5, F, ACCESS
1BD04  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/uart2.c  -----------------------------
1:             /**
2:               UART2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.30
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart2.h"
52:            #include "interrupt_manager.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            #define UART2_TX_BUFFER_SIZE 64
58:            #define UART2_RX_BUFFER_SIZE 255
59:            
60:            /**
61:              Section: Global Variables
62:            */
63:            
64:            static volatile uint8_t uart2TxHead = 0;
65:            static volatile uint8_t uart2TxTail = 0;
66:            static volatile uint8_t uart2TxBuffer[UART2_TX_BUFFER_SIZE];
67:            volatile uint8_t uart2TxBufferRemaining;
68:            
69:            static volatile uint8_t uart2RxHead = 0;
70:            static volatile uint8_t uart2RxTail = 0;
71:            static volatile uint8_t uart2RxBuffer[UART2_RX_BUFFER_SIZE];
72:            volatile uint8_t uart2RxCount;
73:            
74:            /**
75:              Section: UART2 APIs
76:            */
77:            
78:            void UART2_Initialize(void)
79:            {
80:                // Disable interrupts before changing states
81:                PIE6bits.U2RXIE = 0;
1AE00  0139     MOVLB 0x39
1AE02  9596     BCF utctime, 2, BANKED
82:                UART2_SetRxInterruptHandler(UART2_Receive_ISR);
1AE04  0E54     MOVLW 0x54
1AE06  6EE6     MOVWF 0xFE6, ACCESS
1AE08  0EBB     MOVLW 0xBB
1AE0A  6EE6     MOVWF 0xFE6, ACCESS
1AE0C  0E01     MOVLW 0x1
1AE0E  6EE6     MOVWF 0xFE6, ACCESS
1AE10  EC1B     CALL 0x1B836, 0
1AE12  F0DC     NOP
83:                PIE6bits.U2TXIE = 0;
1AE14  0139     MOVLB 0x39
1AE16  9796     BCF utctime, 3, BANKED
84:                UART2_SetTxInterruptHandler(UART2_Transmit_ISR);
1AE18  0E18     MOVLW 0x18
1AE1A  6EE6     MOVWF 0xFE6, ACCESS
1AE1C  0EB7     MOVLW 0xB7
1AE1E  6EE6     MOVWF 0xFE6, ACCESS
1AE20  0E01     MOVLW 0x1
1AE22  6EE6     MOVWF 0xFE6, ACCESS
1AE24  EC07     CALL 0x1B80E, 0
1AE26  F0DC     NOP
85:            
86:                // Set the UART2 module to the options selected in the user interface.
87:            
88:                // P1L 0; 
89:                U2P1L = 0x00;
1AE28  013D     MOVLB 0x3D
1AE2A  6BD4     CLRF 0xD4, BANKED
90:            
91:                // P2L 0; 
92:                U2P2L = 0x00;
1AE2C  6BD6     CLRF 0xD6, BANKED
93:            
94:                // P3L 0; 
95:                U2P3L = 0x00;
1AE2E  6BD8     CLRF 0xD8, BANKED
96:            
97:                // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
98:                U2CON0 = 0xB0;
1AE30  0EB0     MOVLW 0xB0
1AE32  6FDA     MOVWF 0xDA, BANKED
99:            
100:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
101:               U2CON1 = 0x80;
1AE34  0E80     MOVLW 0x80
1AE36  6FDB     MOVWF 0xDB, BANKED
102:           
103:               // TXPOL not inverted; FLO off; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
104:               U2CON2 = 0x00;
1AE38  6BDC     CLRF 0xDC, BANKED
105:           
106:               // BRGL 130; 
107:               U2BRGL = 0x82;
1AE3A  0E82     MOVLW 0x82
1AE3C  6FDD     MOVWF 0xDD, BANKED
108:           
109:               // BRGH 6; 
110:               U2BRGH = 0x06;
1AE3E  0E06     MOVLW 0x6
1AE40  6FDE     MOVWF 0xDE, BANKED
111:           
112:               // STPMD in middle of first Stop bit; TXWRE No error; 
113:               U2FIFO = 0x00;
1AE42  6BDF     CLRF 0xDF, BANKED
114:           
115:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
116:               U2UIR = 0x00;
1AE44  6BE0     CLRF 0xE0, BANKED
117:           
118:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
119:               U2ERRIR = 0x00;
1AE46  6BE1     CLRF 0xE1, BANKED
120:           
121:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
122:               U2ERRIE = 0x00;
1AE48  6BE2     CLRF 0xE2, BANKED
123:           
124:           
125:               // initializing the driver state
126:               uart2TxHead = 0;
1AE4A  0100     MOVLB 0x0
1AE4C  6BCD     CLRF uart2TxHead, BANKED
127:               uart2TxTail = 0;
1AE4E  6A45     CLRF uart2TxTail, ACCESS
128:               uart2TxBufferRemaining = sizeof(uart2TxBuffer);
1AE50  0E40     MOVLW 0x40
1AE52  6E44     MOVWF uart2TxBufferRemaining, ACCESS
129:               uart2RxHead = 0;
1AE54  6A43     CLRF uart2RxHead, ACCESS
130:               uart2RxTail = 0;
1AE56  6BCC     CLRF uart2RxTail, BANKED
131:               uart2RxCount = 0;
1AE58  6BCB     CLRF uart2RxCount, BANKED
132:           
133:               // enable receive interrupt
134:               PIE6bits.U2RXIE = 1;
1AE5A  0139     MOVLB 0x39
1AE5C  8596     BSF utctime, 2, BANKED
135:           }
1AE5E  0012     RETURN 0
136:           
137:           uint8_t UART2_is_rx_ready(void)
138:           {
139:               return uart2RxCount;
140:           }
141:           
142:           uint8_t UART2_is_tx_ready(void)
143:           {
144:               return uart2TxBufferRemaining;
145:           }
146:           
147:           bool UART2_is_tx_done(void)
148:           {
149:               return U2ERRIRbits.TXMTIF;
150:           }
151:           
152:           uint8_t UART2_Read(void)
153:           {
154:               uint8_t readValue  = 0;
155:               
156:               while(0 == uart2RxCount)
157:               {
158:               }
159:           
160:               readValue = uart2RxBuffer[uart2RxTail++];
161:              	if(sizeof(uart2RxBuffer) <= uart2RxTail)
162:               {
163:                   uart2RxTail = 0;
164:               }
165:               PIE6bits.U2RXIE = 0;
166:               uart2RxCount--;
167:               PIE6bits.U2RXIE = 1;
168:           
169:               return readValue;
170:           }
171:           
172:           void UART2_Write(uint8_t txData)
173:           {
174:               while(0 == uart2TxBufferRemaining)
175:               {
176:               }
177:           
178:               if(0 == PIE6bits.U2TXIE)
179:               {
180:                   U2TXB = txData;
181:               }
182:               else
183:               {
184:                   PIE6bits.U2TXIE = 0;
185:                   uart2TxBuffer[uart2TxHead++] = txData;
186:                   if(sizeof(uart2TxBuffer) <= uart2TxHead)
187:                   {
188:                       uart2TxHead = 0;
189:                   }
190:                   uart2TxBufferRemaining--;
191:               }
192:               PIE6bits.U2TXIE = 1;
193:           }
194:           
195:           void __interrupt(irq(U2TX),base(8)) UART2_tx_vect_isr()
1B9C8  EE14     LFSR 1, 0x115C
196:           {   
197:               if(UART2_TxInterruptHandler)
1B9CC  0100     MOVLB 0x0
1B9CE  51B4     MOVF UART2_TxInterruptHandler, W, BANKED
1B9D0  11B5     IORWF 0xB5, W, BANKED
1B9D2  11B6     IORWF 0xB6, W, BANKED
1B9D4  B4D8     BTFSC 0xFD8, 2, ACCESS
1B9D6  0011     RETFIE 1
198:               {
199:                   UART2_TxInterruptHandler();
1B9D8  D801     RCALL 0xB9DC
1B9DA  0011     RETFIE 1
1B9DC  0005     PUSH
1B9DE  6EFA     MOVWF 0xFFA, ACCESS
1B9E0  51B4     MOVF UART2_TxInterruptHandler, W, BANKED
1B9E2  6EFD     MOVWF 0xFFD, ACCESS
1B9E4  51B5     MOVF 0xB5, W, BANKED
1B9E6  6EFE     MOVWF 0xFFE, ACCESS
1B9E8  51B6     MOVF 0xB6, W, BANKED
1B9EA  6EFF     MOVWF 0xFFF, ACCESS
1B9EC  50FA     MOVF 0xFFA, W, ACCESS
1B9EE  0012     RETURN 0
200:               }
201:           }
202:           
203:           void __interrupt(irq(U2RX),base(8)) UART2_rx_vect_isr()
204:           {
205:               if(UART2_RxInterruptHandler)
1B9F4  0100     MOVLB 0x0
1B9F6  51B7     MOVF UART2_RxInterruptHandler, W, BANKED
1B9F8  11B8     IORWF 0xB8, W, BANKED
1B9FA  11B9     IORWF 0xB9, W, BANKED
1B9FC  B4D8     BTFSC 0xFD8, 2, ACCESS
1B9FE  0011     RETFIE 1
206:               {
207:                   UART2_RxInterruptHandler();
1BA00  D801     RCALL 0xBA04
208:               }
209:           }
210:           
211:           
212:           
213:           void UART2_Transmit_ISR(void)
214:           {
215:               // use this default transmit interrupt handler code
216:               if(sizeof(uart2TxBuffer) > uart2TxBufferRemaining)
1B718  0E40     MOVLW 0x40
1B71A  6044     CPFSLT uart2TxBufferRemaining, ACCESS
1B71C  D010     BRA 0xB73E
217:               {
218:                   U2TXB = uart2TxBuffer[uart2TxTail++];
1B71E  0E00     MOVLW 0x0
1B720  2445     ADDWF uart2TxTail, W, ACCESS
1B722  6ED9     MOVWF 0xFD9, ACCESS
1B724  6ADA     CLRF 0xFDA, ACCESS
1B726  0E03     MOVLW 0x3
1B728  22DA     ADDWFC 0xFDA, F, ACCESS
1B72A  50DF     MOVF 0xFDF, W, ACCESS
1B72C  013D     MOVLB 0x3D
1B72E  6FD2     MOVWF 0xD2, BANKED
1B730  2A45     INCF uart2TxTail, F, ACCESS
219:                  if(sizeof(uart2TxBuffer) <= uart2TxTail)
1B732  0E3F     MOVLW 0x3F
1B734  6445     CPFSGT uart2TxTail, ACCESS
1B736  D001     BRA 0xB73A
220:                   {
221:                       uart2TxTail = 0;
1B738  6A45     CLRF uart2TxTail, ACCESS
222:                   }
223:                   uart2TxBufferRemaining++;
1B73A  2A44     INCF uart2TxBufferRemaining, F, ACCESS
224:               }
1B73C  0012     RETURN 0
225:               else
226:               {
227:                   PIE6bits.U2TXIE = 0;
1B73E  0139     MOVLB 0x39
1B740  9796     BCF utctime, 3, BANKED
228:               }
229:               
230:               // or set custom function using UART2_SetTxInterruptHandler()
231:           }
1B742  0012     RETURN 0
1B9F0  EE14     LFSR 1, 0x115C
1B9F2  F15C     NOP
1B9F4  0100     MOVLB 0x0
1B9F6  51B7     MOVF UART2_RxInterruptHandler, W, BANKED
1B9F8  11B8     IORWF 0xB8, W, BANKED
1B9FA  11B9     IORWF 0xB9, W, BANKED
1B9FC  B4D8     BTFSC 0xFD8, 2, ACCESS
1B9FE  0011     RETFIE 1
1BA00  D801     RCALL 0xBA04
1BA02  0011     RETFIE 1
1BA04  0005     PUSH
1BA06  6EFA     MOVWF 0xFFA, ACCESS
1BA08  51B7     MOVF UART2_RxInterruptHandler, W, BANKED
1BA0A  6EFD     MOVWF 0xFFD, ACCESS
1BA0C  51B8     MOVF 0xB8, W, BANKED
1BA0E  6EFE     MOVWF 0xFFE, ACCESS
1BA10  51B9     MOVF 0xB9, W, BANKED
1BA12  6EFF     MOVWF 0xFFF, ACCESS
1BA14  50FA     MOVF 0xFFA, W, ACCESS
1BA16  0012     RETURN 0
232:           
233:           void UART2_Receive_ISR(void)
234:           {
235:               // use this default receive interrupt handler code
236:               uart2RxBuffer[uart2RxHead++] = U2RXB;
1BB54  0E00     MOVLW 0x0
1BB56  2443     ADDWF uart2RxHead, W, ACCESS
1BB58  6ED9     MOVWF 0xFD9, ACCESS
1BB5A  6ADA     CLRF 0xFDA, ACCESS
1BB5C  0E04     MOVLW 0x4
1BB5E  22DA     ADDWFC 0xFDA, F, ACCESS
1BB62  F743     NOP
1BB64  FFDF     NOP
1BB66  2A43     INCF uart2RxHead, F, ACCESS
237:               if(sizeof(uart2RxBuffer) <= uart2RxHead)
1BB68  2843     INCF uart2RxHead, W, ACCESS
1BB6A  B4D8     BTFSC 0xFD8, 2, ACCESS
238:               {
239:                   uart2RxHead = 0;
1BB6C  6A43     CLRF uart2RxHead, ACCESS
240:               }
241:               uart2RxCount++;
1BB6E  0100     MOVLB 0x0
1BB70  2BCB     INCF uart2RxCount, F, BANKED
242:               
243:               // or set custom function using UART2_SetRxInterruptHandler()
244:           }
1BB72  0012     RETURN 0
245:           
246:           
247:           
248:           void UART2_SetRxInterruptHandler(void (* InterruptHandler)(void)){
249:               UART2_RxInterruptHandler = InterruptHandler;
1B836  50E1     MOVF 0xFE1, W, ACCESS
1B838  0FFD     ADDLW 0xFD
1B83A  6ED9     MOVWF 0xFD9, ACCESS
1B83C  50E2     MOVF 0xFE2, W, ACCESS
1B83E  6EDA     MOVWF 0xFDA, ACCESS
1B840  0EFF     MOVLW 0xFF
1B842  22DA     ADDWFC 0xFDA, F, ACCESS
1B846  FF78     NOP
1B848  F0B7     NOP
1B84C  FF78     NOP
1B84E  F0B8     NOP
1B852  FF74     NOP
1B854  F0B9     NOP
250:           }
1B856  52E5     MOVF 0xFE5, F, ACCESS
1B858  52E5     MOVF 0xFE5, F, ACCESS
1B85A  52E5     MOVF 0xFE5, F, ACCESS
1B85C  0012     RETURN 0
251:           
252:           void UART2_SetTxInterruptHandler(void (* InterruptHandler)(void)){
253:               UART2_TxInterruptHandler = InterruptHandler;
1B80E  50E1     MOVF 0xFE1, W, ACCESS
1B810  0FFD     ADDLW 0xFD
1B812  6ED9     MOVWF 0xFD9, ACCESS
1B814  50E2     MOVF 0xFE2, W, ACCESS
1B816  6EDA     MOVWF 0xFDA, ACCESS
1B818  0EFF     MOVLW 0xFF
1B81A  22DA     ADDWFC 0xFDA, F, ACCESS
1B81E  FF78     NOP
1B820  F0B4     NOP
1B824  FF78     NOP
1B826  F0B5     NOP
1B82A  FF74     NOP
1B82C  F0B6     NOP
254:           }
1B82E  52E5     MOVF 0xFE5, F, ACCESS
1B830  52E5     MOVF 0xFE5, F, ACCESS
1B832  52E5     MOVF 0xFE5, F, ACCESS
1B834  0012     RETURN 0
255:           
256:           /* stuff the uart2 receive buffer with testing data */
257:           void UART2_put_buffer(uint8_t bufData)
258:           {
259:           	PIE6bits.U2RXIE = 0;
260:           	uart2RxBuffer[uart2RxHead++] = bufData;
261:           	if (sizeof(uart2RxBuffer) <= uart2RxHead) {
262:           		uart2RxHead = 0;
263:           	}
264:           
265:           	uart2RxCount++;
266:           	PIE6bits.U2RXIE = 1;
267:           }
268:           /**
269:             End of File
270:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/uart1.c  -----------------------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.30
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB             :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            #include "interrupt_manager.h"
53:            #include "pin_manager.h"
54:            
55:            /**
56:              Section: Macro Declarations
57:             */
58:            #define UART1_TX_BUFFER_SIZE 8
59:            #define UART1_RX_BUFFER_SIZE 8
60:            
61:            /**
62:              Section: Global Variables
63:             */
64:            
65:            
66:            static volatile uint8_t uart1RxHead = 0;
67:            static volatile uint8_t uart1RxTail = 0;
68:            static volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
69:            volatile uint8_t uart1RxCount;
70:            
71:            /**
72:              Section: UART1 APIs
73:             */
74:            
75:            void UART1_Initialize(void)
76:            {
77:            	// Disable interrupts before changing states
78:            	PIE3bits.U1RXIE = 0;
1B0EA  0139     MOVLB 0x39
1B0EC  9793     BCF 0x93, 3, BANKED
79:            	UART1_SetRxInterruptHandler(UART1_Receive_ISR);
1B0EE  0ECE     MOVLW 0xCE
1B0F0  6EE6     MOVWF 0xFE6, ACCESS
1B0F2  0EBB     MOVLW 0xBB
1B0F4  6EE6     MOVWF 0xFE6, ACCESS
1B0F6  0E01     MOVLW 0x1
1B0F8  6EE6     MOVWF 0xFE6, ACCESS
1B0FA  EC2F     CALL 0x1B85E, 0
1B0FC  F0DC     NOP
80:            
81:            	// Set the UART1 module to the options selected in the user interface.
82:            
83:            	// P1L 0; 
84:            	U1P1L = 0x00;
1B0FE  013D     MOVLB 0x3D
1B100  6BEC     CLRF 0xEC, BANKED
85:            
86:            	// P1H 0; 
87:            	U1P1H = 0x00;
1B102  6BED     CLRF 0xED, BANKED
88:            
89:            	// P2L 0; 
90:            	U1P2L = 0x00;
1B104  6BEE     CLRF 0xEE, BANKED
91:            
92:            	// P2H 0; 
93:            	U1P2H = 0x00;
1B106  6BEF     CLRF 0xEF, BANKED
94:            
95:            	// P3L 0; 
96:            	U1P3L = 0x00;
1B108  6BF0     CLRF __pdataBANK0, BANKED
97:            
98:            	// P3H 0; 
99:            	U1P3H = 0x00;
1B10A  6BF1     CLRF 0xF1, BANKED
100:           
101:           	// BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
102:           	U1CON0 = 0xB0;
1B10C  0EB0     MOVLW 0xB0
1B10E  6FF2     MOVWF 0xF2, BANKED
103:           
104:           	// RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
105:           	U1CON1 = 0x80;
1B110  0E80     MOVLW 0x80
1B112  6FF3     MOVWF 0xF3, BANKED
106:           
107:           	// TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
108:           	U1CON2 = 0x00;
1B114  6BF4     CLRF 0xF4, BANKED
109:           
110:               // BRGL 138; 
111:               U1BRGL = 0x8A;
1B116  0E8A     MOVLW 0x8A
1B118  6FF5     MOVWF 0xF5, BANKED
112:           
113:               // BRGH 0; 
114:               U1BRGH = 0x00;
1B11A  6BF6     CLRF 0xF6, BANKED
115:           
116:           	// STPMD in middle of first Stop bit; TXWRE No error; 
117:           	U1FIFO = 0x00;
1B11C  6BF7     CLRF H, BANKED
118:           
119:           	// ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
120:           	U1UIR = 0x00;
1B11E  6BF8     CLRF 0xF8, BANKED
121:           
122:           	// ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
123:           	U1ERRIR = 0x00;
1B120  6BF9     CLRF 0xF9, BANKED
124:           
125:           	// TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
126:           	U1ERRIE = 0x00;
1B122  6BFA     CLRF 0xFA, BANKED
127:           
128:           
129:           	uart1RxHead = 0;
1B124  6A47     CLRF uart1RxHead, ACCESS
130:           	uart1RxTail = 0;
1B126  6A46     CLRF uart1RxTail, ACCESS
131:           	uart1RxCount = 0;
1B128  0100     MOVLB 0x0
1B12A  6BCE     CLRF uart1RxCount, BANKED
132:           
133:           	// enable receive interrupt
134:           	PIE3bits.U1RXIE = 1;
1B12C  0139     MOVLB 0x39
1B12E  8793     BSF 0x93, 3, BANKED
135:           }
1B130  0012     RETURN 0
136:           
137:           uint8_t UART1_is_rx_ready(void)
138:           {
139:           	return uart1RxCount;
140:           }
141:           
142:           bool UART1_is_tx_ready(void)
143:           {
144:               return (bool)(PIR3bits.U1TXIF && U1CON0bits.TXEN);
145:           }
146:           
147:           bool UART1_is_tx_done(void)
148:           {
149:           	return U1ERRIRbits.TXMTIF;
150:           }
151:           
152:           uint8_t UART1_Read(void)
153:           {
154:               uint8_t readValue  = 0;
155:           
156:               while(0 == uart1RxCount)
157:               {
158:           	}
159:           
160:           	readValue = uart1RxBuffer[uart1RxTail++];
161:              	if(sizeof(uart1RxBuffer) <= uart1RxTail)
162:               {
163:           		uart1RxTail = 0;
164:           	}
165:           	PIE3bits.U1RXIE = 0;
166:           	uart1RxCount--;
167:           	PIE3bits.U1RXIE = 1;
168:           
169:           	return readValue;
170:           }
171:           
172:           void UART1_Write(uint8_t txData)
173:           {
174:               while(0 == PIR3bits.U1TXIF)
175:               {
176:           	}
177:           
178:               U1TXB = txData;    // Write the data byte to the USART.
179:           		}
180:           	
181:           void __interrupt(irq(U1RX),base(8)) UART1_rx_vect_isr()
1B9A0  EE14     LFSR 1, 0x115C
1B9A2  F15C     NOP
182:           {
183:               if(UART1_RxInterruptHandler)
1B9A4  0100     MOVLB 0x0
1B9A6  51B1     MOVF UART1_RxInterruptHandler, W, BANKED
1B9A8  11B2     IORWF 0xB2, W, BANKED
1B9AA  11B3     IORWF 0xB3, W, BANKED
1B9AC  B4D8     BTFSC 0xFD8, 2, ACCESS
1B9AE  0011     RETFIE 1
184:           {
185:           		UART1_RxInterruptHandler();
1B9B0  D801     RCALL 0xB9B4
1B9B2  0011     RETFIE 1
1B9B4  0005     PUSH
1B9B6  6EFA     MOVWF 0xFFA, ACCESS
1B9B8  51B1     MOVF UART1_RxInterruptHandler, W, BANKED
1B9BA  6EFD     MOVWF 0xFFD, ACCESS
1B9BC  51B2     MOVF 0xB2, W, BANKED
1B9BE  6EFE     MOVWF 0xFFE, ACCESS
1B9C0  51B3     MOVF 0xB3, W, BANKED
1B9C2  6EFF     MOVWF 0xFFF, ACCESS
1B9C4  50FA     MOVF 0xFFA, W, ACCESS
1B9C6  0012     RETURN 0
186:           	}
187:           }
188:           
189:           
190:           
191:           
192:           void UART1_Receive_ISR(void)
193:           {
194:           	// use this default receive interrupt handler code
195:           	uart1RxBuffer[uart1RxHead++] = U1RXB;
1BBCE  5047     MOVF uart1RxHead, W, ACCESS
1BBD0  0F6C     ADDLW 0x6C
1BBD2  6ED9     MOVWF 0xFD9, ACCESS
1BBD4  6ADA     CLRF 0xFDA, ACCESS
1BBD8  F7A3     NOP
1BBDA  FFDF     NOP
1BBDC  2A47     INCF uart1RxHead, F, ACCESS
196:               if(sizeof(uart1RxBuffer) <= uart1RxHead)
1BBDE  0E07     MOVLW 0x7
1BBE0  6447     CPFSGT uart1RxHead, ACCESS
1BBE2  D001     BRA 0xBBE6
197:               {
198:           		uart1RxHead = 0;
1BBE4  6A47     CLRF uart1RxHead, ACCESS
199:           	}
200:           	uart1RxCount++;
1BBE6  0100     MOVLB 0x0
1BBE8  2BCE     INCF uart1RxCount, F, BANKED
201:           
202:           	// or set custom function using UART1_SetRxInterruptHandler()
203:           }
1B9C8  EE14     LFSR 1, 0x115C
1B9CA  F15C     NOP
1BBEA  0012     RETURN 0
204:           
205:           
206:           
207:           void UART1_SetRxInterruptHandler(void (* InterruptHandler)(void)){
208:           	UART1_RxInterruptHandler = InterruptHandler;
1B85E  50E1     MOVF 0xFE1, W, ACCESS
1B860  0FFD     ADDLW 0xFD
1B862  6ED9     MOVWF 0xFD9, ACCESS
1B864  50E2     MOVF 0xFE2, W, ACCESS
1B866  6EDA     MOVWF 0xFDA, ACCESS
1B868  0EFF     MOVLW 0xFF
1B86A  22DA     ADDWFC 0xFDA, F, ACCESS
1B86E  FF78     NOP
1B870  F0B1     NOP
1B874  FF78     NOP
1B876  F0B2     NOP
1B87A  FF74     NOP
1B87C  F0B3     NOP
209:           }
1B87E  52E5     MOVF 0xFE5, F, ACCESS
1B880  52E5     MOVF 0xFE5, F, ACCESS
1B882  52E5     MOVF 0xFE5, F, ACCESS
1B884  0012     RETURN 0
210:           
211:           
212:           /* stuff the uart1 receive buffer with testing data */
213:           void UART1_put_buffer(uint8_t bufData)
214:           {
215:           	PIE3bits.U1RXIE = 0;
216:           	uart1RxBuffer[uart1RxHead++] = bufData;
217:           	if (sizeof(uart1RxBuffer) <= uart1RxHead) {
218:           		uart1RxHead = 0;
219:           	}
220:           
221:           	uart1RxCount++;
222:           	PIE3bits.U1RXIE = 1;
223:           }
224:           /**
225:             End of File
226:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr6.c  ------------------------------
1:             /**
2:               TMR6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR6.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr6.h"
53:            #include "interrupt_manager.h"
54:            #include "../vconfig.h"
55:            #include "../timers.h"
56:            
57:            extern struct V_data V;
58:            extern volatile uint16_t tickCount[TMR_COUNT];
59:            
60:            /**
61:              Section: Global Variables Definitions
62:            */
63:            
64:            void (*TMR6_InterruptHandler)(void);
65:            
66:            /**
67:              Section: TMR6 APIs
68:            */
69:            
70:            void TMR6_Initialize(void)
71:            {
72:                // Set TMR6 to the options selected in the User Interface
73:            
74:                // T6CS FOSC/4; 
75:                T6CLKCON = 0x01;
1B744  0E01     MOVLW 0x1
1B746  6E96     MOVWF 0xF96, ACCESS
76:            
77:                // T6PSYNC Not Synchronized; T6MODE Software control; T6CKPOL Rising Edge; T6CKSYNC Not Synchronized; 
78:                T6HLT = 0x00;
1B748  6A95     CLRF 0xF95, ACCESS
79:            
80:                // T6RSEL T6CKIPPS pin; 
81:                T6RST = 0x00;
1B74A  6A97     CLRF 0xF97, ACCESS
82:            
83:                // PR6 124; 
84:                T6PR = 0x7C;
1B74C  0E7C     MOVLW 0x7C
1B74E  6E93     MOVWF 0xF93, ACCESS
85:            
86:                // TMR6 0; 
87:                T6TMR = 0x00;
1B750  6A92     CLRF 0xF92, ACCESS
88:            
89:                // Clearing IF flag before enabling the interrupt.
90:                PIR9bits.TMR6IF = 0;
1B752  0139     MOVLB 0x39
1B754  91A9     BCF 0xA9, 0, BANKED
91:            
92:                // Enabling TMR6 interrupt.
93:                PIE9bits.TMR6IE = 1;
1B756  8199     BSF 0x99, 0, BANKED
94:            
95:                // Set Default Interrupt Handler
96:                TMR6_SetInterruptHandler(TMR6_DefaultInterruptHandler);
1B758  0E0A     MOVLW 0xA
1B75A  6EE6     MOVWF 0xFE6, ACCESS
1B75C  0EB0     MOVLW 0xB0
1B75E  6EE6     MOVWF 0xFE6, ACCESS
1B760  0E01     MOVLW 0x1
1B762  6EE6     MOVWF 0xFE6, ACCESS
1B764  EC43     CALL 0x1B886, 0
1B766  F0DC     NOP
97:            
98:                // T6CKPS 1:64; T6OUTPS 1:1; TMR6ON on; 
99:                T6CON = 0xE0;
1B768  0EE0     MOVLW 0xE0
1B76A  6E94     MOVWF 0xF94, ACCESS
100:           }
1B76C  0012     RETURN 0
101:           
102:           void TMR6_ModeSet(TMR6_HLT_MODE mode)
103:           {
104:              // Configure different types HLT mode
105:               T6HLTbits.MODE = mode;
106:           }
107:           
108:           void TMR6_ExtResetSourceSet(TMR6_HLT_EXT_RESET_SOURCE reset)
109:           {
110:               //Configure different types of HLT external reset source
111:               T6RSTbits.RSEL = reset;
112:           }
113:           
114:           void TMR6_Start(void)
115:           {
116:               // Start the Timer by writing to TMRxON bit
117:               T6CONbits.TMR6ON = 1;
118:           }
119:           
120:           void TMR6_StartTimer(void)
121:           {
122:               TMR6_Start();
123:           }
124:           
125:           void TMR6_Stop(void)
126:           {
127:               // Stop the Timer by writing to TMRxON bit
128:               T6CONbits.TMR6ON = 0;
129:           }
130:           
131:           void TMR6_StopTimer(void)
132:           {
133:               TMR6_Stop();
134:           }
135:           
136:           uint8_t TMR6_Counter8BitGet(void)
137:           {
138:               uint8_t readVal;
139:           
140:               readVal = TMR6;
141:           
142:               return readVal;
143:           }
144:           
145:           uint8_t TMR6_ReadTimer(void)
146:           {
147:               return TMR6_Counter8BitGet();
148:           }
149:           
150:           void TMR6_Counter8BitSet(uint8_t timerVal)
151:           {
152:               // Write to the Timer6 register
153:               TMR6 = timerVal;
154:           }
155:           
156:           void TMR6_WriteTimer(uint8_t timerVal)
157:           {
158:               TMR6_Counter8BitSet(timerVal);
159:           }
160:           
161:           void TMR6_Period8BitSet(uint8_t periodVal)
162:           {
163:              PR6 = periodVal;
164:           }
165:           
166:           void TMR6_LoadPeriodRegister(uint8_t periodVal)
167:           {
168:              TMR6_Period8BitSet(periodVal);
169:           }
170:           
171:           void __interrupt(irq(TMR6),base(8)) TMR6_ISR()
1BC26  F004     NOP
1BC28  F026     NOP
1BC2A  EE14     LFSR 1, 0x115C
1BC2C  F15C     NOP
172:           {
173:           
174:               // clear the TMR6 interrupt flag
175:               PIR9bits.TMR6IF = 0;
1BC2E  0139     MOVLB 0x39
1BC30  91A9     BCF 0xA9, 0, BANKED
176:           
177:               // ticker function call;
178:               // ticker is 1 -> Callback function gets called everytime this ISR executes
179:               TMR6_CallBack();
1BC32  EC66     CALL 0x1BACC, 0
1BC34  F0DD     NOP
180:           }
1BC38  F098     NOP
1BC3A  F001     NOP
1BC3C  0011     RETFIE 1
181:           
182:           void TMR6_CallBack(void)
183:           {
184:               // Add your custom callback code here
185:               // this code executes every TMR6_INTERRUPT_TICKER_FACTOR periods of TMR6
186:               if(TMR6_InterruptHandler)
1BACC  0100     MOVLB 0x0
1BACE  51A8     MOVF TMR6_InterruptHandler, W, BANKED
1BAD0  11A9     IORWF 0xA9, W, BANKED
1BAD2  11AA     IORWF 0xAA, W, BANKED
1BAD4  B4D8     BTFSC 0xFD8, 2, ACCESS
1BAD6  0012     RETURN 0
187:               {
188:                   TMR6_InterruptHandler();
1BAD8  D801     RCALL 0xBADC
1BADA  0012     RETURN 0
1BADC  0005     PUSH
1BADE  6EFA     MOVWF 0xFFA, ACCESS
1BAE0  51A8     MOVF TMR6_InterruptHandler, W, BANKED
1BAE2  6EFD     MOVWF 0xFFD, ACCESS
1BAE4  51A9     MOVF 0xA9, W, BANKED
1BAE6  6EFE     MOVWF 0xFFE, ACCESS
1BAE8  51AA     MOVF 0xAA, W, BANKED
1BAEA  6EFF     MOVWF 0xFFF, ACCESS
1BAEC  50FA     MOVF 0xFFA, W, ACCESS
1BAEE  0012     RETURN 0
189:               }
190:           }
191:           
192:           void TMR6_SetInterruptHandler(void (* InterruptHandler)(void)){
193:               TMR6_InterruptHandler = InterruptHandler;
1B886  50E1     MOVF 0xFE1, W, ACCESS
1B888  0FFD     ADDLW 0xFD
1B88A  6ED9     MOVWF 0xFD9, ACCESS
1B88C  50E2     MOVF 0xFE2, W, ACCESS
1B88E  6EDA     MOVWF 0xFDA, ACCESS
1B890  0EFF     MOVLW 0xFF
1B892  22DA     ADDWFC 0xFDA, F, ACCESS
1B896  FF78     NOP
1B898  F0A8     NOP
1B89C  FF78     NOP
1B89E  F0A9     NOP
1B8A2  FF74     NOP
1B8A4  F0AA     NOP
194:           }
1B8A6  52E5     MOVF 0xFE5, F, ACCESS
1B8A8  52E5     MOVF 0xFE5, F, ACCESS
1B8AA  52E5     MOVF 0xFE5, F, ACCESS
1B8AC  0012     RETURN 0
195:           
196:           void TMR6_DefaultInterruptHandler(void)
1B00A  52E6     MOVF 0xFE6, F, ACCESS
197:           {
198:           	uint8_t i;
199:               // add your TMR6 interrupt custom code
200:               // or set custom function using TMR6_SetInterruptHandler()
201:           
202:           	//Decrement each software timer
203:           	for (i = 0; i < TMR_COUNT; i++) {
1B00C  0EFF     MOVLW 0xFF
1B00E  6AE3     CLRF 0xFE3, ACCESS
204:           		if (tickCount[i] != 0) {
1B010  0EFF     MOVLW 0xFF
1B012  50E3     MOVF 0xFE3, W, ACCESS
1B014  0D02     MULLW 0x2
1B016  0E7D     MOVLW 0x7D
1B018  24F3     ADDWF 0xFF3, W, ACCESS
1B01A  6ED9     MOVWF 0xFD9, ACCESS
1B01C  0E02     MOVLW 0x2
1B01E  20F4     ADDWFC 0xFF4, W, ACCESS
1B020  6EDA     MOVWF 0xFDA, ACCESS
1B022  50DE     MOVF 0xFDE, W, ACCESS
1B024  10DE     IORWF 0xFDE, W, ACCESS
1B026  B4D8     BTFSC 0xFD8, 2, ACCESS
1B028  D00C     BRA 0xB042
205:           			tickCount[i]--;
1B02A  0EFF     MOVLW 0xFF
1B02C  50E3     MOVF 0xFE3, W, ACCESS
1B02E  0D02     MULLW 0x2
1B030  0E7D     MOVLW 0x7D
1B032  24F3     ADDWF 0xFF3, W, ACCESS
1B034  6ED9     MOVWF 0xFD9, ACCESS
1B036  0E02     MOVLW 0x2
1B038  20F4     ADDWFC 0xFF4, W, ACCESS
1B03A  6EDA     MOVWF 0xFDA, ACCESS
1B03C  06DE     DECF 0xFDE, F, ACCESS
1B03E  0E00     MOVLW 0x0
1B040  5ADD     SUBWFB 0xFDD, F, ACCESS
206:           }
207:           	}
1B042  0EFF     MOVLW 0xFF
1B044  2AE3     INCF 0xFE3, F, ACCESS
1B046  0EFF     MOVLW 0xFF
1B04A  FF8C     NOP
1B04C  F001     NOP
1B04E  0E0C     MOVLW 0xC
1B050  6401     CPFSGT ltemp0, ACCESS
1B052  D7DE     BRA 0xB010
208:           }
1B054  52E5     MOVF 0xFE5, F, ACCESS
1BD60  EE14     LFSR 1, 0x115C
209:           
210:           /**
211:             End of File
212:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr5.c  ------------------------------
1:             /**
2:               TMR5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR5.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "tmr5.h"
53:            #include "interrupt_manager.h"
54:            #include "../vconfig.h"
55:            #include "../mbmc.h"
56:            
57:            /**
58:              Section: Global Variables Definitions
59:             */
60:            volatile uint16_t timer5ReloadVal;
61:            void (*TMR5_InterruptHandler)(void);
62:            extern V_data V;
63:            extern C_data C;
64:            
65:            /**
66:              Section: TMR5 APIs
67:             */
68:            
69:            void TMR5_Initialize(void)
70:            {
71:            	//Set the Timer to the options selected in the GUI
72:            
73:            	//T5GE disabled; T5GTM disabled; T5GPOL low; T5GGO done; T5GSPM disabled; 
74:            	T5GCON = 0x00;
1B132  6A9B     CLRF 0xF9B, ACCESS
75:            
76:            	//GSS T5G_pin; 
77:            	T5GATE = 0x00;
1B134  6A9C     CLRF 0xF9C, ACCESS
78:            
79:            	//CS FOSC/4; 
80:            	T5CLK = 0x01;
1B136  0E01     MOVLW 0x1
1B138  6E9D     MOVWF 0xF9D, ACCESS
81:            
82:            	//TMR5H 99; 
83:            	TMR5H = 0x63;
1B13A  0E63     MOVLW 0x63
1B13C  6E99     MOVWF 0xF99, ACCESS
84:            
85:            	//TMR5L 192; 
86:            	TMR5L = 0xC0;
1B13E  0EC0     MOVLW 0xC0
1B140  6E98     MOVWF 0xF98, ACCESS
87:            
88:            	// Load the TMR value to reload variable
89:            	timer5ReloadVal = (uint16_t) ((TMR5H << 8) | TMR5L);
1B142  5098     MOVF 0xF98, W, ACCESS
1B146  FE64     NOP
1B148  F001     NOP
1B14A  6A02     CLRF ttemp5, ACCESS
1B14E  F004     NOP
1B150  F002     NOP
1B152  6A01     CLRF ltemp0, ACCESS
1B154  1001     IORWF ltemp0, W, ACCESS
1B156  0100     MOVLB 0x0
1B158  6FC8     MOVWF timer5ReloadVal, BANKED
1B15A  5002     MOVF ttemp5, W, ACCESS
1B15C  6FC9     MOVWF 0xC9, BANKED
90:            
91:            	// Clearing IF flag before enabling the interrupt.
92:            	PIR8bits.TMR5IF = 0;
1B15E  0139     MOVLB 0x39
1B160  9DA8     BCF TMR6_InterruptHandler, 6, BANKED
93:            
94:            	// Enabling TMR5 interrupt.
95:            	PIE8bits.TMR5IE = 1;
1B162  8D98     BSF 0x98, 6, BANKED
96:            
97:            	// Set Default Interrupt Handler
98:            	TMR5_SetInterruptHandler(TMR5_DefaultInterruptHandler);
1B164  0EC4     MOVLW 0xC4
1B166  6EE6     MOVWF 0xFE6, ACCESS
1B168  0EB4     MOVLW 0xB4
1B16A  6EE6     MOVWF 0xFE6, ACCESS
1B16C  0E01     MOVLW 0x1
1B16E  6EE6     MOVWF 0xFE6, ACCESS
1B170  EC57     CALL 0x1B8AE, 0
1B172  F0DC     NOP
99:            
100:           	// CKPS 1:8; NOT_SYNC synchronize; TMR5ON enabled; T5RD16 disabled; 
101:           	T5CON = 0x31;
1B174  0E31     MOVLW 0x31
1B176  6E9A     MOVWF 0xF9A, ACCESS
102:           }
1B178  0012     RETURN 0
103:           
104:           void TMR5_StartTimer(void)
105:           {
106:           	// Start the Timer by writing to TMRxON bit
107:           	T5CONbits.TMR5ON = 1;
108:           }
109:           
110:           void TMR5_StopTimer(void)
111:           {
112:           	// Stop the Timer by writing to TMRxON bit
113:           	T5CONbits.TMR5ON = 0;
114:           }
115:           
116:           uint16_t TMR5_ReadTimer(void)
117:           {
118:           	uint16_t readVal;
119:           	uint8_t readValHigh;
120:           	uint8_t readValLow;
121:           
122:           	T5CONbits.T5RD16 = 1;
123:           
124:           	readValLow = TMR5L;
125:           	readValHigh = TMR5H;
126:           
127:           	readVal = ((uint16_t) readValHigh << 8) | readValLow;
128:           
129:           	return readVal;
130:           }
131:           
132:           void TMR5_WriteTimer(uint16_t timerVal)
133:           {
134:           	if (T5CONbits.NOT_SYNC == 1) {
1B354  A49A     BTFSS 0xF9A, 2, ACCESS
1B356  D00F     BRA 0xB376
135:           		// Stop the Timer by writing to TMRxON bit
136:           		T5CONbits.TMR5ON = 0;
1B358  909A     BCF 0xF9A, 0, ACCESS
137:           
138:           		// Write to the Timer5 register
139:           		TMR5H = (timerVal >> 8);
1B35A  0EFF     MOVLW 0xFF
1B35C  24E1     ADDWF 0xFE1, W, ACCESS
1B35E  6ED9     MOVWF 0xFD9, ACCESS
1B360  0EFF     MOVLW 0xFF
1B362  20E2     ADDWFC 0xFE2, W, ACCESS
1B364  6EDA     MOVWF 0xFDA, ACCESS
1B366  50DF     MOVF 0xFDF, W, ACCESS
1B368  6E99     MOVWF 0xF99, ACCESS
140:           		TMR5L = timerVal;
1B36A  0EFE     MOVLW 0xFE
1B36E  FF8F     NOP
1B370  FF98     NOP
141:           
142:           		// Start the Timer after writing to the register
143:           		T5CONbits.TMR5ON = 1;
1B372  809A     BSF 0xF9A, 0, ACCESS
144:           	} else {
1B374  D00C     BRA 0xB38E
145:           		// Write to the Timer5 register
146:           		TMR5H = (timerVal >> 8);
1B376  0EFF     MOVLW 0xFF
1B378  24E1     ADDWF 0xFE1, W, ACCESS
1B37A  6ED9     MOVWF 0xFD9, ACCESS
1B37C  0EFF     MOVLW 0xFF
1B37E  20E2     ADDWFC 0xFE2, W, ACCESS
1B380  6EDA     MOVWF 0xFDA, ACCESS
1B382  50DF     MOVF 0xFDF, W, ACCESS
1B384  6E99     MOVWF 0xF99, ACCESS
147:           		TMR5L = timerVal;
1B386  0EFE     MOVLW 0xFE
1B38A  FF8F     NOP
1B38C  FF98     NOP
148:           	}
149:           }
1B38E  52E5     MOVF 0xFE5, F, ACCESS
1B390  52E5     MOVF 0xFE5, F, ACCESS
1B392  0012     RETURN 0
150:           
151:           void TMR5_Reload(void)
152:           {
153:           	TMR5_WriteTimer(timer5ReloadVal);
154:           }
155:           
156:           void TMR5_StartSinglePulseAcquisition(void)
157:           {
158:           	T5GCONbits.T5GGO = 1;
159:           }
160:           
161:           uint8_t TMR5_CheckGateValueStatus(void)
162:           {
163:           	return(T5GCONbits.T5GVAL);
164:           }
165:           
166:           void __interrupt(irq(TMR5),base(8),low_priority) TMR5_ISR()
19F0A  FF60     NOP
19F0C  F02D     NOP
19F10  F004     NOP
19F12  F02E     NOP
19F16  F008     NOP
19F18  F02F     NOP
19F1C  F00C     NOP
19F1E  F030     NOP
19F22  F010     NOP
19F24  F031     NOP
19F28  F014     NOP
19F2A  F032     NOP
19F2E  F018     NOP
19F30  F033     NOP
19F34  F01C     NOP
19F36  F034     NOP
19F3A  F020     NOP
19F3C  F035     NOP
19F40  F024     NOP
19F42  F036     NOP
19F46  F028     NOP
19F48  F037     NOP
19F4C  F02C     NOP
19F4E  F038     NOP
19F52  F030     NOP
19F54  F039     NOP
19F56  EE16     LFSR 1, 0x18AE
19F58  F0AE     NOP
167:           {
168:           	static volatile unsigned int CountCallBack = 0;
169:           
170:           	// Clear the TMR5 interrupt flag
171:           	PIR8bits.TMR5IF = 0;
19F5A  0139     MOVLB 0x39
19F5C  9DA8     BCF TMR6_InterruptHandler, 6, BANKED
172:           	TMR5_WriteTimer(timer5ReloadVal);
19F60  F323     NOP
19F62  FFE6     NOP
19F66  F327     NOP
19F68  FFE6     NOP
19F6A  ECAA     CALL 0x1B354, 0
19F6C  F0D9     NOP
173:           
174:           	// callback function - called every 100th pass
175:           	if (++CountCallBack >= (TMR5_INTERRUPT_TICKER_FACTOR+V.ticker)) {
19F6E  0101     MOVLB 0x1
19F70  51DA     MOVF 0xDA, W, BANKED
19F72  6E2B     MOVWF 0x2B, ACCESS
19F74  6A2C     CLRF 0x2C, ACCESS
19F76  0E05     MOVLW 0x5
19F78  262B     ADDWF 0x2B, F, ACCESS
19F7A  0E00     MOVLW 0x0
19F7C  222C     ADDWFC 0x2C, F, ACCESS
19F7E  0100     MOVLB 0x0
19F80  4BC6     INFSNZ CountCallBack, F, BANKED
19F82  2BC7     INCF 0xC7, F, BANKED
19F84  502B     MOVF 0x2B, W, ACCESS
19F86  5DC6     SUBWF CountCallBack, W, BANKED
19F88  502C     MOVF 0x2C, W, ACCESS
19F8A  59C7     SUBWFB 0xC7, W, BANKED
19F8C  A0D8     BTFSS 0xFD8, 0, ACCESS
19F8E  D005     BRA 0x9F9A
176:           		// ticker function call
177:           		TMR5_CallBack();
19F90  EC30     CALL 0x1BA60, 0
19F92  F0DD     NOP
178:           
179:           		// reset ticker counter
180:           		CountCallBack = 0;
19F94  0100     MOVLB 0x0
19F96  6BC6     CLRF CountCallBack, BANKED
19F98  6BC7     CLRF 0xC7, BANKED
181:           	}
182:           }
19F9C  F0E4     NOP
19F9E  F00C     NOP
19FA2  F0E0     NOP
19FA4  F00B     NOP
19FA8  F0DC     NOP
19FAA  F00A     NOP
19FAE  F0D8     NOP
19FB0  F009     NOP
19FB4  F0D4     NOP
19FB6  F008     NOP
19FBA  F0D0     NOP
19FBC  F007     NOP
19FC0  F0CC     NOP
19FC2  F006     NOP
19FC6  F0C8     NOP
19FC8  F005     NOP
19FCC  F0C4     NOP
19FCE  F004     NOP
19FD2  F0C0     NOP
19FD4  F003     NOP
19FD8  F0BC     NOP
19FDA  F002     NOP
19FDE  F0B8     NOP
19FE0  F001     NOP
19FE4  F0B7     NOP
19FE6  FFD8     NOP
19FE8  0011     RETFIE 1
183:           
184:           void TMR5_CallBack(void)
185:           {
186:           	// Add your custom callback code here
187:           	if (TMR5_InterruptHandler) {
1BA60  0100     MOVLB 0x0
1BA62  51A5     MOVF TMR5_InterruptHandler, W, BANKED
1BA64  11A6     IORWF 0xA6, W, BANKED
1BA66  11A7     IORWF 0xA7, W, BANKED
1BA68  B4D8     BTFSC 0xFD8, 2, ACCESS
1BA6A  0012     RETURN 0
188:           		TMR5_InterruptHandler();
1BA6C  D801     RCALL 0xBA70
1BA6E  0012     RETURN 0
1BA70  0005     PUSH
1BA72  6EFA     MOVWF 0xFFA, ACCESS
1BA74  51A5     MOVF TMR5_InterruptHandler, W, BANKED
1BA76  6EFD     MOVWF 0xFFD, ACCESS
1BA78  51A6     MOVF 0xA6, W, BANKED
1BA7A  6EFE     MOVWF 0xFFE, ACCESS
1BA7C  51A7     MOVF 0xA7, W, BANKED
1BA7E  6EFF     MOVWF 0xFFF, ACCESS
1BA80  50FA     MOVF 0xFFA, W, ACCESS
1BA82  0012     RETURN 0
189:           	}
190:           }
191:           
192:           void TMR5_SetInterruptHandler(void (* InterruptHandler)(void))
193:           {
194:           	TMR5_InterruptHandler = InterruptHandler;
1B8AE  50E1     MOVF 0xFE1, W, ACCESS
1B8B0  0FFD     ADDLW 0xFD
1B8B2  6ED9     MOVWF 0xFD9, ACCESS
1B8B4  50E2     MOVF 0xFE2, W, ACCESS
1B8B6  6EDA     MOVWF 0xFDA, ACCESS
1B8B8  0EFF     MOVLW 0xFF
1B8BA  22DA     ADDWFC 0xFDA, F, ACCESS
1B8BE  FF78     NOP
1B8C0  F0A5     NOP
1B8C4  FF78     NOP
1B8C6  F0A6     NOP
1B8CA  FF74     NOP
1B8CC  F0A7     NOP
195:           }
1B8CE  52E5     MOVF 0xFE5, F, ACCESS
1B8D0  52E5     MOVF 0xFE5, F, ACCESS
1B8D2  52E5     MOVF 0xFE5, F, ACCESS
1B8D4  0012     RETURN 0
196:           
197:           void TMR5_DefaultInterruptHandler(void)
198:           {
199:           	// add your TMR5 interrupt custom code
200:           	// or set custom function using TMR5_SetInterruptHandler()
201:           	SLED = (uint8_t) ~SLED;
1B4C4  A0BE     BTFSS 0xFBE, 0, ACCESS
1B4C6  D002     BRA 0xB4CC
1B4C8  0E01     MOVLW 0x1
1B4CA  D001     BRA 0xB4CE
1B4CC  0E00     MOVLW 0x0
1B4CE  0AFF     XORLW 0xFF
1B4D0  6E0C     MOVWF 0xC, ACCESS
1B4D2  50BE     MOVF 0xFBE, W, ACCESS
1B4D4  180C     XORWF 0xC, W, ACCESS
1B4D6  0BFE     ANDLW 0xFE
1B4D8  180C     XORWF 0xC, W, ACCESS
1B4DA  6EBE     MOVWF 0xFBE, ACCESS
202:           	V.timerint_count++;
1B4DC  0E01     MOVLW 0x1
1B4DE  0101     MOVLB 0x1
1B4E0  27EB     ADDWF 0xEB, F, BANKED
1B4E2  0E00     MOVLW 0x0
1B4E4  23EC     ADDWFC 0xEC, F, BANKED
1B4E6  23ED     ADDWFC 0xED, F, BANKED
1B4E8  23EE     ADDWFC 0xEE, F, BANKED
203:           	V.ticks++;
1B4EA  0E01     MOVLW 0x1
1B4EC  27B1     ADDWF UART1_RxInterruptHandler, F, BANKED
1B4EE  0E00     MOVLW 0x0
1B4F0  23B2     ADDWFC 0xB2, F, BANKED
1B4F2  23B3     ADDWFC 0xB3, F, BANKED
1B4F4  23B4     ADDWFC UART2_TxInterruptHandler, F, BANKED
204:           	check_day_time();
1B4F6  ECAA     CALL 0x18554, 0
1B4F8  F0C2     NOP
205:           }
1B4FA  0012     RETURN 0
206:           
207:           /**
208:             End of File
209:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr3.c  ------------------------------
1:             /**
2:               TMR3 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr3.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR3 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR3.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr3.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer3ReloadVal;
59:            void (*TMR3_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR3 APIs
63:            */
64:            
65:            void TMR3_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T3GE disabled; T3GTM disabled; T3GPOL low; T3GGO done; T3GSPM disabled; 
70:                T3GCON = 0x00;
1B17A  6AA7     CLRF 0xFA7, ACCESS
71:            
72:                //GSS T3G_pin; 
73:                T3GATE = 0x00;
1B17C  6AA8     CLRF 0xFA8, ACCESS
74:            
75:                //CS FOSC/4; 
76:                T3CLK = 0x01;
1B17E  0E01     MOVLW 0x1
1B180  6EA9     MOVWF 0xFA9, ACCESS
77:            
78:                //TMR3H 60; 
79:                TMR3H = 0x3C;
1B182  0E3C     MOVLW 0x3C
1B184  6EA5     MOVWF 0xFA5, ACCESS
80:            
81:                //TMR3L 176; 
82:                TMR3L = 0xB0;
1B186  0EB0     MOVLW 0xB0
1B188  6EA4     MOVWF 0xFA4, ACCESS
83:            
84:                // Load the TMR value to reload variable
85:                timer3ReloadVal=(uint16_t)((TMR3H << 8) | TMR3L);
1B18A  50A4     MOVF 0xFA4, W, ACCESS
1B18E  FE94     NOP
1B190  F001     NOP
1B192  6A02     CLRF ttemp5, ACCESS
1B196  F004     NOP
1B198  F002     NOP
1B19A  6A01     CLRF ltemp0, ACCESS
1B19C  1001     IORWF ltemp0, W, ACCESS
1B19E  0100     MOVLB 0x0
1B1A0  6FC4     MOVWF timer3ReloadVal, BANKED
1B1A2  5002     MOVF ttemp5, W, ACCESS
1B1A4  6FC5     MOVWF 0xC5, BANKED
86:            
87:                // Clearing IF flag before enabling the interrupt.
88:                PIR6bits.TMR3IF = 0;
1B1A6  0139     MOVLB 0x39
1B1A8  9DA6     BCF 0xA6, 6, BANKED
89:            
90:                // Enabling TMR3 interrupt.
91:                PIE6bits.TMR3IE = 1;
1B1AA  8D96     BSF utctime, 6, BANKED
92:            
93:                // Set Default Interrupt Handler
94:                TMR3_SetInterruptHandler(TMR3_DefaultInterruptHandler);
1B1AC  0EF0     MOVLW 0xF0
1B1AE  6EE6     MOVWF 0xFE6, ACCESS
1B1B0  0EBD     MOVLW 0xBD
1B1B2  6EE6     MOVWF 0xFE6, ACCESS
1B1B4  0E01     MOVLW 0x1
1B1B6  6EE6     MOVWF 0xFE6, ACCESS
1B1B8  EC6B     CALL 0x1B8D6, 0
1B1BA  F0DC     NOP
95:            
96:                // CKPS 1:8; NOT_SYNC synchronize; TMR3ON enabled; T3RD16 disabled; 
97:                T3CON = 0x31;
1B1BC  0E31     MOVLW 0x31
1B1BE  6EA6     MOVWF 0xFA6, ACCESS
98:            }
1B1C0  0012     RETURN 0
99:            
100:           void TMR3_StartTimer(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T3CONbits.TMR3ON = 1;
104:           }
105:           
106:           void TMR3_StopTimer(void)
107:           {
108:               // Stop the Timer by writing to TMRxON bit
109:               T3CONbits.TMR3ON = 0;
110:           }
111:           
112:           uint16_t TMR3_ReadTimer(void)
113:           {
114:               uint16_t readVal;
115:               uint8_t readValHigh;
116:               uint8_t readValLow;
117:               
118:               T3CONbits.T3RD16 = 1;
119:           	
120:               readValLow = TMR3L;
121:               readValHigh = TMR3H;
122:               
123:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
124:           
125:               return readVal;
126:           }
127:           
128:           void TMR3_WriteTimer(uint16_t timerVal)
129:           {
130:               if (T3CONbits.NOT_SYNC == 1)
1B394  A4A6     BTFSS 0xFA6, 2, ACCESS
1B396  D00F     BRA 0xB3B6
131:               {
132:                   // Stop the Timer by writing to TMRxON bit
133:                   T3CONbits.TMR3ON = 0;
1B398  90A6     BCF 0xFA6, 0, ACCESS
134:           
135:                   // Write to the Timer3 register
136:                   TMR3H = (timerVal >> 8);
1B39A  0EFF     MOVLW 0xFF
1B39C  24E1     ADDWF 0xFE1, W, ACCESS
1B39E  6ED9     MOVWF 0xFD9, ACCESS
1B3A0  0EFF     MOVLW 0xFF
1B3A2  20E2     ADDWFC 0xFE2, W, ACCESS
1B3A4  6EDA     MOVWF 0xFDA, ACCESS
1B3A6  50DF     MOVF 0xFDF, W, ACCESS
1B3A8  6EA5     MOVWF 0xFA5, ACCESS
137:                   TMR3L = timerVal;
1B3AA  0EFE     MOVLW 0xFE
1B3AE  FF8F     NOP
1B3B0  FFA4     NOP
138:           
139:                   // Start the Timer after writing to the register
140:                   T3CONbits.TMR3ON =1;
1B3B2  80A6     BSF 0xFA6, 0, ACCESS
141:               }
1B3B4  D00C     BRA 0xB3CE
142:               else
143:               {
144:                   // Write to the Timer3 register
145:                   TMR3H = (timerVal >> 8);
1B3B6  0EFF     MOVLW 0xFF
1B3B8  24E1     ADDWF 0xFE1, W, ACCESS
1B3BA  6ED9     MOVWF 0xFD9, ACCESS
1B3BC  0EFF     MOVLW 0xFF
1B3BE  20E2     ADDWFC 0xFE2, W, ACCESS
1B3C0  6EDA     MOVWF 0xFDA, ACCESS
1B3C2  50DF     MOVF 0xFDF, W, ACCESS
1B3C4  6EA5     MOVWF 0xFA5, ACCESS
146:                   TMR3L = timerVal;
1B3C6  0EFE     MOVLW 0xFE
1B3CA  FF8F     NOP
1B3CC  FFA4     NOP
147:               }
148:           }
1B3CE  52E5     MOVF 0xFE5, F, ACCESS
1B3D0  52E5     MOVF 0xFE5, F, ACCESS
1B3D2  0012     RETURN 0
149:           
150:           void TMR3_Reload(void)
151:           {
152:               TMR3_WriteTimer(timer3ReloadVal);
153:           }
154:           
155:           void TMR3_StartSinglePulseAcquisition(void)
156:           {
157:               T3GCONbits.T3GGO = 1;
158:           }
159:           
160:           uint8_t TMR3_CheckGateValueStatus(void)
161:           {
162:               return (T3GCONbits.T3GVAL);
163:           }
164:           
165:           void __interrupt(irq(TMR3),base(8),low_priority) TMR3_ISR()
18E66  FF60     NOP
18E68  F0D7     NOP
18E6C  FFD8     NOP
18E6E  F0D8     NOP
18E72  FFDC     NOP
18E74  F0D9     NOP
18E78  FFE0     NOP
18E7A  F0DA     NOP
18E7E  FFD4     NOP
18E80  F0DB     NOP
18E84  F004     NOP
18E86  F0DC     NOP
18E8A  F008     NOP
18E8C  F0DD     NOP
18E90  F00C     NOP
18E92  F0DE     NOP
18E96  F010     NOP
18E98  F0DF     NOP
18E9C  F014     NOP
18E9E  F0E0     NOP
18EA2  F018     NOP
18EA4  F0E1     NOP
18EA8  F01C     NOP
18EAA  F0E2     NOP
18EAE  F020     NOP
18EB0  F0E3     NOP
18EB4  F024     NOP
18EB6  F0E4     NOP
18EBA  F028     NOP
18EBC  F0E5     NOP
18EC0  F02C     NOP
18EC2  F0E6     NOP
18EC6  F030     NOP
18EC8  F0E7     NOP
18ECC  F044     NOP
18ECE  F0E8     NOP
18ED2  F048     NOP
18ED4  F0E9     NOP
18ED8  F04C     NOP
18EDA  F0EA     NOP
18EDE  F050     NOP
18EE0  F0EB     NOP
18EE4  F054     NOP
18EE6  F0EC     NOP
18EEA  F058     NOP
18EEC  F0ED     NOP
18EF0  F05C     NOP
18EF2  F0EE     NOP
18EF6  F060     NOP
18EF8  F0EF     NOP
18EFA  EE16     LFSR 1, 0x18AE
18EFC  F0AE     NOP
166:           {
167:               static volatile unsigned int CountCallBack = 0;
168:           
169:               // Clear the TMR3 interrupt flag
170:               PIR6bits.TMR3IF = 0;
18EFE  0139     MOVLB 0x39
18F00  9DA6     BCF 0xA6, 6, BANKED
171:               TMR3_WriteTimer(timer3ReloadVal);
18F04  F313     NOP
18F06  FFE6     NOP
18F0A  F317     NOP
18F0C  FFE6     NOP
18F0E  ECCA     CALL 0x1B394, 0
18F10  F0D9     NOP
172:           
173:               // callback function - called every 40th pass
174:               if (++CountCallBack >= TMR3_INTERRUPT_TICKER_FACTOR)
18F12  0100     MOVLB 0x0
18F14  4BC2     INFSNZ CountCallBack, F, BANKED
18F16  2BC3     INCF 0xC3, F, BANKED
18F18  51C3     MOVF 0xC3, W, BANKED
18F1A  E104     BNZ 0x8F24
18F1C  0E28     MOVLW 0x28
18F1E  5DC2     SUBWF CountCallBack, W, BANKED
18F20  A0D8     BTFSS 0xFD8, 0, ACCESS
18F22  D005     BRA 0x8F2E
175:               {
176:                   // ticker function call
177:                   TMR3_CallBack();
18F24  EC42     CALL 0x1BA84, 0
18F26  F0DD     NOP
178:           
179:                   // reset ticker counter
180:                   CountCallBack = 0;
18F28  0100     MOVLB 0x0
18F2A  6BC2     CLRF CountCallBack, BANKED
18F2C  6BC3     CLRF 0xC3, BANKED
181:               }
182:           }
18F30  F3BC     NOP
18F32  F018     NOP
18F36  F3B8     NOP
18F38  F017     NOP
18F3C  F3B4     NOP
18F3E  F016     NOP
18F42  F3B0     NOP
18F44  F015     NOP
18F48  F3AC     NOP
18F4A  F014     NOP
18F4E  F3A8     NOP
18F50  F013     NOP
18F54  F3A4     NOP
18F56  F012     NOP
18F5A  F3A0     NOP
18F5C  F011     NOP
18F60  F39C     NOP
18F62  F00C     NOP
18F66  F398     NOP
18F68  F00B     NOP
18F6C  F394     NOP
18F6E  F00A     NOP
18F72  F390     NOP
18F74  F009     NOP
18F78  F38C     NOP
18F7A  F008     NOP
18F7E  F388     NOP
18F80  F007     NOP
18F84  F384     NOP
18F86  F006     NOP
18F8A  F380     NOP
18F8C  F005     NOP
18F90  F37C     NOP
18F92  F004     NOP
18F96  F378     NOP
18F98  F003     NOP
18F9C  F374     NOP
18F9E  F002     NOP
18FA2  F370     NOP
18FA4  F001     NOP
18FA8  F36F     NOP
18FAA  FFF5     NOP
18FAE  F36B     NOP
18FB0  FFF8     NOP
18FB4  F367     NOP
18FB6  FFF7     NOP
18FBA  F363     NOP
18FBC  FFF6     NOP
18FC0  F35F     NOP
18FC2  FFD8     NOP
18FC4  0011     RETFIE 1
183:           
184:           void TMR3_CallBack(void)
185:           {
186:               // Add your custom callback code here
187:               if(TMR3_InterruptHandler)
1BA84  0100     MOVLB 0x0
1BA86  51A2     MOVF TMR3_InterruptHandler, W, BANKED
1BA88  11A3     IORWF 0xA3, W, BANKED
1BA8A  11A4     IORWF 0xA4, W, BANKED
1BA8C  B4D8     BTFSC 0xFD8, 2, ACCESS
1BA8E  0012     RETURN 0
188:               {
189:                   TMR3_InterruptHandler();
1BA90  D801     RCALL 0xBA94
1BA92  0012     RETURN 0
1BA94  0005     PUSH
1BA96  6EFA     MOVWF 0xFFA, ACCESS
1BA98  51A2     MOVF TMR3_InterruptHandler, W, BANKED
1BA9A  6EFD     MOVWF 0xFFD, ACCESS
1BA9C  51A3     MOVF 0xA3, W, BANKED
1BA9E  6EFE     MOVWF 0xFFE, ACCESS
1BAA0  51A4     MOVF 0xA4, W, BANKED
1BAA2  6EFF     MOVWF 0xFFF, ACCESS
1BAA4  50FA     MOVF 0xFFA, W, ACCESS
1BAA6  0012     RETURN 0
190:               }
191:           }
192:           
193:           void TMR3_SetInterruptHandler(void (* InterruptHandler)(void)){
194:               TMR3_InterruptHandler = InterruptHandler;
1B8D6  50E1     MOVF 0xFE1, W, ACCESS
1B8D8  0FFD     ADDLW 0xFD
1B8DA  6ED9     MOVWF 0xFD9, ACCESS
1B8DC  50E2     MOVF 0xFE2, W, ACCESS
1B8DE  6EDA     MOVWF 0xFDA, ACCESS
1B8E0  0EFF     MOVLW 0xFF
1B8E2  22DA     ADDWFC 0xFDA, F, ACCESS
1B8E6  FF78     NOP
1B8E8  F0A2     NOP
1B8EC  FF78     NOP
1B8EE  F0A3     NOP
1B8F2  FF74     NOP
1B8F4  F0A4     NOP
195:           }
1B8F6  52E5     MOVF 0xFE5, F, ACCESS
1B8F8  52E5     MOVF 0xFE5, F, ACCESS
1B8FA  52E5     MOVF 0xFE5, F, ACCESS
1B8FC  0012     RETURN 0
196:           
197:           void TMR3_DefaultInterruptHandler(void){
198:               // add your TMR3 interrupt custom code
199:               // or set custom function using TMR3_SetInterruptHandler()
200:           }
1BDF0  0012     RETURN 0
201:           
202:           /**
203:             End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr2.c  ------------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
1BC56  0E01     MOVLW 0x1
1BC58  6EAE     MOVWF 0xFAE, ACCESS
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
1BC5A  6AAD     CLRF 0xFAD, ACCESS
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
1BC5C  6AAF     CLRF 0xFAF, ACCESS
74:            
75:                // PR2 99; 
76:                T2PR = 0x63;
1BC5E  0E63     MOVLW 0x63
1BC60  6EAB     MOVWF 0xFAB, ACCESS
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
1BC62  6AAA     CLRF 0xFAA, ACCESS
80:            
81:                // Clearing IF flag.
82:                PIR4bits.TMR2IF = 0;
1BC64  0139     MOVLB 0x39
1BC66  95A4     BCF 0xA4, 2, BANKED
83:            
84:                // T2CKPS 1:16; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0xC0;
1BC68  0EC0     MOVLW 0xC0
1BC6A  6EAC     MOVWF 0xFAC, ACCESS
86:            }
1BC6C  0012     RETURN 0
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR4bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR4bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/spi1.c  ------------------------------
1:             /**
2:               SPI1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the SPI1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for SPI1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15	
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "spi1.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            
58:            #define SPI_RX_IN_PROGRESS 0x0
59:            
60:            /**
61:              Section: Module APIs
62:            */
63:            
64:            void SPI1_Initialize(void)
65:            {
66:                // Set the SPI1 module to the options selected in the User Interface
67:            		// SSP active high; SDOP active high; FST disabled; SMP Middle; CKP Idle:Low, Active:High; CKE Active to idle; SDIP active high; 
68:            		SPI1CON1 = 0x40;
1BC6E  0E40     MOVLW 0x40
1BC70  013D     MOVLB 0x3D
1BC72  6F15     MOVWF 0x15, BANKED
69:            		// SSET disabled; RXR suspended if the RxFIFO is full; TXR required for a transfer; 
70:            		SPI1CON2 = 0x03;
1BC74  0E03     MOVLW 0x3
1BC76  6F16     MOVWF 0x16, BANKED
71:            		// BAUD 0; 
72:            		SPI1BAUD = 0x4F;
1BC78  0E4F     MOVLW 0x4F
1BC7A  6F19     MOVWF lltemp3, BANKED
73:            		// CLKSEL FOSC; 
74:            		SPI1CLK = 0x00;
1BC7C  6B1C     CLRF 0x1C, BANKED
75:            		// BMODE every byte; LSBF MSb first; EN enabled; MST bus master; 
76:            		SPI1CON0 = 0x83;
1BC7E  0E83     MOVLW 0x83
1BC80  6F14     MOVWF 0x14, BANKED
77:            }
1BC82  0012     RETURN 0
78:            
79:            uint8_t SPI1_Exchange8bit(uint8_t data)
80:            {
81:                //One byte transfer count
82:                SPI1TCNTL = 1;
1BB74  0E01     MOVLW 0x1
1BB76  013D     MOVLB 0x3D
1BB78  6F12     MOVWF 0x12, BANKED
83:                SPI1TXB = data;
1BB7A  0EFF     MOVLW 0xFF
1BB7E  FF8F     NOP
1BB80  FD11     NOP
84:            
85:                while(PIR2bits.SPI1RXIF == SPI_RX_IN_PROGRESS)
86:                {
87:                }
1BB82  0139     MOVLB 0x39
1BB84  A9A2     BTFSS TMR3_InterruptHandler, 4, BANKED
1BB86  D7FD     BRA 0xBB82
88:            
89:                return (SPI1RXB);
1BB8A  F440     NOP
1BB8C  F001     NOP
90:            }
1BB8E  52E5     MOVF 0xFE5, F, ACCESS
1BB90  0012     RETURN 0
91:            
92:            uint8_t SPI1_Exchange8bitBuffer(uint8_t *dataIn, uint8_t bufLen, uint8_t *dataOut)
93:            {
94:                uint8_t bytesWritten = 0;
95:            
96:                if(bufLen != 0)
97:                {
98:                    if(dataIn != NULL)
99:                    {
100:                       while(bytesWritten < bufLen)
101:                       {
102:                           if(dataOut == NULL)
103:                           {
104:                               SPI1_Exchange8bit(dataIn[bytesWritten]);
105:                           }
106:                           else
107:                           {
108:                               dataOut[bytesWritten] = SPI1_Exchange8bit(dataIn[bytesWritten]);
109:                           }
110:           
111:                           bytesWritten++;
112:                       }
113:                   }
114:                   else
115:                   {
116:                       if(dataOut != NULL)
117:                       {
118:                           while(bytesWritten < bufLen )
119:                           {
120:                               dataOut[bytesWritten] = SPI1_Exchange8bit(DUMMY_DATA);
121:           
122:                               bytesWritten++;
123:                           }
124:                       }
125:                   }
126:               }
127:           
128:               return bytesWritten;
129:           }
130:           
131:           /**
132:            End of File
133:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/pwm8.c  ------------------------------
1:              /**
2:                PWM8 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm8.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM8 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM8.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                     Device            :  PIC18F57K42
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 1.45 or later
21:                     MPLAB             :  MPLAB X 4.15
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm8.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM8_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM8POL active_hi; PWM8EN enabled; 
62:                PWM8CON = 0x80;   
1BC84  0E80     MOVLW 0x80
1BC86  6E62     MOVWF 0xF62, ACCESS
63:            
64:                // DC 0; 
65:                PWM8DCH = 0x00;   
1BC88  6A61     CLRF 0xF61, ACCESS
66:            
67:                // DC 1; 
68:                PWM8DCL = 0x40;   
1BC8A  0E40     MOVLW 0x40
1BC8C  6E60     MOVWF 0xF60, ACCESS
69:            
70:                // Select timer
71:                CCPTMRS1bits.P8TSEL = 1;
1BC8E  013F     MOVLB 0x3F
1BC90  515F     MOVF 0x5F, W, BANKED
1BC92  0B3F     ANDLW 0x3F
1BC94  0940     IORLW 0x40
1BC96  6F5F     MOVWF 0x5F, BANKED
72:             }
1BC98  0012     RETURN 0
73:            
74:             void PWM8_LoadDutyValue(uint16_t dutyValue)
75:             {
76:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
77:                 PWM8DCH = (dutyValue & 0x03FC)>>2;
1B292  0EFE     MOVLW 0xFE
1B296  FF8C     NOP
1B298  F00B     NOP
1B29A  0EFF     MOVLW 0xFF
1B29E  FF8C     NOP
1B2A0  F00C     NOP
1B2A2  90D8     BCF 0xFD8, 0, ACCESS
1B2A4  320C     RRCF 0xC, F, ACCESS
1B2A6  320B     RRCF wtemp5, F, ACCESS
1B2A8  90D8     BCF 0xFD8, 0, ACCESS
1B2AA  320C     RRCF 0xC, F, ACCESS
1B2AC  320B     RRCF wtemp5, F, ACCESS
1B2AE  500B     MOVF wtemp5, W, ACCESS
1B2B0  6E61     MOVWF 0xF61, ACCESS
78:                 
79:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
80:                 PWM8DCL = (dutyValue & 0x0003)<<6;
1B2B2  0EFE     MOVLW 0xFE
1B2B6  FF8C     NOP
1B2B8  F00C     NOP
1B2BA  0E03     MOVLW 0x3
1B2BC  160C     ANDWF 0xC, F, ACCESS
1B2BE  0E06     MOVLW 0x6
1B2C0  6E01     MOVWF ltemp0, ACCESS
1B2C2  90D8     BCF 0xFD8, 0, ACCESS
1B2C4  360C     RLCF 0xC, F, ACCESS
1B2C6  2E01     DECFSZ ltemp0, F, ACCESS
1B2C8  D7FC     BRA 0xB2C2
1B2CA  500C     MOVF 0xC, W, ACCESS
1B2CC  6E60     MOVWF 0xF60, ACCESS
81:             }
1B2CE  52E5     MOVF 0xFE5, F, ACCESS
1B2D0  52E5     MOVF 0xFE5, F, ACCESS
1B2D2  0012     RETURN 0
82:             /**
83:              End of File
84:             */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/pin_manager.c  -----------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include <xc.h>
50:            #include "pin_manager.h"
51:            #include "stdbool.h"
52:            
53:            
54:            
55:            
56:            
57:            void PIN_MANAGER_Initialize(void)
58:            {
59:                /**
60:                LATx registers
61:                */
62:                LATE = 0x07;
1A6F2  0E07     MOVLW 0x7
1A6F4  6EBE     MOVWF 0xFBE, ACCESS
63:                LATD = 0x80;
1A6F6  0E80     MOVLW 0x80
1A6F8  6EBD     MOVWF 0xFBD, ACCESS
64:                LATA = 0x00;
1A6FA  6ABA     CLRF 0xFBA, ACCESS
65:                LATF = 0x20;
1A6FC  0E20     MOVLW 0x20
1A6FE  6EBF     MOVWF 0xFBF, ACCESS
66:                LATB = 0x00;
1A700  6ABB     CLRF 0xFBB, ACCESS
67:                LATC = 0x07;
1A702  0E07     MOVLW 0x7
1A704  6EBC     MOVWF 0xFBC, ACCESS
68:            
69:                /**
70:                TRISx registers
71:                */
72:                TRISE = 0x00;
1A706  6AC6     CLRF 0xFC6, ACCESS
73:                TRISF = 0x0F;
1A708  0E0F     MOVLW 0xF
1A70A  6EC7     MOVWF 0xFC7, ACCESS
74:                TRISA = 0xFF;
1A70C  68C2     SETF 0xFC2, ACCESS
75:                TRISB = 0xBF;
1A70E  0EBF     MOVLW 0xBF
1A710  6EC3     MOVWF 0xFC3, ACCESS
76:                TRISC = 0x90;
1A712  0E90     MOVLW 0x90
1A714  6EC4     MOVWF 0xFC4, ACCESS
77:                TRISD = 0x0C;
1A716  0E0C     MOVLW 0xC
1A718  6EC5     MOVWF 0xFC5, ACCESS
78:            
79:                /**
80:                ANSELx registers
81:                */
82:                ANSELD = 0x00;
1A71A  013A     MOVLB 0x3A
1A71C  6B70     CLRF 0x70, BANKED
83:                ANSELC = 0x00;
1A71E  6B60     CLRF spi_link, BANKED
84:                ANSELB = 0x3C;
1A720  0E3C     MOVLW 0x3C
1A722  6F50     MOVWF 0x50, BANKED
85:                ANSELE = 0x00;
1A724  6B80     CLRF 0x80, BANKED
86:                ANSELF = 0x00;
1A726  6B90     CLRF 0x90, BANKED
87:                ANSELA = 0xFF;
1A728  6940     SETF esr_state, BANKED
88:            
89:                /**
90:                WPUx registers
91:                */
92:                WPUD = 0x0C;
1A72A  0E0C     MOVLW 0xC
1A72C  6F71     MOVWF 0x71, BANKED
93:                WPUF = 0x0F;
1A72E  0E0F     MOVLW 0xF
1A730  6F91     MOVWF 0x91, BANKED
94:                WPUE = 0x00;
1A732  6B81     CLRF 0x81, BANKED
95:                WPUB = 0x83;
1A734  0E83     MOVLW 0x83
1A736  6F51     MOVWF 0x51, BANKED
96:                WPUA = 0x00;
1A738  6B41     CLRF log_update_wait, BANKED
97:                WPUC = 0x97;
1A73A  0E97     MOVLW 0x97
1A73C  6F61     MOVWF 0x61, BANKED
98:            
99:                /**
100:               ODx registers
101:               */
102:               ODCONE = 0x00;
1A73E  6B82     CLRF F463, BANKED
103:               ODCONF = 0x00;
1A740  6B92     CLRF bvror, BANKED
104:               ODCONA = 0x00;
1A742  6B42     CLRF day_delay, BANKED
105:               ODCONB = 0x00;
1A744  6B52     CLRF 0x52, BANKED
106:               ODCONC = 0x00;
1A746  6B62     CLRF 0x62, BANKED
107:               ODCOND = 0x00;
1A748  6B72     CLRF 0x72, BANKED
108:           
109:               /**
110:               SLRCONx registers
111:               */
112:               SLRCONA = 0xFF;
1A74A  6943     SETF uart2RxHead, BANKED
113:               SLRCONB = 0xFF;
1A74C  6953     SETF 0x53, BANKED
114:               SLRCONC = 0xFF;
1A74E  6963     SETF 0x63, BANKED
115:               SLRCOND = 0xFF;
1A750  6973     SETF 0x73, BANKED
116:               SLRCONE = 0x07;
1A752  0E07     MOVLW 0x7
1A754  6F83     MOVWF 0x83, BANKED
117:               SLRCONF = 0xFF;
1A756  6993     SETF 0x93, BANKED
118:           
119:           
120:           
121:           
122:           
123:              
124:               
125:           	
126:               U2RXPPS = 0x0F;   //RB7->UART2:RX2;    
1A758  0E0F     MOVLW 0xF
1A75A  6FE8     MOVWF 0xE8, BANKED
127:               SPI1SCKPPS = 0x13;   //RC3->SPI1:SCK1;    
1A75C  0E13     MOVLW 0x13
1A75E  6FDE     MOVWF 0xDE, BANKED
128:               RB6PPS = 0x16;   //RB6->UART2:TX2;    
1A760  0E16     MOVLW 0x16
1A762  6F0E     MOVWF 0xE, BANKED
129:               RC3PPS = 0x1E;   //RC3->SPI1:SCK1;    
1A764  0E1E     MOVLW 0x1E
1A766  6F13     MOVWF 0x13, BANKED
130:               INT0PPS = 0x08;   //RB0->EXT_INT:INT0;    
1A768  0E08     MOVLW 0x8
1A76A  6FC0     MOVWF nout, BANKED
131:               RD1PPS = 0x10;   //RD1->PWM8:PWM8;    
1A76C  0E10     MOVLW 0x10
1A76E  6F19     MOVWF lltemp3, BANKED
132:               INT1PPS = 0x09;   //RB1->EXT_INT:INT1;    
1A770  0E09     MOVLW 0x9
1A772  6FC1     MOVWF 0xC1, BANKED
133:               RC5PPS = 0x1F;   //RC5->SPI1:SDO1;    
1A774  0E1F     MOVLW 0x1F
1A776  6F15     MOVWF 0x15, BANKED
134:               RC6PPS = 0x13;   //RC6->UART1:TX1;    
1A778  0E13     MOVLW 0x13
1A77A  6F16     MOVWF 0x16, BANKED
135:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
1A77C  0E17     MOVLW 0x17
1A77E  6FE5     MOVWF 0xE5, BANKED
136:               SPI1SDIPPS = 0x14;   //RC4->SPI1:SDI1;    
1A780  0E14     MOVLW 0x14
1A782  6FDF     MOVWF 0xDF, BANKED
137:           }
1A784  0012     RETURN 0
138:             
139:           void PIN_MANAGER_IOC(void)
140:           {   
141:           }
142:           
143:           /**
144:            End of File
145:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/mcc.c  -------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 or later
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
1B058  EC39     CALL 0x1AC72, 0
1B05A  F0D6     NOP
53:                PMD_Initialize();
1B05C  EC58     CALL 0x1BCB0, 0
1B05E  F0DE     NOP
54:                PIN_MANAGER_Initialize();
1B060  EC79     CALL 0x1A6F2, 0
1B062  F0D3     NOP
55:                OSCILLATOR_Initialize();
1B064  EC4D     CALL 0x1BC9A, 0
1B066  F0DE     NOP
56:                FVR_Initialize();
1B068  ECE3     CALL 0x1BDC6, 0
1B06A  F0DE     NOP
57:                ADCC_Initialize();
1B06C  ECCE     CALL 0x1AB9C, 0
1B06E  F0D5     NOP
58:                TMR2_Initialize();
1B070  EC2B     CALL 0x1BC56, 0
1B072  F0DE     NOP
59:                PWM8_Initialize();
1B074  EC42     CALL 0x1BC84, 0
1B076  F0DE     NOP
60:                EXT_INT_Initialize();
1B078  ECCE     CALL 0x1B59C, 0
1B07A  F0DA     NOP
61:                TMR6_Initialize();
1B07C  ECA2     CALL 0x1B744, 0
1B07E  F0DB     NOP
62:                TMR3_Initialize();
1B080  ECBD     CALL 0x1B17A, 0
1B082  F0D8     NOP
63:                TMR5_Initialize();
1B084  EC99     CALL 0x1B132, 0
1B086  F0D8     NOP
64:                UART1_Initialize();
1B088  EC75     CALL 0x1B0EA, 0
1B08A  F0D8     NOP
65:                UART2_Initialize();
1B08C  EC00     CALL 0x1AE00, 0
1B08E  F0D7     NOP
66:                SPI1_Initialize();
1B090  EC37     CALL 0x1BC6E, 0
1B092  F0DE     NOP
67:                DMA2_Initialize();
1B094  EC5D     CALL 0x1AEBA, 0
1B096  F0D7     NOP
68:                DMA1_Initialize();
1B098  EC99     CALL 0x1AB32, 0
1B09A  F0D5     NOP
69:                CLKREF_Initialize();
1B09C  ECB7     CALL 0x1BD6E, 0
1B09E  F0DE     NOP
70:            }
1B0A0  0012     RETURN 0
71:            
72:            void OSCILLATOR_Initialize(void)
73:            {
74:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
75:                OSCCON1 = 0x20;
1BC9A  0E20     MOVLW 0x20
1BC9C  0139     MOVLB 0x39
1BC9E  6FD9     MOVWF 0xD9, BANKED
76:                // CSWHOLD may proceed; SOSCPWR Low power; 
77:                OSCCON3 = 0x00;
1BCA0  6BDB     CLRF 0xDB, BANKED
78:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
79:                OSCEN = 0x00;
1BCA2  6BDD     CLRF 0xDD, BANKED
80:                // HFFRQ 4_MHz; 
81:                OSCFRQ = 0x02;
1BCA4  0E02     MOVLW 0x2
1BCA6  6FDF     MOVWF 0xDF, BANKED
82:                // TUN 0; 
83:                OSCTUNE = 0x00;
1BCA8  6BDE     CLRF 0xDE, BANKED
84:                // Wait for PLL to stabilize
85:                while(PLLR == 0)
86:                {
87:                }
1BCAA  B1DC     BTFSC 0xDC, 0, BANKED
1BCAC  0012     RETURN 0
1BCAE  D7FD     BRA 0xBCAA
88:            }
89:            
90:            void PMD_Initialize(void)
91:            {
92:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; NVMMD NVM enabled; 
93:                PMD0 = 0x00;
1BCB0  0139     MOVLB 0x39
1BCB2  6BC0     CLRF nout, BANKED
94:                // NCO1MD DDS(NCO1) enabled; TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
95:                PMD1 = 0x00;
1BCB4  6BC1     CLRF 0xC1, BANKED
96:                // ZCDMD ZCD enabled; DACMD DAC enabled; CMP1MD CMP1 enabled; ADCMD ADC enabled; CMP2MD CMP2 enabled; 
97:                PMD2 = 0x00;
1BCB6  6BC2     CLRF CountCallBack, BANKED
98:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; CCP4MD CCP4 enabled; CCP3MD CCP3 enabled; PWM6MD PWM6 enabled; PWM5MD PWM5 enabled; PWM8MD PWM8 enabled; PWM7MD PWM7 enabled; 
99:                PMD3 = 0x00;
1BCB8  6BC3     CLRF 0xC3, BANKED
100:               // CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; 
101:               PMD4 = 0x00;
1BCBA  6BC4     CLRF timer3ReloadVal, BANKED
102:               // U2MD UART2 enabled; U1MD UART1 enabled; SPI1MD SPI1 enabled; I2C2MD I2C2 enabled; I2C1MD I2C1 enabled; 
103:               PMD5 = 0x00;
1BCBC  6BC5     CLRF 0xC5, BANKED
104:               // DSMMD DSM1 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; SMT1MD SMT1 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
105:               PMD6 = 0x00;
1BCBE  6BC6     CLRF CountCallBack, BANKED
106:               // DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; 
107:               PMD7 = 0x00;
1BCC0  6BC7     CLRF 0xC7, BANKED
108:           }
1BCC2  0012     RETURN 0
109:           
110:           
111:           /**
112:            End of File
113:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/interrupt_manager.c  -----------------
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
19:                    Device            :  PIC18F57K42
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 1.45 or later
23:                    MPLAB 	          :  MPLAB X 4.15
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
1AC72  52E6     MOVF 0xFE6, F, ACCESS
53:            {
54:                INTCON0bits.IPEN = 1;
1AC74  8AD2     BSF 0xFD2, 5, ACCESS
55:            
56:                bool state = (unsigned char)GIE;
1AC76  AED2     BTFSS 0xFD2, 7, ACCESS
1AC78  D003     BRA 0xAC80
1AC7A  6A0C     CLRF 0xC, ACCESS
1AC7C  2A0C     INCF 0xC, F, ACCESS
1AC7E  D001     BRA 0xAC82
1AC80  6A0C     CLRF 0xC, ACCESS
1AC82  0EFF     MOVLW 0xFF
1AC86  F033     NOP
1AC88  FFE3     NOP
57:                GIE = 0;
1AC8A  9ED2     BCF 0xFD2, 7, ACCESS
58:                IVTLOCK = 0x55;
1AC8C  0E55     MOVLW 0x55
1AC8E  6ED4     MOVWF 0xFD4, ACCESS
59:                IVTLOCK = 0xAA;
1AC90  0EAA     MOVLW 0xAA
1AC92  6ED4     MOVWF 0xFD4, ACCESS
60:                IVTLOCKbits.IVTLOCKED = 0x00; // unlock IVT
1AC94  90D4     BCF 0xFD4, 0, ACCESS
61:            
62:                IVTADU = 0;
1AC96  0138     MOVLB 0x38
1AC98  6B9F     CLRF 0x9F, BANKED
63:                IVTADH = 0;
1AC9A  6B9E     CLRF P, BANKED
64:                IVTADL = 8;
1AC9C  0E08     MOVLW 0x8
1AC9E  6F9D     MOVWF 0x9D, BANKED
65:            
66:                IVTLOCK = 0x55;
1ACA0  0E55     MOVLW 0x55
1ACA2  6ED4     MOVWF 0xFD4, ACCESS
67:                IVTLOCK = 0xAA;
1ACA4  0EAA     MOVLW 0xAA
1ACA6  6ED4     MOVWF 0xFD4, ACCESS
68:                IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
1ACA8  80D4     BSF 0xFD4, 0, ACCESS
69:            
70:                GIE = state;
1ACAA  0EFF     MOVLW 0xFF
1ACAC  B0E3     BTFSC 0xFE3, 0, ACCESS
1ACAE  D002     BRA 0xACB4
1ACB0  9ED2     BCF 0xFD2, 7, ACCESS
1ACB2  D001     BRA 0xACB6
1ACB4  8ED2     BSF 0xFD2, 7, ACCESS
71:                // Assign peripheral interrupt priority vectors
72:                IPR2bits.DMA1AIP = 1;
1ACB6  0139     MOVLB 0x39
1ACB8  8782     BSF F463, 3, BANKED
73:                IPR2bits.DMA1DCNTIP = 1;
1ACBA  8382     BSF F463, 1, BANKED
74:                IPR2bits.DMA1SCNTIP = 1;
1ACBC  8182     BSF F463, 0, BANKED
75:                IPR2bits.DMA1ORIP = 1;
1ACBE  8582     BSF F463, 2, BANKED
76:                IPR6bits.U2TXIP = 1;
1ACC0  8786     BSF bcror, 3, BANKED
77:                IPR6bits.U2RXIP = 1;
1ACC2  8586     BSF bcror, 2, BANKED
78:                IPR3bits.U1RXIP = 1;
1ACC4  8783     BSF 0x83, 3, BANKED
79:                IPR1bits.INT0IP = 1;
1ACC6  8181     BSF 0x81, 0, BANKED
80:                IPR5bits.INT1IP = 0;
1ACC8  9185     BCF 0x85, 0, BANKED
81:                IPR9bits.TMR6IP = 1;
1ACCA  8189     BSF 0x89, 0, BANKED
82:                IPR8bits.TMR5IP = 0;
1ACCC  9D88     BCF 0x88, 6, BANKED
83:                IPR1bits.ADIP = 1;
1ACCE  8581     BSF 0x81, 2, BANKED
84:                IPR1bits.ADTIP = 1;
1ACD0  8781     BSF 0x81, 3, BANKED
85:                IPR6bits.TMR3IP = 0;
1ACD2  9D86     BCF bcror, 6, BANKED
86:            }
1ACD4  52E5     MOVF 0xFE5, F, ACCESS
1ACD6  0012     RETURN 0
87:            
88:            void __interrupt(irq(default),base(8)) Default_ISR()
1BDE8  EE14     LFSR 1, 0x115C
1BDEA  F15C     NOP
89:            {
90:            }
1B6EC  EE14     LFSR 1, 0x115C
1BDEC  0011     RETFIE 1
91:            
92:            /**
93:             End of File
94:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/fvr.c  -------------------------------
1:             /**
2:               FVR Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 fvr.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the FVR driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for FVR.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "fvr.h"
53:            
54:            /**
55:              Section: FVR APIs
56:            */
57:            
58:            void FVR_Initialize(void)
59:            {
60:                // CDAFVR 4x; FVREN enabled; TSRNG Lo_range; ADFVR 4x; TSEN enabled; 
61:                FVRCON = 0xAF;
1BDC6  0EAF     MOVLW 0xAF
1BDC8  013E     MOVLB 0x3E
1BDCA  6FC1     MOVWF 0xC1, BANKED
62:            }
1BDCC  0012     RETURN 0
63:            
64:            bool FVR_IsOutputReady(void)
65:            {
66:                return (FVRCONbits.FVRRDY);
67:            }
68:            /**
69:             End of File
70:            */
71:            
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/ext_int.c  ---------------------------
1:             /**
2:                EXT_INT Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  ext_int.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the EXT_INT driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for EXT_INT.
15:                 Generation Information :
16:            	 Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	 Device            :  PIC18F57K42
18:            	 Driver Version    :  1.11
19:                 The generated drivers are tested against the following:
20:            	 Compiler          :  XC8 1.45
21:            	 MPLAB             :  MPLAB X 4.15
22:             */
23:            
24:            /**
25:              Section: Includes
26:             */
27:            #include <xc.h>
28:            #include "ext_int.h"
29:            #include "interrupt_manager.h"
30:            #include "pin_manager.h"
31:            #include "../vconfig.h"
32:            
33:            void (*INT0_InterruptHandler)(void);
34:            void (*INT1_InterruptHandler)(void);
35:            
36:            void __interrupt(irq(INT0), base(8)) INT0_ISR()
1BD50  EE14     LFSR 1, 0x115C
1BD52  F15C     NOP
37:            {
38:            	EXT_INT0_InterruptFlagClear();
1BD54  0139     MOVLB 0x39
1BD56  91A1     BCF 0xA1, 0, BANKED
39:            
40:            	// Callback function gets called everytime this ISR executes
41:            	INT0_CallBack();
1BD58  EC54     CALL 0x1BAA8, 0
1BD5A  F0DD     NOP
42:            }
1BD5C  0011     RETFIE 1
43:            
44:            void INT0_CallBack(void)
45:            {
46:            	// Add your custom callback code here
47:            	if (INT0_InterruptHandler) {
1BAA8  0100     MOVLB 0x0
1BAAA  51BD     MOVF INT0_InterruptHandler, W, BANKED
1BAAC  11BE     IORWF 0xBE, W, BANKED
1BAAE  11BF     IORWF 0xBF, W, BANKED
1BAB0  B4D8     BTFSC 0xFD8, 2, ACCESS
1BAB2  0012     RETURN 0
48:            		INT0_InterruptHandler();
1BAB4  D801     RCALL 0xBAB8
1BAB6  0012     RETURN 0
1BAB8  0005     PUSH
1BABA  6EFA     MOVWF 0xFFA, ACCESS
1BABC  51BD     MOVF INT0_InterruptHandler, W, BANKED
1BABE  6EFD     MOVWF 0xFFD, ACCESS
1BAC0  51BE     MOVF 0xBE, W, BANKED
1BAC2  6EFE     MOVWF 0xFFE, ACCESS
1BAC4  51BF     MOVF 0xBF, W, BANKED
1BAC6  6EFF     MOVWF 0xFFF, ACCESS
1BAC8  50FA     MOVF 0xFFA, W, ACCESS
1BACA  0012     RETURN 0
49:            	}
50:            }
51:            
52:            void INT0_SetInterruptHandler(void (* InterruptHandler)(void))
53:            {
54:            	INT0_InterruptHandler = InterruptHandler;
1B926  50E1     MOVF 0xFE1, W, ACCESS
1B928  0FFD     ADDLW 0xFD
1B92A  6ED9     MOVWF 0xFD9, ACCESS
1B92C  50E2     MOVF 0xFE2, W, ACCESS
1B92E  6EDA     MOVWF 0xFDA, ACCESS
1B930  0EFF     MOVLW 0xFF
1B932  22DA     ADDWFC 0xFDA, F, ACCESS
1B936  FF78     NOP
1B938  F0BD     NOP
1B93C  FF78     NOP
1B93E  F0BE     NOP
1B942  FF74     NOP
1B944  F0BF     NOP
55:            }
1B946  52E5     MOVF 0xFE5, F, ACCESS
1B948  52E5     MOVF 0xFE5, F, ACCESS
1B94A  52E5     MOVF 0xFE5, F, ACCESS
1B94C  0012     RETURN 0
56:            
57:            void INT0_DefaultInterruptHandler(void)
58:            {
59:            	// add your INT0 interrupt custom code
60:            	// or set custom function using INT0_SetInterruptHandler()
61:            }
1BDE8  EE14     LFSR 1, 0x115C
1BDEA  F15C     NOP
1BDEC  0011     RETFIE 1
1BDF2  0012     RETURN 0
62:            void __interrupt(irq(INT1),base(8),low_priority) INT1_ISR()
1B416  FF60     NOP
1B418  F027     NOP
1B41C  F004     NOP
1B41E  F028     NOP
1B422  F02C     NOP
1B424  F029     NOP
1B428  F030     NOP
1B42A  F02A     NOP
1B42C  EE16     LFSR 1, 0x18AE
1B42E  F0AE     NOP
63:            {
64:            	EXT_INT1_InterruptFlagClear();
1B430  0139     MOVLB 0x39
1B432  91A5     BCF TMR5_InterruptHandler, 0, BANKED
65:            
66:            	// Callback function gets called everytime this ISR executes
67:            	INT1_CallBack();
1B434  EC1E     CALL 0x1BA3C, 0
1B436  F0DD     NOP
68:            }
1B43A  F0A8     NOP
1B43C  F00C     NOP
1B440  F0A4     NOP
1B442  F00B     NOP
1B446  F0A0     NOP
1B448  F001     NOP
1B44C  F09F     NOP
1B44E  FFD8     NOP
1B450  0011     RETFIE 1
69:            
70:            void INT1_CallBack(void)
71:            {
72:            	// Add your custom callback code here
73:            	if (INT1_InterruptHandler) {
1BA3C  0100     MOVLB 0x0
1BA3E  51BA     MOVF INT1_InterruptHandler, W, BANKED
1BA40  11BB     IORWF 0xBB, W, BANKED
1BA42  11BC     IORWF 0xBC, W, BANKED
1BA44  B4D8     BTFSC 0xFD8, 2, ACCESS
1BA46  0012     RETURN 0
74:            		INT1_InterruptHandler();
1BA48  D801     RCALL 0xBA4C
1BA4A  0012     RETURN 0
1BA4C  0005     PUSH
1BA4E  6EFA     MOVWF 0xFFA, ACCESS
1BA50  51BA     MOVF INT1_InterruptHandler, W, BANKED
1BA52  6EFD     MOVWF 0xFFD, ACCESS
1BA54  51BB     MOVF 0xBB, W, BANKED
1BA56  6EFE     MOVWF 0xFFE, ACCESS
1BA58  51BC     MOVF 0xBC, W, BANKED
1BA5A  6EFF     MOVWF 0xFFF, ACCESS
1BA5C  50FA     MOVF 0xFFA, W, ACCESS
1BA5E  0012     RETURN 0
75:            	}
76:            }
77:            
78:            void INT1_SetInterruptHandler(void (* InterruptHandler)(void))
79:            {
80:            	INT1_InterruptHandler = InterruptHandler;
1B8FE  50E1     MOVF 0xFE1, W, ACCESS
1B900  0FFD     ADDLW 0xFD
1B902  6ED9     MOVWF 0xFD9, ACCESS
1B904  50E2     MOVF 0xFE2, W, ACCESS
1B906  6EDA     MOVWF 0xFDA, ACCESS
1B908  0EFF     MOVLW 0xFF
1B90A  22DA     ADDWFC 0xFDA, F, ACCESS
1B90E  FF78     NOP
1B910  F0BA     NOP
1B914  FF78     NOP
1B916  F0BB     NOP
1B91A  FF74     NOP
1B91C  F0BC     NOP
81:            }
1B91E  52E5     MOVF 0xFE5, F, ACCESS
1B920  52E5     MOVF 0xFE5, F, ACCESS
1B922  52E5     MOVF 0xFE5, F, ACCESS
1B924  0012     RETURN 0
82:            
83:            void INT1_DefaultInterruptHandler(void)
84:            {
85:            	// add your INT1 interrupt custom code
86:            	// or set custom function using INT1_SetInterruptHandler()
87:            }
1BDEE  0012     RETURN 0
88:            
89:            void EXT_INT_Initialize(void)
90:            {
91:            
92:            	// Clear the interrupt flag
93:            	// Set the external interrupt edge detect
94:            	EXT_INT0_InterruptFlagClear();
1B59C  0139     MOVLB 0x39
1B59E  91A1     BCF 0xA1, 0, BANKED
95:            	EXT_INT0_fallingEdgeSet();
1B5A0  90D2     BCF 0xFD2, 0, ACCESS
96:            	// Set Default Interrupt Handler
97:            	INT0_SetInterruptHandler(INT0_DefaultInterruptHandler);
1B5A2  0EF2     MOVLW 0xF2
1B5A4  6EE6     MOVWF 0xFE6, ACCESS
1B5A6  0EBD     MOVLW 0xBD
1B5A8  6EE6     MOVWF 0xFE6, ACCESS
1B5AA  0E01     MOVLW 0x1
1B5AC  6EE6     MOVWF 0xFE6, ACCESS
1B5AE  EC93     CALL 0x1B926, 0
1B5B0  F0DC     NOP
98:            	EXT_INT0_InterruptEnable();
1B5B2  0139     MOVLB 0x39
1B5B4  8191     BSF 0x91, 0, BANKED
99:            
100:           
101:           	// Clear the interrupt flag
102:           	// Set the external interrupt edge detect
103:           	EXT_INT1_InterruptFlagClear();
1B5B6  91A5     BCF TMR5_InterruptHandler, 0, BANKED
104:           	EXT_INT1_fallingEdgeSet();
1B5B8  92D2     BCF 0xFD2, 1, ACCESS
105:           	// Set Default Interrupt Handler
106:           	INT1_SetInterruptHandler(INT1_DefaultInterruptHandler);
1B5BA  0EEE     MOVLW 0xEE
1B5BC  6EE6     MOVWF 0xFE6, ACCESS
1B5BE  0EBD     MOVLW 0xBD
1B5C0  6EE6     MOVWF 0xFE6, ACCESS
1B5C2  0E01     MOVLW 0x1
1B5C4  6EE6     MOVWF 0xFE6, ACCESS
1B5C6  EC7F     CALL 0x1B8FE, 0
1B5C8  F0DC     NOP
107:           	EXT_INT1_InterruptEnable();
1B5CA  0139     MOVLB 0x39
1B5CC  8195     BSF 0x95, 0, BANKED
108:           
109:           }
1B5CE  0012     RETURN 0
110:           
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/dma2.c  ------------------------------
1:             /**
2:               DMA Generated Driver File
3:               
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for DMA CHANNEL2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: DMA APIs
60:            */
61:            void DMA2_Initialize(void)
62:            {
63:                DMA2SSA = 0x001000; //set source start address
1AEBA  0E00     MOVLW 0x0
1AEBC  013B     MOVLB 0x3B
1AEBE  6FD9     MOVWF 0xD9, BANKED
1AEC0  0E10     MOVLW 0x10
1AEC2  6FDA     MOVWF 0xDA, BANKED
1AEC4  0E00     MOVLW 0x0
1AEC6  6FDB     MOVWF 0xDB, BANKED
64:                DMA2DSA = 0x3FBB; //set destination start address 
1AEC8  0E3F     MOVLW 0x3F
1AECA  6FD1     MOVWF 0xD1, BANKED
1AECC  0EBB     MOVLW 0xBB
1AECE  6FD0     MOVWF 0xD0, BANKED
65:                DMA2CON1 = 0x03; //set control register1 
1AED0  0E03     MOVLW 0x3
1AED2  6FDD     MOVWF 0xDD, BANKED
66:                DMA2SSZ = 0x0001; //set source size
1AED4  0E00     MOVLW 0x0
1AED6  6FD8     MOVWF 0xD8, BANKED
1AED8  0E01     MOVLW 0x1
1AEDA  6FD7     MOVWF __pcstackBANK0, BANKED
67:                DMA2DSZ = 0x0001; //set destination size
1AEDC  0E00     MOVLW 0x0
1AEDE  6FCF     MOVWF seed, BANKED
1AEE0  0E01     MOVLW 0x1
1AEE2  6FCE     MOVWF uart1RxCount, BANKED
68:                DMA2SIRQ = 0x1C; //set DMA Transfer Trigger Source
1AEE4  0E1C     MOVLW 0x1C
1AEE6  6FDF     MOVWF 0xDF, BANKED
69:                DMA2AIRQ = 0x3D; //set DMA Transfer abort Source
1AEE8  0E3D     MOVLW 0x3D
1AEEA  6FDE     MOVWF 0xDE, BANKED
70:                
71:                PIR5bits.DMA2DCNTIF =0; // clear Destination Count Interrupt Flag bit
1AEEC  0139     MOVLB 0x39
1AEEE  97A5     BCF TMR5_InterruptHandler, 3, BANKED
72:                PIR5bits.DMA2SCNTIF =0; // clear Source Count Interrupt Flag bit
1AEF0  95A5     BCF TMR5_InterruptHandler, 2, BANKED
73:                PIR5bits.DMA2AIF =0; // clear abort Interrupt Flag bit
1AEF2  9BA5     BCF TMR5_InterruptHandler, 5, BANKED
74:            	PIR5bits.DMA2ORIF =0; // clear overrun Interrupt Flag bit
1AEF4  99A5     BCF TMR5_InterruptHandler, 4, BANKED
75:                
76:                PIE5bits.DMA2DCNTIE =0; // disable Destination Count 0 Interrupt
1AEF6  9795     BCF 0x95, 3, BANKED
77:                PIE5bits.DMA2SCNTIE =0; // disable Source Count Interrupt
1AEF8  9595     BCF 0x95, 2, BANKED
78:                PIE5bits.DMA2AIE =0; // disable abort Interrupt
1AEFA  9B95     BCF 0x95, 5, BANKED
79:                PIE5bits.DMA2ORIE =0; // disable overrun Interrupt 
1AEFC  9995     BCF 0x95, 4, BANKED
80:            	
81:            	asm("BCF INTCON0,7");
1AEFE  9ED2     BCF 0xFD2, 7, ACCESS
82:            	
83:            	asm ("BANKSEL PRLOCK");
1AF00  0139     MOVLB 0x39
84:                asm ("MOVLW 0x55");
1AF02  0E55     MOVLW 0x55
85:                asm ("MOVWF PRLOCK");
1AF04  6FEF     MOVWF 0xEF, BANKED
86:                asm ("MOVLW 0xAA");
1AF06  0EAA     MOVLW 0xAA
87:                asm ("MOVWF PRLOCK");
1AF08  6FEF     MOVWF 0xEF, BANKED
88:                asm ("BSF PRLOCK, 0");
1AF0A  81EF     BSF 0xEF, 0, BANKED
89:            	
90:            	asm("BSF INTCON0,7");
1AF0C  8ED2     BSF 0xFD2, 7, ACCESS
91:                    
92:                DMA2CON0 = 0x00; //set control register0
1AF0E  013B     MOVLB 0x3B
1AF10  6BDC     CLRF 0xDC, BANKED
93:            }
1AF12  0012     RETURN 0
94:            
95:            
96:            
97:            
98:            /**
99:              End of File
100:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/dma1.c  ------------------------------
1:             /**
2:               DMA Generated Driver File
3:               
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for DMA CHANNEL1.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.10
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "dma1.h"
53:            #include "interrupt_manager.h"
54:            #include "../vconfig.h"
55:            
56:            /**
57:              Section: Global Variables Definitions
58:             */
59:            
60:            extern struct spi_link_type spi_link;
61:            
62:            //------------------------------------------------------------------------------
63:            #define m_ARBITER_LOCK()    \
64:                  do{ \
65:                       asm("BANKSEL PRLOCK");\
66:                       asm("MOVLW   0x55");\
67:                       asm("MOVWF   (PRLOCK & 0xFF)");\
68:                       asm("MOVLW   0xAA");\
69:                       asm("MOVWF   (PRLOCK & 0xFF)");\
70:                       asm("BSF     (PRLOCK & 0xFF),0");\
71:                    }while(0)
72:            //------------------------------------------------------------------------------
73:            #define m_ARBITER_UNLOCK()  \
74:                  do{ \
75:                       asm("BANKSEL PRLOCK");\
76:                       asm("MOVLW   0x55");\
77:                       asm("MOVWF   (PRLOCK & 0xFF)");\
78:                       asm("MOVLW   0xAA");\
79:                       asm("MOVWF   (PRLOCK & 0xFF)");\
80:                       asm("BCF     (PRLOCK & 0xFF),0");\
81:                    }while(0)
82:            
83:            /**
84:              Section: DMA APIs
85:             */
86:            void DMA1_Initialize(void)
87:            {
88:            	DMA1SSA = 0x001000; //set source start address
1AB32  0E00     MOVLW 0x0
1AB34  013B     MOVLB 0x3B
1AB36  6FF9     MOVWF 0xF9, BANKED
1AB38  0E10     MOVLW 0x10
1AB3A  6FFA     MOVWF 0xFA, BANKED
1AB3C  0E00     MOVLW 0x0
1AB3E  6FFB     MOVWF 0xFB, BANKED
89:            	DMA1DSA = 0x3D11; //set destination start address 
1AB40  0E3D     MOVLW 0x3D
1AB42  6FF1     MOVWF 0xF1, BANKED
1AB44  0E11     MOVLW 0x11
1AB46  6FF0     MOVWF __pdataBANK0, BANKED
90:            	DMA1CON1 = 0x03; //set control register1 
1AB48  0E03     MOVLW 0x3
1AB4A  6FFD     MOVWF 0xFD, BANKED
91:            	DMA1SSZ = 0x0001; //set source size
1AB4C  0E00     MOVLW 0x0
1AB4E  6FF8     MOVWF 0xF8, BANKED
1AB50  0E01     MOVLW 0x1
1AB52  6FF7     MOVWF H, BANKED
92:            	DMA1DSZ = 0x0001; //set destination size
1AB54  0E00     MOVLW 0x0
1AB56  6FEF     MOVWF 0xEF, BANKED
1AB58  0E01     MOVLW 0x1
1AB5A  6FEE     MOVWF 0xEE, BANKED
93:            	DMA1SIRQ = 0x15; //set DMA Transfer Trigger Source
1AB5C  0E15     MOVLW 0x15
1AB5E  6FFF     MOVWF 0xFF, BANKED
94:            	DMA1AIRQ = 0x0; //set DMA Transfer abort Source
1AB60  6BFE     CLRF 0xFE, BANKED
95:            
96:            	PIR2bits.DMA1DCNTIF = 0; // clear Destination Count Interrupt Flag bit
1AB62  0139     MOVLB 0x39
1AB64  93A2     BCF TMR3_InterruptHandler, 1, BANKED
97:            	PIR2bits.DMA1SCNTIF = 0; // clear Source Count Interrupt Flag bit
1AB66  91A2     BCF TMR3_InterruptHandler, 0, BANKED
98:            	PIR2bits.DMA1AIF = 0; // clear abort Interrupt Flag bit
1AB68  97A2     BCF TMR3_InterruptHandler, 3, BANKED
99:            	PIR2bits.DMA1ORIF = 0; // clear overrun Interrupt Flag bit
1AB6A  95A2     BCF TMR3_InterruptHandler, 2, BANKED
100:           
101:           	PIE2bits.DMA1DCNTIE = 1; // enable Destination Count 0 Interrupt
1AB6C  8392     BSF bvror, 1, BANKED
102:           	PIE2bits.DMA1SCNTIE = 1; // enable Source Count Interrupt
1AB6E  8192     BSF bvror, 0, BANKED
103:           	PIE2bits.DMA1AIE = 1; // enable abort Interrupt
1AB70  8792     BSF bvror, 3, BANKED
104:           	PIE2bits.DMA1ORIE = 1; // enable overrun Interrupt 
1AB72  8592     BSF bvror, 2, BANKED
105:           
106:           	ISRPR = 0;
1AB74  6BF1     CLRF 0xF1, BANKED
107:           	MAINPR = 1;
1AB76  0E01     MOVLW 0x1
1AB78  6FF2     MOVWF 0xF2, BANKED
108:           	DMA1PR = 4;
1AB7A  0E04     MOVLW 0x4
1AB7C  6FF3     MOVWF 0xF3, BANKED
109:           	DMA2PR = 2;
1AB7E  0E02     MOVLW 0x2
1AB80  6FF4     MOVWF 0xF4, BANKED
110:           	SCANPR = 3;
1AB82  0E03     MOVLW 0x3
1AB84  6FF7     MOVWF H, BANKED
111:           
112:           	asm("BCF INTCON0,7");
1AB86  9ED2     BCF 0xFD2, 7, ACCESS
113:           
114:           	asm("BANKSEL PRLOCK");
1AB88  0139     MOVLB 0x39
115:           	asm("MOVLW 0x55");
1AB8A  0E55     MOVLW 0x55
116:           	asm("MOVWF PRLOCK");
1AB8C  6FEF     MOVWF 0xEF, BANKED
117:           	asm("MOVLW 0xAA");
1AB8E  0EAA     MOVLW 0xAA
118:           	asm("MOVWF PRLOCK");
1AB90  6FEF     MOVWF 0xEF, BANKED
119:           	asm("BSF PRLOCK, 0");
1AB92  81EF     BSF 0xEF, 0, BANKED
120:           
121:           	asm("BSF INTCON0,7");
1AB94  8ED2     BSF 0xFD2, 7, ACCESS
122:           
123:           	DMA1CON0 = 0x00; //set control register0
1AB96  013B     MOVLB 0x3B
1AB98  6BFC     CLRF 0xFC, BANKED
124:           }
1AB9A  0012     RETURN 0
125:           
126:           void __interrupt(irq(DMA1SCNT), base(8)) DMA1_DMASCNT_ISR()
1BD60  EE14     LFSR 1, 0x115C
1BD62  F15C     NOP
127:           {
128:           	PIR2bits.DMA1SCNTIF = 0; // clear Source Count Interrupt Flag 
1BD64  0139     MOVLB 0x39
1BD66  91A2     BCF TMR3_InterruptHandler, 0, BANKED
129:           	// add your DMA channel 1 source count 0 interrupt custom code
130:           	spi_link.LCD_DATA = 0;
1BD68  0100     MOVLB 0x0
1BD6A  9760     BCF spi_link, 3, BANKED
131:           //	DEBUG2_SetLow();
132:           }
1BD6C  0011     RETFIE 1
133:           
134:           void __interrupt(irq(DMA1DCNT), base(8)) DMA1_DMADCNT_ISR()
1BD84  EE14     LFSR 1, 0x115C
1BD86  F15C     NOP
135:           {
136:           	PIR2bits.DMA1DCNTIF = 0; // clear Destination Count Interrupt Flag 
1BD88  0139     MOVLB 0x39
1BD8A  93A2     BCF TMR3_InterruptHandler, 1, BANKED
137:           	// add your DMA channel 1 destination count 0 interrupt custom code
138:           }
1BD8C  0011     RETFIE 1
139:           
140:           #if (__XC8_VERSION <= 1400)
141:           void __interrupt(irq(DMA1ARBT), base(8)) DMA1_DMAA_ISR()
142:           #else   // __XC8_VERSION
143:           
144:           void __interrupt(irq(DMA1A), base(8)) DMA1_DMAA_ISR()
1BD90  EE14     LFSR 1, 0x115C
1BD92  F15C     NOP
145:           #endif // __XC8_VERSION
146:           {
147:           	PIR2bits.DMA1AIF = 0; // clear abort Interrupt Flag 
1BD94  0139     MOVLB 0x39
1BD96  97A2     BCF TMR3_InterruptHandler, 3, BANKED
148:           	// add your DMA channel 1 abort interrupt custom code
149:           }
1BD98  0011     RETFIE 1
150:           
151:           #if (__XC8_VERSION <= 1400)
152:           void __interrupt(irq(IRQ_DMA1OVR), base(8)) DMA1_DMAOR_ISR()
153:           #else // __XC8_VERSION
154:           
155:           void __interrupt(irq(DMA1OR), base(8)) DMA1_DMAOR_ISR()
1BD9C  EE14     LFSR 1, 0x115C
1BD9E  F15C     NOP
156:           #endif // __XC8_VERSION
157:           {
158:           	PIR2bits.DMA1ORIF = 0; // clear overrun Interrupt Flag 
1BDA0  0139     MOVLB 0x39
1BDA2  95A2     BCF TMR3_InterruptHandler, 2, BANKED
159:           	// add your DMA channel 1 overrun interrupt custom code
160:           }
1BDA4  0011     RETFIE 1
161:           /**
162:             End of File
163:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/clkref.c  ----------------------------
1:             /**
2:               CLKREF Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 clkref.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CLKREF driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for CLKREF.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "clkref.h"
53:            
54:            /**
55:              Section: CLKREF APIs
56:            */
57:            
58:            void CLKREF_Initialize(void)
59:            {
60:                // CLK FOSC; 
61:                CLKRCLK = 0x00;
1BD6E  013C     MOVLB 0x3C
1BD70  6BE6     CLRF 0xE6, BANKED
62:                // DC 50% Duty Cycle; DIV BaseClock/16; CLKREN enabled; 
63:                CLKRCON = 0x94;
1BD72  0E94     MOVLW 0x94
1BD74  6FE5     MOVWF 0xE5, BANKED
64:            }
1BD76  0012     RETURN 0
65:            /**
66:             End of File
67:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/adcc.c  ------------------------------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adcc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADCC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.13
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "adcc.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: ADCC Module Variables
57:            */
58:            void (*ADCC_ADI_InterruptHandler)(void);
59:            void (*ADCC_ADTI_InterruptHandler)(void);
60:            
61:            /**
62:              Section: ADCC Module APIs
63:            */
64:            
65:            void ADCC_Initialize(void)
66:            {
67:                // set the ADCC to the options selected in the User Interface
68:                // ADLTH 0; 
69:                ADLTHL = 0x00;
1AB9C  013E     MOVLB 0x3E
1AB9E  6BDE     CLRF 0xDE, BANKED
70:                // ADLTH 0; 
71:                ADLTHH = 0x00;
1ABA0  6BDF     CLRF 0xDF, BANKED
72:                // ADUTH 0; 
73:                ADUTHL = 0x00;
1ABA2  6BE0     CLRF 0xE0, BANKED
74:                // ADUTH 0; 
75:                ADUTHH = 0x00;
1ABA4  6BE1     CLRF 0xE1, BANKED
76:                // ADSTPT 0; 
77:                ADSTPTL = 0x00;
1ABA6  6BE4     CLRF 0xE4, BANKED
78:                // ADSTPT 0; 
79:                ADSTPTH = 0x00;
1ABA8  6BE5     CLRF 0xE5, BANKED
80:                // ADACC 0; 
81:                ADACCU = 0x00;
1ABAA  6BEA     CLRF 0xEA, BANKED
82:                // ADRPT 64; 
83:                ADRPT = 0x40;
1ABAC  0E40     MOVLW 0x40
1ABAE  6FEC     MOVWF 0xEC, BANKED
84:                // ADPCH ANA0; 
85:                ADPCH = 0x00;
1ABB0  6BF1     CLRF 0xF1, BANKED
86:                // ADACQ 32; 
87:                ADACQL = 0x20;
1ABB2  0E20     MOVLW 0x20
1ABB4  6FF3     MOVWF 0xF3, BANKED
88:                // ADACQ 0; 
89:                ADACQH = 0x00;
1ABB6  6BF4     CLRF 0xF4, BANKED
90:                // ADCAP Additional uC disabled; 
91:                ADCAP = 0x00;
1ABB8  6BF5     CLRF 0xF5, BANKED
92:                // ADPRE 0; 
93:                ADPREL = 0x00;
1ABBA  6BF6     CLRF 0xF6, BANKED
94:                // ADPRE 0; 
95:                ADPREH = 0x00;
1ABBC  6BF7     CLRF H, BANKED
96:                // ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL Vss; 
97:                ADCON1 = 0x00;
1ABBE  6BF9     CLRF 0xF9, BANKED
98:                // ADCRS 5; ADMD Burst_average_mode; ADACLR enabled; ADPSIS RES; 
99:                ADCON2 = 0x5B;
1ABC0  0E5B     MOVLW 0x5B
1ABC2  6FFA     MOVWF 0xFA, BANKED
100:               // ADCALC Actual result vs filtered value; ADTMD enabled; ADSOI ADGO not cleared; 
101:               ADCON3 = 0x27;
1ABC4  0E27     MOVLW 0x27
1ABC6  6FFB     MOVWF 0xFB, BANKED
102:               // ADMATH registers not updated; 
103:               ADSTAT = 0x00;
1ABC8  6BFC     CLRF 0xFC, BANKED
104:               // ADNREF VSS; ADPREF external; 
105:               ADREF = 0x02;
1ABCA  0E02     MOVLW 0x2
1ABCC  6FFD     MOVWF 0xFD, BANKED
106:               // ADACT disabled; 
107:               ADACT = 0x00;
1ABCE  6BFE     CLRF 0xFE, BANKED
108:               // ADCS FOSC/16; 
109:               ADCLK = 0x07;
1ABD0  0E07     MOVLW 0x7
1ABD2  6FFF     MOVWF 0xFF, BANKED
110:               // ADGO stop; ADFM right; ADON enabled; ADCS FOSC/ADCLK; ADCONT disabled; 
111:               ADCON0 = 0x84;
1ABD4  0E84     MOVLW 0x84
1ABD6  6FF8     MOVWF 0xF8, BANKED
112:               
113:               // Clear the ADC interrupt flag
114:               PIR1bits.ADIF = 0;
1ABD8  0139     MOVLB 0x39
1ABDA  95A1     BCF 0xA1, 2, BANKED
115:               // Enabling ADCC interrupt.
116:               PIE1bits.ADIE = 1;
1ABDC  8591     BSF 0x91, 2, BANKED
117:           
118:               ADCC_SetADIInterruptHandler(ADCC_DefaultInterruptHandler);
1ABDE  0EF4     MOVLW 0xF4
1ABE0  6EE6     MOVWF 0xFE6, ACCESS
1ABE2  0EBD     MOVLW 0xBD
1ABE4  6EE6     MOVWF 0xFE6, ACCESS
1ABE6  0E01     MOVLW 0x1
1ABE8  6EE6     MOVWF 0xFE6, ACCESS
1ABEA  ECBB     CALL 0x1B976, 0
1ABEC  F0DC     NOP
119:           
120:               // Clear the ADC Threshold interrupt flag
121:               PIR1bits.ADTIF = 0;
1ABEE  0139     MOVLB 0x39
1ABF0  97A1     BCF 0xA1, 3, BANKED
122:               // Enabling ADCC threshold interrupt.
123:               PIE1bits.ADTIE = 1;
1ABF2  8791     BSF 0x91, 3, BANKED
124:           
125:               ADCC_SetADTIInterruptHandler(ADCC_DefaultInterruptHandler);
1ABF4  0EF4     MOVLW 0xF4
1ABF6  6EE6     MOVWF 0xFE6, ACCESS
1ABF8  0EBD     MOVLW 0xBD
1ABFA  6EE6     MOVWF 0xFE6, ACCESS
1ABFC  0E01     MOVLW 0x1
1ABFE  6EE6     MOVWF 0xFE6, ACCESS
1AC00  ECA7     CALL 0x1B94E, 0
1AC02  F0DC     NOP
126:           }
1AC04  0012     RETURN 0
127:           
128:           void ADCC_StartConversion(adcc_channel_t channel)
129:           {
130:               // select the A/D channel
131:               ADPCH = channel;      
1BCC4  0EFF     MOVLW 0xFF
1BCC8  FF8F     NOP
1BCCA  FEF1     NOP
132:             
133:               // Turn on the ADC module
134:               ADCON0bits.ADON = 1;
1BCCC  013E     MOVLB 0x3E
1BCCE  8FF8     BSF 0xF8, 7, BANKED
135:           
136:               // Start the conversion
137:               ADCON0bits.ADGO = 1;
1BCD0  81F8     BSF 0xF8, 0, BANKED
138:           }
1BCD2  52E5     MOVF 0xFE5, F, ACCESS
1BCD4  0012     RETURN 0
139:           
140:           bool ADCC_IsConversionDone()
141:           {
142:               // Start the conversion
143:               return ((unsigned char)(!ADCON0bits.ADGO));
144:           }
145:           
146:           adc_result_t ADCC_GetConversionResult(void)
147:           {
148:               // Return the result
149:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
150:           }
151:           
152:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
153:           {
154:               // select the A/D channel
155:               ADPCH = channel;  
156:           
157:               // Turn on the ADC module
158:               ADCON0bits.ADON = 1;
159:           	
160:               //Disable the continuous mode.
161:               ADCON0bits.ADCONT = 0;    
162:           
163:               // Start the conversion
164:               ADCON0bits.ADGO = 1;
165:           
166:           
167:               // Wait for the conversion to finish
168:               while (ADCON0bits.ADGO)
169:               {
170:               }
171:               
172:               
173:               // Conversion finished, return the result
174:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
175:           }
176:           
177:           void ADCC_StopConversion(void)
178:           {
179:               //Reset the ADGO bit.
180:               ADCON0bits.ADGO = 0;
181:           }
182:           
183:           void ADCC_SetStopOnInterrupt(void)
184:           {
185:               //Set the ADSOI bit.
186:               ADCON3bits.ADSOI = 1;
187:           }
188:           
189:           void ADCC_DischargeSampleCapacitor(void)
190:           {
191:               //Set the ADC channel to AVss.
192:               ADPCH = 0x3b;   
1BDA6  0E3B     MOVLW 0x3B
1BDA8  013E     MOVLB 0x3E
1BDAA  6FF1     MOVWF 0xF1, BANKED
193:           }
1BDAC  0012     RETURN 0
194:           
195:           void ADCC_LoadAcquisitionRegister(uint16_t acquisitionValue)
196:           {
197:               //Load the ADACQH and ADACQL registers.
198:               ADACQH = acquisitionValue >> 8; 
199:               ADACQL = acquisitionValue;  
200:           }
201:           
202:           void ADCC_SetPrechargeTime(uint16_t prechargeTime)
203:           {
204:               //Load the ADPREH and ADPREL registers.
205:               ADPREH = prechargeTime >> 8;  
206:               ADPREL = prechargeTime;
207:           }
208:           
209:           void ADCC_SetRepeatCount(uint8_t repeatCount)
210:           {
211:               //Load the ADRPT register.
212:               ADRPT = repeatCount;   
213:           }
214:           
215:           uint8_t ADCC_GetCurrentCountofConversions(void)
216:           {
217:               //Return the contents of ADCNT register
218:               return ADCNT;
219:           }
220:           
221:           void ADCC_ClearAccumulator(void)
222:           {
223:               //Reset the ADCON2bits.ADACLR bit.
224:               ADCON2bits.ADACLR = 1;
225:           }
226:           
227:           int24_t ADCC_GetAccumulatorValue(void)
228:           {
229:               //Return the contents of ADACCU, ADACCH and ADACCL registers
230:               return (((int24_t)ADACCU << 16)+((int24_t)ADACCH << 8) + ADACCL);
231:           }
232:           
233:           bool ADCC_HasAccumulatorOverflowed(void)
234:           {
235:               //Return the status of ADSTATbits.ADAOV
236:               return ADSTATbits.ADAOV;
237:           }
238:           
239:           uint16_t ADCC_GetFilterValue(void)
240:           {
241:               //Return the contents of ADFLTRH and ADFLTRL registers
242:               return ((uint16_t)((ADFLTRH << 8) + ADFLTRL));
243:           }
244:           
245:           uint16_t ADCC_GetPreviousResult(void)
246:           {
247:               //Return the contents of ADPREVH and ADPREVL registers
248:               return ((uint16_t)((ADPREVH << 8) + ADPREVL));
249:           }
250:           
251:           void ADCC_DefineSetPoint(uint16_t setPoint)
252:           {
253:               //Sets the ADSTPTH and ADSTPTL registers
254:               ADSTPTH = setPoint >> 8;
255:               ADSTPTL = setPoint;
256:           }
257:           
258:           void ADCC_SetUpperThreshold(uint16_t upperThreshold)
259:           {
260:               //Sets the ADUTHH and ADUTHL registers
261:               ADUTHH = upperThreshold >> 8;
262:               ADUTHL = upperThreshold;
263:           }
264:           
265:           void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
266:           {
267:               //Sets the ADLTHH and ADLTHL registers
268:               ADLTHH = lowerThreshold >> 8;
269:               ADLTHL = lowerThreshold;
270:           }
271:           
272:           uint16_t ADCC_GetErrorCalculation(void)
273:           {
274:           	//Return the contents of ADERRH and ADERRL registers
275:           	return ((uint16_t)((ADERRH << 8) + ADERRL));
276:           }
277:           
278:           void ADCC_EnableDoubleSampling(void)
279:           {
280:               //Sets the ADCON1bits.ADDSEN
281:               ADCON1bits.ADDSEN = 1;
282:           }
283:           
284:           void ADCC_EnableContinuousConversion(void)
285:           {
286:               //Sets the ADCON0bits.ADCONT
287:               ADCON0bits.ADCONT = 1;
288:           }
289:           
290:           void ADCC_DisableContinuousConversion(void)
291:           {
292:               //Resets the ADCON0bits.ADCONT
293:               ADCON0bits.ADCONT = 0;
294:           }
295:           
296:           bool ADCC_HasErrorCrossedUpperThreshold(void)
297:           {
298:               //Returns the value of ADSTATbits.ADUTHR bit.
299:               return ADSTATbits.ADUTHR;
300:           }
301:           
302:           bool ADCC_HasErrorCrossedLowerThreshold(void)
303:           {
304:               //Returns the value of ADSTATbits.ADLTHR bit.
305:               return ADSTATbits.ADLTHR;
306:           }
307:           
308:           uint8_t ADCC_GetConversionStageStatus(void)
309:           {
310:               //Returns the contents of ADSTATbits.ADSTAT field.
311:               return ADSTATbits.ADSTAT;
312:           }
313:           
314:           void __interrupt(irq(AD),base(8)) ADCC_ISR()
1B6EC  EE14     LFSR 1, 0x115C
1B6EE  F15C     NOP
315:           {
316:               // Clear the ADCC interrupt flag
317:               PIR1bits.ADIF = 0;
1B6F0  0139     MOVLB 0x39
1B6F2  95A1     BCF 0xA1, 2, BANKED
318:           
319:               if (ADCC_ADI_InterruptHandler)
1B6F4  0100     MOVLB 0x0
1B6F6  51AE     MOVF ADCC_ADI_InterruptHandler, W, BANKED
1B6F8  11AF     IORWF 0xAF, W, BANKED
1B6FA  11B0     IORWF 0xB0, W, BANKED
1B6FC  B4D8     BTFSC 0xFD8, 2, ACCESS
1B6FE  0011     RETFIE 1
320:                       ADCC_ADI_InterruptHandler();
1B700  D801     RCALL 0xB704
1B702  0011     RETFIE 1
1B704  0005     PUSH
1B706  6EFA     MOVWF 0xFFA, ACCESS
1B708  51AE     MOVF ADCC_ADI_InterruptHandler, W, BANKED
1B70A  6EFD     MOVWF 0xFFD, ACCESS
1B70C  51AF     MOVF 0xAF, W, BANKED
1B70E  6EFE     MOVWF 0xFFE, ACCESS
1B710  51B0     MOVF 0xB0, W, BANKED
1B712  6EFF     MOVWF 0xFFF, ACCESS
1B714  50FA     MOVF 0xFFA, W, ACCESS
1B716  0012     RETURN 0
321:           }
322:           
323:           void ADCC_SetADIInterruptHandler(void (* InterruptHandler)(void)){
324:               ADCC_ADI_InterruptHandler = InterruptHandler;
1B976  50E1     MOVF 0xFE1, W, ACCESS
1B978  0FFD     ADDLW 0xFD
1B97A  6ED9     MOVWF 0xFD9, ACCESS
1B97C  50E2     MOVF 0xFE2, W, ACCESS
1B97E  6EDA     MOVWF 0xFDA, ACCESS
1B980  0EFF     MOVLW 0xFF
1B982  22DA     ADDWFC 0xFDA, F, ACCESS
1B986  FF78     NOP
1B988  F0AE     NOP
1B98C  FF78     NOP
1B98E  F0AF     NOP
1B992  FF74     NOP
1B994  F0B0     NOP
325:           }
1B996  52E5     MOVF 0xFE5, F, ACCESS
1B998  52E5     MOVF 0xFE5, F, ACCESS
1B99A  52E5     MOVF 0xFE5, F, ACCESS
1B99C  0012     RETURN 0
326:           
327:           void __interrupt(irq(ADT),base(8)) ADCC_ThresholdISR()
1AC0A  F004     NOP
1AC0C  F021     NOP
1AC10  F008     NOP
1AC12  F022     NOP
1AC16  F024     NOP
1AC18  F023     NOP
1AC1C  F028     NOP
1AC1E  F024     NOP
1AC22  F030     NOP
1AC24  F025     NOP
1AC26  EE14     LFSR 1, 0x115C
1AC28  F15C     NOP
328:           {
329:               // Clear the ADCC Threshold interrupt flag
330:               PIR1bits.ADTIF = 0;
1AC2A  0139     MOVLB 0x39
1AC2C  97A1     BCF 0xA1, 3, BANKED
331:           
332:               if (ADCC_ADTI_InterruptHandler)
1AC2E  0100     MOVLB 0x0
1AC30  51AB     MOVF ADCC_ADTI_InterruptHandler, W, BANKED
1AC32  11AC     IORWF 0xAC, W, BANKED
1AC34  11AD     IORWF 0xAD, W, BANKED
1AC36  B4D8     BTFSC 0xFD8, 2, ACCESS
1AC38  D00C     BRA 0xAC52
333:                   ADCC_ADTI_InterruptHandler();
1AC3A  D801     RCALL 0xAC3E
1AC3C  D00A     BRA 0xAC52
1AC3E  0005     PUSH
1AC40  6EFA     MOVWF 0xFFA, ACCESS
1AC42  51AB     MOVF ADCC_ADTI_InterruptHandler, W, BANKED
1AC44  6EFD     MOVWF 0xFFD, ACCESS
1AC46  51AC     MOVF 0xAC, W, BANKED
1AC48  6EFE     MOVWF 0xFFE, ACCESS
1AC4A  51AD     MOVF 0xAD, W, BANKED
1AC4C  6EFF     MOVWF 0xFFF, ACCESS
1AC4E  50FA     MOVF 0xFFA, W, ACCESS
1AC50  0012     RETURN 0
334:           }
1B9A0  EE14     LFSR 1, 0x115C
335:           
336:           void ADCC_SetADTIInterruptHandler(void (* InterruptHandler)(void)){
337:               ADCC_ADTI_InterruptHandler = InterruptHandler;
1B94E  50E1     MOVF 0xFE1, W, ACCESS
1B950  0FFD     ADDLW 0xFD
1B952  6ED9     MOVWF 0xFD9, ACCESS
1B954  50E2     MOVF 0xFE2, W, ACCESS
1B956  6EDA     MOVWF 0xFDA, ACCESS
1B958  0EFF     MOVLW 0xFF
1B95A  22DA     ADDWFC 0xFDA, F, ACCESS
1B95E  FF78     NOP
1B960  F0AB     NOP
1B964  FF78     NOP
1B966  F0AC     NOP
1B96A  FF74     NOP
1B96C  F0AD     NOP
338:           }
1B96E  52E5     MOVF 0xFE5, F, ACCESS
1B970  52E5     MOVF 0xFE5, F, ACCESS
1B972  52E5     MOVF 0xFE5, F, ACCESS
1B974  0012     RETURN 0
339:           void ADCC_DefaultInterruptHandler(void){
340:               // add your ADCC interrupt custom code
341:               // or set custom function using ADCC_SetADIInterruptHandler() or ADCC_SetADTIInterruptHandler()
342:           }
1BDF4  0012     RETURN 0
343:           /**
344:            End of File
345:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mbmc.c  --------------------------------------------------
1:             #include "mbmc.h"
2:             #include "mcc_generated_files/ext_int.h"
3:             #include "bsoc.h"
4:             
5:             extern C_data C;
6:             extern V_data V;
7:             
8:             struct tm t_mbmc; // don't use the xc8 clock function
9:             volatile uint32_t utctime = 0; // utctime set from remote ntp server
10:            volatile struct P_data P = {
11:            	.SYSTEM_STABLE = false,
12:            };
13:            
14:            /* spinner defines */
15:            #define MAX_SHAPES  6
16:            const char spin[MAX_SHAPES][20] = {
17:            	"||//--", // classic LCD version with no \ character
18:            	"||//--\\\\", // classic
19:            	"OOOOOO--__-", // eye blink
20:            	"vv<<^^>>", // point spinner
21:            	"..**x#x#XX||--", // warp portal
22:            	"..ooOOoo" // ball bouncer
23:            };
24:            
25:            /*
26:             * floating point low pass filter, 
27:             * slow/fast select, use (-1) to zero buffer channel and return new
28:             */
29:            float lp_filter(const float new, const uint8_t bn, const int8_t slow)
18398  52E6     MOVF 0xFE6, F, ACCESS
1839A  52E6     MOVF 0xFE6, F, ACCESS
1839C  52E6     MOVF 0xFE6, F, ACCESS
1839E  52E6     MOVF 0xFE6, F, ACCESS
30:            {
31:            	static float smooth[LP_BUFFER_SIZE];
32:            	float lp_speed;
33:            
34:            	if (bn >= LP_BUFFER_SIZE) // buffer index check
183A0  0EF7     MOVLW 0xF7
183A4  FF8C     NOP
183A6  F001     NOP
183A8  0E14     MOVLW 0x14
183AA  6401     CPFSGT ltemp0, ACCESS
183AC  D011     BRA 0x83D0
35:            		return new;
183AE  0EF8     MOVLW 0xF8
183B2  FF8C     NOP
183B4  F001     NOP
183B6  0EF9     MOVLW 0xF9
183BA  FF8C     NOP
183BC  F002     NOP
183BE  0EFA     MOVLW 0xFA
183C2  FF8C     NOP
183C4  F003     NOP
183C6  0EFB     MOVLW 0xFB
183CA  FF8C     NOP
183CC  F004     NOP
183CE  D0BD     BRA 0x854A
36:            
37:            	if (slow == (-1)) { // reset smooth buffer and return original value
183D0  0EF6     MOVLW 0xF6
183D2  28E3     INCF 0xFE3, W, ACCESS
183D4  A4D8     BTFSS 0xFD8, 2, ACCESS
183D6  D012     BRA 0x83FC
38:            		smooth[bn] = 0.0;
183D8  0EF7     MOVLW 0xF7
183DA  50E3     MOVF 0xFE3, W, ACCESS
183DC  0D04     MULLW 0x4
183DE  0E00     MOVLW 0x0
183E0  24F3     ADDWF 0xFF3, W, ACCESS
183E2  6ED9     MOVWF 0xFD9, ACCESS
183E4  0E02     MOVLW 0x2
183E6  20F4     ADDWFC 0xFF4, W, ACCESS
183E8  6EDA     MOVWF 0xFDA, ACCESS
183EA  0E00     MOVLW 0x0
183EC  6EDE     MOVWF 0xFDE, ACCESS
183EE  0E00     MOVLW 0x0
183F0  6EDE     MOVWF 0xFDE, ACCESS
183F2  0E00     MOVLW 0x0
183F4  6EDE     MOVWF 0xFDE, ACCESS
183F6  0E00     MOVLW 0x0
183F8  6EDD     MOVWF 0xFDD, ACCESS
183FA  D7D9     BRA 0x83AE
39:            		return new;
40:            	}
41:            
42:            	if (slow) { // some random filter cutoffs beta values
183FC  0EF6     MOVLW 0xF6
183FE  50E3     MOVF 0xFE3, W, ACCESS
18400  B4D8     BTFSC 0xFD8, 2, ACCESS
18402  D006     BRA 0x8410
43:            		lp_speed = 0.033;
18404  0E02     MOVLW 0x2
18406  6E09     MOVWF ltemp2, ACCESS
18408  0E2B     MOVLW 0x2B
1840A  6E0A     MOVWF ttemp3, ACCESS
1840C  0E07     MOVLW 0x7
1840E  D005     BRA 0x841A
44:            	} else {
45:            		lp_speed = 0.066;
18410  0E02     MOVLW 0x2
18412  6E09     MOVWF ltemp2, ACCESS
18414  0E2B     MOVLW 0x2B
18416  6E0A     MOVWF ttemp3, ACCESS
18418  0E87     MOVLW 0x87
1841A  6E0B     MOVWF wtemp5, ACCESS
1841C  0E3D     MOVLW 0x3D
1841E  6E0C     MOVWF 0xC, ACCESS
18420  0EFC     MOVLW 0xFC
18424  F027     NOP
18426  FFE3     NOP
18428  0EFD     MOVLW 0xFD
1842C  F02B     NOP
1842E  FFE3     NOP
18430  0EFE     MOVLW 0xFE
18434  F02F     NOP
18436  FFE3     NOP
18438  0EFF     MOVLW 0xFF
1843C  F033     NOP
1843E  FFE3     NOP
46:            	}
47:            	// exponentially weighted moving average
48:            	return smooth[bn] = smooth[bn] + ((new - smooth[bn]) * lp_speed);
18440  0EF7     MOVLW 0xF7
18442  50E3     MOVF 0xFE3, W, ACCESS
18444  0D04     MULLW 0x4
18446  0E00     MOVLW 0x0
18448  24F3     ADDWF 0xFF3, W, ACCESS
1844A  6ED9     MOVWF 0xFD9, ACCESS
1844C  0E02     MOVLW 0x2
1844E  20F4     ADDWFC 0xFF4, W, ACCESS
18450  6EDA     MOVWF 0xFDA, ACCESS
18454  FF7B     NOP
18456  FFE6     NOP
1845A  FF7B     NOP
1845C  FFE6     NOP
18460  FF7B     NOP
18462  FFE6     NOP
18466  FF7B     NOP
18468  FFE6     NOP
1846A  0EF8     MOVLW 0xF8
1846E  FF8F     NOP
18470  FFE6     NOP
18474  FF8F     NOP
18476  FFE6     NOP
1847A  FF8F     NOP
1847C  FFE6     NOP
18480  FF8F     NOP
18482  FFE6     NOP
18484  0EEF     MOVLW 0xEF
18486  50E3     MOVF 0xFE3, W, ACCESS
18488  0D04     MULLW 0x4
1848A  0E00     MOVLW 0x0
1848C  24F3     ADDWF 0xFF3, W, ACCESS
1848E  6ED9     MOVWF 0xFD9, ACCESS
18490  0E02     MOVLW 0x2
18492  20F4     ADDWFC 0xFF4, W, ACCESS
18494  6EDA     MOVWF 0xFDA, ACCESS
18498  FF7B     NOP
1849A  FFE6     NOP
1849E  FF7B     NOP
184A0  FFE6     NOP
184A4  FF7B     NOP
184A6  FFE6     NOP
184AA  FF7B     NOP
184AC  FFE6     NOP
184AE  0EEC     MOVLW 0xEC
184B2  FF8F     NOP
184B4  FFE6     NOP
184B8  FF8F     NOP
184BA  FFE6     NOP
184BE  FF8F     NOP
184C0  FFE6     NOP
184C4  FF8F     NOP
184C6  FFE6     NOP
184C8  EC04     CALL 0x1B208, 0
184CA  F0D9     NOP
184CE  F007     NOP
184D0  FFE6     NOP
184D4  F00B     NOP
184D6  FFE6     NOP
184DA  F00F     NOP
184DC  FFE6     NOP
184E0  F013     NOP
184E2  FFE6     NOP
184E4  ECA0     CALL 0x13340, 0
184E6  F099     NOP
184EA  F007     NOP
184EC  FFE6     NOP
184F0  F00B     NOP
184F2  FFE6     NOP
184F6  F00F     NOP
184F8  FFE6     NOP
184FC  F013     NOP
184FE  FFE6     NOP
18500  ECB5     CALL 0x13B6A, 0
18502  F09D     NOP
18504  0EF7     MOVLW 0xF7
18506  50E3     MOVF 0xFE3, W, ACCESS
18508  0D04     MULLW 0x4
1850A  0E00     MOVLW 0x0
1850C  24F3     ADDWF 0xFF3, W, ACCESS
1850E  6ED9     MOVWF 0xFD9, ACCESS
18510  0E02     MOVLW 0x2
18512  20F4     ADDWFC 0xFF4, W, ACCESS
18514  6EDA     MOVWF 0xFDA, ACCESS
18518  F007     NOP
1851A  FFDE     NOP
1851E  F00B     NOP
18520  FFDE     NOP
18524  F00F     NOP
18526  FFDE     NOP
1852A  F013     NOP
1852C  FFDD     NOP
1852E  52DD     MOVF 0xFDD, F, ACCESS
18530  52DD     MOVF 0xFDD, F, ACCESS
18534  FF78     NOP
18536  F001     NOP
1853A  FF78     NOP
1853C  F002     NOP
18540  FF78     NOP
18542  F003     NOP
18546  FF78     NOP
18548  F004     NOP
49:            }
1854A  0EF6     MOVLW 0xF6
1854C  26E1     ADDWF 0xFE1, F, ACCESS
1854E  0EFF     MOVLW 0xFF
18550  22E2     ADDWFC 0xFE2, F, ACCESS
18552  0012     RETURN 0
50:            
51:            void convert_adc_data(void)
1A256  52E6     MOVF 0xFE6, F, ACCESS
52:            {
53:            	uint8_t i = 0;
1A258  0EFF     MOVLW 0xFF
1A25A  6AE3     CLRF 0xFE3, ACCESS
54:            
55:            	do {
56:            		if (V.calib) {
1A25C  0101     MOVLB 0x1
1A25E  51DC     MOVF 0xDC, W, BANKED
1A260  B4D8     BTFSC 0xFD8, 2, ACCESS
1A262  D01B     BRA 0xA29A
57:            			C.calc[i] = lp_filter(conv_raw_result(i, O_CONV), i, true);
1A264  0E01     MOVLW 0x1
1A266  6EE6     MOVWF 0xFE6, ACCESS
1A268  0EFE     MOVLW 0xFE
1A26A  50E3     MOVF 0xFE3, W, ACCESS
1A26C  6EE6     MOVWF 0xFE6, ACCESS
1A26E  0E01     MOVLW 0x1
1A270  6EE6     MOVWF 0xFE6, ACCESS
1A272  0EFC     MOVLW 0xFC
1A274  50E3     MOVF 0xFE3, W, ACCESS
1A276  6EE6     MOVWF 0xFE6, ACCESS
1A278  EC0E     CALL 0x1501C, 0
1A27A  F0A8     NOP
1A27E  F007     NOP
1A280  FFE6     NOP
1A284  F00B     NOP
1A286  FFE6     NOP
1A28A  F00F     NOP
1A28C  FFE6     NOP
1A290  F013     NOP
1A292  FFE6     NOP
1A294  ECCC     CALL 0x18398, 0
1A296  F0C1     NOP
1A298  D01A     BRA 0xA2CE
58:            		} else {
59:            			C.calc[i] = lp_filter(conv_raw_result(i, CONV), i, false);
1A29A  0E00     MOVLW 0x0
1A29C  6EE6     MOVWF 0xFE6, ACCESS
1A29E  0EFE     MOVLW 0xFE
1A2A0  50E3     MOVF 0xFE3, W, ACCESS
1A2A2  6EE6     MOVWF 0xFE6, ACCESS
1A2A4  0E00     MOVLW 0x0
1A2A6  6EE6     MOVWF 0xFE6, ACCESS
1A2A8  0EFC     MOVLW 0xFC
1A2AA  50E3     MOVF 0xFE3, W, ACCESS
1A2AC  6EE6     MOVWF 0xFE6, ACCESS
1A2AE  EC0E     CALL 0x1501C, 0
1A2B0  F0A8     NOP
1A2B4  F007     NOP
1A2B6  FFE6     NOP
1A2BA  F00B     NOP
1A2BC  FFE6     NOP
1A2C0  F00F     NOP
1A2C2  FFE6     NOP
1A2C6  F013     NOP
1A2C8  FFE6     NOP
1A2CA  ECCC     CALL 0x18398, 0
1A2CC  F0C1     NOP
1A2CE  0EFF     MOVLW 0xFF
1A2D0  50E3     MOVF 0xFE3, W, ACCESS
1A2D2  0D04     MULLW 0x4
1A2D4  0EFF     MOVLW 0xFF
1A2D6  24F3     ADDWF 0xFF3, W, ACCESS
1A2D8  6ED9     MOVWF 0xFD9, ACCESS
1A2DA  0E06     MOVLW 0x6
1A2DC  20F4     ADDWFC 0xFF4, W, ACCESS
1A2DE  6EDA     MOVWF 0xFDA, ACCESS
1A2E2  F007     NOP
1A2E4  FFDE     NOP
1A2E8  F00B     NOP
1A2EA  FFDE     NOP
1A2EE  F00F     NOP
1A2F0  FFDE     NOP
1A2F4  F013     NOP
1A2F6  FFDE     NOP
60:            		}
61:            	} while (++i < ADC_BUFFER_SIZE);
1A2F8  0EFF     MOVLW 0xFF
1A2FA  2AE3     INCF 0xFE3, F, ACCESS
1A2FC  0EFF     MOVLW 0xFF
1A300  FF8C     NOP
1A302  F001     NOP
1A304  0E0F     MOVLW 0xF
1A306  6401     CPFSGT ltemp0, ACCESS
1A308  D7A9     BRA 0xA25C
62:            }
1A30A  52E5     MOVF 0xFE5, F, ACCESS
1A30C  0012     RETURN 0
63:            
64:            /*
65:             * buffer model data from DAQ
66:             */
67:            void calc_model_data(void)
68:            {
69:            	static float bvror = 0.0, bcror = 0.0;
70:            	stop_bsoc();
159B0  ECF0     CALL 0x1BDE0, 0
159B2  F0DE     NOP
71:            
72:            	if (!V.calib) {
159B4  0101     MOVLB 0x1
159B6  51DC     MOVF 0xDC, W, BANKED
159B8  A4D8     BTFSS 0xFD8, 2, ACCESS
159BA  D219     BRA 0x5DEE
73:            		C.c_bat = C.calc[C_BATT];
159BC  EE21     LFSR 2, 0x6FF
159BE  F2FF     NOP
159C2  FF78     NOP
159C4  F743     NOP
159C8  FF78     NOP
159CA  F744     NOP
159CE  FF78     NOP
159D0  F745     NOP
159D4  FF74     NOP
159D6  F746     NOP
74:            		C.bc_ror = C.c_bat - bcror;
159DA  F23B     NOP
159DC  FFE6     NOP
159E0  F23F     NOP
159E2  FFE6     NOP
159E6  F243     NOP
159E8  FFE6     NOP
159EC  F247     NOP
159EE  FFE6     NOP
159F0  EE21     LFSR 2, 0x743
159F2  F343     NOP
159F6  FF7B     NOP
159F8  FFE6     NOP
159FC  FF7B     NOP
159FE  FFE6     NOP
15A02  FF7B     NOP
15A04  FFE6     NOP
15A08  FF7B     NOP
15A0A  FFE6     NOP
15A0C  EC04     CALL 0x1B208, 0
15A0E  F0D9     NOP
15A12  F004     NOP
15A14  F76F     NOP
15A18  F008     NOP
15A1A  F770     NOP
15A1E  F00C     NOP
15A20  F771     NOP
15A24  F010     NOP
15A26  F772     NOP
75:            		bcror = C.c_bat;
15A28  C743     MOVFF 0x743, bcror
15A2A  F08E     NOP
15A2C  C744     MOVFF 0x744, 0x8F
15A2E  F08F     NOP
15A30  C745     MOVFF 0x745, 0x90
15A32  F090     NOP
15A34  C746     MOVFF 0x746, 0x91
15A36  F091     NOP
76:            		C.c_pv = C.calc[C_PV];
15A38  EE21     LFSR 2, 0x703
15A3A  F303     NOP
15A3E  FF78     NOP
15A40  F747     NOP
15A44  FF78     NOP
15A46  F748     NOP
15A4A  FF78     NOP
15A4C  F749     NOP
15A50  FF74     NOP
15A52  F74A     NOP
77:            		C.v_bat = C.calc[V_BAT];
15A54  EE21     LFSR 2, 0x70F
15A56  F30F     NOP
15A5A  FF78     NOP
15A5C  F753     NOP
15A60  FF78     NOP
15A62  F754     NOP
15A66  FF78     NOP
15A68  F755     NOP
15A6C  FF74     NOP
15A6E  F756     NOP
78:            		C.v_sensor = C.calc[V_LIGHT_SENSOR];
15A70  EE21     LFSR 2, 0x733
15A72  F333     NOP
15A76  FF78     NOP
15A78  F767     NOP
15A7C  FF78     NOP
15A7E  F768     NOP
15A82  FF78     NOP
15A84  F769     NOP
15A88  FF74     NOP
15A8A  F76A     NOP
79:            		C.bv_ror = C.v_bat - bvror;
15A8E  F24B     NOP
15A90  FFE6     NOP
15A94  F24F     NOP
15A96  FFE6     NOP
15A9A  F253     NOP
15A9C  FFE6     NOP
15AA0  F257     NOP
15AA2  FFE6     NOP
15AA4  EE21     LFSR 2, 0x753
15AA6  F353     NOP
15AAA  FF7B     NOP
15AAC  FFE6     NOP
15AB0  FF7B     NOP
15AB2  FFE6     NOP
15AB6  FF7B     NOP
15AB8  FFE6     NOP
15ABC  FF7B     NOP
15ABE  FFE6     NOP
15AC0  EC04     CALL 0x1B208, 0
15AC2  F0D9     NOP
15AC6  F004     NOP
15AC8  F76B     NOP
15ACC  F008     NOP
15ACE  F76C     NOP
15AD2  F00C     NOP
15AD4  F76D     NOP
15AD8  F010     NOP
15ADA  F76E     NOP
80:            		bvror = C.v_bat;
15ADC  C753     MOVFF 0x753, bvror
15ADE  F092     NOP
15AE0  C754     MOVFF 0x754, 0x93
15AE2  F093     NOP
15AE4  C755     MOVFF 0x755, 0x94
15AE6  F094     NOP
15AE8  C756     MOVFF 0x756, 0x95
15AEA  F095     NOP
81:            		C.v_pv = C.calc[V_PV];
15AEC  EE21     LFSR 2, 0x713
15AEE  F313     NOP
15AF2  FF78     NOP
15AF4  F74F     NOP
15AF8  FF78     NOP
15AFA  F750     NOP
15AFE  FF78     NOP
15B00  F751     NOP
15B04  FF74     NOP
15B06  F752     NOP
82:            		C.v_cc = C.calc[V_CC];
15B08  EE21     LFSR 2, 0x707
15B0A  F307     NOP
15B0E  FF78     NOP
15B10  F74B     NOP
15B14  FF78     NOP
15B16  F74C     NOP
15B1A  FF78     NOP
15B1C  F74D     NOP
15B20  FF74     NOP
15B22  F74E     NOP
83:            		C.v_inverter = C.calc[V_INVERTER];
15B24  EE21     LFSR 2, 0x72F
15B26  F32F     NOP
15B2A  FF78     NOP
15B2C  F763     NOP
15B30  FF78     NOP
15B32  F764     NOP
15B36  FF78     NOP
15B38  F765     NOP
15B3C  FF74     NOP
15B3E  F766     NOP
84:            		C.c_load = lp_filter(C.calc[C_PV]+(-(C.calc[C_BATT])), 16, true);
15B40  0E01     MOVLW 0x1
15B42  6EE6     MOVWF 0xFE6, ACCESS
15B44  0E10     MOVLW 0x10
15B46  6EE6     MOVWF 0xFE6, ACCESS
15B48  EE21     LFSR 2, 0x6FF
15B4A  F2FF     NOP
15B4E  FF7B     NOP
15B50  FFE6     NOP
15B54  FF7B     NOP
15B56  FFE6     NOP
15B5A  FF7B     NOP
15B5C  FFE6     NOP
15B60  FF7B     NOP
15B62  FFE6     NOP
15B64  EE21     LFSR 2, 0x703
15B66  F303     NOP
15B6A  FF7B     NOP
15B6C  FFE6     NOP
15B70  FF7B     NOP
15B72  FFE6     NOP
15B76  FF7B     NOP
15B78  FFE6     NOP
15B7C  FF7B     NOP
15B7E  FFE6     NOP
15B80  EC04     CALL 0x1B208, 0
15B82  F0D9     NOP
15B86  F007     NOP
15B88  FFE6     NOP
15B8C  F00B     NOP
15B8E  FFE6     NOP
15B92  F00F     NOP
15B94  FFE6     NOP
15B98  F013     NOP
15B9A  FFE6     NOP
15B9C  ECCC     CALL 0x18398, 0
15B9E  F0C1     NOP
15BA2  F004     NOP
15BA4  F73F     NOP
15BA8  F008     NOP
15BAA  F740     NOP
15BAE  F00C     NOP
15BB0  F741     NOP
15BB4  F010     NOP
15BB6  F742     NOP
85:            		C.p_load = lp_filter(C.c_load * C.v_bat, 17, true);
15BB8  0E01     MOVLW 0x1
15BBA  6EE6     MOVWF 0xFE6, ACCESS
15BBC  0E11     MOVLW 0x11
15BBE  6EE6     MOVWF 0xFE6, ACCESS
15BC0  EE21     LFSR 2, 0x753
15BC2  F353     NOP
15BC6  FF7B     NOP
15BC8  FFE6     NOP
15BCC  FF7B     NOP
15BCE  FFE6     NOP
15BD2  FF7B     NOP
15BD4  FFE6     NOP
15BD8  FF7B     NOP
15BDA  FFE6     NOP
15BDC  EE21     LFSR 2, 0x73F
15BDE  F33F     NOP
15BE2  FF7B     NOP
15BE4  FFE6     NOP
15BE8  FF7B     NOP
15BEA  FFE6     NOP
15BEE  FF7B     NOP
15BF0  FFE6     NOP
15BF4  FF7B     NOP
15BF6  FFE6     NOP
15BF8  ECA0     CALL 0x13340, 0
15BFA  F099     NOP
15BFE  F007     NOP
15C00  FFE6     NOP
15C04  F00B     NOP
15C06  FFE6     NOP
15C0A  F00F     NOP
15C0C  FFE6     NOP
15C10  F013     NOP
15C12  FFE6     NOP
15C14  ECCC     CALL 0x18398, 0
15C16  F0C1     NOP
15C1A  F004     NOP
15C1C  F773     NOP
15C20  F008     NOP
15C22  F774     NOP
15C26  F00C     NOP
15C28  F775     NOP
15C2C  F010     NOP
15C2E  F776     NOP
86:            		C.p_pv = lp_filter(C.c_pv * C.v_pv, 18, true);
15C30  0E01     MOVLW 0x1
15C32  6EE6     MOVWF 0xFE6, ACCESS
15C34  0E12     MOVLW 0x12
15C36  6EE6     MOVWF 0xFE6, ACCESS
15C38  EE21     LFSR 2, 0x74F
15C3A  F34F     NOP
15C3E  FF7B     NOP
15C40  FFE6     NOP
15C44  FF7B     NOP
15C46  FFE6     NOP
15C4A  FF7B     NOP
15C4C  FFE6     NOP
15C50  FF7B     NOP
15C52  FFE6     NOP
15C54  EE21     LFSR 2, 0x747
15C56  F347     NOP
15C5A  FF7B     NOP
15C5C  FFE6     NOP
15C60  FF7B     NOP
15C62  FFE6     NOP
15C66  FF7B     NOP
15C68  FFE6     NOP
15C6C  FF7B     NOP
15C6E  FFE6     NOP
15C70  ECA0     CALL 0x13340, 0
15C72  F099     NOP
15C76  F007     NOP
15C78  FFE6     NOP
15C7C  F00B     NOP
15C7E  FFE6     NOP
15C82  F00F     NOP
15C84  FFE6     NOP
15C88  F013     NOP
15C8A  FFE6     NOP
15C8C  ECCC     CALL 0x18398, 0
15C8E  F0C1     NOP
15C92  F004     NOP
15C94  F77B     NOP
15C98  F008     NOP
15C9A  F77C     NOP
15C9E  F00C     NOP
15CA0  F77D     NOP
15CA4  F010     NOP
15CA6  F77E     NOP
87:            		C.p_inverter = lp_filter((C.c_load * C.v_inverter) - STATIC_LOAD_POWER, 19, true);
15CA8  0E01     MOVLW 0x1
15CAA  6EE6     MOVWF 0xFE6, ACCESS
15CAC  0E13     MOVLW 0x13
15CAE  6EE6     MOVWF 0xFE6, ACCESS
15CB0  0E00     MOVLW 0x0
15CB2  6EE6     MOVWF 0xFE6, ACCESS
15CB4  0E00     MOVLW 0x0
15CB6  6EE6     MOVWF 0xFE6, ACCESS
15CB8  0E60     MOVLW 0x60
15CBA  6EE6     MOVWF 0xFE6, ACCESS
15CBC  0EC1     MOVLW 0xC1
15CBE  6EE6     MOVWF 0xFE6, ACCESS
15CC0  EE21     LFSR 2, 0x763
15CC2  F363     NOP
15CC6  FF7B     NOP
15CC8  FFE6     NOP
15CCC  FF7B     NOP
15CCE  FFE6     NOP
15CD2  FF7B     NOP
15CD4  FFE6     NOP
15CD8  FF7B     NOP
15CDA  FFE6     NOP
15CDC  EE21     LFSR 2, 0x73F
15CDE  F33F     NOP
15CE2  FF7B     NOP
15CE4  FFE6     NOP
15CE8  FF7B     NOP
15CEA  FFE6     NOP
15CEE  FF7B     NOP
15CF0  FFE6     NOP
15CF4  FF7B     NOP
15CF6  FFE6     NOP
15CF8  ECA0     CALL 0x13340, 0
15CFA  F099     NOP
15CFE  F007     NOP
15D00  FFE6     NOP
15D04  F00B     NOP
15D06  FFE6     NOP
15D0A  F00F     NOP
15D0C  FFE6     NOP
15D10  F013     NOP
15D12  FFE6     NOP
15D14  ECB5     CALL 0x13B6A, 0
15D16  F09D     NOP
15D1A  F007     NOP
15D1C  FFE6     NOP
15D20  F00B     NOP
15D22  FFE6     NOP
15D26  F00F     NOP
15D28  FFE6     NOP
15D2C  F013     NOP
15D2E  FFE6     NOP
15D30  ECCC     CALL 0x18398, 0
15D32  F0C1     NOP
15D36  F004     NOP
15D38  F777     NOP
15D3C  F008     NOP
15D3E  F778     NOP
15D42  F00C     NOP
15D44  F779     NOP
15D48  F010     NOP
15D4A  F77A     NOP
88:            		C.p_bat = lp_filter(C.c_bat * C.v_bat, 20, true);
15D4C  0E01     MOVLW 0x1
15D4E  6EE6     MOVWF 0xFE6, ACCESS
15D50  0E14     MOVLW 0x14
15D52  6EE6     MOVWF 0xFE6, ACCESS
15D54  EE21     LFSR 2, 0x753
15D56  F353     NOP
15D5A  FF7B     NOP
15D5C  FFE6     NOP
15D60  FF7B     NOP
15D62  FFE6     NOP
15D66  FF7B     NOP
15D68  FFE6     NOP
15D6C  FF7B     NOP
15D6E  FFE6     NOP
15D70  EE21     LFSR 2, 0x743
15D72  F343     NOP
15D76  FF7B     NOP
15D78  FFE6     NOP
15D7C  FF7B     NOP
15D7E  FFE6     NOP
15D82  FF7B     NOP
15D84  FFE6     NOP
15D88  FF7B     NOP
15D8A  FFE6     NOP
15D8C  ECA0     CALL 0x13340, 0
15D8E  F099     NOP
15D92  F007     NOP
15D94  FFE6     NOP
15D98  F00B     NOP
15D9A  FFE6     NOP
15D9E  F00F     NOP
15DA0  FFE6     NOP
15DA4  F013     NOP
15DA6  FFE6     NOP
15DA8  ECCC     CALL 0x18398, 0
15DAA  F0C1     NOP
15DAE  F004     NOP
15DB0  F77F     NOP
15DB4  F008     NOP
15DB6  F780     NOP
15DBA  F00C     NOP
15DBC  F781     NOP
15DC0  F010     NOP
15DC2  F782     NOP
89:            		/*
90:            		 * calculation limits
91:            		 */
92:            		if (C.p_inverter < 0.0)
15DC4  EE21     LFSR 2, 0x777
15DC6  F377     NOP
15DC8  0E03     MOVLW 0x3
15DCA  AEDB     BTFSS 0xFDB, 7, ACCESS
15DCC  D010     BRA 0x5DEE
93:            			C.p_inverter = 0.0001;
15DCE  0E17     MOVLW 0x17
15DD2  FFA0     NOP
15DD4  F777     NOP
15DD6  0EB7     MOVLW 0xB7
15DDA  FFA0     NOP
15DDC  F778     NOP
15DDE  0ED1     MOVLW 0xD1
15DE2  FFA0     NOP
15DE4  F779     NOP
15DE6  0E38     MOVLW 0x38
15DEA  FFA0     NOP
15DEC  F77A     NOP
94:            	}
95:            	start_bsoc();
15DEE  EC89     CALL 0x1BB12, 0
15DF0  F0DD     NOP
96:            	C.update = true;
15DF2  0E01     MOVLW 0x1
15DF6  FFA0     NOP
15DF8  F7B3     NOP
97:            }
15DFA  0012     RETURN 0
98:            
99:            /*
100:            * find rate of change of battery voltage under load
101:            */
102:           void calc_ror_data(void)
103:           {
104:           	static float bvror = 0.0, bcror = 0.0; // must remember prior values
105:           
106:           	C.bc_ror = fabs(conv_raw_result(C_BATT, CONV) - bcror);
1888C  F21B     NOP
1888E  FFE6     NOP
18892  F21F     NOP
18894  FFE6     NOP
18898  F223     NOP
1889A  FFE6     NOP
1889E  F227     NOP
188A0  FFE6     NOP
188A2  0E00     MOVLW 0x0
188A4  6EE6     MOVWF 0xFE6, ACCESS
188A6  0E00     MOVLW 0x0
188A8  6EE6     MOVWF 0xFE6, ACCESS
188AA  EC0E     CALL 0x1501C, 0
188AC  F0A8     NOP
188B0  F007     NOP
188B2  FFE6     NOP
188B6  F00B     NOP
188B8  FFE6     NOP
188BC  F00F     NOP
188BE  FFE6     NOP
188C2  F013     NOP
188C4  FFE6     NOP
188C6  EC04     CALL 0x1B208, 0
188C8  F0D9     NOP
188CC  F007     NOP
188CE  FFE6     NOP
188D2  F00B     NOP
188D4  FFE6     NOP
188D8  F00F     NOP
188DA  FFE6     NOP
188DE  F013     NOP
188E0  FFE6     NOP
188E2  EC87     CALL 0x1A30E, 0
188E4  F0D1     NOP
188E8  F004     NOP
188EA  F76F     NOP
188EE  F008     NOP
188F0  F770     NOP
188F4  F00C     NOP
188F6  F771     NOP
188FA  F010     NOP
188FC  F772     NOP
107:           	bcror = conv_raw_result(C_BATT, CONV);
188FE  0E00     MOVLW 0x0
18900  6EE6     MOVWF 0xFE6, ACCESS
18902  0E00     MOVLW 0x0
18904  6EE6     MOVWF 0xFE6, ACCESS
18906  EC0E     CALL 0x1501C, 0
18908  F0A8     NOP
1890C  F004     NOP
1890E  F086     NOP
18912  F008     NOP
18914  F087     NOP
18918  F00C     NOP
1891A  F088     NOP
1891E  F010     NOP
18920  F089     NOP
108:           	C.bv_ror = fabs(conv_raw_result(V_BAT, CONV) - bvror);
18924  F22B     NOP
18926  FFE6     NOP
1892A  F22F     NOP
1892C  FFE6     NOP
18930  F233     NOP
18932  FFE6     NOP
18936  F237     NOP
18938  FFE6     NOP
1893A  0E00     MOVLW 0x0
1893C  6EE6     MOVWF 0xFE6, ACCESS
1893E  0E04     MOVLW 0x4
18940  6EE6     MOVWF 0xFE6, ACCESS
18942  EC0E     CALL 0x1501C, 0
18944  F0A8     NOP
18948  F007     NOP
1894A  FFE6     NOP
1894E  F00B     NOP
18950  FFE6     NOP
18954  F00F     NOP
18956  FFE6     NOP
1895A  F013     NOP
1895C  FFE6     NOP
1895E  EC04     CALL 0x1B208, 0
18960  F0D9     NOP
18964  F007     NOP
18966  FFE6     NOP
1896A  F00B     NOP
1896C  FFE6     NOP
18970  F00F     NOP
18972  FFE6     NOP
18976  F013     NOP
18978  FFE6     NOP
1897A  EC87     CALL 0x1A30E, 0
1897C  F0D1     NOP
18980  F004     NOP
18982  F76B     NOP
18986  F008     NOP
18988  F76C     NOP
1898C  F00C     NOP
1898E  F76D     NOP
18992  F010     NOP
18994  F76E     NOP
109:           	if (C.bv_ror < ROR_LIMIT_NOISE) // skip noise values
18996  0EE7     MOVLW 0xE7
18998  6EE6     MOVWF 0xFE6, ACCESS
1899A  0E1D     MOVLW 0x1D
1899C  6EE6     MOVWF 0xFE6, ACCESS
1899E  0EA7     MOVLW 0xA7
189A0  6EE6     MOVWF 0xFE6, ACCESS
189A2  0E3B     MOVLW 0x3B
189A4  6EE6     MOVWF 0xFE6, ACCESS
189A6  EE21     LFSR 2, 0x76B
189A8  F36B     NOP
189AC  FF7B     NOP
189AE  FFE6     NOP
189B2  FF7B     NOP
189B4  FFE6     NOP
189B8  FF7B     NOP
189BA  FFE6     NOP
189BE  FF7B     NOP
189C0  FFE6     NOP
189C2  EC81     CALL 0x18D02, 0
189C4  F0C6     NOP
189C6  B001     BTFSC ltemp0, 0, ACCESS
189C8  D010     BRA 0x89EA
110:           		C.bv_ror = ROR_LIMIT_LOW + ROR_LIMIT_SET; // keep trying value
189CA  0EB0     MOVLW 0xB0
189CE  FFA0     NOP
189D0  F76B     NOP
189D2  0E03     MOVLW 0x3
189D6  FFA0     NOP
189D8  F76C     NOP
189DA  0E67     MOVLW 0x67
189DE  FFA0     NOP
189E0  F76D     NOP
189E2  0E3C     MOVLW 0x3C
189E6  FFA0     NOP
189E8  F76E     NOP
111:           	bvror = conv_raw_result(V_BAT, CONV);
189EA  0E00     MOVLW 0x0
189EC  6EE6     MOVWF 0xFE6, ACCESS
189EE  0E04     MOVLW 0x4
189F0  6EE6     MOVWF 0xFE6, ACCESS
189F2  EC0E     CALL 0x1501C, 0
189F4  F0A8     NOP
189F8  F004     NOP
189FA  F08A     NOP
189FE  F008     NOP
18A00  F08B     NOP
18A04  F00C     NOP
18A06  F08C     NOP
18A0A  F010     NOP
18A0C  F08D     NOP
112:           }
18A0E  0012     RETURN 0
113:           
114:           /*
115:            * boot battery condition defaults
116:            */
117:           void static_soc(void)
118:           {
119:           	C.runtime = 120;
1B3D4  0E78     MOVLW 0x78
1B3D8  FFA0     NOP
1B3DA  F7AF     NOP
1B3DC  0E00     MOVLW 0x0
1B3E0  FFA0     NOP
1B3E2  F7B0     NOP
120:           	C.soc = 100;
1B3E4  0E64     MOVLW 0x64
1B3E8  FFA0     NOP
1B3EA  F7B1     NOP
1B3EC  0E00     MOVLW 0x0
1B3F0  FFA0     NOP
1B3F2  F7B2     NOP
121:           	C.dynamic_ah = C.bank_ah;
1B3F4  EE21     LFSR 2, 0x78B
1B3F6  F38B     NOP
1B3FA  FF78     NOP
1B3FC  F78F     NOP
1B400  FF78     NOP
1B402  F790     NOP
1B406  FF78     NOP
1B408  F791     NOP
1B40C  FF74     NOP
1B40E  F792     NOP
122:           }
1B410  0012     RETURN 0
123:           
124:           void set_load_relay_one(bool mode)
125:           {
126:           	RELAYL1_LAT = mode;
1BCE6  0EFF     MOVLW 0xFF
1BCE8  B0E3     BTFSC 0xFE3, 0, ACCESS
1BCEA  D002     BRA 0xBCF0
1BCEC  98BD     BCF 0xFBD, 4, ACCESS
1BCEE  D001     BRA 0xBCF2
1BCF0  88BD     BSF 0xFBD, 4, ACCESS
127:           }
1BCF2  52E5     MOVF 0xFE5, F, ACCESS
1BCF4  0012     RETURN 0
128:           
129:           void set_load_relay_two(bool mode)
130:           {
131:           	RELAYL2_LAT = mode;
1BCD6  0EFF     MOVLW 0xFF
1BCD8  B0E3     BTFSC 0xFE3, 0, ACCESS
1BCDA  D002     BRA 0xBCE0
1BCDC  9ABD     BCF 0xFBD, 5, ACCESS
1BCDE  D001     BRA 0xBCE2
1BCE0  8ABD     BSF 0xFBD, 5, ACCESS
132:           }
1BCE2  52E5     MOVF 0xFE5, F, ACCESS
1BCE4  0012     RETURN 0
133:           
134:           void set_ac_charger_relay(bool mode)
135:           {
136:           	AC_CHARGER_LAT = mode;
1BD06  0EFF     MOVLW 0xFF
1BD08  B0E3     BTFSC 0xFE3, 0, ACCESS
1BD0A  D002     BRA 0xBD10
1BD0C  9CBD     BCF 0xFBD, 6, ACCESS
1BD0E  D001     BRA 0xBD12
1BD10  8CBD     BSF 0xFBD, 6, ACCESS
137:           }
1BD12  52E5     MOVF 0xFE5, F, ACCESS
1BD14  0012     RETURN 0
138:           
139:           bool get_ac_charger_relay(void)
140:           {
141:           	return AC_CHARGER_LAT;
1BD40  ACBD     BTFSS 0xFBD, 6, ACCESS
1BD42  D003     BRA 0xBD4A
1BD44  6A01     CLRF ltemp0, ACCESS
1BD46  2A01     INCF ltemp0, F, ACCESS
1BD48  0012     RETURN 0
1BD4A  6A01     CLRF ltemp0, ACCESS
142:           }
1BD4C  0012     RETURN 0
143:           
144:           /* Misc ACSII spinner character generator, stores position for each shape */
145:           char spinners(uint8_t shape, uint8_t reset)
19E22  52E6     MOVF 0xFE6, F, ACCESS
146:           {
147:           	static uint8_t s[MAX_SHAPES];
148:           	char c;
149:           
150:           	if (shape > (MAX_SHAPES - 1))
19E24  0EFE     MOVLW 0xFE
19E28  FF8C     NOP
19E2A  F001     NOP
19E2C  0E05     MOVLW 0x5
19E2E  6401     CPFSGT ltemp0, ACCESS
19E30  D002     BRA 0x9E36
151:           		shape = 0;
19E32  0EFE     MOVLW 0xFE
19E34  6AE3     CLRF 0xFE3, ACCESS
152:           	if (reset)
19E36  0EFD     MOVLW 0xFD
19E38  50E3     MOVF 0xFE3, W, ACCESS
19E3A  B4D8     BTFSC 0xFD8, 2, ACCESS
19E3C  D00A     BRA 0x9E52
153:           		s[shape] = 0;
19E3E  0EFE     MOVLW 0xFE
19E42  FF8C     NOP
19E44  F00C     NOP
19E46  500C     MOVF 0xC, W, ACCESS
19E48  0F74     ADDLW 0x74
19E4A  6ED9     MOVWF 0xFD9, ACCESS
19E4C  6ADA     CLRF 0xFDA, ACCESS
19E4E  0E00     MOVLW 0x0
19E50  6EDF     MOVWF 0xFDF, ACCESS
154:           	c = spin[shape][s[shape]];
19E52  0EFE     MOVLW 0xFE
19E54  50E3     MOVF 0xFE3, W, ACCESS
19E56  0D14     MULLW 0x14
19E58  0EC7     MOVLW 0xC7
19E5A  6E0B     MOVWF wtemp5, ACCESS
19E5C  0EFB     MOVLW 0xFB
19E5E  6E0C     MOVWF 0xC, ACCESS
19E60  50F3     MOVF 0xFF3, W, ACCESS
19E62  260B     ADDWF wtemp5, F, ACCESS
19E64  50F4     MOVF 0xFF4, W, ACCESS
19E66  220C     ADDWFC 0xC, F, ACCESS
19E68  0EFE     MOVLW 0xFE
19E6C  FF8C     NOP
19E6E  F00A     NOP
19E70  500A     MOVF ttemp3, W, ACCESS
19E72  0F74     ADDLW 0x74
19E74  6ED9     MOVWF 0xFD9, ACCESS
19E76  6ADA     CLRF 0xFDA, ACCESS
19E78  50DF     MOVF 0xFDF, W, ACCESS
19E7A  260B     ADDWF wtemp5, F, ACCESS
19E7C  0E00     MOVLW 0x0
19E7E  220C     ADDWFC 0xC, F, ACCESS
19E82  F02F     NOP
19E84  FFF6     NOP
19E88  F033     NOP
19E8A  FFF7     NOP
19E8C  0E00     MOVLW 0x0
19E8E  6EF8     MOVWF 0xFF8, ACCESS
19E90  0008     TBLRD*
19E92  0EFF     MOVLW 0xFF
19E96  FFD7     NOP
19E98  FFE3     NOP
155:           	if (++s[shape] >= strlen(spin[shape]))
19E9A  0EFE     MOVLW 0xFE
19E9C  50E3     MOVF 0xFE3, W, ACCESS
19E9E  0D14     MULLW 0x14
19EA0  0EC7     MOVLW 0xC7
19EA2  6E0B     MOVWF wtemp5, ACCESS
19EA4  0EFB     MOVLW 0xFB
19EA6  6E0C     MOVWF 0xC, ACCESS
19EA8  50F3     MOVF 0xFF3, W, ACCESS
19EAA  260B     ADDWF wtemp5, F, ACCESS
19EAC  50F4     MOVF 0xFF4, W, ACCESS
19EAE  220C     ADDWFC 0xC, F, ACCESS
19EB2  F02F     NOP
19EB4  FFE6     NOP
19EB8  F033     NOP
19EBA  FFE6     NOP
19EBC  ECDC     CALL 0x1A5B8, 0
19EBE  F0D2     NOP
19EC0  0EFE     MOVLW 0xFE
19EC4  FF8C     NOP
19EC6  F00C     NOP
19EC8  500C     MOVF 0xC, W, ACCESS
19ECA  0F74     ADDLW 0x74
19ECC  6ED9     MOVWF 0xFD9, ACCESS
19ECE  6ADA     CLRF 0xFDA, ACCESS
19ED0  2ADF     INCF 0xFDF, F, ACCESS
19ED2  50DF     MOVF 0xFDF, W, ACCESS
19ED4  6E0B     MOVWF wtemp5, ACCESS
19ED6  6A0C     CLRF 0xC, ACCESS
19ED8  5001     MOVF ltemp0, W, ACCESS
19EDA  5C0B     SUBWF wtemp5, W, ACCESS
19EDC  5002     MOVF ttemp5, W, ACCESS
19EDE  580C     SUBWFB 0xC, W, ACCESS
19EE0  A0D8     BTFSS 0xFD8, 0, ACCESS
19EE2  D00A     BRA 0x9EF8
156:           		s[shape] = 0;
19EE4  0EFE     MOVLW 0xFE
19EE8  FF8C     NOP
19EEA  F00C     NOP
19EEC  500C     MOVF 0xC, W, ACCESS
19EEE  0F74     ADDLW 0x74
19EF0  6ED9     MOVWF 0xFD9, ACCESS
19EF2  6ADA     CLRF 0xFDA, ACCESS
19EF4  0E00     MOVLW 0x0
19EF6  6EDF     MOVWF 0xFDF, ACCESS
157:           	return c;
19EF8  0EFF     MOVLW 0xFF
19EFC  FF8C     NOP
19EFE  F001     NOP
158:           }
19F00  52E5     MOVF 0xFE5, F, ACCESS
19F02  52E5     MOVF 0xFE5, F, ACCESS
19F04  52E5     MOVF 0xFE5, F, ACCESS
19F06  0012     RETURN 0
159:           
160:           /*
161:            * should be called every second in the time keeper task
162:            * returns true at dusk or dawn switch-over
163:            */
164:           bool check_day_time(void)
18554  52E6     MOVF 0xFE6, F, ACCESS
18556  52E6     MOVF 0xFE6, F, ACCESS
18558  52E6     MOVF 0xFE6, F, ACCESS
1855A  52E6     MOVF 0xFE6, F, ACCESS
165:           {
166:           	static uint8_t day_delay = 0;
167:           	float light;
168:           
169:           	light = conv_raw_result(V_LIGHT_SENSOR, CONV);
1855C  0E00     MOVLW 0x0
1855E  6EE6     MOVWF 0xFE6, ACCESS
18560  0E0D     MOVLW 0xD
18562  6EE6     MOVWF 0xFE6, ACCESS
18564  EC0E     CALL 0x1501C, 0
18566  F0A8     NOP
18568  0EFC     MOVLW 0xFC
1856C  F007     NOP
1856E  FFE3     NOP
18570  0EFD     MOVLW 0xFD
18574  F00B     NOP
18576  FFE3     NOP
18578  0EFE     MOVLW 0xFE
1857C  F00F     NOP
1857E  FFE3     NOP
18580  0EFF     MOVLW 0xFF
18584  F013     NOP
18586  FFE3     NOP
170:           
171:           	if (!day_delay++ && V.system_stable) {
18588  2A42     INCF day_delay, F, ACCESS
1858A  0442     DECF day_delay, W, ACCESS
1858C  A4D8     BTFSS 0xFD8, 2, ACCESS
1858E  D0A9     BRA 0x86E2
18590  0101     MOVLB 0x1
18592  51DE     MOVF 0xDE, W, BANKED
18594  B4D8     BTFSC 0xFD8, 2, ACCESS
18596  D0A5     BRA 0x86E2
172:           		if (C.soc > SOC_CRITICAL) {
18598  EE21     LFSR 2, 0x7B1
1859A  F3B1     NOP
1859C  0E01     MOVLW 0x1
1859E  50DB     MOVF 0xFDB, W, ACCESS
185A0  E104     BNZ 0x85AA
185A2  0E10     MOVLW 0x10
185A4  5CDE     SUBWF 0xFDE, W, ACCESS
185A6  A0D8     BTFSS 0xFD8, 0, ACCESS
185A8  D073     BRA 0x8690
173:           			if (!C.day) {
185AA  EE22     LFSR 2, 0x81D
185AC  F01D     NOP
185AE  50DF     MOVF 0xFDF, W, ACCESS
185B0  A4D8     BTFSS 0xFD8, 2, ACCESS
185B2  D035     BRA 0x861E
174:           				if (light > DAWN_VOLTS) {
185B4  0EFC     MOVLW 0xFC
185B8  FF8F     NOP
185BA  FFE6     NOP
185BE  FF8F     NOP
185C0  FFE6     NOP
185C4  FF8F     NOP
185C6  FFE6     NOP
185CA  FF8F     NOP
185CC  FFE6     NOP
185CE  0E00     MOVLW 0x0
185D0  6EE6     MOVWF 0xFE6, ACCESS
185D2  0E00     MOVLW 0x0
185D4  6EE6     MOVWF 0xFE6, ACCESS
185D6  0EB0     MOVLW 0xB0
185D8  6EE6     MOVWF 0xFE6, ACCESS
185DA  0E41     MOVLW 0x41
185DC  6EE6     MOVWF 0xFE6, ACCESS
185DE  EC81     CALL 0x18D02, 0
185E0  F0C6     NOP
185E2  B001     BTFSC ltemp0, 0, ACCESS
185E4  D07E     BRA 0x86E2
175:           					C.day = true;
185E6  0E01     MOVLW 0x1
185EA  FFA0     NOP
185EC  F81D     NOP
176:           					C.day_start = V.ticks;
185EE  EE20     LFSR 2, 0x1B1
185F0  F1B1     NOP
185F4  FF78     NOP
185F6  F81E     NOP
185FA  FF78     NOP
185FC  F81F     NOP
18600  FF78     NOP
18602  F820     NOP
18606  FF74     NOP
18608  F821     NOP
177:           					if (get_ac_charger_relay()) { // USE PV charging during the day
1860A  ECA0     CALL 0x1BD40, 0
1860C  F0DE     NOP
1860E  5001     MOVF ltemp0, W, ACCESS
18610  B4D8     BTFSC 0xFD8, 2, ACCESS
18612  D06B     BRA 0x86EA
178:           						set_ac_charger_relay(false);
18614  0E00     MOVLW 0x0
18616  6EE6     MOVWF 0xFE6, ACCESS
18618  EC83     CALL 0x1BD06, 0
1861A  F0DE     NOP
1861C  D066     BRA 0x86EA
179:           					}
180:           					return true;
181:           				}
182:           			} else {
183:           				if (light < DUSK_VOLTS) {
1861E  0E00     MOVLW 0x0
18620  6EE6     MOVWF 0xFE6, ACCESS
18622  0E00     MOVLW 0x0
18624  6EE6     MOVWF 0xFE6, ACCESS
18626  0E40     MOVLW 0x40
18628  6EE6     MOVWF 0xFE6, ACCESS
1862A  0E41     MOVLW 0x41
1862C  6EE6     MOVWF 0xFE6, ACCESS
1862E  0EF8     MOVLW 0xF8
18632  FF8F     NOP
18634  FFE6     NOP
18638  FF8F     NOP
1863A  FFE6     NOP
1863E  FF8F     NOP
18640  FFE6     NOP
18644  FF8F     NOP
18646  FFE6     NOP
18648  EC81     CALL 0x18D02, 0
1864A  F0C6     NOP
1864C  B001     BTFSC ltemp0, 0, ACCESS
1864E  D049     BRA 0x86E2
184:           					C.day = false;
18650  0E00     MOVLW 0x0
18654  FFA0     NOP
18656  F81D     NOP
185:           					C.day_end = V.ticks;
18658  EE20     LFSR 2, 0x1B1
1865A  F1B1     NOP
1865E  FF78     NOP
18660  F822     NOP
18664  FF78     NOP
18666  F823     NOP
1866A  FF78     NOP
1866C  F824     NOP
18670  FF74     NOP
18672  F825     NOP
186:           					/*
187:           					 * at low battery condition charge with AC at night
188:           					 */
189:           					if ((C.soc < SOC_TOO_LOW)) {
18674  EE21     LFSR 2, 0x7B1
18676  F3B1     NOP
18678  0E01     MOVLW 0x1
1867A  50DB     MOVF 0xFDB, W, ACCESS
1867C  E136     BNZ 0x86EA
1867E  0E28     MOVLW 0x28
18680  5CDE     SUBWF 0xFDE, W, ACCESS
18682  B0D8     BTFSC 0xFD8, 0, ACCESS
18684  D032     BRA 0x86EA
190:           						set_ac_charger_relay(true);
18686  0E01     MOVLW 0x1
18688  6EE6     MOVWF 0xFE6, ACCESS
1868A  EC83     CALL 0x1BD06, 0
1868C  F0DE     NOP
1868E  D02D     BRA 0x86EA
191:           					}
192:           					return true;
193:           				}
194:           			}
195:           		} else {
196:           			if (C.p_pv < C.p_inverter) { // see if PV can raise SOC
18690  EE21     LFSR 2, 0x777
18692  F377     NOP
18696  FF7B     NOP
18698  FFE6     NOP
1869C  FF7B     NOP
1869E  FFE6     NOP
186A2  FF7B     NOP
186A4  FFE6     NOP
186A8  FF7B     NOP
186AA  FFE6     NOP
186AC  EE21     LFSR 2, 0x77B
186AE  F37B     NOP
186B2  FF7B     NOP
186B4  FFE6     NOP
186B8  FF7B     NOP
186BA  FFE6     NOP
186BE  FF7B     NOP
186C0  FFE6     NOP
186C4  FF7B     NOP
186C6  FFE6     NOP
186C8  EC81     CALL 0x18D02, 0
186CA  F0C6     NOP
186CC  B001     BTFSC ltemp0, 0, ACCESS
186CE  D009     BRA 0x86E2
197:           				if (!get_ac_charger_relay()) { // USE AC charger
186D0  ECA0     CALL 0x1BD40, 0
186D2  F0DE     NOP
186D4  5001     MOVF ltemp0, W, ACCESS
186D6  A4D8     BTFSS 0xFD8, 2, ACCESS
186D8  D004     BRA 0x86E2
198:           					set_ac_charger_relay(true);
186DA  0E01     MOVLW 0x1
186DC  6EE6     MOVWF 0xFE6, ACCESS
186DE  EC83     CALL 0x1BD06, 0
186E0  F0DE     NOP
199:           				}
200:           			}
201:           		}
202:           	}
203:           	if (day_delay >= DAY_DELAY)
186E2  0EEF     MOVLW 0xEF
186E4  6442     CPFSGT day_delay, ACCESS
186E6  D001     BRA 0x86EA
204:           		day_delay = 0;
186E8  6A42     CLRF day_delay, ACCESS
205:           	return false;
206:           }
186EA  52E5     MOVF 0xFE5, F, ACCESS
186EC  52E5     MOVF 0xFE5, F, ACCESS
186EE  52E5     MOVF 0xFE5, F, ACCESS
186F0  52E5     MOVF 0xFE5, F, ACCESS
186F2  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/main.c  --------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries.
23:            
24:                Subject to your compliance with these terms, you may use Microchip software and any
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party
26:                license terms applicable to your use of third party software (including open source software) that
27:                may accompany Microchip software.
28:            
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS
32:                FOR A PARTICULAR PURPOSE.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
41:                SOFTWARE.
42:             */
43:            
44:            /*
45:             *
46:             * This program controls and monitors solar power battery arrays on a 12vdc system
47:             * MBMC uses a simple expert machine to try and keep current the energy stored in a bank of batteries
48:             * The main physics functions are contained in the noload_soc, update_cef, ChargeBatt and pick_batt functions
49:             * Much more work is needed to make the program flow logical but making it work first is the current effort
50:             * The network interface processor on a pic32 will be able to analyze the collected data for better control at some future point
51:             *
52:             * standard program display units:
53:             * Voltage  in millivolts,
54:             * Current in milliamps
55:             * Watts Power in milliwatts
56:             * Ah battery capacity milliAh
57:             *
58:             * R: structure, real values from measurements
59:             * C: structure, calculated values from measurements or programs
60:             * B: structure, battery parameters
61:             *
62:             * USART2 		Is the client comm port 38400
63:             * USART1		MBMC logger channel
64:             * timer 2 100 us PWM clock, no interrupt
65:             * timer 3 one second housekeeping clock for battery state tracking, low priority interrupt
66:             * timer 5 one second timer, interrupt
67:             * timer 6 500 us software timer ticker, interrupt
68:             *
69:             * dma1 spi transmit
70:             * dma2 tx1 transmit
71:             *
72:             * 10 analog channels are active
73:             * PORTA,PORTB		analog inputs
74:             * ana0	battery current					200A hall sensor battery output to inverter 5v R1
75:             * ana1	PV input current				100A hall sensor input from PV array 5v R2
76:             * ana2	charge controller output voltage		R3
77:             * ana3  PLUS VREF					Using a external 4.095 volt reference IC from TI/BB
78:             * ana4	battery voltage					Voltage a primary inverter battery R4
79:             * ana5	pv voltage					R5
80:             * ana6 controller buss voltage				R6
81:             * anb2 backup battery voltage				R7
82:             * anb3 thermo_batt					thermistor input 10K at 25C 5v R8
83:             * anb4 inverter voltage				R9
84:             * anb5 spare						R10
85:             *
86:             * switch MAX debounce inputs INP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
87:             * max pin	pic pin		connector pin	name	MBMC_IO board input connector pin
88:             * 1		rf0		spi 9			10
89:             * 2		rf1		spi 10			1
90:             * 3		rf2		PD 9		SELECT	2
91:             * 4		rf3		PD 8		ENTER	3
92:             * 5		rd3		PD 3			4
93:             * 6		rd2		PD 2/misc 2	SW0	5
94:             * 7				misc 3			6
95:             * 8				misc 4			7
96:             *
97:             * adc_cal[0-3]						current sensors zero offset stored in eeprom 0=a100, 1=a200, 2..3=future
98:             * 3x16 LCD status panel and led status lights.
99:             *
100:            * uln2802 port output pins OUTP
101:            * i/o  port	function
102:            * 0	RD4	load relay 1
103:            * 1	RD5	load relay 2
104:            * 2	RD6	PV/AC Charger DC charge-controller source relay
105:            * 4	RF4	spare
106:            * 
107:            * system variables float
108:            *
109:            * current_in
110:            * current_battery
111:            * current_load
112:            *
113:            * voltage_pv
114:            * voltage_cc
115:            * voltage_battery
116:            * voltage_load
117:            * voltage_buss
118:            * voltage_thermo
119:            * voltage_backup
120:            */
121:           
122:           #pragma warning disable 520
123:           #pragma warning disable 1498
124:           
125:           #ifndef __DEFINED_int24_t
126:           typedef signed long long int24_t;
127:           #define __DEFINED_int24_t
128:           #endif
129:           
130:           #include <stdio.h>
131:           #include <string.h>
132:           #include "mcc_generated_files/mcc.h"
133:           #include "mcc_generated_files/uart1.h"
134:           #include "eadog.h"
135:           #include "timers.h"
136:           #include "mconfig.h"
137:           #include "mydisplay.h"
138:           #include "daq.h"
139:           #include "mbmc.h"
140:           #include "dio.h"
141:           #include "hid.h"
142:           #include "bsoc.h"
143:           
144:           V_data V = {
145:           	.ticker = 45,
146:           	.checksum_error = 0,
147:           	.all_errors = 0,
148:           	.debug = false,
149:           	.stack = false, // 0 no messages, 1-10 messages in queue
150:           	.help_id = 0,
151:           	.sequences = 0,
152:           	.set_sequ = false,
153:           	.highint_count = 0,
154:           	.lowint_count = 0,
155:           	.timerint_count = 0,
156:           	.calib = CALIB,
157:           	.screen = 0,
158:           	.system_stable = false,
159:           };
160:           H_data H = {
161:           	.hid_display = HID_MAIN,
162:           	.h_state = H_STATE_INIT,
163:           	.wait_enter = true,
164:           	.wait_select = true,
165:           	.sequence = 0,
166:           };
167:           
168:           /*
169:            * FIXME STUFF
170:            */
171:           
172:           volatile uint16_t tickCount[TMR_COUNT] = {0};
173:           volatile uint8_t mode_sw = false;
174:           volatile C_data C = {
175:           	.bank_ah = BANKAH - DEGRADE,
176:           	.day = true,
177:           	.hist[0].version = HVER,
178:           };
179:           
180:           extern volatile struct P_data P;
181:           
182:           /*
183:            * Main application
184:            */
185:           void main(void)
11244  0E11     MOVLW 0x11
11246  26E1     ADDWF 0xFE1, F, ACCESS
11248  0E00     MOVLW 0x0
1124A  22E2     ADDWFC 0xFE2, F, ACCESS
186:           {
187:           	UI_STATES mode; /* link configuration host/equipment/etc ... */
188:           	uint8_t inp_index = 0, i = C_BATT, j = C_PV, k = V_CC, i_ror;
1124C  0EFD     MOVLW 0xFD
1124E  6AE3     CLRF 0xFE3, ACCESS
11250  0EFC     MOVLW 0xFC
11252  6AE3     CLRF 0xFE3, ACCESS
11254  0EFB     MOVLW 0xFB
11256  6AE3     CLRF 0xFE3, ACCESS
11258  2AE3     INCF 0xFE3, F, ACCESS
1125A  0EFA     MOVLW 0xFA
1125C  6AE3     CLRF 0xFE3, ACCESS
1125E  82E3     BSF 0xFE3, 1, ACCESS
189:           
190:           	// Initialize the device
191:           	SYSTEM_Initialize();
11260  EC2C     CALL 0x1B058, 0
11262  F0D8     NOP
192:           
193:           	// Enable high priority global interrupts
194:           	INTERRUPT_GlobalInterruptHighEnable();
11264  8ED2     BSF 0xFD2, 7, ACCESS
195:           
196:           	// Enable low priority global interrupts.
197:           	INTERRUPT_GlobalInterruptLowEnable();
11266  8CD2     BSF 0xFD2, 6, ACCESS
198:           
199:           	V.ui_state = UI_STATE_INIT;
11268  0101     MOVLB 0x1
1126A  6B30     CLRF 0x30, BANKED
200:           
201:           	/*
202:           	 * RS-232 link I/O relay defaults to monitor/log mode with no power
203:           	 */
204:           	WaitMs(300); // wait for mode switch to settle
1126C  0E2C     MOVLW 0x2C
1126E  6EE6     MOVWF 0xFE6, ACCESS
11270  0E01     MOVLW 0x1
11272  6EE6     MOVWF 0xFE6, ACCESS
11274  EC7E     CALL 0x1B4FC, 0
11276  F0DA     NOP
205:           	if (RB0_GetValue()) {
11278  A0CB     BTFSS 0xFCB, 0, ACCESS
1127A  D004     BRA 0x1284
206:           		mode = UI_STATE_HOST;
1127C  0EFE     MOVLW 0xFE
1127E  6AE3     CLRF 0xFE3, ACCESS
11280  2AE3     INCF 0xFE3, F, ACCESS
207:           	} else {
11282  D004     BRA 0x128C
208:           		mode = UI_STATE_LOG;
11284  0EFE     MOVLW 0xFE
11286  6AE3     CLRF 0xFE3, ACCESS
11288  80E3     BSF 0xFE3, 0, ACCESS
1128A  82E3     BSF 0xFE3, 1, ACCESS
209:           	}
210:           
211:           	if (mode == UI_STATE_HOST) {
1128C  0EFE     MOVLW 0xFE
1128E  04E3     DECF 0xFE3, W, ACCESS
11290  A4D8     BTFSS 0xFD8, 2, ACCESS
11292  D007     BRA 0x12A2
212:           		RELAY0_SetHigh();
11294  80BD     BSF 0xFBD, 0, ACCESS
213:           		V.mode_pwm = 70; // mode switch indicator lamp normal level
11296  0E00     MOVLW 0x0
11298  0101     MOVLB 0x1
1129A  6FC6     MOVWF CountCallBack, BANKED
1129C  0E46     MOVLW 0x46
1129E  6FC5     MOVWF 0xC5, BANKED
214:           	} else {
112A0  D004     BRA 0x12AA
215:           		RELAY0_SetLow();
112A2  90BD     BCF 0xFBD, 0, ACCESS
216:           		V.mode_pwm = 0;
112A4  0101     MOVLB 0x1
112A6  6BC5     CLRF 0xC5, BANKED
112A8  6BC6     CLRF CountCallBack, BANKED
217:           	}
218:           	mode_lamp_dim(V.mode_pwm); // 10KHz PWM
112AC  F717     NOP
112AE  FFE6     NOP
112B2  F71B     NOP
112B4  FFE6     NOP
112B6  EC1F     CALL 0x1BC3E, 0
112B8  F0DE     NOP
112BA  D32C     BRA 0x1914
219:           
220:           	while (true) {
221:           		switch (V.ui_state) {
222:           		case UI_STATE_INIT:
223:           			/*
224:           			 * DMA serial uart1 I/O testing
225:           			 */
226:           			init_port_dma();
112BC  ECE8     CALL 0x1B5D0, 0
112BE  F0DA     NOP
227:           
228:           			init_display();
112C0  EC9C     CALL 0x19D38, 0
112C2  F0CE     NOP
229:           			eaDogM_CursorOff();
112C4  0E0C     MOVLW 0xC
112C6  6EE6     MOVWF 0xFE6, ACCESS
112C8  EC92     CALL 0x1BD24, 0
112CA  F0DE     NOP
230:           			/*
231:           			 * load the battery to reduce surface charge
232:           			 */
233:           			set_load_relay_one(true);
112CC  0E01     MOVLW 0x1
112CE  6EE6     MOVWF 0xFE6, ACCESS
112D0  EC73     CALL 0x1BCE6, 0
112D2  F0DE     NOP
234:           			set_load_relay_two(true);
112D4  0E01     MOVLW 0x1
112D6  6EE6     MOVWF 0xFE6, ACCESS
112D8  EC6B     CALL 0x1BCD6, 0
112DA  F0DE     NOP
235:           
236:           			V.ui_state = mode;
112DC  0EFE     MOVLW 0xFE
112E0  FF8C     NOP
112E2  F130     NOP
237:           			srand(1957);
112E4  0EA5     MOVLW 0xA5
112E6  6EE6     MOVWF 0xFE6, ACCESS
112E8  0E07     MOVLW 0x7
112EA  6EE6     MOVWF 0xFE6, ACCESS
112EC  ECB4     CALL 0x1B568, 0
112EE  F0DA     NOP
238:           			set_vterm(0); // set to buffer 0
112F0  0E00     MOVLW 0x0
112F2  6EE6     MOVWF 0xFE6, ACCESS
112F4  ECC9     CALL 0x1BB92, 0
112F6  F0DD     NOP
239:           			sprintf(get_vterm_ptr(0, 0), " MBMC SOLARMON  ");
112F8  0E50     MOVLW 0x50
112FA  6EE6     MOVWF 0xFE6, ACCESS
112FC  0EFF     MOVLW 0xFF
112FE  6EE6     MOVWF 0xFE6, ACCESS
11300  0E00     MOVLW 0x0
11302  6EE6     MOVWF 0xFE6, ACCESS
11304  0E00     MOVLW 0x0
11306  6EE6     MOVWF 0xFE6, ACCESS
11308  EC48     CALL 0x1B690, 0
1130A  F0DB     NOP
1130E  F007     NOP
11310  FFE6     NOP
11314  F00B     NOP
11316  FFE6     NOP
11318  0E04     MOVLW 0x4
1131A  6EE6     MOVWF 0xFE6, ACCESS
1131C  EC1E     CALL 0x19A3C, 0
1131E  F0CD     NOP
240:           			sprintf(get_vterm_ptr(1, 0), " Version %s   ", VER);
11320  0ED0     MOVLW 0xD0
11322  6EE6     MOVWF 0xFE6, ACCESS
11324  0EFF     MOVLW 0xFF
11326  6EE6     MOVWF 0xFE6, ACCESS
11328  0EA2     MOVLW 0xA2
1132A  6EE6     MOVWF 0xFE6, ACCESS
1132C  0EFF     MOVLW 0xFF
1132E  6EE6     MOVWF 0xFE6, ACCESS
11330  0E00     MOVLW 0x0
11332  6EE6     MOVWF 0xFE6, ACCESS
11334  0E01     MOVLW 0x1
11336  6EE6     MOVWF 0xFE6, ACCESS
11338  EC48     CALL 0x1B690, 0
1133A  F0DB     NOP
1133E  F007     NOP
11340  FFE6     NOP
11344  F00B     NOP
11346  FFE6     NOP
11348  0E06     MOVLW 0x6
1134A  6EE6     MOVWF 0xFE6, ACCESS
1134C  EC1E     CALL 0x19A3C, 0
1134E  F0CD     NOP
241:           			sprintf(get_vterm_ptr(2, 0), " NSASPOOK       ");
11350  0E1D     MOVLW 0x1D
11352  6EE6     MOVWF 0xFE6, ACCESS
11354  0EFF     MOVLW 0xFF
11356  6EE6     MOVWF 0xFE6, ACCESS
11358  0E00     MOVLW 0x0
1135A  6EE6     MOVWF 0xFE6, ACCESS
1135C  0E02     MOVLW 0x2
1135E  6EE6     MOVWF 0xFE6, ACCESS
11360  EC48     CALL 0x1B690, 0
11362  F0DB     NOP
11366  F007     NOP
11368  FFE6     NOP
1136C  F00B     NOP
1136E  FFE6     NOP
11370  0E04     MOVLW 0x4
11372  6EE6     MOVWF 0xFE6, ACCESS
11374  EC1E     CALL 0x19A3C, 0
11376  F0CD     NOP
242:           			sprintf(get_vterm_ptr(0, 2), "                ");
11378  0E16     MOVLW 0x16
1137A  6EE6     MOVWF 0xFE6, ACCESS
1137C  0EFE     MOVLW 0xFE
1137E  6EE6     MOVWF 0xFE6, ACCESS
11380  0E02     MOVLW 0x2
11382  6EE6     MOVWF 0xFE6, ACCESS
11384  0E00     MOVLW 0x0
11386  6EE6     MOVWF 0xFE6, ACCESS
11388  EC48     CALL 0x1B690, 0
1138A  F0DB     NOP
1138E  F007     NOP
11390  FFE6     NOP
11394  F00B     NOP
11396  FFE6     NOP
11398  0E04     MOVLW 0x4
1139A  6EE6     MOVWF 0xFE6, ACCESS
1139C  EC1E     CALL 0x19A3C, 0
1139E  F0CD     NOP
243:           			sprintf(get_vterm_ptr(1, 2), "                ");
113A0  0E16     MOVLW 0x16
113A2  6EE6     MOVWF 0xFE6, ACCESS
113A4  0EFE     MOVLW 0xFE
113A6  6EE6     MOVWF 0xFE6, ACCESS
113A8  0E02     MOVLW 0x2
113AA  6EE6     MOVWF 0xFE6, ACCESS
113AC  0E01     MOVLW 0x1
113AE  6EE6     MOVWF 0xFE6, ACCESS
113B0  EC48     CALL 0x1B690, 0
113B2  F0DB     NOP
113B6  F007     NOP
113B8  FFE6     NOP
113BC  F00B     NOP
113BE  FFE6     NOP
113C0  0E04     MOVLW 0x4
113C2  6EE6     MOVWF 0xFE6, ACCESS
113C4  EC1E     CALL 0x19A3C, 0
113C6  F0CD     NOP
244:           			sprintf(get_vterm_ptr(2, 2), "                ");
113C8  0E16     MOVLW 0x16
113CA  6EE6     MOVWF 0xFE6, ACCESS
113CC  0EFE     MOVLW 0xFE
113CE  6EE6     MOVWF 0xFE6, ACCESS
113D0  0E02     MOVLW 0x2
113D2  6EE6     MOVWF 0xFE6, ACCESS
113D4  0E02     MOVLW 0x2
113D6  6EE6     MOVWF 0xFE6, ACCESS
113D8  EC48     CALL 0x1B690, 0
113DA  F0DB     NOP
113DE  F007     NOP
113E0  FFE6     NOP
113E4  F00B     NOP
113E6  FFE6     NOP
113E8  0E04     MOVLW 0x4
113EA  6EE6     MOVWF 0xFE6, ACCESS
113EC  EC1E     CALL 0x19A3C, 0
113EE  F0CD     NOP
245:           			update_lcd(0);
113F0  0E00     MOVLW 0x0
113F2  6EE6     MOVWF 0xFE6, ACCESS
113F4  EC96     CALL 0x1992C, 0
113F6  F0CC     NOP
246:           			WaitMs(1000);
113F8  0EE8     MOVLW 0xE8
113FA  6EE6     MOVWF 0xFE6, ACCESS
113FC  0E03     MOVLW 0x3
113FE  6EE6     MOVWF 0xFE6, ACCESS
11400  EC7E     CALL 0x1B4FC, 0
11402  F0DA     NOP
247:           			StartTimer(TMR_DISPLAY, DDELAY);
11404  0EFA     MOVLW 0xFA
11406  6EE6     MOVWF 0xFE6, ACCESS
11408  0E00     MOVLW 0x0
1140A  6EE6     MOVWF 0xFE6, ACCESS
1140C  0E0A     MOVLW 0xA
1140E  6EE6     MOVWF 0xFE6, ACCESS
11410  EC6A     CALL 0x1B2D4, 0
11412  F0D9     NOP
248:           			StartTimer(TMR_ADC, ADC_SCAN_SPEED);
11414  0EC8     MOVLW 0xC8
11416  6EE6     MOVWF 0xFE6, ACCESS
11418  0E00     MOVLW 0x0
1141A  6EE6     MOVWF 0xFE6, ACCESS
1141C  0E01     MOVLW 0x1
1141E  6EE6     MOVWF 0xFE6, ACCESS
11420  EC6A     CALL 0x1B2D4, 0
11422  F0D9     NOP
249:           			StartTimer(TMR_INFO, TDELAY);
11424  0EB8     MOVLW 0xB8
11426  6EE6     MOVWF 0xFE6, ACCESS
11428  0E0B     MOVLW 0xB
1142A  6EE6     MOVWF 0xFE6, ACCESS
1142C  0E07     MOVLW 0x7
1142E  6EE6     MOVWF 0xFE6, ACCESS
11430  EC6A     CALL 0x1B2D4, 0
11432  F0D9     NOP
250:           			StartTimer(TMR_FLIPPER, DFLIP);
11434  0EDC     MOVLW 0xDC
11436  6EE6     MOVWF 0xFE6, ACCESS
11438  0E05     MOVLW 0x5
1143A  6EE6     MOVWF 0xFE6, ACCESS
1143C  0E0B     MOVLW 0xB
1143E  6EE6     MOVWF 0xFE6, ACCESS
11440  EC6A     CALL 0x1B2D4, 0
11442  F0D9     NOP
251:           			StartTimer(TMR_HELPDIS, TDELAY);
11444  0EB8     MOVLW 0xB8
11446  6EE6     MOVWF 0xFE6, ACCESS
11448  0E0B     MOVLW 0xB
1144A  6EE6     MOVWF 0xFE6, ACCESS
1144C  0E09     MOVLW 0x9
1144E  6EE6     MOVWF 0xFE6, ACCESS
11450  EC6A     CALL 0x1B2D4, 0
11452  F0D9     NOP
252:           
253:           			start_adc_scan();
11454  EC6C     CALL 0x1ACD8, 0
11456  F0D6     NOP
254:           			start_switch_handler();
11458  EC9A     CALL 0x1BB34, 0
1145A  F0DD     NOP
255:           			WaitMs(1000);
1145C  0EE8     MOVLW 0xE8
1145E  6EE6     MOVWF 0xFE6, ACCESS
11460  0E03     MOVLW 0x3
11462  6EE6     MOVWF 0xFE6, ACCESS
11464  EC7E     CALL 0x1B4FC, 0
11466  F0DA     NOP
256:           			/*
257:           			 * check for quickly changing battery voltage
258:           			 * to stabilize as to get a better static SOC value
259:           			 */
260:           			i_ror = 1;
11468  0EFF     MOVLW 0xFF
1146A  6AE3     CLRF 0xFE3, ACCESS
1146C  2AE3     INCF 0xFE3, F, ACCESS
261:           			do {
262:           				calc_ror_data();
1146E  EC45     CALL 0x1888A, 0
11470  F0C4     NOP
263:           				sprintf(get_vterm_ptr(1, 0), "BV %2.4f         ", conv_raw_result(V_BAT, CONV));
11472  0E00     MOVLW 0x0
11474  6EE6     MOVWF 0xFE6, ACCESS
11476  0E04     MOVLW 0x4
11478  6EE6     MOVWF 0xFE6, ACCESS
1147A  EC0E     CALL 0x1501C, 0
1147C  F0A8     NOP
11480  F007     NOP
11482  FFE6     NOP
11486  F00B     NOP
11488  FFE6     NOP
1148C  F00F     NOP
1148E  FFE6     NOP
11492  F013     NOP
11494  FFE6     NOP
11496  0E0B     MOVLW 0xB
11498  6EE6     MOVWF 0xFE6, ACCESS
1149A  0EFF     MOVLW 0xFF
1149C  6EE6     MOVWF 0xFE6, ACCESS
1149E  0E00     MOVLW 0x0
114A0  6EE6     MOVWF 0xFE6, ACCESS
114A2  0E01     MOVLW 0x1
114A4  6EE6     MOVWF 0xFE6, ACCESS
114A6  EC48     CALL 0x1B690, 0
114A8  F0DB     NOP
114AC  F007     NOP
114AE  FFE6     NOP
114B2  F00B     NOP
114B4  FFE6     NOP
114B6  0E08     MOVLW 0x8
114B8  6EE6     MOVWF 0xFE6, ACCESS
114BA  EC1E     CALL 0x19A3C, 0
114BC  F0CD     NOP
264:           				sprintf(get_vterm_ptr(2, 0), "S S%cC %d %2.4f       ", spinners(5, false), i_ror, C.bv_ror);
114BE  EE21     LFSR 2, 0x76B
114C0  F36B     NOP
114C4  FF7B     NOP
114C6  FFE6     NOP
114CA  FF7B     NOP
114CC  FFE6     NOP
114D0  FF7B     NOP
114D2  FFE6     NOP
114D6  FF7B     NOP
114D8  FFE6     NOP
114DA  0EFB     MOVLW 0xFB
114DC  50E3     MOVF 0xFE3, W, ACCESS
114DE  6EE6     MOVWF 0xFE6, ACCESS
114E0  0E00     MOVLW 0x0
114E2  6EE6     MOVWF 0xFE6, ACCESS
114E4  0E00     MOVLW 0x0
114E6  6EE6     MOVWF 0xFE6, ACCESS
114E8  0E05     MOVLW 0x5
114EA  6EE6     MOVWF 0xFE6, ACCESS
114EC  EC11     CALL 0x19E22, 0
114EE  F0CF     NOP
114F0  5001     MOVF ltemp0, W, ACCESS
114F2  6EE6     MOVWF 0xFE6, ACCESS
114F4  0E00     MOVLW 0x0
114F6  6EE6     MOVWF 0xFE6, ACCESS
114F8  0E06     MOVLW 0x6
114FA  6EE6     MOVWF 0xFE6, ACCESS
114FC  0EFD     MOVLW 0xFD
114FE  6EE6     MOVWF 0xFE6, ACCESS
11500  0E00     MOVLW 0x0
11502  6EE6     MOVWF 0xFE6, ACCESS
11504  0E02     MOVLW 0x2
11506  6EE6     MOVWF 0xFE6, ACCESS
11508  EC48     CALL 0x1B690, 0
1150A  F0DB     NOP
1150E  F007     NOP
11510  FFE6     NOP
11514  F00B     NOP
11516  FFE6     NOP
11518  0E0C     MOVLW 0xC
1151A  6EE6     MOVWF 0xFE6, ACCESS
1151C  EC1E     CALL 0x19A3C, 0
1151E  F0CD     NOP
265:           				update_lcd(0);
11520  0E00     MOVLW 0x0
11522  6EE6     MOVWF 0xFE6, ACCESS
11524  EC96     CALL 0x1992C, 0
11526  F0CC     NOP
266:           				WaitMs(ROR_WAIT); // time between samples
11528  0ED0     MOVLW 0xD0
1152A  6EE6     MOVWF 0xFE6, ACCESS
1152C  0E07     MOVLW 0x7
1152E  6EE6     MOVWF 0xFE6, ACCESS
11530  EC7E     CALL 0x1B4FC, 0
11532  F0DA     NOP
267:           				clear_adc_scan();
11534  ECE7     CALL 0x1BDCE, 0
11536  F0DE     NOP
268:           				start_adc_scan();
11538  EC6C     CALL 0x1ACD8, 0
1153A  F0D6     NOP
269:           				WaitMs(500); // wait for updated ADC data
1153C  0EF4     MOVLW 0xF4
1153E  6EE6     MOVWF 0xFE6, ACCESS
11540  0E01     MOVLW 0x1
11542  6EE6     MOVWF 0xFE6, ACCESS
11544  EC7E     CALL 0x1B4FC, 0
11546  F0DA     NOP
270:           			} while ((i_ror++ < ROR_TIMES) && (C.bv_ror > ROR_LIMIT_LOW));
11548  0EFF     MOVLW 0xFF
1154C  FF8C     NOP
1154E  F00C     NOP
11550  2A0C     INCF 0xC, F, ACCESS
11554  F033     NOP
11556  FFE3     NOP
11558  060C     DECF 0xC, F, ACCESS
1155A  0E1E     MOVLW 0x1E
1155C  600C     CPFSLT 0xC, ACCESS
1155E  D01A     BRA 0x1594
11560  EE21     LFSR 2, 0x76B
11562  F36B     NOP
11566  FF7B     NOP
11568  FFE6     NOP
1156C  FF7B     NOP
1156E  FFE6     NOP
11572  FF7B     NOP
11574  FFE6     NOP
11578  FF7B     NOP
1157A  FFE6     NOP
1157C  0E42     MOVLW 0x42
1157E  6EE6     MOVWF 0xFE6, ACCESS
11580  0E60     MOVLW 0x60
11582  6EE6     MOVWF 0xFE6, ACCESS
11584  0E65     MOVLW 0x65
11586  6EE6     MOVWF 0xFE6, ACCESS
11588  0E3C     MOVLW 0x3C
1158A  6EE6     MOVWF 0xFE6, ACCESS
1158C  EC81     CALL 0x18D02, 0
1158E  F0C6     NOP
11590  A001     BTFSS ltemp0, 0, ACCESS
11592  D76D     BRA 0x146E
271:           
272:           			static_soc(); // defaults
11594  ECEA     CALL 0x1B3D4, 0
11596  F0D9     NOP
273:           			init_bsoc(); // system calculations
11598  EC9C     CALL 0x17B38, 0
1159A  F0BD     NOP
274:           			set_load_relay_one(false);
1159C  0E00     MOVLW 0x0
1159E  6EE6     MOVWF 0xFE6, ACCESS
115A0  EC73     CALL 0x1BCE6, 0
115A2  F0DE     NOP
275:           			set_load_relay_two(false);
115A4  0E00     MOVLW 0x0
115A6  6EE6     MOVWF 0xFE6, ACCESS
115A8  EC6B     CALL 0x1BCD6, 0
115AA  F0DE     NOP
276:           			sprintf(get_vterm_ptr(0, 0), "Static SOC %d        ", C.soc);
115AC  EE21     LFSR 2, 0x7B1
115AE  F3B1     NOP
115B2  FF78     NOP
115B4  F00B     NOP
115B8  FF74     NOP
115BA  F00C     NOP
115BE  F02F     NOP
115C0  FFE6     NOP
115C4  F033     NOP
115C6  FFE6     NOP
115C8  0E33     MOVLW 0x33
115CA  6EE6     MOVWF 0xFE6, ACCESS
115CC  0EFD     MOVLW 0xFD
115CE  6EE6     MOVWF 0xFE6, ACCESS
115D0  0E00     MOVLW 0x0
115D2  6EE6     MOVWF 0xFE6, ACCESS
115D4  0E00     MOVLW 0x0
115D6  6EE6     MOVWF 0xFE6, ACCESS
115D8  EC48     CALL 0x1B690, 0
115DA  F0DB     NOP
115DE  F007     NOP
115E0  FFE6     NOP
115E4  F00B     NOP
115E6  FFE6     NOP
115E8  0E06     MOVLW 0x6
115EA  6EE6     MOVWF 0xFE6, ACCESS
115EC  EC1E     CALL 0x19A3C, 0
115EE  F0CD     NOP
277:           			sprintf(get_vterm_ptr(1, 0), "Battery Ah %3.2f     ", C.dynamic_ah);
115F0  EE21     LFSR 2, 0x78F
115F2  F38F     NOP
115F6  FF7B     NOP
115F8  FFE6     NOP
115FC  FF7B     NOP
115FE  FFE6     NOP
11602  FF7B     NOP
11604  FFE6     NOP
11608  FF7B     NOP
1160A  FFE6     NOP
1160C  0E49     MOVLW 0x49
1160E  6EE6     MOVWF 0xFE6, ACCESS
11610  0EFD     MOVLW 0xFD
11612  6EE6     MOVWF 0xFE6, ACCESS
11614  0E00     MOVLW 0x0
11616  6EE6     MOVWF 0xFE6, ACCESS
11618  0E01     MOVLW 0x1
1161A  6EE6     MOVWF 0xFE6, ACCESS
1161C  EC48     CALL 0x1B690, 0
1161E  F0DB     NOP
11622  F007     NOP
11624  FFE6     NOP
11628  F00B     NOP
1162A  FFE6     NOP
1162C  0E08     MOVLW 0x8
1162E  6EE6     MOVWF 0xFE6, ACCESS
11630  EC1E     CALL 0x19A3C, 0
11632  F0CD     NOP
278:           			update_lcd(0);
11634  0E00     MOVLW 0x0
11636  6EE6     MOVWF 0xFE6, ACCESS
11638  EC96     CALL 0x1992C, 0
1163A  F0CC     NOP
279:           			WaitMs(2000);
1163C  0ED0     MOVLW 0xD0
1163E  6EE6     MOVWF 0xFE6, ACCESS
11640  0E07     MOVLW 0x7
11642  6EE6     MOVWF 0xFE6, ACCESS
11644  EC7E     CALL 0x1B4FC, 0
11646  F0DA     NOP
280:           			sprintf(get_vterm_ptr(0, 0), "Battery ESR     ");
11648  0E2E     MOVLW 0x2E
1164A  6EE6     MOVWF 0xFE6, ACCESS
1164C  0EFF     MOVLW 0xFF
1164E  6EE6     MOVWF 0xFE6, ACCESS
11650  0E00     MOVLW 0x0
11652  6EE6     MOVWF 0xFE6, ACCESS
11654  0E00     MOVLW 0x0
11656  6EE6     MOVWF 0xFE6, ACCESS
11658  EC48     CALL 0x1B690, 0
1165A  F0DB     NOP
1165E  F007     NOP
11660  FFE6     NOP
11664  F00B     NOP
11666  FFE6     NOP
11668  0E04     MOVLW 0x4
1166A  6EE6     MOVWF 0xFE6, ACCESS
1166C  EC1E     CALL 0x19A3C, 0
1166E  F0CD     NOP
281:           			sprintf(get_vterm_ptr(1, 0), "Calculation     ");
11670  0E3F     MOVLW 0x3F
11672  6EE6     MOVWF 0xFE6, ACCESS
11674  0EFF     MOVLW 0xFF
11676  6EE6     MOVWF 0xFE6, ACCESS
11678  0E00     MOVLW 0x0
1167A  6EE6     MOVWF 0xFE6, ACCESS
1167C  0E01     MOVLW 0x1
1167E  6EE6     MOVWF 0xFE6, ACCESS
11680  EC48     CALL 0x1B690, 0
11682  F0DB     NOP
11686  F007     NOP
11688  FFE6     NOP
1168C  F00B     NOP
1168E  FFE6     NOP
11690  0E04     MOVLW 0x4
11692  6EE6     MOVWF 0xFE6, ACCESS
11694  EC1E     CALL 0x19A3C, 0
11696  F0CD     NOP
282:           			sprintf(get_vterm_ptr(2, 0), "Check 30 seconds");
11698  0E72     MOVLW 0x72
1169A  6EE6     MOVWF 0xFE6, ACCESS
1169C  0EFF     MOVLW 0xFF
1169E  6EE6     MOVWF 0xFE6, ACCESS
116A0  0E00     MOVLW 0x0
116A2  6EE6     MOVWF 0xFE6, ACCESS
116A4  0E02     MOVLW 0x2
116A6  6EE6     MOVWF 0xFE6, ACCESS
116A8  EC48     CALL 0x1B690, 0
116AA  F0DB     NOP
116AE  F007     NOP
116B0  FFE6     NOP
116B4  F00B     NOP
116B6  FFE6     NOP
116B8  0E04     MOVLW 0x4
116BA  6EE6     MOVWF 0xFE6, ACCESS
116BC  EC1E     CALL 0x19A3C, 0
116BE  F0CD     NOP
283:           			update_lcd(0);
116C0  0E00     MOVLW 0x0
116C2  6EE6     MOVWF 0xFE6, ACCESS
116C4  EC96     CALL 0x1992C, 0
116C6  F0CC     NOP
284:           			uint16_t i_esr = 1;
116C8  0E01     MOVLW 0x1
116CA  6E0B     MOVWF wtemp5, ACCESS
116CC  0E00     MOVLW 0x0
116CE  6E0C     MOVWF 0xC, ACCESS
116D0  0EF7     MOVLW 0xF7
116D4  F02F     NOP
116D6  FFE3     NOP
116D8  0EF8     MOVLW 0xF8
116DC  F033     NOP
116DE  FFE3     NOP
285:           			uint8_t shape = 0;
286:           			float esr_temp;
287:           			while ((esr_temp = esr_check(false)) < 0.0) {
116E0  D06D     BRA 0x17BC
117BC  0E00     MOVLW 0x0
117BE  6EE6     MOVWF 0xFE6, ACCESS
117C0  EC3B     CALL 0x16E76, 0
117C2  F0B7     NOP
117C4  0EF3     MOVLW 0xF3
117C8  F007     NOP
117CA  FFE3     NOP
117CC  0EF4     MOVLW 0xF4
117D0  F00B     NOP
117D2  FFE3     NOP
117D4  0EF5     MOVLW 0xF5
117D8  F00F     NOP
117DA  FFE3     NOP
117DC  0EF6     MOVLW 0xF6
117E0  F013     NOP
117E2  FFE3     NOP
117E4  0EF6     MOVLW 0xF6
117E6  BEE3     BTFSC 0xFE3, 7, ACCESS
117E8  D77C     BRA 0x16E2
288:           				WaitMs(110); // limit display updates
116E2  0E6E     MOVLW 0x6E
116E4  6EE6     MOVWF 0xFE6, ACCESS
116E6  0E00     MOVLW 0x0
116E8  6EE6     MOVWF 0xFE6, ACCESS
116EA  EC7E     CALL 0x1B4FC, 0
116EC  F0DA     NOP
289:           				shape = (uint8_t) fabs(esr_temp);
116EE  0EF3     MOVLW 0xF3
116F2  FF8F     NOP
116F4  FFE6     NOP
116F8  FF8F     NOP
116FA  FFE6     NOP
116FE  FF8F     NOP
11700  FFE6     NOP
11704  FF8F     NOP
11706  FFE6     NOP
11708  EC87     CALL 0x1A30E, 0
1170A  F0D1     NOP
1170E  F007     NOP
11710  FFE6     NOP
11714  F00B     NOP
11716  FFE6     NOP
1171A  F00F     NOP
1171C  FFE6     NOP
11720  F013     NOP
11722  FFE6     NOP
11724  ECC8     CALL 0x18B90, 0
11726  F0C5     NOP
1172A  F004     NOP
1172C  F00C     NOP
1172E  0EF9     MOVLW 0xF9
11732  F033     NOP
11734  FFE3     NOP
290:           				sprintf(get_vterm_ptr(2, 0), "Checking %c %c      ", spinners(0, false), spinners(shape, false));
11736  0E00     MOVLW 0x0
11738  6EE6     MOVWF 0xFE6, ACCESS
1173A  0EF8     MOVLW 0xF8
1173C  50E3     MOVF 0xFE3, W, ACCESS
1173E  6EE6     MOVWF 0xFE6, ACCESS
11740  EC11     CALL 0x19E22, 0
11742  F0CF     NOP
11744  5001     MOVF ltemp0, W, ACCESS
11746  6EE6     MOVWF 0xFE6, ACCESS
11748  0E00     MOVLW 0x0
1174A  6EE6     MOVWF 0xFE6, ACCESS
1174C  0E00     MOVLW 0x0
1174E  6EE6     MOVWF 0xFE6, ACCESS
11750  0E00     MOVLW 0x0
11752  6EE6     MOVWF 0xFE6, ACCESS
11754  EC11     CALL 0x19E22, 0
11756  F0CF     NOP
11758  5001     MOVF ltemp0, W, ACCESS
1175A  6EE6     MOVWF 0xFE6, ACCESS
1175C  0E00     MOVLW 0x0
1175E  6EE6     MOVWF 0xFE6, ACCESS
11760  0E5F     MOVLW 0x5F
11762  6EE6     MOVWF 0xFE6, ACCESS
11764  0EFD     MOVLW 0xFD
11766  6EE6     MOVWF 0xFE6, ACCESS
11768  0E00     MOVLW 0x0
1176A  6EE6     MOVWF 0xFE6, ACCESS
1176C  0E02     MOVLW 0x2
1176E  6EE6     MOVWF 0xFE6, ACCESS
11770  EC48     CALL 0x1B690, 0
11772  F0DB     NOP
11776  F007     NOP
11778  FFE6     NOP
1177C  F00B     NOP
1177E  FFE6     NOP
11780  0E08     MOVLW 0x8
11782  6EE6     MOVWF 0xFE6, ACCESS
11784  EC1E     CALL 0x19A3C, 0
11786  F0CD     NOP
291:           				update_lcd(0);
11788  0E00     MOVLW 0x0
1178A  6EE6     MOVWF 0xFE6, ACCESS
1178C  EC96     CALL 0x1992C, 0
1178E  F0CC     NOP
292:           
293:           				if (i_esr++ > 512)
11790  50E1     MOVF 0xFE1, W, ACCESS
11792  0FF7     ADDLW 0xF7
11794  6ED9     MOVWF 0xFD9, ACCESS
11796  50E2     MOVF 0xFE2, W, ACCESS
11798  6EDA     MOVWF 0xFDA, ACCESS
1179A  0EFF     MOVLW 0xFF
1179C  22DA     ADDWFC 0xFDA, F, ACCESS
117A0  FF7C     NOP
117A2  F00B     NOP
117A4  0E01     MOVLW 0x1
117A6  26DE     ADDWF 0xFDE, F, ACCESS
117AA  FF7C     NOP
117AC  F00C     NOP
117AE  0E00     MOVLW 0x0
117B0  22DD     ADDWFC 0xFDD, F, ACCESS
117B2  040B     DECF wtemp5, W, ACCESS
117B4  0E02     MOVLW 0x2
117B6  580C     SUBWFB 0xC, W, ACCESS
117B8  B0D8     BTFSC 0xFD8, 0, ACCESS
117BA  D017     BRA 0x17EA
294:           					break;
295:           			};
296:           			sprintf(get_vterm_ptr(0, 0), "ESR  %2.6f           ", C.esr);
117EA  EE21     LFSR 2, 0x787
117EC  F387     NOP
117F0  FF7B     NOP
117F2  FFE6     NOP
117F6  FF7B     NOP
117F8  FFE6     NOP
117FC  FF7B     NOP
117FE  FFE6     NOP
11802  FF7B     NOP
11804  FFE6     NOP
11806  0E1D     MOVLW 0x1D
11808  6EE6     MOVWF 0xFE6, ACCESS
1180A  0EFD     MOVLW 0xFD
1180C  6EE6     MOVWF 0xFE6, ACCESS
1180E  0E00     MOVLW 0x0
11810  6EE6     MOVWF 0xFE6, ACCESS
11812  0E00     MOVLW 0x0
11814  6EE6     MOVWF 0xFE6, ACCESS
11816  EC48     CALL 0x1B690, 0
11818  F0DB     NOP
1181C  F007     NOP
1181E  FFE6     NOP
11822  F00B     NOP
11824  FFE6     NOP
11826  0E08     MOVLW 0x8
11828  6EE6     MOVWF 0xFE6, ACCESS
1182A  EC1E     CALL 0x19A3C, 0
1182C  F0CD     NOP
297:           			sprintf(get_vterm_ptr(1, 0), "R1 %2.3f %3.4f           ", C.bv_one_load, C.load_i1);
1182E  EE22     LFSR 2, 0x809
11830  F009     NOP
11834  FF7B     NOP
11836  FFE6     NOP
1183A  FF7B     NOP
1183C  FFE6     NOP
11840  FF7B     NOP
11842  FFE6     NOP
11846  FF7B     NOP
11848  FFE6     NOP
1184A  EE22     LFSR 2, 0x815
1184C  F015     NOP
11850  FF7B     NOP
11852  FFE6     NOP
11856  FF7B     NOP
11858  FFE6     NOP
1185C  FF7B     NOP
1185E  FFE6     NOP
11862  FF7B     NOP
11864  FFE6     NOP
11866  0EBA     MOVLW 0xBA
11868  6EE6     MOVWF 0xFE6, ACCESS
1186A  0EFC     MOVLW 0xFC
1186C  6EE6     MOVWF 0xFE6, ACCESS
1186E  0E00     MOVLW 0x0
11870  6EE6     MOVWF 0xFE6, ACCESS
11872  0E01     MOVLW 0x1
11874  6EE6     MOVWF 0xFE6, ACCESS
11876  EC48     CALL 0x1B690, 0
11878  F0DB     NOP
1187C  F007     NOP
1187E  FFE6     NOP
11882  F00B     NOP
11884  FFE6     NOP
11886  0E0C     MOVLW 0xC
11888  6EE6     MOVWF 0xFE6, ACCESS
1188A  EC1E     CALL 0x19A3C, 0
1188C  F0CD     NOP
298:           			sprintf(get_vterm_ptr(2, 0), "R2 %2.3f %3.4f           ", C.bv_full_load, C.load_i2);
1188E  EE22     LFSR 2, 0x80D
11890  F00D     NOP
11894  FF7B     NOP
11896  FFE6     NOP
1189A  FF7B     NOP
1189C  FFE6     NOP
118A0  FF7B     NOP
118A2  FFE6     NOP
118A6  FF7B     NOP
118A8  FFE6     NOP
118AA  EE22     LFSR 2, 0x819
118AC  F019     NOP
118B0  FF7B     NOP
118B2  FFE6     NOP
118B6  FF7B     NOP
118B8  FFE6     NOP
118BC  FF7B     NOP
118BE  FFE6     NOP
118C2  FF7B     NOP
118C4  FFE6     NOP
118C6  0ED4     MOVLW 0xD4
118C8  6EE6     MOVWF 0xFE6, ACCESS
118CA  0EFC     MOVLW 0xFC
118CC  6EE6     MOVWF 0xFE6, ACCESS
118CE  0E00     MOVLW 0x0
118D0  6EE6     MOVWF 0xFE6, ACCESS
118D2  0E02     MOVLW 0x2
118D4  6EE6     MOVWF 0xFE6, ACCESS
118D6  EC48     CALL 0x1B690, 0
118D8  F0DB     NOP
118DC  F007     NOP
118DE  FFE6     NOP
118E2  F00B     NOP
118E4  FFE6     NOP
118E6  0E0C     MOVLW 0xC
118E8  6EE6     MOVWF 0xFE6, ACCESS
118EA  EC1E     CALL 0x19A3C, 0
118EC  F0CD     NOP
299:           			update_lcd(0);
118EE  0E00     MOVLW 0x0
118F0  6EE6     MOVWF 0xFE6, ACCESS
118F2  EC96     CALL 0x1992C, 0
118F4  F0CC     NOP
300:           			WaitMs(5000);
118F6  0E88     MOVLW 0x88
118F8  6EE6     MOVWF 0xFE6, ACCESS
118FA  0E13     MOVLW 0x13
118FC  6EE6     MOVWF 0xFE6, ACCESS
118FE  EC7E     CALL 0x1B4FC, 0
11900  F0DA     NOP
301:           			V.system_stable = true;
11902  0E01     MOVLW 0x1
11904  0101     MOVLB 0x1
11906  6FDE     MOVWF 0xDE, BANKED
302:           			break;
11908  D01C     BRA 0x1942
303:           		case UI_STATE_HOST:
304:           			break;
305:           		case UI_STATE_LOG:
306:           			break;
307:           		case UI_STATE_MON: // monitor
308:           			P.SYSTEM_STABLE = true;
1190A  0100     MOVLB 0x0
1190C  819F     BSF 0x9F, 0, BANKED
309:           			break;
1190E  D019     BRA 0x1942
310:           		case UI_STATE_ERROR:
311:           		default:
312:           			V.ui_state = UI_STATE_INIT;
11910  6B30     CLRF 0x30, BANKED
313:           			break;
11912  D017     BRA 0x1942
314:           		}
11914  0101     MOVLB 0x1
11916  5130     MOVF 0x30, W, BANKED
11918  6E0B     MOVWF wtemp5, ACCESS
1191A  6A0C     CLRF 0xC, ACCESS
1191C  500C     MOVF 0xC, W, ACCESS
1191E  0A00     XORLW 0x0
11920  A4D8     BTFSS 0xFD8, 2, ACCESS
11922  D7F6     BRA 0x1910
11924  500B     MOVF wtemp5, W, ACCESS
11926  0A00     XORLW 0x0
11928  B4D8     BTFSC 0xFD8, 2, ACCESS
1192A  D4C8     BRA 0x12BC
1192C  0A01     XORLW 0x1
1192E  B4D8     BTFSC 0xFD8, 2, ACCESS
11930  D008     BRA 0x1942
11932  0A02     XORLW 0x2
11934  B4D8     BTFSC 0xFD8, 2, ACCESS
11936  D005     BRA 0x1942
11938  0A07     XORLW 0x7
1193A  B4D8     BTFSC 0xFD8, 2, ACCESS
1193C  D7E6     BRA 0x190A
1193E  0A01     XORLW 0x1
11940  D7E7     BRA 0x1910
315:           
316:           		if (TimerDone(TMR_ADC) && check_adc_scan()) {
11942  0E01     MOVLW 0x1
11944  6EE6     MOVWF 0xFE6, ACCESS
11946  ECF3     CALL 0x1B7E6, 0
11948  F0DB     NOP
1194A  5001     MOVF ltemp0, W, ACCESS
1194C  B4D8     BTFSC 0xFD8, 2, ACCESS
1194E  D013     BRA 0x1976
11950  ECD7     CALL 0x1BDAE, 0
11952  F0DE     NOP
11954  5001     MOVF ltemp0, W, ACCESS
11956  B4D8     BTFSC 0xFD8, 2, ACCESS
11958  D00E     BRA 0x1976
317:           			/*
318:           			 * download the system data variables
319:           			 */
320:           			convert_adc_data();
1195A  EC2B     CALL 0x1A256, 0
1195C  F0D1     NOP
321:           			/*
322:           			 * restart the conversion process
323:           			 */
324:           			clear_adc_scan();
1195E  ECE7     CALL 0x1BDCE, 0
11960  F0DE     NOP
325:           			start_adc_scan();
11962  EC6C     CALL 0x1ACD8, 0
11964  F0D6     NOP
326:           			StartTimer(TMR_ADC, ADC_SCAN_SPEED);
11966  0EC8     MOVLW 0xC8
11968  6EE6     MOVWF 0xFE6, ACCESS
1196A  0E00     MOVLW 0x0
1196C  6EE6     MOVWF 0xFE6, ACCESS
1196E  0E01     MOVLW 0x1
11970  6EE6     MOVWF 0xFE6, ACCESS
11972  EC6A     CALL 0x1B2D4, 0
11974  F0D9     NOP
327:           		}
328:           
329:           		if (V.ticks) {
330:           
331:           		}
332:           
333:           		if (TimerDone(TMR_DISPLAY)) { // limit update rate
11976  0E0A     MOVLW 0xA
11978  6EE6     MOVWF 0xFE6, ACCESS
1197A  ECF3     CALL 0x1B7E6, 0
1197C  F0DB     NOP
1197E  5001     MOVF ltemp0, W, ACCESS
11980  B4D8     BTFSC 0xFD8, 2, ACCESS
11982  EF3F     GOTO 0x1227E
11984  F091     NOP
334:           			if (TimerDone(TMR_HELPDIS)) {
11986  0E09     MOVLW 0x9
11988  6EE6     MOVWF 0xFE6, ACCESS
1198A  ECF3     CALL 0x1B7E6, 0
1198C  F0DB     NOP
1198E  5001     MOVF ltemp0, W, ACCESS
11990  B4D8     BTFSC 0xFD8, 2, ACCESS
11992  D004     BRA 0x199C
335:           				set_display_info(DIS_STR);
11994  0E00     MOVLW 0x0
11996  6EE6     MOVWF 0xFE6, ACCESS
11998  ECD8     CALL 0x1BBB0, 0
1199A  F0DD     NOP
336:           			}
337:           			calc_model_data();
1199C  ECD8     CALL 0x159B0, 0
1199E  F0AC     NOP
338:           
339:           			if (false) {
340:           				sprintf(get_vterm_ptr(0, 0), "%d %2.4f   %d  ", get_raw_result(i), C.calc[i], get_switch(SSELECT));
341:           				sprintf(get_vterm_ptr(1, 0), "%d %2.4f   %d  ", get_raw_result(j), C.calc[j], get_switch(SENTER));
342:           				sprintf(get_vterm_ptr(2, 0), "%d %2.4f, %d   #", get_raw_result(k), C.calc[k], inp_index);
343:           			} else {
344:           				hid_display(&H);
119A0  0EF7     MOVLW 0xF7
119A2  6EE6     MOVWF 0xFE6, ACCESS
119A4  ECA3     CALL 0x19B46, 0
119A6  F0CD     NOP
345:           				switch (H.hid_display) {
119A8  EFEE     GOTO 0x121DC
119AA  F090     NOP
346:           				case HID_PWR:
347:           					V.calib = false;
119AC  0101     MOVLB 0x1
119AE  6BDC     CLRF 0xDC, BANKED
348:           					sprintf(get_vterm_ptr(0, 0), "PV %c PWR %3.2f    ", (C.day) ? 'D' : ' ', C.p_pv);
119B0  EE22     LFSR 2, 0x81D
119B2  F01D     NOP
119B4  50DF     MOVF 0xFDF, W, ACCESS
119B6  A4D8     BTFSS 0xFD8, 2, ACCESS
119B8  D002     BRA 0x19BE
119BA  0E20     MOVLW 0x20
119BC  D001     BRA 0x19C0
119BE  0E44     MOVLW 0x44
119C0  6E0B     MOVWF wtemp5, ACCESS
119C2  0E00     MOVLW 0x0
119C4  6E0C     MOVWF 0xC, ACCESS
119C6  0EF1     MOVLW 0xF1
119CA  F02F     NOP
119CC  FFE3     NOP
119CE  0EF2     MOVLW 0xF2
119D2  F033     NOP
119D4  FFE3     NOP
119D6  EE21     LFSR 2, 0x77B
119D8  F37B     NOP
119DC  FF7B     NOP
119DE  FFE6     NOP
119E2  FF7B     NOP
119E4  FFE6     NOP
119E8  FF7B     NOP
119EA  FFE6     NOP
119EE  FF7B     NOP
119F0  FFE6     NOP
119F2  0EED     MOVLW 0xED
119F6  FF8F     NOP
119F8  FFE6     NOP
119FC  FF8F     NOP
119FE  FFE6     NOP
11A00  0EEC     MOVLW 0xEC
11A02  6EE6     MOVWF 0xFE6, ACCESS
11A04  0EFD     MOVLW 0xFD
11A06  6EE6     MOVWF 0xFE6, ACCESS
11A08  0E00     MOVLW 0x0
11A0A  6EE6     MOVWF 0xFE6, ACCESS
11A0C  0E00     MOVLW 0x0
11A0E  6EE6     MOVWF 0xFE6, ACCESS
11A10  EC48     CALL 0x1B690, 0
11A12  F0DB     NOP
11A16  F007     NOP
11A18  FFE6     NOP
11A1C  F00B     NOP
11A1E  FFE6     NOP
11A20  0E0A     MOVLW 0xA
11A22  6EE6     MOVWF 0xFE6, ACCESS
11A24  EC1E     CALL 0x19A3C, 0
11A26  F0CD     NOP
349:           					sprintf(get_vterm_ptr(1, 0), "LOAD PWR %3.2f    ", C.p_load);
11A28  EE21     LFSR 2, 0x773
11A2A  F373     NOP
11A2E  FF7B     NOP
11A30  FFE6     NOP
11A34  FF7B     NOP
11A36  FFE6     NOP
11A3A  FF7B     NOP
11A3C  FFE6     NOP
11A40  FF7B     NOP
11A42  FFE6     NOP
11A44  0EBF     MOVLW 0xBF
11A46  6EE6     MOVWF 0xFE6, ACCESS
11A48  0EFE     MOVLW 0xFE
11A4A  6EE6     MOVWF 0xFE6, ACCESS
11A4C  0E00     MOVLW 0x0
11A4E  6EE6     MOVWF 0xFE6, ACCESS
11A50  0E01     MOVLW 0x1
11A52  6EE6     MOVWF 0xFE6, ACCESS
11A54  EC48     CALL 0x1B690, 0
11A56  F0DB     NOP
11A5A  F007     NOP
11A5C  FFE6     NOP
11A60  F00B     NOP
11A62  FFE6     NOP
11A64  0E08     MOVLW 0x8
11A66  6EE6     MOVWF 0xFE6, ACCESS
11A68  EC1E     CALL 0x19A3C, 0
11A6A  F0CD     NOP
350:           					sprintf(get_vterm_ptr(2, 0), "INV  PWR %3.2f    ", C.p_inverter);
11A6C  EE21     LFSR 2, 0x777
11A6E  F377     NOP
11A72  FF7B     NOP
11A74  FFE6     NOP
11A78  FF7B     NOP
11A7A  FFE6     NOP
11A7E  FF7B     NOP
11A80  FFE6     NOP
11A84  FF7B     NOP
11A86  FFE6     NOP
11A88  0EAC     MOVLW 0xAC
11A8A  6EE6     MOVWF 0xFE6, ACCESS
11A8C  0EFE     MOVLW 0xFE
11A8E  6EE6     MOVWF 0xFE6, ACCESS
11A90  0E00     MOVLW 0x0
11A92  6EE6     MOVWF 0xFE6, ACCESS
11A94  0E02     MOVLW 0x2
11A96  6EE6     MOVWF 0xFE6, ACCESS
11A98  EC48     CALL 0x1B690, 0
11A9A  F0DB     NOP
11A9E  F007     NOP
11AA0  FFE6     NOP
11AA4  F00B     NOP
11AA6  FFE6     NOP
11AA8  0E08     MOVLW 0x8
11AAA  6EE6     MOVWF 0xFE6, ACCESS
11AAC  EC1E     CALL 0x19A3C, 0
11AAE  F0CD     NOP
351:           
352:           					sprintf(get_vterm_ptr(0, 1), "PV %c WH %3.2f     ", (C.day) ? 'D' : ' ', C.pvkw);
11AB0  EE22     LFSR 2, 0x81D
11AB2  F01D     NOP
11AB4  50DF     MOVF 0xFDF, W, ACCESS
11AB6  A4D8     BTFSS 0xFD8, 2, ACCESS
11AB8  D002     BRA 0x1ABE
11ABA  0E20     MOVLW 0x20
11ABC  D001     BRA 0x1AC0
11ABE  0E44     MOVLW 0x44
11AC0  6E0B     MOVWF wtemp5, ACCESS
11AC2  0E00     MOVLW 0x0
11AC4  6E0C     MOVWF 0xC, ACCESS
11AC6  0EEF     MOVLW 0xEF
11ACA  F02F     NOP
11ACC  FFE3     NOP
11ACE  0EF0     MOVLW 0xF0
11AD2  F033     NOP
11AD4  FFE3     NOP
11AD6  EE21     LFSR 2, 0x7A3
11AD8  F3A3     NOP
11ADC  FF7B     NOP
11ADE  FFE6     NOP
11AE2  FF7B     NOP
11AE4  FFE6     NOP
11AE8  FF7B     NOP
11AEA  FFE6     NOP
11AEE  FF7B     NOP
11AF0  FFE6     NOP
11AF2  0EEB     MOVLW 0xEB
11AF6  FF8F     NOP
11AF8  FFE6     NOP
11AFC  FF8F     NOP
11AFE  FFE6     NOP
11B00  0E9C     MOVLW 0x9C
11B02  6EE6     MOVWF 0xFE6, ACCESS
11B04  0EFD     MOVLW 0xFD
11B06  6EE6     MOVWF 0xFE6, ACCESS
11B08  0E01     MOVLW 0x1
11B0A  6EE6     MOVWF 0xFE6, ACCESS
11B0C  0E00     MOVLW 0x0
11B0E  6EE6     MOVWF 0xFE6, ACCESS
11B10  EC48     CALL 0x1B690, 0
11B12  F0DB     NOP
11B16  F007     NOP
11B18  FFE6     NOP
11B1C  F00B     NOP
11B1E  FFE6     NOP
11B20  0E0A     MOVLW 0xA
11B22  6EE6     MOVWF 0xFE6, ACCESS
11B24  EC1E     CALL 0x19A3C, 0
11B26  F0CD     NOP
353:           					sprintf(get_vterm_ptr(1, 1), "LOAD WH %3.2f     ", C.loadkw);
11B28  EE21     LFSR 2, 0x7AB
11B2A  F3AB     NOP
11B2E  FF7B     NOP
11B30  FFE6     NOP
11B34  FF7B     NOP
11B36  FFE6     NOP
11B3A  FF7B     NOP
11B3C  FFE6     NOP
11B40  FF7B     NOP
11B42  FFE6     NOP
11B44  0E99     MOVLW 0x99
11B46  6EE6     MOVWF 0xFE6, ACCESS
11B48  0EFE     MOVLW 0xFE
11B4A  6EE6     MOVWF 0xFE6, ACCESS
11B4C  0E01     MOVLW 0x1
11B4E  6EE6     MOVWF 0xFE6, ACCESS
11B50  0E01     MOVLW 0x1
11B52  6EE6     MOVWF 0xFE6, ACCESS
11B54  EC48     CALL 0x1B690, 0
11B56  F0DB     NOP
11B5A  F007     NOP
11B5C  FFE6     NOP
11B60  F00B     NOP
11B62  FFE6     NOP
11B64  0E08     MOVLW 0x8
11B66  6EE6     MOVWF 0xFE6, ACCESS
11B68  EC1E     CALL 0x19A3C, 0
11B6A  F0CD     NOP
354:           					sprintf(get_vterm_ptr(2, 1), "INV  WH %3.2f     ", C.invkw);
11B6C  EE21     LFSR 2, 0x7A7
11B6E  F3A7     NOP
11B72  FF7B     NOP
11B74  FFE6     NOP
11B78  FF7B     NOP
11B7A  FFE6     NOP
11B7E  FF7B     NOP
11B80  FFE6     NOP
11B84  FF7B     NOP
11B86  FFE6     NOP
11B88  0E86     MOVLW 0x86
11B8A  6EE6     MOVWF 0xFE6, ACCESS
11B8C  0EFE     MOVLW 0xFE
11B8E  6EE6     MOVWF 0xFE6, ACCESS
11B90  0E01     MOVLW 0x1
11B92  6EE6     MOVWF 0xFE6, ACCESS
11B94  0E02     MOVLW 0x2
11B96  6EE6     MOVWF 0xFE6, ACCESS
11B98  EC48     CALL 0x1B690, 0
11B9A  F0DB     NOP
11B9E  F007     NOP
11BA0  FFE6     NOP
11BA4  F00B     NOP
11BA6  FFE6     NOP
11BA8  0E08     MOVLW 0x8
11BAA  6EE6     MOVWF 0xFE6, ACCESS
11BAC  EC1E     CALL 0x19A3C, 0
11BAE  F0CD     NOP
355:           					break;
11BB0  D32B     BRA 0x2208
356:           				case HID_MAIN:
357:           					V.calib = false;
11BB2  0101     MOVLB 0x1
11BB4  6BDC     CLRF 0xDC, BANKED
358:           					sprintf(get_vterm_ptr(0, 0), "PV %2.2f PA %2.2f ", C.calc[V_PV], C.calc[C_PV]);
11BB6  EE21     LFSR 2, 0x703
11BB8  F303     NOP
11BBC  FF7B     NOP
11BBE  FFE6     NOP
11BC2  FF7B     NOP
11BC4  FFE6     NOP
11BC8  FF7B     NOP
11BCA  FFE6     NOP
11BCE  FF7B     NOP
11BD0  FFE6     NOP
11BD2  EE21     LFSR 2, 0x713
11BD4  F313     NOP
11BD8  FF7B     NOP
11BDA  FFE6     NOP
11BDE  FF7B     NOP
11BE0  FFE6     NOP
11BE4  FF7B     NOP
11BE6  FFE6     NOP
11BEA  FF7B     NOP
11BEC  FFE6     NOP
11BEE  0EF8     MOVLW 0xF8
11BF0  6EE6     MOVWF 0xFE6, ACCESS
11BF2  0EFE     MOVLW 0xFE
11BF4  6EE6     MOVWF 0xFE6, ACCESS
11BF6  0E00     MOVLW 0x0
11BF8  6EE6     MOVWF 0xFE6, ACCESS
11BFA  0E00     MOVLW 0x0
11BFC  6EE6     MOVWF 0xFE6, ACCESS
11BFE  EC48     CALL 0x1B690, 0
11C00  F0DB     NOP
11C04  F007     NOP
11C06  FFE6     NOP
11C0A  F00B     NOP
11C0C  FFE6     NOP
11C0E  0E0C     MOVLW 0xC
11C10  6EE6     MOVWF 0xFE6, ACCESS
11C12  EC1E     CALL 0x19A3C, 0
11C14  F0CD     NOP
359:           					sprintf(get_vterm_ptr(1, 0), "BV %2.2f BA %2.2f ", C.calc[V_BAT], C.calc[C_BATT]);
11C16  EE21     LFSR 2, 0x6FF
11C18  F2FF     NOP
11C1C  FF7B     NOP
11C1E  FFE6     NOP
11C22  FF7B     NOP
11C24  FFE6     NOP
11C28  FF7B     NOP
11C2A  FFE6     NOP
11C2E  FF7B     NOP
11C30  FFE6     NOP
11C32  EE21     LFSR 2, 0x70F
11C34  F30F     NOP
11C38  FF7B     NOP
11C3A  FFE6     NOP
11C3E  FF7B     NOP
11C40  FFE6     NOP
11C44  FF7B     NOP
11C46  FFE6     NOP
11C4A  FF7B     NOP
11C4C  FFE6     NOP
11C4E  0ED2     MOVLW 0xD2
11C50  6EE6     MOVWF 0xFE6, ACCESS
11C52  0EFE     MOVLW 0xFE
11C54  6EE6     MOVWF 0xFE6, ACCESS
11C56  0E00     MOVLW 0x0
11C58  6EE6     MOVWF 0xFE6, ACCESS
11C5A  0E01     MOVLW 0x1
11C5C  6EE6     MOVWF 0xFE6, ACCESS
11C5E  EC48     CALL 0x1B690, 0
11C60  F0DB     NOP
11C64  F007     NOP
11C66  FFE6     NOP
11C6A  F00B     NOP
11C6C  FFE6     NOP
11C6E  0E0C     MOVLW 0xC
11C70  6EE6     MOVWF 0xFE6, ACCESS
11C72  EC1E     CALL 0x19A3C, 0
11C74  F0CD     NOP
360:           					sprintf(get_vterm_ptr(2, 0), "CV %2.2f LA %2.2f ", C.calc[V_CC], C.c_load);
11C76  EE21     LFSR 2, 0x73F
11C78  F33F     NOP
11C7C  FF7B     NOP
11C7E  FFE6     NOP
11C82  FF7B     NOP
11C84  FFE6     NOP
11C88  FF7B     NOP
11C8A  FFE6     NOP
11C8E  FF7B     NOP
11C90  FFE6     NOP
11C92  EE21     LFSR 2, 0x707
11C94  F307     NOP
11C98  FF7B     NOP
11C9A  FFE6     NOP
11C9E  FF7B     NOP
11CA0  FFE6     NOP
11CA4  FF7B     NOP
11CA6  FFE6     NOP
11CAA  FF7B     NOP
11CAC  FFE6     NOP
11CAE  0EE5     MOVLW 0xE5
11CB0  6EE6     MOVWF 0xFE6, ACCESS
11CB2  0EFE     MOVLW 0xFE
11CB4  6EE6     MOVWF 0xFE6, ACCESS
11CB6  0E00     MOVLW 0x0
11CB8  6EE6     MOVWF 0xFE6, ACCESS
11CBA  0E02     MOVLW 0x2
11CBC  6EE6     MOVWF 0xFE6, ACCESS
11CBE  EC48     CALL 0x1B690, 0
11CC0  F0DB     NOP
11CC4  F007     NOP
11CC6  FFE6     NOP
11CCA  F00B     NOP
11CCC  FFE6     NOP
11CCE  0E0C     MOVLW 0xC
11CD0  6EE6     MOVWF 0xFE6, ACCESS
11CD2  EC1E     CALL 0x19A3C, 0
11CD4  F0CD     NOP
361:           
362:           					sprintf(get_vterm_ptr(0, 1), "BAT IWH %4.1f     ", C.bkwi);
11CD6  EE21     LFSR 2, 0x79B
11CD8  F39B     NOP
11CDC  FF7B     NOP
11CDE  FFE6     NOP
11CE2  FF7B     NOP
11CE4  FFE6     NOP
11CE8  FF7B     NOP
11CEA  FFE6     NOP
11CEE  FF7B     NOP
11CF0  FFE6     NOP
11CF2  0E4D     MOVLW 0x4D
11CF4  6EE6     MOVWF 0xFE6, ACCESS
11CF6  0EFE     MOVLW 0xFE
11CF8  6EE6     MOVWF 0xFE6, ACCESS
11CFA  0E01     MOVLW 0x1
11CFC  6EE6     MOVWF 0xFE6, ACCESS
11CFE  0E00     MOVLW 0x0
11D00  6EE6     MOVWF 0xFE6, ACCESS
11D02  EC48     CALL 0x1B690, 0
11D04  F0DB     NOP
11D08  F007     NOP
11D0A  FFE6     NOP
11D0E  F00B     NOP
11D10  FFE6     NOP
11D12  0E08     MOVLW 0x8
11D14  6EE6     MOVWF 0xFE6, ACCESS
11D16  EC1E     CALL 0x19A3C, 0
11D18  F0CD     NOP
363:           					sprintf(get_vterm_ptr(1, 1), "BAT OWH %4.1f     ", C.bkwo);
11D1A  EE21     LFSR 2, 0x79F
11D1C  F39F     NOP
11D20  FF7B     NOP
11D22  FFE6     NOP
11D26  FF7B     NOP
11D28  FFE6     NOP
11D2C  FF7B     NOP
11D2E  FFE6     NOP
11D32  FF7B     NOP
11D34  FFE6     NOP
11D36  0E60     MOVLW 0x60
11D38  6EE6     MOVWF 0xFE6, ACCESS
11D3A  0EFE     MOVLW 0xFE
11D3C  6EE6     MOVWF 0xFE6, ACCESS
11D3E  0E01     MOVLW 0x1
11D40  6EE6     MOVWF 0xFE6, ACCESS
11D42  0E01     MOVLW 0x1
11D44  6EE6     MOVWF 0xFE6, ACCESS
11D46  EC48     CALL 0x1B690, 0
11D48  F0DB     NOP
11D4C  F007     NOP
11D4E  FFE6     NOP
11D52  F00B     NOP
11D54  FFE6     NOP
11D56  0E08     MOVLW 0x8
11D58  6EE6     MOVWF 0xFE6, ACCESS
11D5A  EC1E     CALL 0x19A3C, 0
11D5C  F0CD     NOP
364:           					sprintf(get_vterm_ptr(2, 1), "BAT TWH %4.1f     ", C.bkwi + C.bkwo);
11D5E  EE21     LFSR 2, 0x79F
11D60  F39F     NOP
11D64  FF7B     NOP
11D66  FFE6     NOP
11D6A  FF7B     NOP
11D6C  FFE6     NOP
11D70  FF7B     NOP
11D72  FFE6     NOP
11D76  FF7B     NOP
11D78  FFE6     NOP
11D7A  EE21     LFSR 2, 0x79B
11D7C  F39B     NOP
11D80  FF7B     NOP
11D82  FFE6     NOP
11D86  FF7B     NOP
11D88  FFE6     NOP
11D8C  FF7B     NOP
11D8E  FFE6     NOP
11D92  FF7B     NOP
11D94  FFE6     NOP
11D96  ECB5     CALL 0x13B6A, 0
11D98  F09D     NOP
11D9C  F007     NOP
11D9E  FFE6     NOP
11DA2  F00B     NOP
11DA4  FFE6     NOP
11DA8  F00F     NOP
11DAA  FFE6     NOP
11DAE  F013     NOP
11DB0  FFE6     NOP
11DB2  0E73     MOVLW 0x73
11DB4  6EE6     MOVWF 0xFE6, ACCESS
11DB6  0EFE     MOVLW 0xFE
11DB8  6EE6     MOVWF 0xFE6, ACCESS
11DBA  0E01     MOVLW 0x1
11DBC  6EE6     MOVWF 0xFE6, ACCESS
11DBE  0E02     MOVLW 0x2
11DC0  6EE6     MOVWF 0xFE6, ACCESS
11DC2  EC48     CALL 0x1B690, 0
11DC4  F0DB     NOP
11DC8  F007     NOP
11DCA  FFE6     NOP
11DCE  F00B     NOP
11DD0  FFE6     NOP
11DD2  0E08     MOVLW 0x8
11DD4  6EE6     MOVWF 0xFE6, ACCESS
11DD6  EC1E     CALL 0x19A3C, 0
11DD8  F0CD     NOP
365:           					break;
11DDA  D216     BRA 0x2208
366:           				case HID_RUN:
367:           					V.calib = false;
11DDC  0101     MOVLB 0x1
11DDE  6BDC     CLRF 0xDC, BANKED
368:           					sprintf(get_vterm_ptr(0, 0), "BATT PWR %3.2f     ", C.p_bat);
11DE0  EE21     LFSR 2, 0x77F
11DE2  F37F     NOP
11DE6  FF7B     NOP
11DE8  FFE6     NOP
11DEC  FF7B     NOP
11DEE  FFE6     NOP
11DF2  FF7B     NOP
11DF4  FFE6     NOP
11DF8  FF7B     NOP
11DFA  FFE6     NOP
11DFC  0EB0     MOVLW 0xB0
11DFE  6EE6     MOVWF 0xFE6, ACCESS
11E00  0EFD     MOVLW 0xFD
11E02  6EE6     MOVWF 0xFE6, ACCESS
11E04  0E00     MOVLW 0x0
11E06  6EE6     MOVWF 0xFE6, ACCESS
11E08  0E00     MOVLW 0x0
11E0A  6EE6     MOVWF 0xFE6, ACCESS
11E0C  EC48     CALL 0x1B690, 0
11E0E  F0DB     NOP
11E12  F007     NOP
11E14  FFE6     NOP
11E18  F00B     NOP
11E1A  FFE6     NOP
11E1C  0E08     MOVLW 0x8
11E1E  6EE6     MOVWF 0xFE6, ACCESS
11E20  EC1E     CALL 0x19A3C, 0
11E22  F0CD     NOP
369:           					sprintf(get_vterm_ptr(1, 0), "BAH %3.2f P%3.2f   ", C.dynamic_ah, C.pv_ah);
11E24  EE21     LFSR 2, 0x793
11E26  F393     NOP
11E2A  FF7B     NOP
11E2C  FFE6     NOP
11E30  FF7B     NOP
11E32  FFE6     NOP
11E36  FF7B     NOP
11E38  FFE6     NOP
11E3C  FF7B     NOP
11E3E  FFE6     NOP
11E40  EE21     LFSR 2, 0x78F
11E42  F38F     NOP
11E46  FF7B     NOP
11E48  FFE6     NOP
11E4C  FF7B     NOP
11E4E  FFE6     NOP
11E52  FF7B     NOP
11E54  FFE6     NOP
11E58  FF7B     NOP
11E5A  FFE6     NOP
11E5C  0E00     MOVLW 0x0
11E5E  6EE6     MOVWF 0xFE6, ACCESS
11E60  0EFE     MOVLW 0xFE
11E62  6EE6     MOVWF 0xFE6, ACCESS
11E64  0E00     MOVLW 0x0
11E66  6EE6     MOVWF 0xFE6, ACCESS
11E68  0E01     MOVLW 0x1
11E6A  6EE6     MOVWF 0xFE6, ACCESS
11E6C  EC48     CALL 0x1B690, 0
11E6E  F0DB     NOP
11E72  F007     NOP
11E74  FFE6     NOP
11E78  F00B     NOP
11E7A  FFE6     NOP
11E7C  0E0C     MOVLW 0xC
11E7E  6EE6     MOVWF 0xFE6, ACCESS
11E80  EC1E     CALL 0x19A3C, 0
11E82  F0CD     NOP
370:           					sprintf(get_vterm_ptr(2, 0), "S%cC %d RUN %d     ", spinners(5, false), C.soc, C.runtime);
11E84  EE21     LFSR 2, 0x7AF
11E86  F3AF     NOP
11E8A  FF78     NOP
11E8C  F00B     NOP
11E90  FF74     NOP
11E92  F00C     NOP
11E96  F02F     NOP
11E98  FFE6     NOP
11E9C  F033     NOP
11E9E  FFE6     NOP
11EA0  EE21     LFSR 2, 0x7B1
11EA2  F3B1     NOP
11EA6  FF78     NOP
11EA8  F00B     NOP
11EAC  FF74     NOP
11EAE  F00C     NOP
11EB2  F02F     NOP
11EB4  FFE6     NOP
11EB8  F033     NOP
11EBA  FFE6     NOP
11EBC  0E00     MOVLW 0x0
11EBE  6EE6     MOVWF 0xFE6, ACCESS
11EC0  0E05     MOVLW 0x5
11EC2  6EE6     MOVWF 0xFE6, ACCESS
11EC4  EC11     CALL 0x19E22, 0
11EC6  F0CF     NOP
11EC8  5001     MOVF ltemp0, W, ACCESS
11ECA  6EE6     MOVWF 0xFE6, ACCESS
11ECC  0E00     MOVLW 0x0
11ECE  6EE6     MOVWF 0xFE6, ACCESS
11ED0  0E88     MOVLW 0x88
11ED2  6EE6     MOVWF 0xFE6, ACCESS
11ED4  0EFD     MOVLW 0xFD
11ED6  6EE6     MOVWF 0xFE6, ACCESS
11ED8  0E00     MOVLW 0x0
11EDA  6EE6     MOVWF 0xFE6, ACCESS
11EDC  0E02     MOVLW 0x2
11EDE  6EE6     MOVWF 0xFE6, ACCESS
11EE0  EC48     CALL 0x1B690, 0
11EE2  F0DB     NOP
11EE6  F007     NOP
11EE8  FFE6     NOP
11EEC  F00B     NOP
11EEE  FFE6     NOP
11EF0  0E0A     MOVLW 0xA
11EF2  6EE6     MOVWF 0xFE6, ACCESS
11EF4  EC1E     CALL 0x19A3C, 0
11EF6  F0CD     NOP
371:           
372:           					sprintf(get_vterm_ptr(0, 1), "ESR  %2.6f         ", C.esr);
11EF8  EE21     LFSR 2, 0x787
11EFA  F387     NOP
11EFE  FF7B     NOP
11F00  FFE6     NOP
11F04  FF7B     NOP
11F06  FFE6     NOP
11F0A  FF7B     NOP
11F0C  FFE6     NOP
11F10  FF7B     NOP
11F12  FFE6     NOP
11F14  0E74     MOVLW 0x74
11F16  6EE6     MOVWF 0xFE6, ACCESS
11F18  0EFD     MOVLW 0xFD
11F1A  6EE6     MOVWF 0xFE6, ACCESS
11F1C  0E01     MOVLW 0x1
11F1E  6EE6     MOVWF 0xFE6, ACCESS
11F20  0E00     MOVLW 0x0
11F22  6EE6     MOVWF 0xFE6, ACCESS
11F24  EC48     CALL 0x1B690, 0
11F26  F0DB     NOP
11F2A  F007     NOP
11F2C  FFE6     NOP
11F30  F00B     NOP
11F32  FFE6     NOP
11F34  0E08     MOVLW 0x8
11F36  6EE6     MOVWF 0xFE6, ACCESS
11F38  EC1E     CALL 0x19A3C, 0
11F3A  F0CD     NOP
373:           					sprintf(get_vterm_ptr(1, 1), "R1 %2.3f %3.4f     ", C.bv_one_load, C.load_i1);
11F3C  EE22     LFSR 2, 0x809
11F3E  F009     NOP
11F42  FF7B     NOP
11F44  FFE6     NOP
11F48  FF7B     NOP
11F4A  FFE6     NOP
11F4E  FF7B     NOP
11F50  FFE6     NOP
11F54  FF7B     NOP
11F56  FFE6     NOP
11F58  EE22     LFSR 2, 0x815
11F5A  F015     NOP
11F5E  FF7B     NOP
11F60  FFE6     NOP
11F64  FF7B     NOP
11F66  FFE6     NOP
11F6A  FF7B     NOP
11F6C  FFE6     NOP
11F70  FF7B     NOP
11F72  FFE6     NOP
11F74  0EC4     MOVLW 0xC4
11F76  6EE6     MOVWF 0xFE6, ACCESS
11F78  0EFD     MOVLW 0xFD
11F7A  6EE6     MOVWF 0xFE6, ACCESS
11F7C  0E01     MOVLW 0x1
11F7E  6EE6     MOVWF 0xFE6, ACCESS
11F80  0E01     MOVLW 0x1
11F82  6EE6     MOVWF 0xFE6, ACCESS
11F84  EC48     CALL 0x1B690, 0
11F86  F0DB     NOP
11F8A  F007     NOP
11F8C  FFE6     NOP
11F90  F00B     NOP
11F92  FFE6     NOP
11F94  0E0C     MOVLW 0xC
11F96  6EE6     MOVWF 0xFE6, ACCESS
11F98  EC1E     CALL 0x19A3C, 0
11F9A  F0CD     NOP
374:           					sprintf(get_vterm_ptr(2, 1), "R2 %2.3f %3.4f     ", C.bv_full_load, C.load_i2);
11F9C  EE22     LFSR 2, 0x80D
11F9E  F00D     NOP
11FA2  FF7B     NOP
11FA4  FFE6     NOP
11FA8  FF7B     NOP
11FAA  FFE6     NOP
11FAE  FF7B     NOP
11FB0  FFE6     NOP
11FB4  FF7B     NOP
11FB6  FFE6     NOP
11FB8  EE22     LFSR 2, 0x819
11FBA  F019     NOP
11FBE  FF7B     NOP
11FC0  FFE6     NOP
11FC4  FF7B     NOP
11FC6  FFE6     NOP
11FCA  FF7B     NOP
11FCC  FFE6     NOP
11FD0  FF7B     NOP
11FD2  FFE6     NOP
11FD4  0ED8     MOVLW 0xD8
11FD6  6EE6     MOVWF 0xFE6, ACCESS
11FD8  0EFD     MOVLW 0xFD
11FDA  6EE6     MOVWF 0xFE6, ACCESS
11FDC  0E01     MOVLW 0x1
11FDE  6EE6     MOVWF 0xFE6, ACCESS
11FE0  0E02     MOVLW 0x2
11FE2  6EE6     MOVWF 0xFE6, ACCESS
11FE4  EC48     CALL 0x1B690, 0
11FE6  F0DB     NOP
11FEA  F007     NOP
11FEC  FFE6     NOP
11FF0  F00B     NOP
11FF2  FFE6     NOP
11FF4  0E0C     MOVLW 0xC
11FF6  6EE6     MOVWF 0xFE6, ACCESS
11FF8  EC1E     CALL 0x19A3C, 0
11FFA  F0CD     NOP
375:           					break;
11FFC  D105     BRA 0x2208
376:           				case HID_AUX:
377:           					if (!V.calib) {
11FFE  0101     MOVLB 0x1
12000  51DC     MOVF 0xDC, W, BANKED
12002  A4D8     BTFSS 0xFD8, 2, ACCESS
12004  D02D     BRA 0x2060
378:           						lp_filter(0.0, i, -1);
12006  0EFF     MOVLW 0xFF
12008  6EE6     MOVWF 0xFE6, ACCESS
1200A  0EFB     MOVLW 0xFB
1200C  50E3     MOVF 0xFE3, W, ACCESS
1200E  6EE6     MOVWF 0xFE6, ACCESS
12010  0E00     MOVLW 0x0
12012  6EE6     MOVWF 0xFE6, ACCESS
12014  0E00     MOVLW 0x0
12016  6EE6     MOVWF 0xFE6, ACCESS
12018  0E00     MOVLW 0x0
1201A  6EE6     MOVWF 0xFE6, ACCESS
1201C  0E00     MOVLW 0x0
1201E  6EE6     MOVWF 0xFE6, ACCESS
12020  ECCC     CALL 0x18398, 0
12022  F0C1     NOP
379:           						lp_filter(0.0, j, -1);
12024  0EFF     MOVLW 0xFF
12026  6EE6     MOVWF 0xFE6, ACCESS
12028  0EFA     MOVLW 0xFA
1202A  50E3     MOVF 0xFE3, W, ACCESS
1202C  6EE6     MOVWF 0xFE6, ACCESS
1202E  0E00     MOVLW 0x0
12030  6EE6     MOVWF 0xFE6, ACCESS
12032  0E00     MOVLW 0x0
12034  6EE6     MOVWF 0xFE6, ACCESS
12036  0E00     MOVLW 0x0
12038  6EE6     MOVWF 0xFE6, ACCESS
1203A  0E00     MOVLW 0x0
1203C  6EE6     MOVWF 0xFE6, ACCESS
1203E  ECCC     CALL 0x18398, 0
12040  F0C1     NOP
380:           						lp_filter(0.0, k, -1);
12042  0EFF     MOVLW 0xFF
12044  6EE6     MOVWF 0xFE6, ACCESS
12046  0EF9     MOVLW 0xF9
12048  50E3     MOVF 0xFE3, W, ACCESS
1204A  6EE6     MOVWF 0xFE6, ACCESS
1204C  0E00     MOVLW 0x0
1204E  6EE6     MOVWF 0xFE6, ACCESS
12050  0E00     MOVLW 0x0
12052  6EE6     MOVWF 0xFE6, ACCESS
12054  0E00     MOVLW 0x0
12056  6EE6     MOVWF 0xFE6, ACCESS
12058  0E00     MOVLW 0x0
1205A  6EE6     MOVWF 0xFE6, ACCESS
1205C  ECCC     CALL 0x18398, 0
1205E  F0C1     NOP
381:           					}
382:           					V.calib = true;
12060  0E01     MOVLW 0x1
12062  0101     MOVLB 0x1
12064  6FDC     MOVWF 0xDC, BANKED
383:           					sprintf(get_vterm_ptr(0, 0), "%d %2.4f   %d  ", get_raw_result(i), C.calc[i], get_switch(SSELECT));
12066  0E02     MOVLW 0x2
12068  6EE6     MOVWF 0xFE6, ACCESS
1206A  EC5F     CALL 0x1B6BE, 0
1206C  F0DB     NOP
1206E  5001     MOVF ltemp0, W, ACCESS
12070  6EE6     MOVWF 0xFE6, ACCESS
12072  0E00     MOVLW 0x0
12074  6EE6     MOVWF 0xFE6, ACCESS
12076  0EFA     MOVLW 0xFA
12078  50E3     MOVF 0xFE3, W, ACCESS
1207A  0D04     MULLW 0x4
1207C  0EFF     MOVLW 0xFF
1207E  24F3     ADDWF 0xFF3, W, ACCESS
12080  6ED9     MOVWF 0xFD9, ACCESS
12082  0E06     MOVLW 0x6
12084  20F4     ADDWFC 0xFF4, W, ACCESS
12086  6EDA     MOVWF 0xFDA, ACCESS
1208A  FF7B     NOP
1208C  FFE6     NOP
12090  FF7B     NOP
12092  FFE6     NOP
12096  FF7B     NOP
12098  FFE6     NOP
1209C  FF7B     NOP
1209E  FFE6     NOP
120A0  0EF6     MOVLW 0xF6
120A2  50E3     MOVF 0xFE3, W, ACCESS
120A4  6EE6     MOVWF 0xFE6, ACCESS
120A6  EC78     CALL 0x1BAF0, 0
120A8  F0DD     NOP
120AC  F007     NOP
120AE  FFE6     NOP
120B2  F00B     NOP
120B4  FFE6     NOP
120B6  0E83     MOVLW 0x83
120B8  6EE6     MOVWF 0xFE6, ACCESS
120BA  0EFF     MOVLW 0xFF
120BC  6EE6     MOVWF 0xFE6, ACCESS
120BE  0E00     MOVLW 0x0
120C0  6EE6     MOVWF 0xFE6, ACCESS
120C2  0E00     MOVLW 0x0
120C4  6EE6     MOVWF 0xFE6, ACCESS
120C6  EC48     CALL 0x1B690, 0
120C8  F0DB     NOP
120CC  F007     NOP
120CE  FFE6     NOP
120D2  F00B     NOP
120D4  FFE6     NOP
120D6  0E0C     MOVLW 0xC
120D8  6EE6     MOVWF 0xFE6, ACCESS
120DA  EC1E     CALL 0x19A3C, 0
120DC  F0CD     NOP
384:           					sprintf(get_vterm_ptr(1, 0), "%d %2.4f   %d  ", get_raw_result(j), C.calc[j], get_switch(SENTER));
120DE  0E03     MOVLW 0x3
120E0  6EE6     MOVWF 0xFE6, ACCESS
120E2  EC5F     CALL 0x1B6BE, 0
120E4  F0DB     NOP
120E6  5001     MOVF ltemp0, W, ACCESS
120E8  6EE6     MOVWF 0xFE6, ACCESS
120EA  0E00     MOVLW 0x0
120EC  6EE6     MOVWF 0xFE6, ACCESS
120EE  0EF9     MOVLW 0xF9
120F0  50E3     MOVF 0xFE3, W, ACCESS
120F2  0D04     MULLW 0x4
120F4  0EFF     MOVLW 0xFF
120F6  24F3     ADDWF 0xFF3, W, ACCESS
120F8  6ED9     MOVWF 0xFD9, ACCESS
120FA  0E06     MOVLW 0x6
120FC  20F4     ADDWFC 0xFF4, W, ACCESS
120FE  6EDA     MOVWF 0xFDA, ACCESS
12102  FF7B     NOP
12104  FFE6     NOP
12108  FF7B     NOP
1210A  FFE6     NOP
1210E  FF7B     NOP
12110  FFE6     NOP
12114  FF7B     NOP
12116  FFE6     NOP
12118  0EF5     MOVLW 0xF5
1211A  50E3     MOVF 0xFE3, W, ACCESS
1211C  6EE6     MOVWF 0xFE6, ACCESS
1211E  EC78     CALL 0x1BAF0, 0
12120  F0DD     NOP
12124  F007     NOP
12126  FFE6     NOP
1212A  F00B     NOP
1212C  FFE6     NOP
1212E  0E83     MOVLW 0x83
12130  6EE6     MOVWF 0xFE6, ACCESS
12132  0EFF     MOVLW 0xFF
12134  6EE6     MOVWF 0xFE6, ACCESS
12136  0E00     MOVLW 0x0
12138  6EE6     MOVWF 0xFE6, ACCESS
1213A  0E01     MOVLW 0x1
1213C  6EE6     MOVWF 0xFE6, ACCESS
1213E  EC48     CALL 0x1B690, 0
12140  F0DB     NOP
12144  F007     NOP
12146  FFE6     NOP
1214A  F00B     NOP
1214C  FFE6     NOP
1214E  0E0C     MOVLW 0xC
12150  6EE6     MOVWF 0xFE6, ACCESS
12152  EC1E     CALL 0x19A3C, 0
12154  F0CD     NOP
385:           					sprintf(get_vterm_ptr(2, 0), "%d %2.4f, %d   #", get_raw_result(k), C.calc[k], inp_index + 1);
12156  0EFD     MOVLW 0xFD
12158  50E3     MOVF 0xFE3, W, ACCESS
1215A  6E0B     MOVWF wtemp5, ACCESS
1215C  6A0C     CLRF 0xC, ACCESS
1215E  0E01     MOVLW 0x1
12160  260B     ADDWF wtemp5, F, ACCESS
12162  0E00     MOVLW 0x0
12164  220C     ADDWFC 0xC, F, ACCESS
12168  F02F     NOP
1216A  FFE6     NOP
1216E  F033     NOP
12170  FFE6     NOP
12172  0EF8     MOVLW 0xF8
12174  50E3     MOVF 0xFE3, W, ACCESS
12176  0D04     MULLW 0x4
12178  0EFF     MOVLW 0xFF
1217A  24F3     ADDWF 0xFF3, W, ACCESS
1217C  6ED9     MOVWF 0xFD9, ACCESS
1217E  0E06     MOVLW 0x6
12180  20F4     ADDWFC 0xFF4, W, ACCESS
12182  6EDA     MOVWF 0xFDA, ACCESS
12186  FF7B     NOP
12188  FFE6     NOP
1218C  FF7B     NOP
1218E  FFE6     NOP
12192  FF7B     NOP
12194  FFE6     NOP
12198  FF7B     NOP
1219A  FFE6     NOP
1219C  0EF4     MOVLW 0xF4
1219E  50E3     MOVF 0xFE3, W, ACCESS
121A0  6EE6     MOVWF 0xFE6, ACCESS
121A2  EC78     CALL 0x1BAF0, 0
121A4  F0DD     NOP
121A8  F007     NOP
121AA  FFE6     NOP
121AE  F00B     NOP
121B0  FFE6     NOP
121B2  0E61     MOVLW 0x61
121B4  6EE6     MOVWF 0xFE6, ACCESS
121B6  0EFF     MOVLW 0xFF
121B8  6EE6     MOVWF 0xFE6, ACCESS
121BA  0E00     MOVLW 0x0
121BC  6EE6     MOVWF 0xFE6, ACCESS
121BE  0E02     MOVLW 0x2
121C0  6EE6     MOVWF 0xFE6, ACCESS
121C2  EC48     CALL 0x1B690, 0
121C4  F0DB     NOP
121C8  F007     NOP
121CA  FFE6     NOP
121CE  F00B     NOP
121D0  FFE6     NOP
121D2  0E0C     MOVLW 0xC
121D4  6EE6     MOVWF 0xFE6, ACCESS
121D6  EC1E     CALL 0x19A3C, 0
121D8  F0CD     NOP
386:           					break;
121DA  D016     BRA 0x2208
387:           				default:
388:           					break;
389:           				}
121DC  0100     MOVLB 0x0
121DE  51F7     MOVF H, W, BANKED
121E0  6E0B     MOVWF wtemp5, ACCESS
121E2  6A0C     CLRF 0xC, ACCESS
121E4  500C     MOVF 0xC, W, ACCESS
121E6  0A00     XORLW 0x0
121E8  A4D8     BTFSS 0xFD8, 2, ACCESS
121EA  D00E     BRA 0x2208
121EC  500B     MOVF wtemp5, W, ACCESS
121EE  0A00     XORLW 0x0
121F0  B4D8     BTFSC 0xFD8, 2, ACCESS
121F2  D4DF     BRA 0x1BB2
121F4  0A01     XORLW 0x1
121F6  B4D8     BTFSC 0xFD8, 2, ACCESS
121F8  EFD6     GOTO 0x119AC
121FA  F08C     NOP
121FC  0A03     XORLW 0x3
121FE  B4D8     BTFSC 0xFD8, 2, ACCESS
12200  D5ED     BRA 0x1DDC
12202  0A01     XORLW 0x1
12204  B4D8     BTFSC 0xFD8, 2, ACCESS
12206  D6FB     BRA 0x1FFE
390:           				clear_hid_pflags(&H);
12208  0EF7     MOVLW 0xF7
1220A  6EE6     MOVWF 0xFE6, ACCESS
1220C  EC0C     CALL 0x1BA18, 0
1220E  F0DD     NOP
391:           			}
392:           			StartTimer(TMR_DISPLAY, DDELAY);
12210  0EFA     MOVLW 0xFA
12212  6EE6     MOVWF 0xFE6, ACCESS
12214  0E00     MOVLW 0x0
12216  6EE6     MOVWF 0xFE6, ACCESS
12218  0E0A     MOVLW 0xA
1221A  6EE6     MOVWF 0xFE6, ACCESS
1221C  EC6A     CALL 0x1B2D4, 0
1221E  F0D9     NOP
393:           			V.enter = check_enter_button(&H);
12220  0EF7     MOVLW 0xF7
12222  6EE6     MOVWF 0xFE6, ACCESS
12224  EC8A     CALL 0x1B314, 0
12226  F0D9     NOP
12228  5001     MOVF ltemp0, W, ACCESS
1222A  0101     MOVLB 0x1
1222C  6FDD     MOVWF 0xDD, BANKED
394:           			if (V.enter && (H.hid_display != HID_AUX)) {
1222E  51DD     MOVF 0xDD, W, BANKED
12230  B4D8     BTFSC 0xFD8, 2, ACCESS
12232  D013     BRA 0x225A
12234  0E03     MOVLW 0x3
12236  0100     MOVLB 0x0
12238  19F7     XORWF H, W, BANKED
1223A  B4D8     BTFSC 0xFD8, 2, ACCESS
1223C  D00E     BRA 0x225A
395:           				V.enter = false;
1223E  0101     MOVLB 0x1
12240  6BDD     CLRF 0xDD, BANKED
396:           				V.screen = ~V.screen;
12242  A1CC     BTFSS uart2RxTail, 0, BANKED
12244  D002     BRA 0x224A
12246  0E01     MOVLW 0x1
12248  D001     BRA 0x224C
1224A  0E00     MOVLW 0x0
1224C  0AFF     XORLW 0xFF
1224E  6E0C     MOVWF 0xC, ACCESS
12250  51CC     MOVF uart2RxTail, W, BANKED
12252  180C     XORWF 0xC, W, ACCESS
12254  0BFE     ANDLW 0xFE
12256  180C     XORWF 0xC, W, ACCESS
12258  6FCC     MOVWF uart2RxTail, BANKED
397:           			}
398:           			set_vterm(V.screen);
1225A  0101     MOVLB 0x1
1225C  A1CC     BTFSS uart2RxTail, 0, BANKED
1225E  D002     BRA 0x2264
12260  0E01     MOVLW 0x1
12262  D001     BRA 0x2266
12264  0E00     MOVLW 0x0
12266  6EE6     MOVWF 0xFE6, ACCESS
12268  ECC9     CALL 0x1BB92, 0
1226A  F0DD     NOP
399:           			update_lcd(V.screen);
1226C  0101     MOVLB 0x1
1226E  A1CC     BTFSS uart2RxTail, 0, BANKED
12270  D002     BRA 0x2276
12272  0E01     MOVLW 0x1
12274  D001     BRA 0x2278
12276  0E00     MOVLW 0x0
12278  6EE6     MOVWF 0xFE6, ACCESS
1227A  EC96     CALL 0x1992C, 0
1227C  F0CC     NOP
400:           		}
401:           
402:           		/*
403:           		 * show help display if button pressed
404:           		 */
405:           		check_help(V.flipper);
1227E  0101     MOVLB 0x1
12280  51DB     MOVF 0xDB, W, BANKED
12282  6EE6     MOVWF 0xFE6, ACCESS
12284  ECC1     CALL 0x17F82, 0
12286  F0BF     NOP
406:           
407:           		if (V.enter) {
12288  0101     MOVLB 0x1
1228A  51DD     MOVF 0xDD, W, BANKED
1228C  B4D8     BTFSC 0xFD8, 2, ACCESS
1228E  D062     BRA 0x2354
408:           			V.enter = false;
12290  6BDD     CLRF 0xDD, BANKED
409:           			V.calib = false;
12292  6BDC     CLRF 0xDC, BANKED
410:           			inp_index += 3;
12294  0EFD     MOVLW 0xFD
12298  FF8C     NOP
1229A  F001     NOP
1229C  0E03     MOVLW 0x3
1229E  2601     ADDWF ltemp0, F, ACCESS
122A0  0EFD     MOVLW 0xFD
122A4  F007     NOP
122A6  FFE3     NOP
411:           			if (inp_index > 9)
122A8  0EFD     MOVLW 0xFD
122AC  FF8C     NOP
122AE  F001     NOP
122B0  0E09     MOVLW 0x9
122B2  6401     CPFSGT ltemp0, ACCESS
122B4  D03A     BRA 0x232A
412:           				inp_index = 0;
122B6  0EFD     MOVLW 0xFD
122B8  6AE3     CLRF 0xFE3, ACCESS
122BA  D037     BRA 0x232A
413:           			switch (inp_index) {
414:           			case 0:
415:           				i = C_BATT;
122BC  0EFC     MOVLW 0xFC
122BE  6AE3     CLRF 0xFE3, ACCESS
416:           				j = C_PV;
122C0  0EFB     MOVLW 0xFB
122C2  6AE3     CLRF 0xFE3, ACCESS
122C4  2AE3     INCF 0xFE3, F, ACCESS
417:           				k = V_CC;
122C6  0EFA     MOVLW 0xFA
122C8  6AE3     CLRF 0xFE3, ACCESS
122CA  82E3     BSF 0xFE3, 1, ACCESS
418:           				break;
122CC  D043     BRA 0x2354
419:           			case 3:
420:           				i = V_BAT;
122CE  0EFC     MOVLW 0xFC
122D0  6AE3     CLRF 0xFE3, ACCESS
122D2  84E3     BSF 0xFE3, 2, ACCESS
421:           				j = V_PV;
122D4  0EFB     MOVLW 0xFB
122D6  6AE3     CLRF 0xFE3, ACCESS
122D8  80E3     BSF 0xFE3, 0, ACCESS
122DA  84E3     BSF 0xFE3, 2, ACCESS
422:           				k = V_CBUS;
122DC  0EFA     MOVLW 0xFA
122DE  6AE3     CLRF 0xFE3, ACCESS
122E0  82E3     BSF 0xFE3, 1, ACCESS
122E2  84E3     BSF 0xFE3, 2, ACCESS
423:           				break;
122E4  D037     BRA 0x2354
424:           			case 6:
425:           				i = V_BBAT;
122E6  0EFC     MOVLW 0xFC
122E8  6AE3     CLRF 0xFE3, ACCESS
122EA  82E3     BSF 0xFE3, 1, ACCESS
122EC  86E3     BSF 0xFE3, 3, ACCESS
426:           				j = V_TEMP;
122EE  0E0B     MOVLW 0xB
122F0  6E0C     MOVWF 0xC, ACCESS
122F2  0EFB     MOVLW 0xFB
122F6  F033     NOP
122F8  FFE3     NOP
427:           				k = V_INVERTER;
122FA  0EFA     MOVLW 0xFA
122FC  6AE3     CLRF 0xFE3, ACCESS
122FE  84E3     BSF 0xFE3, 2, ACCESS
12300  86E3     BSF 0xFE3, 3, ACCESS
428:           				break;
12302  D028     BRA 0x2354
429:           			case 9:
430:           				i = V_LIGHT_SENSOR;
12304  0E0D     MOVLW 0xD
12306  6E0C     MOVWF 0xC, ACCESS
12308  0EFC     MOVLW 0xFC
1230C  F033     NOP
1230E  FFE3     NOP
431:           				j = V_LIGHT_SENSOR;
12310  0E0D     MOVLW 0xD
12312  6E0C     MOVWF 0xC, ACCESS
12314  0EFB     MOVLW 0xFB
12318  F033     NOP
1231A  FFE3     NOP
432:           				k = V_LIGHT_SENSOR;
1231C  0E0D     MOVLW 0xD
1231E  6E0C     MOVWF 0xC, ACCESS
12320  0EFA     MOVLW 0xFA
12324  F033     NOP
12326  FFE3     NOP
433:           				break;
12328  D015     BRA 0x2354
434:           			default:
435:           				break;
436:           			}
1232A  0EFD     MOVLW 0xFD
1232C  50E3     MOVF 0xFE3, W, ACCESS
1232E  6E0B     MOVWF wtemp5, ACCESS
12330  6A0C     CLRF 0xC, ACCESS
12332  500C     MOVF 0xC, W, ACCESS
12334  0A00     XORLW 0x0
12336  A4D8     BTFSS 0xFD8, 2, ACCESS
12338  D00D     BRA 0x2354
1233A  500B     MOVF wtemp5, W, ACCESS
1233C  0A00     XORLW 0x0
1233E  B4D8     BTFSC 0xFD8, 2, ACCESS
12340  D7BD     BRA 0x22BC
12342  0A03     XORLW 0x3
12344  B4D8     BTFSC 0xFD8, 2, ACCESS
12346  D7C3     BRA 0x22CE
12348  0A05     XORLW 0x5
1234A  B4D8     BTFSC 0xFD8, 2, ACCESS
1234C  D7CC     BRA 0x22E6
1234E  0A0F     XORLW 0xF
12350  B4D8     BTFSC 0xFD8, 2, ACCESS
12352  D7D8     BRA 0x2304
437:           		};
438:           
439:           		/*
440:           		 * show command messages if flag is set for timer duration
441:           		 */
442:           		if (V.set_sequ) {
12354  A1CB     BTFSS uart2RxCount, 0, BANKED
12356  EF8A     GOTO 0x11914
12358  F08C     NOP
443:           			if (TimerDone(TMR_INFO)) {
1235A  0E07     MOVLW 0x7
1235C  6EE6     MOVWF 0xFE6, ACCESS
1235E  ECF3     CALL 0x1B7E6, 0
12360  F0DB     NOP
12362  5001     MOVF ltemp0, W, ACCESS
12364  B4D8     BTFSC 0xFD8, 2, ACCESS
12366  D00C     BRA 0x2380
444:           				V.set_sequ = false;
12368  0101     MOVLB 0x1
1236A  91CB     BCF uart2RxCount, 0, BANKED
445:           				set_vterm(0);
1236C  0E00     MOVLW 0x0
1236E  6EE6     MOVWF 0xFE6, ACCESS
12370  ECC9     CALL 0x1BB92, 0
12372  F0DD     NOP
446:           				update_lcd(0);
12374  0E00     MOVLW 0x0
12376  6EE6     MOVWF 0xFE6, ACCESS
12378  EC96     CALL 0x1992C, 0
1237A  F0CC     NOP
447:           			} else {
1237C  EF8A     GOTO 0x11914
1237E  F08C     NOP
448:           				set_vterm(2);
12380  0E02     MOVLW 0x2
12382  6EE6     MOVWF 0xFE6, ACCESS
12384  ECC9     CALL 0x1BB92, 0
12386  F0DD     NOP
449:           				update_lcd(2);
12388  0E02     MOVLW 0x2
1238A  6EE6     MOVWF 0xFE6, ACCESS
1238C  EC96     CALL 0x1992C, 0
1238E  F0CC     NOP
12390  EF8A     GOTO 0x11914
12392  F08C     NOP
450:           			}
451:           		}
452:           	}
453:           }
454:           
455:           /**
456:            End of File
457:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/hid.c  ---------------------------------------------------
1:             #include "hid.h"
2:             
3:             H_data* hid_input(H_data* h)
4:             {
5:             	if (get_switch(SSELECT)) {
1A818  0E02     MOVLW 0x2
1A81A  6EE6     MOVWF 0xFE6, ACCESS
1A81C  EC5F     CALL 0x1B6BE, 0
1A81E  F0DB     NOP
1A820  5001     MOVF ltemp0, W, ACCESS
1A822  B4D8     BTFSC 0xFD8, 2, ACCESS
1A824  D01C     BRA 0xA85E
6:             		h->wait_select = false;
1A826  0EFF     MOVLW 0xFF
1A828  50E3     MOVF 0xFE3, W, ACCESS
1A82A  6ED9     MOVWF 0xFD9, ACCESS
1A82C  6ADA     CLRF 0xFDA, ACCESS
1A82E  0E02     MOVLW 0x2
1A830  26D9     ADDWF 0xFD9, F, ACCESS
1A832  0E00     MOVLW 0x0
1A834  6EDF     MOVWF 0xFDF, ACCESS
7:             		h->select_p = get_switch(SSELECT);
1A836  0E02     MOVLW 0x2
1A838  6EE6     MOVWF 0xFE6, ACCESS
1A83A  EC5F     CALL 0x1B6BE, 0
1A83C  F0DB     NOP
1A83E  5001     MOVF ltemp0, W, ACCESS
1A840  B4D8     BTFSC 0xFD8, 2, ACCESS
1A842  D003     BRA 0xA84A
1A844  6A0C     CLRF 0xC, ACCESS
1A846  2A0C     INCF 0xC, F, ACCESS
1A848  D001     BRA 0xA84C
1A84A  6A0C     CLRF 0xC, ACCESS
1A84C  0EFF     MOVLW 0xFF
1A84E  50E3     MOVF 0xFE3, W, ACCESS
1A850  6ED9     MOVWF 0xFD9, ACCESS
1A852  6ADA     CLRF 0xFDA, ACCESS
1A854  0E03     MOVLW 0x3
1A856  26D9     ADDWF 0xFD9, F, ACCESS
1A85A  F033     NOP
1A85C  FFDF     NOP
8:             	}
9:             
10:            	if (get_switch(SENTER)) {
1A85E  0E03     MOVLW 0x3
1A860  6EE6     MOVWF 0xFE6, ACCESS
1A862  EC5F     CALL 0x1B6BE, 0
1A864  F0DB     NOP
1A866  5001     MOVF ltemp0, W, ACCESS
1A868  B4D8     BTFSC 0xFD8, 2, ACCESS
1A86A  D01C     BRA 0xA8A4
11:            		h->wait_enter = false;
1A86C  0EFF     MOVLW 0xFF
1A86E  50E3     MOVF 0xFE3, W, ACCESS
1A870  6ED9     MOVWF 0xFD9, ACCESS
1A872  6ADA     CLRF 0xFDA, ACCESS
1A874  0E04     MOVLW 0x4
1A876  26D9     ADDWF 0xFD9, F, ACCESS
1A878  0E00     MOVLW 0x0
1A87A  6EDF     MOVWF 0xFDF, ACCESS
12:            		h->enter_p = get_switch(SENTER);
1A87C  0E03     MOVLW 0x3
1A87E  6EE6     MOVWF 0xFE6, ACCESS
1A880  EC5F     CALL 0x1B6BE, 0
1A882  F0DB     NOP
1A884  5001     MOVF ltemp0, W, ACCESS
1A886  B4D8     BTFSC 0xFD8, 2, ACCESS
1A888  D003     BRA 0xA890
1A88A  6A0C     CLRF 0xC, ACCESS
1A88C  2A0C     INCF 0xC, F, ACCESS
1A88E  D001     BRA 0xA892
1A890  6A0C     CLRF 0xC, ACCESS
1A892  0EFF     MOVLW 0xFF
1A894  50E3     MOVF 0xFE3, W, ACCESS
1A896  6ED9     MOVWF 0xFD9, ACCESS
1A898  6ADA     CLRF 0xFDA, ACCESS
1A89A  0E05     MOVLW 0x5
1A89C  26D9     ADDWF 0xFD9, F, ACCESS
1A8A0  F033     NOP
1A8A2  FFDF     NOP
13:            	}
14:            	return h;
15:            }
1A8A4  52E5     MOVF 0xFE5, F, ACCESS
1A8A6  0012     RETURN 0
16:            
17:            H_data* hid_display(H_data* h)
18:            {
19:            	hid_input(h);
19B46  0EFF     MOVLW 0xFF
19B48  50E3     MOVF 0xFE3, W, ACCESS
19B4A  6EE6     MOVWF 0xFE6, ACCESS
19B4C  EC0C     CALL 0x1A818, 0
19B4E  F0D4     NOP
20:            
21:            	switch (h->h_state) {
19B50  D066     BRA 0x9C1E
22:            	case H_STATE_INIT:
23:            		h->h_state = H_STATE_DISPLAY;
19B52  0EFF     MOVLW 0xFF
19B54  50E3     MOVF 0xFE3, W, ACCESS
19B56  6ED9     MOVWF 0xFD9, ACCESS
19B58  6ADA     CLRF 0xFDA, ACCESS
19B5A  0E01     MOVLW 0x1
19B5C  26D9     ADDWF 0xFD9, F, ACCESS
19B5E  0E01     MOVLW 0x1
19B60  6EDF     MOVWF 0xFDF, ACCESS
24:            		h->hid_display = HID_MAIN;
19B62  0EFF     MOVLW 0xFF
19B64  50E3     MOVF 0xFE3, W, ACCESS
19B66  6ED9     MOVWF 0xFD9, ACCESS
19B68  6ADA     CLRF 0xFDA, ACCESS
19B6A  0E00     MOVLW 0x0
19B6C  6EDF     MOVWF 0xFDF, ACCESS
25:            		h->wait_enter = true;
19B6E  0EFF     MOVLW 0xFF
19B70  50E3     MOVF 0xFE3, W, ACCESS
19B72  6ED9     MOVWF 0xFD9, ACCESS
19B74  6ADA     CLRF 0xFDA, ACCESS
19B76  0E04     MOVLW 0x4
19B78  26D9     ADDWF 0xFD9, F, ACCESS
19B7A  0E01     MOVLW 0x1
19B7C  6EDF     MOVWF 0xFDF, ACCESS
26:            		h->wait_select = true;
19B7E  0EFF     MOVLW 0xFF
19B80  50E3     MOVF 0xFE3, W, ACCESS
19B82  6ED9     MOVWF 0xFD9, ACCESS
19B84  6ADA     CLRF 0xFDA, ACCESS
19B86  0E02     MOVLW 0x2
19B88  26D9     ADDWF 0xFD9, F, ACCESS
19B8A  0E01     MOVLW 0x1
19B8C  6EDF     MOVWF 0xFDF, ACCESS
27:            		h->select_p = SW_OFF;
19B8E  0EFF     MOVLW 0xFF
19B90  50E3     MOVF 0xFE3, W, ACCESS
19B92  6ED9     MOVWF 0xFD9, ACCESS
19B94  6ADA     CLRF 0xFDA, ACCESS
19B96  0E03     MOVLW 0x3
19B98  26D9     ADDWF 0xFD9, F, ACCESS
19B9A  0E00     MOVLW 0x0
19B9C  6EDF     MOVWF 0xFDF, ACCESS
28:            		h->enter_p = SW_OFF;
19B9E  0EFF     MOVLW 0xFF
19BA0  50E3     MOVF 0xFE3, W, ACCESS
19BA2  6ED9     MOVWF 0xFD9, ACCESS
19BA4  6ADA     CLRF 0xFDA, ACCESS
19BA6  0E05     MOVLW 0x5
19BA8  26D9     ADDWF 0xFD9, F, ACCESS
19BAA  0E00     MOVLW 0x0
19BAC  D036     BRA 0x9C1A
29:            		break;
30:            	default:
31:            	case H_STATE_DISPLAY:
32:            		if (!h->wait_select && (h->select_p == SW_OFF)) {
19BAE  0EFF     MOVLW 0xFF
19BB0  50E3     MOVF 0xFE3, W, ACCESS
19BB2  6ED9     MOVWF 0xFD9, ACCESS
19BB4  6ADA     CLRF 0xFDA, ACCESS
19BB6  0E02     MOVLW 0x2
19BB8  26D9     ADDWF 0xFD9, F, ACCESS
19BBA  50DF     MOVF 0xFDF, W, ACCESS
19BBC  A4D8     BTFSS 0xFD8, 2, ACCESS
19BBE  D042     BRA 0x9C44
19BC0  0EFF     MOVLW 0xFF
19BC2  50E3     MOVF 0xFE3, W, ACCESS
19BC4  6ED9     MOVWF 0xFD9, ACCESS
19BC6  6ADA     CLRF 0xFDA, ACCESS
19BC8  0E03     MOVLW 0x3
19BCA  26D9     ADDWF 0xFD9, F, ACCESS
19BCC  50DF     MOVF 0xFDF, W, ACCESS
19BCE  A4D8     BTFSS 0xFD8, 2, ACCESS
19BD0  D039     BRA 0x9C44
33:            			h->sequence = ++h->sequence & 0x3;
19BD2  0EFF     MOVLW 0xFF
19BD4  50E3     MOVF 0xFE3, W, ACCESS
19BD6  6ED9     MOVWF 0xFD9, ACCESS
19BD8  6ADA     CLRF 0xFDA, ACCESS
19BDA  0E06     MOVLW 0x6
19BDC  26D9     ADDWF 0xFD9, F, ACCESS
19BDE  0EFF     MOVLW 0xFF
19BE0  50E3     MOVF 0xFE3, W, ACCESS
19BE2  6EE9     MOVWF 0xFE9, ACCESS
19BE4  6AEA     CLRF 0xFEA, ACCESS
19BE6  0E06     MOVLW 0x6
19BE8  26E9     ADDWF 0xFE9, F, ACCESS
19BEA  2AEF     INCF 0xFEF, F, ACCESS
19BEC  50EF     MOVF 0xFEF, W, ACCESS
19BEE  0B03     ANDLW 0x3
19BF0  6EDF     MOVWF 0xFDF, ACCESS
34:            			h->hid_display = h->sequence;
19BF2  0EFF     MOVLW 0xFF
19BF4  50E3     MOVF 0xFE3, W, ACCESS
19BF6  6ED9     MOVWF 0xFD9, ACCESS
19BF8  6ADA     CLRF 0xFDA, ACCESS
19BFA  0E06     MOVLW 0x6
19BFC  26D9     ADDWF 0xFD9, F, ACCESS
19BFE  0EFF     MOVLW 0xFF
19C00  50E3     MOVF 0xFE3, W, ACCESS
19C02  6EE9     MOVWF 0xFE9, ACCESS
19C04  6AEA     CLRF 0xFEA, ACCESS
19C08  FF7F     NOP
19C0A  FFEF     NOP
35:            			h->wait_select = true;
19C0C  0EFF     MOVLW 0xFF
19C0E  50E3     MOVF 0xFE3, W, ACCESS
19C10  6ED9     MOVWF 0xFD9, ACCESS
19C12  6ADA     CLRF 0xFDA, ACCESS
19C14  0E02     MOVLW 0x2
19C16  26D9     ADDWF 0xFD9, F, ACCESS
19C18  0E01     MOVLW 0x1
19C1A  6EDF     MOVWF 0xFDF, ACCESS
19C1C  D013     BRA 0x9C44
36:            		}
37:            		break;
38:            	}
19C1E  0EFF     MOVLW 0xFF
19C20  50E3     MOVF 0xFE3, W, ACCESS
19C22  6ED9     MOVWF 0xFD9, ACCESS
19C24  6ADA     CLRF 0xFDA, ACCESS
19C26  0E01     MOVLW 0x1
19C28  26D9     ADDWF 0xFD9, F, ACCESS
19C2A  50DF     MOVF 0xFDF, W, ACCESS
19C2C  6E0B     MOVWF wtemp5, ACCESS
19C2E  6A0C     CLRF 0xC, ACCESS
19C30  500C     MOVF 0xC, W, ACCESS
19C32  0A00     XORLW 0x0
19C34  A4D8     BTFSS 0xFD8, 2, ACCESS
19C36  D7BB     BRA 0x9BAE
19C38  500B     MOVF wtemp5, W, ACCESS
19C3A  0A00     XORLW 0x0
19C3C  B4D8     BTFSC 0xFD8, 2, ACCESS
19C3E  D789     BRA 0x9B52
19C40  0A01     XORLW 0x1
19C42  D7B5     BRA 0x9BAE
39:            	return h;
40:            }
19C44  52E5     MOVF 0xFE5, F, ACCESS
19C46  0012     RETURN 0
41:            
42:            bool check_enter_button(H_data* h)
43:            {
44:            	if (!h->wait_enter && (h->enter_p == SW_OFF)) {
1B314  0EFF     MOVLW 0xFF
1B316  50E3     MOVF 0xFE3, W, ACCESS
1B318  6ED9     MOVWF 0xFD9, ACCESS
1B31A  6ADA     CLRF 0xFDA, ACCESS
1B31C  0E04     MOVLW 0x4
1B31E  26D9     ADDWF 0xFD9, F, ACCESS
1B320  50DF     MOVF 0xFDF, W, ACCESS
1B322  A4D8     BTFSS 0xFD8, 2, ACCESS
1B324  D013     BRA 0xB34C
1B326  0EFF     MOVLW 0xFF
1B328  50E3     MOVF 0xFE3, W, ACCESS
1B32A  6ED9     MOVWF 0xFD9, ACCESS
1B32C  6ADA     CLRF 0xFDA, ACCESS
1B32E  0E05     MOVLW 0x5
1B330  26D9     ADDWF 0xFD9, F, ACCESS
1B332  50DF     MOVF 0xFDF, W, ACCESS
1B334  A4D8     BTFSS 0xFD8, 2, ACCESS
1B336  D00A     BRA 0xB34C
45:            		h->wait_enter = true;
1B338  0EFF     MOVLW 0xFF
1B33A  50E3     MOVF 0xFE3, W, ACCESS
1B33C  6ED9     MOVWF 0xFD9, ACCESS
1B33E  6ADA     CLRF 0xFDA, ACCESS
1B340  0E04     MOVLW 0x4
1B342  26D9     ADDWF 0xFD9, F, ACCESS
1B344  0E01     MOVLW 0x1
1B346  6EDF     MOVWF 0xFDF, ACCESS
46:            		return true;
1B348  0E01     MOVLW 0x1
1B34A  D001     BRA 0xB34E
47:            	}
48:            	return false;
1B34C  0E00     MOVLW 0x0
1B34E  6E01     MOVWF ltemp0, ACCESS
49:            }
1B350  52E5     MOVF 0xFE5, F, ACCESS
1B352  0012     RETURN 0
50:            
51:            void clear_hid_pflags(H_data* h)
52:            {
53:            	h->select_p = SW_OFF;
1BA18  0EFF     MOVLW 0xFF
1BA1A  50E3     MOVF 0xFE3, W, ACCESS
1BA1C  6ED9     MOVWF 0xFD9, ACCESS
1BA1E  6ADA     CLRF 0xFDA, ACCESS
1BA20  0E03     MOVLW 0x3
1BA22  26D9     ADDWF 0xFD9, F, ACCESS
1BA24  0E00     MOVLW 0x0
1BA26  6EDF     MOVWF 0xFDF, ACCESS
54:            	h->enter_p = SW_OFF;
1BA28  0EFF     MOVLW 0xFF
1BA2A  50E3     MOVF 0xFE3, W, ACCESS
1BA2C  6ED9     MOVWF 0xFD9, ACCESS
1BA2E  6ADA     CLRF 0xFDA, ACCESS
1BA30  0E05     MOVLW 0x5
1BA32  26D9     ADDWF 0xFD9, F, ACCESS
1BA34  0E00     MOVLW 0x0
1BA36  6EDF     MOVWF 0xFDF, ACCESS
55:            }
1BA38  52E5     MOVF 0xFE5, F, ACCESS
1BA3A  0012     RETURN 0
56:            
57:            void clear_hid_wflags(H_data* h)
58:            {
59:            	h->wait_enter = true;
60:            	h->wait_select = true;
61:            }
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/eadog.c  -------------------------------------------------
1:             #include "vconfig.h"
2:             #include "eadog.h"
3:             #include "ringbufs.h"
4:             #include <stdio.h>
5:             #include <string.h>
6:             
7:             
8:             
9:             #define max_strlen	64
10:            #define max_port_data	512
11:            
12:            struct spi_link_type spi_link;
13:            struct ringBufS_t ring_buf1;
14:            struct ringBufS_t ring_buf2;
15:            static uint8_t port_data[max_port_data] = {255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0};
16:            
17:            extern struct V_data V;
18:            
19:            static void send_lcd_cmd_long(uint8_t); // for display init only
20:            static void send_lcd_data(uint8_t);
21:            static void send_lcd_cmd(uint8_t);
22:            
23:            void wdtdelay(const uint32_t delay)
24:            {
25:            	static uint32_t dcount;
26:            
27:            	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
1AE60  0100     MOVLB 0x0
1AE62  6B9A     CLRF dcount, BANKED
1AE64  6B9B     CLRF 0x9B, BANKED
1AE66  6B9C     CLRF 0x9C, BANKED
1AE68  6B9D     CLRF 0x9D, BANKED
28:            		Nop();
1AE6A  F000     NOP
29:            		ClrWdt(); // reset the WDT timer
1AE6C  0004     CLRWDT
30:            	};
1AE6E  0E01     MOVLW 0x1
1AE70  0100     MOVLB 0x0
1AE72  279A     ADDWF dcount, F, BANKED
1AE74  0E00     MOVLW 0x0
1AE76  239B     ADDWFC 0x9B, F, BANKED
1AE78  239C     ADDWFC 0x9C, F, BANKED
1AE7A  239D     ADDWFC 0x9D, F, BANKED
1AE7C  0EFC     MOVLW 0xFC
1AE80  FF8C     NOP
1AE82  F001     NOP
1AE84  519A     MOVF dcount, W, BANKED
1AE86  5C01     SUBWF ltemp0, W, ACCESS
1AE88  0EFD     MOVLW 0xFD
1AE8C  FF8C     NOP
1AE8E  F001     NOP
1AE90  519B     MOVF 0x9B, W, BANKED
1AE92  5801     SUBWFB ltemp0, W, ACCESS
1AE94  0EFE     MOVLW 0xFE
1AE98  FF8C     NOP
1AE9A  F001     NOP
1AE9C  519C     MOVF 0x9C, W, BANKED
1AE9E  5801     SUBWFB ltemp0, W, ACCESS
1AEA0  0EFF     MOVLW 0xFF
1AEA4  FF8C     NOP
1AEA6  F001     NOP
1AEA8  519D     MOVF 0x9D, W, BANKED
1AEAA  5801     SUBWFB ltemp0, W, ACCESS
1AEAC  B0D8     BTFSC 0xFD8, 0, ACCESS
1AEAE  D7DD     BRA 0xAE6A
31:            
32:            }
1AEB0  52E5     MOVF 0xFE5, F, ACCESS
1AEB2  52E5     MOVF 0xFE5, F, ACCESS
1AEB4  52E5     MOVF 0xFE5, F, ACCESS
1AEB6  52E5     MOVF 0xFE5, F, ACCESS
1AEB8  0012     RETURN 0
33:            
34:            /*
35:             * Init the EA DOGM163 in 8-bit serial mode
36:             * channel 1 DMA
37:             */
38:            void init_display(void)
39:            {
40:            	spi_link.tx1a = &ring_buf1;
19D38  0E83     MOVLW 0x83
19D3A  0100     MOVLB 0x0
19D3C  6F66     MOVWF 0x66, BANKED
19D3E  0E03     MOVLW 0x3
19D40  6F67     MOVWF 0x67, BANKED
41:            	spi_link.tx1b = &ring_buf2;
19D42  0E40     MOVLW 0x40
19D44  6F64     MOVWF 0x64, BANKED
19D46  0E03     MOVLW 0x3
19D48  6F65     MOVWF 0x65, BANKED
42:            	ringBufS_init(spi_link.tx1a);
19D4C  F19B     NOP
19D4E  FFE6     NOP
19D52  F19F     NOP
19D54  FFE6     NOP
19D56  ECDF     CALL 0x1B7BE, 0
19D58  F0DB     NOP
43:            	ringBufS_init(spi_link.tx1b);
19D5C  F193     NOP
19D5E  FFE6     NOP
19D62  F197     NOP
19D64  FFE6     NOP
19D66  ECDF     CALL 0x1B7BE, 0
19D68  F0DB     NOP
44:            
45:            	DLED = true;
19D6A  84BE     BSF 0xFBE, 2, ACCESS
46:            #ifdef NHD
47:            	// mode 3
48:            	SPI1CON1 = 0x20;
49:            	// SSET disabled; RXR suspended if the RxFIFO is full; TXR required for a transfer; 
50:            	SPI1CON2 = 0x03;
51:            	// BAUD 0; 
52:            	SPI1BAUD = 0xFF; // 125kHz
53:            	// CLKSEL FOSC; 
54:            	SPI1CLK = 0x00;
55:            	// BMODE every byte; LSBF MSb first; EN enabled; MST bus master; 
56:            	SPI1CON0 = 0x83;
57:            #else
58:            	CSB_SetHigh();
19D6C  84BC     BSF 0xFBC, 2, ACCESS
59:            	wdtdelay(350000); // > 400ms power up delay
19D6E  0E30     MOVLW 0x30
19D70  6EE6     MOVWF 0xFE6, ACCESS
19D72  0E57     MOVLW 0x57
19D74  6EE6     MOVWF 0xFE6, ACCESS
19D76  0E05     MOVLW 0x5
19D78  6EE6     MOVWF 0xFE6, ACCESS
19D7A  0E00     MOVLW 0x0
19D7C  6EE6     MOVWF 0xFE6, ACCESS
19D7E  EC30     CALL 0x1AE60, 0
19D80  F0D7     NOP
60:            	send_lcd_cmd(0x39);
19D82  0E39     MOVLW 0x39
19D84  6EE6     MOVWF 0xFE6, ACCESS
19D86  ECCB     CALL 0x1B796, 0
19D88  F0DB     NOP
61:            	send_lcd_cmd(0x1d);
19D8A  0E1D     MOVLW 0x1D
19D8C  6EE6     MOVWF 0xFE6, ACCESS
19D8E  ECCB     CALL 0x1B796, 0
19D90  F0DB     NOP
62:            	send_lcd_cmd(0x50);
19D92  0E50     MOVLW 0x50
19D94  6EE6     MOVWF 0xFE6, ACCESS
19D96  ECCB     CALL 0x1B796, 0
19D98  F0DB     NOP
63:            	send_lcd_cmd(0x6c);
19D9A  0E6C     MOVLW 0x6C
19D9C  6EE6     MOVWF 0xFE6, ACCESS
19D9E  ECCB     CALL 0x1B796, 0
19DA0  F0DB     NOP
64:            	send_lcd_cmd(0x76); // contrast last 4 bits
19DA2  0E76     MOVLW 0x76
19DA4  6EE6     MOVWF 0xFE6, ACCESS
19DA6  ECCB     CALL 0x1B796, 0
19DA8  F0DB     NOP
65:            	send_lcd_cmd_long(0x38); // follower control
19DAA  0E38     MOVLW 0x38
19DAC  6EE6     MOVWF 0xFE6, ACCESS
19DAE  ECB7     CALL 0x1B76E, 0
19DB0  F0DB     NOP
66:            	send_lcd_cmd(0x0f);
19DB2  0E0F     MOVLW 0xF
19DB4  6EE6     MOVWF 0xFE6, ACCESS
19DB6  ECCB     CALL 0x1B796, 0
19DB8  F0DB     NOP
67:            	send_lcd_cmd_long(0x01); // clear
19DBA  0E01     MOVLW 0x1
19DBC  6EE6     MOVWF 0xFE6, ACCESS
19DBE  ECB7     CALL 0x1B76E, 0
19DC0  F0DB     NOP
68:            	send_lcd_cmd(0x02);
19DC2  0E02     MOVLW 0x2
19DC4  6EE6     MOVWF 0xFE6, ACCESS
19DC6  ECCB     CALL 0x1B796, 0
19DC8  F0DB     NOP
69:            	send_lcd_cmd(0x06);
19DCA  0E06     MOVLW 0x6
19DCC  6EE6     MOVWF 0xFE6, ACCESS
19DCE  ECCB     CALL 0x1B796, 0
19DD0  F0DB     NOP
70:            	wdtdelay(30);
19DD2  0E1E     MOVLW 0x1E
19DD4  6EE6     MOVWF 0xFE6, ACCESS
19DD6  0E00     MOVLW 0x0
19DD8  6EE6     MOVWF 0xFE6, ACCESS
19DDA  0E00     MOVLW 0x0
19DDC  6EE6     MOVWF 0xFE6, ACCESS
19DDE  0E00     MOVLW 0x0
19DE0  6EE6     MOVWF 0xFE6, ACCESS
19DE2  EC30     CALL 0x1AE60, 0
19DE4  F0D7     NOP
71:            	SPI1CON2 = 0x02;
19DE6  0E02     MOVLW 0x2
19DE8  013D     MOVLB 0x3D
19DEA  6F16     MOVWF 0x16, BANKED
72:            	SPI1CON1 = 0x40;
19DEC  0E40     MOVLW 0x40
19DEE  6F15     MOVWF 0x15, BANKED
73:            	SPI1CON0 = 0x83;
19DF0  0E83     MOVLW 0x83
19DF2  6F14     MOVWF 0x14, BANKED
74:            #endif
75:            	SPI1INTFbits.SPI1TXUIF = 0;
19DF4  931A     BCF 0x1A, 1, BANKED
76:            	DMA1CON1bits.DMODE = 0;
19DF6  0E3F     MOVLW 0x3F
19DF8  013B     MOVLB 0x3B
19DFA  17FD     ANDWF 0xFD, F, BANKED
77:            	DMA1CON1bits.DSTP = 0;
19DFC  9BFD     BCF 0xFD, 5, BANKED
78:            	DMA1CON1bits.SMODE = 1;
19DFE  51FD     MOVF 0xFD, W, BANKED
19E00  0BF9     ANDLW 0xF9
19E02  0902     IORLW 0x2
19E04  6FFD     MOVWF 0xFD, BANKED
79:            	DMA1CON1bits.SMR = 0;
19E06  0EE7     MOVLW 0xE7
19E08  17FD     ANDWF 0xFD, F, BANKED
80:            	DMA1CON1bits.SSTP = 1;
19E0A  81FD     BSF 0xFD, 0, BANKED
81:            	DMA1SSA = (uint32_t) & ring_buf1;
19E0C  0E83     MOVLW 0x83
19E0E  6FF9     MOVWF 0xF9, BANKED
19E10  0E03     MOVLW 0x3
19E12  6FFA     MOVWF 0xFA, BANKED
19E14  0E00     MOVLW 0x0
19E16  6FFB     MOVWF 0xFB, BANKED
82:            	DMA1CON0bits.DGO = 0;
19E18  9BFC     BCF 0xFC, 5, BANKED
83:            	SPI1INTFbits.SPI1TXUIF = 1;
19E1A  013D     MOVLB 0x3D
19E1C  831A     BSF 0x1A, 1, BANKED
84:            	DLED = false;
19E1E  94BE     BCF 0xFBE, 2, ACCESS
85:            }
19E20  0012     RETURN 0
86:            
87:            /*
88:             * channel 2 DMA, serial port 1 transmit
89:             */
90:            void init_port_dma(void)
91:            {
92:            	DMA2CON1bits.DMODE = 0;
1B5D0  0E3F     MOVLW 0x3F
1B5D2  013B     MOVLB 0x3B
1B5D4  17DD     ANDWF 0xDD, F, BANKED
93:            	DMA2CON1bits.DSTP = 0;
1B5D6  9BDD     BCF 0xDD, 5, BANKED
94:            	DMA2CON1bits.SMODE = 1;
1B5D8  51DD     MOVF 0xDD, W, BANKED
1B5DA  0BF9     ANDLW 0xF9
1B5DC  0902     IORLW 0x2
1B5DE  6FDD     MOVWF 0xDD, BANKED
95:            	DMA2CON1bits.SMR = 0;
1B5E0  0EE7     MOVLW 0xE7
1B5E2  17DD     ANDWF 0xDD, F, BANKED
96:            	DMA2CON1bits.SSTP = 1;
1B5E4  81DD     BSF 0xDD, 0, BANKED
97:            	DMA2CON0bits.SIRQEN = 0;
1B5E6  9DDC     BCF 0xDC, 6, BANKED
98:            	DMA2DSA = 0x3DEA; // U1TXB SERIAL PORT 1
1B5E8  0E3D     MOVLW 0x3D
1B5EA  6FD1     MOVWF 0xD1, BANKED
1B5EC  0EEA     MOVLW 0xEA
1B5EE  6FD0     MOVWF 0xD0, BANKED
99:            	DMA2SSA = (uint32_t) port_data;
1B5F0  0EFF     MOVLW 0xFF
1B5F2  6FD9     MOVWF 0xD9, BANKED
1B5F4  0E04     MOVLW 0x4
1B5F6  6FDA     MOVWF 0xDA, BANKED
1B5F8  0E00     MOVLW 0x0
1B5FA  6FDB     MOVWF 0xDB, BANKED
100:           	DMA2CON0bits.DGO = 0;
1B5FC  9BDC     BCF 0xDC, 5, BANKED
101:           }
1B5FE  0012     RETURN 0
102:           
103:           /*
104:            * add short spi delay (default)
105:            */
106:           static void send_lcd_data(const uint8_t data)
107:           {
108:           	RS_SetHigh();
109:           	CSB_SetLow();
110:           	SPI1_Exchange8bit(data);
111:           	wdtdelay(8);
112:           }
113:           
114:           /*
115:            * add inst spi delay
116:            */
117:           static void send_lcd_cmd(const uint8_t cmd)
118:           {
119:           	RS_SetLow();
1B796  92BC     BCF 0xFBC, 1, ACCESS
120:           	CSB_SetLow();
1B798  94BC     BCF 0xFBC, 2, ACCESS
121:           	SPI1_Exchange8bit(cmd);
1B79A  0EFF     MOVLW 0xFF
1B79C  50E3     MOVF 0xFE3, W, ACCESS
1B79E  6EE6     MOVWF 0xFE6, ACCESS
1B7A0  ECBA     CALL 0x1BB74, 0
1B7A2  F0DD     NOP
122:           	wdtdelay(30);
1B7A4  0E1E     MOVLW 0x1E
1B7A6  6EE6     MOVWF 0xFE6, ACCESS
1B7A8  0E00     MOVLW 0x0
1B7AA  6EE6     MOVWF 0xFE6, ACCESS
1B7AC  0E00     MOVLW 0x0
1B7AE  6EE6     MOVWF 0xFE6, ACCESS
1B7B0  0E00     MOVLW 0x0
1B7B2  6EE6     MOVWF 0xFE6, ACCESS
1B7B4  EC30     CALL 0x1AE60, 0
1B7B6  F0D7     NOP
123:           	RS_SetHigh();
1B7B8  82BC     BSF 0xFBC, 1, ACCESS
124:           }
1B7BA  52E5     MOVF 0xFE5, F, ACCESS
1B7BC  0012     RETURN 0
125:           
126:           /*
127:            * add clear/home spi delay
128:            */
129:           static void send_lcd_cmd_long(const uint8_t cmd)
130:           {
131:           	RS_SetLow();
1B76E  92BC     BCF 0xFBC, 1, ACCESS
132:           	CSB_SetLow();
1B770  94BC     BCF 0xFBC, 2, ACCESS
133:           	SPI1_Exchange8bit(cmd);
1B772  0EFF     MOVLW 0xFF
1B774  50E3     MOVF 0xFE3, W, ACCESS
1B776  6EE6     MOVWF 0xFE6, ACCESS
1B778  ECBA     CALL 0x1BB74, 0
1B77A  F0DD     NOP
134:           	wdtdelay(800);
1B77C  0E20     MOVLW 0x20
1B77E  6EE6     MOVWF 0xFE6, ACCESS
1B780  0E03     MOVLW 0x3
1B782  6EE6     MOVWF 0xFE6, ACCESS
1B784  0E00     MOVLW 0x0
1B786  6EE6     MOVWF 0xFE6, ACCESS
1B788  0E00     MOVLW 0x0
1B78A  6EE6     MOVWF 0xFE6, ACCESS
1B78C  EC30     CALL 0x1AE60, 0
1B78E  F0D7     NOP
135:           	RS_SetHigh();
1B790  82BC     BSF 0xFBC, 1, ACCESS
136:           }
1B792  52E5     MOVF 0xFE5, F, ACCESS
1B794  0012     RETURN 0
137:           
138:           /*
139:            * Trigger the SPI DMA transfer to the LCD display
140:            */
141:           void start_lcd(void)
142:           {
143:           	DMA1CON0bits.DMA1SIRQEN = 1; /* start DMA trigger */
1BDDA  013B     MOVLB 0x3B
1BDDC  8DFC     BSF 0xFC, 6, BANKED
144:           }
1BDDE  0012     RETURN 0
145:           
146:           void wait_lcd_set(void)
147:           {
148:           	spi_link.LCD_DATA = 1;
1BDD4  0100     MOVLB 0x0
1BDD6  8760     BSF spi_link, 3, BANKED
149:           }
1BDD8  0012     RETURN 0
150:           
151:           bool wait_lcd_check(void)
152:           {
153:           	return spi_link.LCD_DATA;
154:           }
155:           
156:           void wait_lcd_done(void)
157:           {
158:           	while (spi_link.LCD_DATA);
1BBEC  0100     MOVLB 0x0
1BBEE  B760     BTFSC spi_link, 3, BANKED
1BBF0  D7FD     BRA 0xBBEC
159:           	wdtdelay(50);
1BBF2  0E32     MOVLW 0x32
1BBF4  6EE6     MOVWF 0xFE6, ACCESS
1BBF6  0E00     MOVLW 0x0
1BBF8  6EE6     MOVWF 0xFE6, ACCESS
1BBFA  0E00     MOVLW 0x0
1BBFC  6EE6     MOVWF 0xFE6, ACCESS
1BBFE  0E00     MOVLW 0x0
1BC00  6EE6     MOVWF 0xFE6, ACCESS
1BC02  EC30     CALL 0x1AE60, 0
1BC04  F0D7     NOP
160:           }
1BC06  0012     RETURN 0
161:           
162:           void eaDogM_WriteChr(const int8_t value)
163:           {
164:           	send_lcd_data_dma((uint8_t) value);
165:           }
166:           
167:           /*
168:            * STDOUT user handler function
169:            */
170:           void putch(char c)
171:           {
172:           	ringBufS_put_dma(spi_link.tx1a, c);
1BC08  0EFF     MOVLW 0xFF
1BC0A  50E3     MOVF 0xFE3, W, ACCESS
1BC0C  6EE6     MOVWF 0xFE6, ACCESS
1BC10  F19B     NOP
1BC12  FFE6     NOP
1BC16  F19F     NOP
1BC18  FFE6     NOP
1BC1A  EC34     CALL 0x1A468, 0
1BC1C  F0D2     NOP
173:           }
1BC1E  52E5     MOVF 0xFE5, F, ACCESS
1BC20  0012     RETURN 0
174:           
175:           void eaDogM_WriteCommand(const uint8_t cmd)
176:           {
177:           	send_lcd_cmd_dma(cmd);
1BD24  0EFF     MOVLW 0xFF
1BD26  50E3     MOVF 0xFE3, W, ACCESS
1BD28  6EE6     MOVWF 0xFE6, ACCESS
1BD2A  EC8A     CALL 0x1AF14, 0
1BD2C  F0D7     NOP
178:           }
1BD2E  52E5     MOVF 0xFE5, F, ACCESS
1BD30  0012     RETURN 0
179:           
180:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
181:           {
182:           	uint8_t cmdPos;
183:           	cmdPos = (uint8_t) EADOGM_CMD_DDRAM_ADDR + (uint8_t) ((uint8_t) r * (uint8_t) EADOGM_COLSPAN) + (uint8_t) c;
184:           	eaDogM_WriteCommand(cmdPos);
185:           }
186:           
187:           void eaDogM_ClearRow(const uint8_t r)
188:           {
189:           	uint8_t i;
190:           	eaDogM_SetPos(r, 0);
191:           	for (i = 0; i < EADOGM_COLSPAN; i++) {
192:           		eaDogM_WriteChr(' ');
193:           	}
194:           }
195:           
196:           /*
197:            * uses DMA channel 1 for transfers
198:            */
199:           void eaDogM_WriteString(char *strPtr)
200:           {
201:           	//	DEBUG2_SetHigh();
202:           	wait_lcd_set();
1A512  ECEA     CALL 0x1BDD4, 0
1A514  F0DE     NOP
203:           	/* reset buffer for DMA */
204:           	ringBufS_flush(spi_link.tx1a, false);
1A516  0E00     MOVLW 0x0
1A518  6EE6     MOVWF 0xFE6, ACCESS
1A51C  F19B     NOP
1A51E  FFE6     NOP
1A522  F19F     NOP
1A524  FFE6     NOP
1A526  ECC3     CALL 0x1A786, 0
1A528  F0D3     NOP
205:           	CSB_SetLow(); /* SPI select display */
1A52A  94BC     BCF 0xFBC, 2, ACCESS
206:           	if (strlen(strPtr) > max_strlen) strPtr[max_strlen] = 0; // buffer overflow check
1A52C  0EFE     MOVLW 0xFE
1A530  FF8F     NOP
1A532  FFE6     NOP
1A536  FF8F     NOP
1A538  FFE6     NOP
1A53A  ECDC     CALL 0x1A5B8, 0
1A53C  F0D2     NOP
1A53E  5002     MOVF ttemp5, W, ACCESS
1A540  E104     BNZ 0xA54A
1A542  0E41     MOVLW 0x41
1A544  5C01     SUBWF ltemp0, W, ACCESS
1A546  A0D8     BTFSS 0xFD8, 0, ACCESS
1A548  D010     BRA 0xA56A
1A54A  0EFE     MOVLW 0xFE
1A54E  FF8C     NOP
1A550  F00B     NOP
1A552  0EFF     MOVLW 0xFF
1A556  FF8C     NOP
1A558  F00C     NOP
1A55A  0E40     MOVLW 0x40
1A55C  240B     ADDWF wtemp5, W, ACCESS
1A55E  6ED9     MOVWF 0xFD9, ACCESS
1A560  0E00     MOVLW 0x0
1A562  200C     ADDWFC 0xC, W, ACCESS
1A564  6EDA     MOVWF 0xFDA, ACCESS
1A566  0E00     MOVLW 0x0
1A568  6EDF     MOVWF 0xFDF, ACCESS
207:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
1A56A  013B     MOVLB 0x3B
1A56C  9FFC     BCF 0xFC, 7, BANKED
208:           	DMA1SSZ = strlen(strPtr);
1A56E  0EFE     MOVLW 0xFE
1A572  FF8F     NOP
1A574  FFE6     NOP
1A578  FF8F     NOP
1A57A  FFE6     NOP
1A57C  ECDC     CALL 0x1A5B8, 0
1A57E  F0D2     NOP
1A582  F007     NOP
1A584  FBF7     NOP
1A588  F00B     NOP
1A58A  FBF8     NOP
209:           	DMA1CON0bits.EN = 1; /* enable DMA */
1A58C  013B     MOVLB 0x3B
1A58E  8FFC     BSF 0xFC, 7, BANKED
210:           	printf("%s", strPtr); // testing copy method using STDIO redirect to buffer
1A590  0EFE     MOVLW 0xFE
1A594  FF8F     NOP
1A596  FFE6     NOP
1A59A  FF8F     NOP
1A59C  FFE6     NOP
1A59E  0EFB     MOVLW 0xFB
1A5A0  6EE6     MOVWF 0xFE6, ACCESS
1A5A2  0EFF     MOVLW 0xFF
1A5A4  6EE6     MOVWF 0xFE6, ACCESS
1A5A6  0E04     MOVLW 0x4
1A5A8  6EE6     MOVWF 0xFE6, ACCESS
1A5AA  EC9E     CALL 0x1AD3C, 0
1A5AC  F0D6     NOP
211:           	start_lcd();
1A5AE  ECED     CALL 0x1BDDA, 0
1A5B0  F0DE     NOP
212:           #ifdef DISPLAY_SLOW
213:           	wdtdelay(9000);
214:           #endif
215:           }
1A5B2  52E5     MOVF 0xFE5, F, ACCESS
1A5B4  52E5     MOVF 0xFE5, F, ACCESS
1A5B6  0012     RETURN 0
216:           
217:           /*
218:            * uses DMA channel 1 for transfers
219:            */
220:           void send_lcd_cmd_dma(uint8_t strPtr)
221:           {
222:           	//	DEBUG2_SetHigh();
223:           	wait_lcd_set();
1AF14  ECEA     CALL 0x1BDD4, 0
1AF16  F0DE     NOP
224:           	/* reset buffer for DMA */
225:           	ringBufS_flush(spi_link.tx1a, false);
1AF18  0E00     MOVLW 0x0
1AF1A  6EE6     MOVWF 0xFE6, ACCESS
1AF1E  F19B     NOP
1AF20  FFE6     NOP
1AF24  F19F     NOP
1AF26  FFE6     NOP
1AF28  ECC3     CALL 0x1A786, 0
1AF2A  F0D3     NOP
226:           	RS_SetLow();
1AF2C  92BC     BCF 0xFBC, 1, ACCESS
227:           	CSB_SetLow(); /* SPI select display */
1AF2E  94BC     BCF 0xFBC, 2, ACCESS
228:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
1AF30  013B     MOVLB 0x3B
1AF32  9FFC     BCF 0xFC, 7, BANKED
229:           	DMA1SSZ = 1;
1AF34  0E00     MOVLW 0x0
1AF36  6FF8     MOVWF 0xF8, BANKED
1AF38  0E01     MOVLW 0x1
1AF3A  6FF7     MOVWF H, BANKED
230:           	DMA1CON0bits.EN = 1; /* enable DMA */
1AF3C  8FFC     BSF 0xFC, 7, BANKED
231:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
1AF3E  0EFF     MOVLW 0xFF
1AF40  50E3     MOVF 0xFE3, W, ACCESS
1AF42  6EE6     MOVWF 0xFE6, ACCESS
1AF44  0E00     MOVLW 0x0
1AF46  6EE6     MOVWF 0xFE6, ACCESS
1AF48  0EF8     MOVLW 0xF8
1AF4A  6EE6     MOVWF 0xFE6, ACCESS
1AF4C  0EFF     MOVLW 0xFF
1AF4E  6EE6     MOVWF 0xFE6, ACCESS
1AF50  0E04     MOVLW 0x4
1AF52  6EE6     MOVWF 0xFE6, ACCESS
1AF54  EC9E     CALL 0x1AD3C, 0
1AF56  F0D6     NOP
232:           	start_lcd();
1AF58  ECED     CALL 0x1BDDA, 0
1AF5A  F0DE     NOP
233:           	wait_lcd_done();
1AF5C  ECF6     CALL 0x1BBEC, 0
1AF5E  F0DD     NOP
234:           	RS_SetHigh();
1AF60  82BC     BSF 0xFBC, 1, ACCESS
235:           }
1AF62  52E5     MOVF 0xFE5, F, ACCESS
1AF64  0012     RETURN 0
236:           
237:           /*
238:            * uses DMA channel 1 for transfers
239:            */
240:           void send_lcd_data_dma(uint8_t strPtr)
241:           {
242:           	//	DEBUG2_SetHigh();
243:           	wait_lcd_set();
244:           	/* reset buffer for DMA */
245:           	ringBufS_flush(spi_link.tx1a, false);
246:           	RS_SetHigh();
247:           	CSB_SetLow(); /* SPI select display */
248:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
249:           	DMA1SSZ = 1;
250:           	DMA1CON0bits.EN = 1; /* enable DMA */
251:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
252:           	start_lcd();
253:           }
254:           
255:           /*
256:            * uses DMA channel 2 for transfers
257:            */
258:           void send_port_data_dma(uint16_t dsize)
259:           {
260:           	if (dsize > max_port_data)
1AFB8  0EFE     MOVLW 0xFE
1AFBA  04E3     DECF 0xFE3, W, ACCESS
1AFBC  0EFF     MOVLW 0xFF
1AFC0  FF8C     NOP
1AFC2  F001     NOP
1AFC4  0E02     MOVLW 0x2
1AFC6  5A01     SUBWFB ltemp0, F, ACCESS
1AFC8  A0D8     BTFSS 0xFD8, 0, ACCESS
1AFCA  D00C     BRA 0xAFE4
261:           		dsize = max_port_data;
1AFCC  0E00     MOVLW 0x0
1AFCE  6E0B     MOVWF wtemp5, ACCESS
1AFD0  0E02     MOVLW 0x2
1AFD2  6E0C     MOVWF 0xC, ACCESS
1AFD4  0EFE     MOVLW 0xFE
1AFD8  F02F     NOP
1AFDA  FFE3     NOP
1AFDC  0EFF     MOVLW 0xFF
1AFE0  F033     NOP
1AFE2  FFE3     NOP
262:           
263:           	DMA2CON0bits.EN = 0; /* disable DMA to change source count */
1AFE4  013B     MOVLB 0x3B
1AFE6  9FDC     BCF 0xDC, 7, BANKED
264:           	DMA2SSZ = dsize;
1AFE8  0EFE     MOVLW 0xFE
1AFEC  FF8F     NOP
1AFEE  FBD7     NOP
1AFF0  0EFF     MOVLW 0xFF
1AFF4  FF8F     NOP
1AFF6  FBD8     NOP
265:           	DMA2DSZ = 1;
1AFF8  0E00     MOVLW 0x0
1AFFA  6FCF     MOVWF seed, BANKED
1AFFC  0E01     MOVLW 0x1
1AFFE  6FCE     MOVWF uart1RxCount, BANKED
266:           	DMA2CON0bits.EN = 1; /* enable DMA */
1B000  8FDC     BSF 0xDC, 7, BANKED
267:           	DMA2CON0bits.DMA2SIRQEN = 1; /* start DMA trigger */
1B002  8DDC     BSF 0xDC, 6, BANKED
268:           }
1B004  52E5     MOVF 0xFE5, F, ACCESS
1B006  52E5     MOVF 0xFE5, F, ACCESS
1B008  0012     RETURN 0
269:           
270:           /*
271:            * return pointer to internal data buffer for DMA
272:            */
273:           uint8_t* port_data_dma_ptr(void)
274:           {
275:           	return port_data;
1BD78  0EFF     MOVLW 0xFF
1BD7A  6E01     MOVWF ltemp0, ACCESS
1BD7C  0E04     MOVLW 0x4
1BD7E  6E02     MOVWF ttemp5, ACCESS
276:           }
1BD80  0012     RETURN 0
277:           
278:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
279:           {
280:           	send_lcd_cmd_dma((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
1B532  0EFE     MOVLW 0xFE
1B536  FF8C     NOP
1B538  F00C     NOP
1B53A  0EFF     MOVLW 0xFF
1B53C  50E3     MOVF 0xFE3, W, ACCESS
1B53E  0D10     MULLW 0x10
1B540  50F3     MOVF 0xFF3, W, ACCESS
1B542  240C     ADDWF 0xC, W, ACCESS
1B544  0F80     ADDLW 0x80
1B546  6EE6     MOVWF 0xFE6, ACCESS
1B548  EC8A     CALL 0x1AF14, 0
1B54A  F0D7     NOP
281:           	eaDogM_WriteString(strPtr);
1B54C  0EFC     MOVLW 0xFC
1B550  FF8F     NOP
1B552  FFE6     NOP
1B556  FF8F     NOP
1B558  FFE6     NOP
1B55A  EC89     CALL 0x1A512, 0
1B55C  F0D2     NOP
282:           }
1B55E  52E5     MOVF 0xFE5, F, ACCESS
1B560  52E5     MOVF 0xFE5, F, ACCESS
1B562  52E5     MOVF 0xFE5, F, ACCESS
1B564  52E5     MOVF 0xFE5, F, ACCESS
1B566  0012     RETURN 0
283:           
284:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
285:           {
286:           	eaDogM_WriteCommand((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
287:           
288:           	eaDogM_WriteChr(i / 10 + '0');
289:           	eaDogM_WriteChr(i % 10 + '0');
290:           
291:           }
292:           
293:           // this writes a byte to the internal CGRAM (v2.02)
294:           // format for ndx: 00CCCRRR = CCC = character 0 to 7, RRR = row 0 to 7
295:           
296:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
297:           {
298:           	uint8_t cmd;
299:           
300:           	cmd = ndx & 0b00111111; // mask off upper to bits
301:           	cmd = cmd | EADOGM_CMD_CGRAM_ADDR; // set bit cmd bits
302:           
303:           	eaDogM_WriteCommand(cmd);
304:           	eaDogM_WriteChr(data);
305:           
306:           	// this is done to make sure we are back in data mode
307:           	eaDogM_SetPos(0, 0);
308:           }
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/dio.c  ---------------------------------------------------
1:             #include "dio.h"
2:             #include "mcc_generated_files/ext_int.h"
3:             
4:             typedef struct S_data { // switch control data structure 
5:             	volatile rbutton_type button[MAX_BUTTONS];
6:             	volatile uint8_t sw_bitmap;
7:             } S_data;
8:             
9:             static S_data S;
10:            extern V_data V;
11:            
12:            static void switch_handler(void);
13:            
14:            /*
15:             * return the current actual state of x switch
16:             * the actual current state of a switch is ONLY changed in the interrupt handler
17:             */
18:            SW_STATES get_switch(uint8_t i)
19:            {
20:            	if (i >= NUM_SWITCHES)
1B6BE  0EFF     MOVLW 0xFF
1B6C2  FF8C     NOP
1B6C4  F001     NOP
1B6C6  0E03     MOVLW 0x3
1B6C8  6401     CPFSGT ltemp0, ACCESS
1B6CA  D002     BRA 0xB6D0
21:            		return SW_OFF;
1B6CC  0E00     MOVLW 0x0
1B6CE  D00A     BRA 0xB6E4
22:            
23:            	return S.button[i].sw;
1B6D0  0EFF     MOVLW 0xFF
1B6D2  50E3     MOVF 0xFE3, W, ACCESS
1B6D4  0D05     MULLW 0x5
1B6D6  0E54     MOVLW 0x54
1B6D8  24F3     ADDWF 0xFF3, W, ACCESS
1B6DA  6ED9     MOVWF 0xFD9, ACCESS
1B6DC  0E02     MOVLW 0x2
1B6DE  20F4     ADDWFC 0xFF4, W, ACCESS
1B6E0  6EDA     MOVWF 0xFDA, ACCESS
1B6E2  50DF     MOVF 0xFDF, W, ACCESS
1B6E4  6E01     MOVWF ltemp0, ACCESS
24:            }
1B6E6  52E5     MOVF 0xFE5, F, ACCESS
1B6E8  0012     RETURN 0
25:            
26:            /*
27:             * return the x switch structure
28:             * mainly for testing
29:             */
30:            rbutton_type get_switch_data(uint8_t i)
31:            {
32:            	if (i >= NUM_SWITCHES)
33:            		return S.button[SNULL];
34:            
35:            	return S.button[i];
36:            }
37:            
38:            /*
39:             * check the switch pressed bitmap for button presses, the actual current switch state might differ
40:             */
41:            uint8_t check_switches(void)
42:            {
43:            	return S.sw_bitmap;
44:            }
45:            
46:            /*
47:             * clear X switch pressed and time pressed data
48:             */
49:            void clear_switch(uint8_t i)
50:            {
51:            	if (i >= NUM_SWITCHES)
52:            		return;
53:            
54:            	S.button[i].count = 0;
55:            	S.sw_bitmap &= ~(1 << i); //clear switch pressed bit
56:            }
57:            
58:            void switch_handler(void)
19254  52E6     MOVF 0xFE6, F, ACCESS
19256  52E6     MOVF 0xFE6, F, ACCESS
59:            {
60:            	uint8_t i = 0, sw_value;
19258  0EFE     MOVLW 0xFE
1925A  6AE3     CLRF 0xFE3, ACCESS
61:            
62:            	/*
63:            	 * enable the outputs for reading and reset MAX Change-of-State pin
64:            	 */
65:            	MAX_EN_SetLow(); // rev 1.0 board, wire patch
1925C  9EBD     BCF 0xFBD, 7, ACCESS
66:            	MAX_EN1_SetLow(); // rev 1.1+ board
1925E  9ABF     BCF 0xFBF, 5, ACCESS
67:            
68:            #ifdef DEBUG_SWH1
69:            	DEBUG1_SetHigh();
70:            #endif
71:            
72:            	// Nop for MAX chip output Propagation Delay after enable
73:            	Nop();
19260  F000     NOP
74:            	Nop();
19262  F000     NOP
75:            	Nop();
19264  F000     NOP
19266  D019     BRA 0x929A
76:            	// start reading the various pic port input bits after the max chip is ready
77:            	do {
78:            		switch (i) {
79:            		case SENTER:
80:            			sw_value = ENTER_B_GetValue();
19268  A6CF     BTFSS 0xFCF, 3, ACCESS
1926A  D011     BRA 0x928E
1926C  D00D     BRA 0x9288
1926E  0EFF     MOVLW 0xFF
19272  F033     NOP
19274  FFE3     NOP
81:            			break;
19276  D027     BRA 0x92C6
82:            		case SSELECT:
83:            			sw_value = SELECT_B_GetValue();
19278  A4CF     BTFSS 0xFCF, 2, ACCESS
1927A  D009     BRA 0x928E
1927C  D005     BRA 0x9288
84:            			break;
85:            		case S1:
86:            			sw_value = IO_RF1_GetValue();
1927E  A2CF     BTFSS 0xFCF, 1, ACCESS
19280  D006     BRA 0x928E
19282  D002     BRA 0x9288
87:            			break;
88:            		case S0:
89:            			sw_value = IO_RF0_GetValue();
19284  A0CF     BTFSS 0xFCF, 0, ACCESS
19286  D003     BRA 0x928E
19288  6A0C     CLRF 0xC, ACCESS
1928A  2A0C     INCF 0xC, F, ACCESS
1928C  D7F0     BRA 0x926E
1928E  6A0C     CLRF 0xC, ACCESS
19290  D7EE     BRA 0x926E
90:            			break;
91:            		default:
92:            			sw_value = 1;
19292  0EFF     MOVLW 0xFF
19294  6AE3     CLRF 0xFE3, ACCESS
19296  2AE3     INCF 0xFE3, F, ACCESS
93:            			break;
19298  D016     BRA 0x92C6
94:            		}
1929A  0EFE     MOVLW 0xFE
1929C  50E3     MOVF 0xFE3, W, ACCESS
1929E  6E0B     MOVWF wtemp5, ACCESS
192A0  6A0C     CLRF 0xC, ACCESS
192A2  500C     MOVF 0xC, W, ACCESS
192A4  0A00     XORLW 0x0
192A6  A4D8     BTFSS 0xFD8, 2, ACCESS
192A8  D7F4     BRA 0x9292
192AA  500B     MOVF wtemp5, W, ACCESS
192AC  0A00     XORLW 0x0
192AE  B4D8     BTFSC 0xFD8, 2, ACCESS
192B0  D7E9     BRA 0x9284
192B2  0A01     XORLW 0x1
192B4  B4D8     BTFSC 0xFD8, 2, ACCESS
192B6  D7E3     BRA 0x927E
192B8  0A03     XORLW 0x3
192BA  B4D8     BTFSC 0xFD8, 2, ACCESS
192BC  D7DD     BRA 0x9278
192BE  0A01     XORLW 0x1
192C0  B4D8     BTFSC 0xFD8, 2, ACCESS
192C2  D7D2     BRA 0x9268
192C4  D7E6     BRA 0x9292
95:            
96:            		// update actual current button state
97:            		if (sw_value) {
192C6  0EFF     MOVLW 0xFF
192C8  50E3     MOVF 0xFE3, W, ACCESS
192CA  B4D8     BTFSC 0xFD8, 2, ACCESS
192CC  D018     BRA 0x92FE
98:            			if (S.button[i].sw == SW_ON) {
192CE  0EFE     MOVLW 0xFE
192D0  50E3     MOVF 0xFE3, W, ACCESS
192D2  0D05     MULLW 0x5
192D4  0E54     MOVLW 0x54
192D6  24F3     ADDWF 0xFF3, W, ACCESS
192D8  6ED9     MOVWF 0xFD9, ACCESS
192DA  0E02     MOVLW 0x2
192DC  20F4     ADDWFC 0xFF4, W, ACCESS
192DE  6EDA     MOVWF 0xFDA, ACCESS
192E0  04DE     DECF 0xFDE, W, ACCESS
192E2  A4D8     BTFSS 0xFD8, 2, ACCESS
192E4  D049     BRA 0x9378
99:            				S.button[i].sw = SW_OFF;
192E6  0EFE     MOVLW 0xFE
192E8  50E3     MOVF 0xFE3, W, ACCESS
192EA  0D05     MULLW 0x5
192EC  0E54     MOVLW 0x54
192EE  24F3     ADDWF 0xFF3, W, ACCESS
192F0  6ED9     MOVWF 0xFD9, ACCESS
192F2  0E02     MOVLW 0x2
192F4  20F4     ADDWFC 0xFF4, W, ACCESS
192F6  6EDA     MOVWF 0xFDA, ACCESS
192F8  0E00     MOVLW 0x0
192FA  6EDF     MOVWF 0xFDF, ACCESS
192FC  D03D     BRA 0x9378
100:           			}
101:           		} else {
102:           			if (S.button[i].sw == SW_OFF) {
192FE  0EFE     MOVLW 0xFE
19300  50E3     MOVF 0xFE3, W, ACCESS
19302  0D05     MULLW 0x5
19304  0E54     MOVLW 0x54
19306  24F3     ADDWF 0xFF3, W, ACCESS
19308  6ED9     MOVWF 0xFD9, ACCESS
1930A  0E02     MOVLW 0x2
1930C  20F4     ADDWFC 0xFF4, W, ACCESS
1930E  6EDA     MOVWF 0xFDA, ACCESS
19310  50DF     MOVF 0xFDF, W, ACCESS
19312  A4D8     BTFSS 0xFD8, 2, ACCESS
19314  D031     BRA 0x9378
103:           				S.button[i].sw = SW_ON;
19316  0EFE     MOVLW 0xFE
19318  50E3     MOVF 0xFE3, W, ACCESS
1931A  0D05     MULLW 0x5
1931C  0E54     MOVLW 0x54
1931E  24F3     ADDWF 0xFF3, W, ACCESS
19320  6ED9     MOVWF 0xFD9, ACCESS
19322  0E02     MOVLW 0x2
19324  20F4     ADDWFC 0xFF4, W, ACCESS
19326  6EDA     MOVWF 0xFDA, ACCESS
19328  0E01     MOVLW 0x1
1932A  6EDF     MOVWF 0xFDF, ACCESS
104:           				S.button[i].count = V.timerint_count; // so we can check button SW_ON duration
1932C  EE20     LFSR 2, 0x1EB
1932E  F1EB     NOP
19330  0EFE     MOVLW 0xFE
19332  50E3     MOVF 0xFE3, W, ACCESS
19334  0D05     MULLW 0x5
19336  0E55     MOVLW 0x55
19338  24F3     ADDWF 0xFF3, W, ACCESS
1933A  6EE9     MOVWF 0xFE9, ACCESS
1933C  0E02     MOVLW 0x2
1933E  20F4     ADDWFC 0xFF4, W, ACCESS
19340  6EEA     MOVWF 0xFEA, ACCESS
19344  FF7B     NOP
19346  FFEE     NOP
1934A  FF7B     NOP
1934C  FFEE     NOP
19350  FF7B     NOP
19352  FFEE     NOP
19356  FF7B     NOP
19358  FFEE     NOP
105:           				S.sw_bitmap |= 1 << i; // set switch pressed bit
1935A  0EFE     MOVLW 0xFE
1935E  FF8C     NOP
19360  F00C     NOP
19362  0E01     MOVLW 0x1
19364  6E0B     MOVWF wtemp5, ACCESS
19366  2A0C     INCF 0xC, F, ACCESS
19368  D002     BRA 0x936E
1936A  90D8     BCF 0xFD8, 0, ACCESS
1936C  360B     RLCF wtemp5, F, ACCESS
1936E  2E0C     DECFSZ 0xC, F, ACCESS
19370  D7FC     BRA 0x936A
19372  500B     MOVF wtemp5, W, ACCESS
19374  0102     MOVLB 0x2
19376  137C     IORWF 0x7C, F, BANKED
106:           			}
107:           		}
108:           	} while (++i < NUM_SWITCHES);
19378  0EFE     MOVLW 0xFE
1937A  2AE3     INCF 0xFE3, F, ACCESS
1937C  0EFE     MOVLW 0xFE
19380  FF8C     NOP
19382  F001     NOP
19384  0E03     MOVLW 0x3
19386  6401     CPFSGT ltemp0, ACCESS
19388  D788     BRA 0x929A
109:           
110:           #ifdef DEBUG_SWH1
111:           	DEBUG1_SetLow();
112:           #endif
113:           #ifdef DEBUG_SWH2
114:           	DEBUG2_Toggle();
115:           #endif
116:           
117:           	MAX_EN_SetHigh(); // disable MAX output pins
1938A  8EBD     BSF 0xFBD, 7, ACCESS
118:           	MAX_EN1_SetHigh(); // disable MAX output pins
1938C  8ABF     BSF 0xFBF, 5, ACCESS
119:           }
1938E  52E5     MOVF 0xFE5, F, ACCESS
120:           
121:           void start_switch_handler(void)
122:           {
123:           	EXT_INT1_InterruptDisable();
1BB34  0139     MOVLB 0x39
1BB36  9195     BCF 0x95, 0, BANKED
124:           	INT1_SetInterruptHandler(switch_handler);
1BB38  0E54     MOVLW 0x54
1BB3A  6EE6     MOVWF 0xFE6, ACCESS
1BB3C  0E92     MOVLW 0x92
1BB3E  6EE6     MOVWF 0xFE6, ACCESS
1BB40  0E01     MOVLW 0x1
1BB42  6EE6     MOVWF 0xFE6, ACCESS
1BB44  EC7F     CALL 0x1B8FE, 0
1BB46  F0DC     NOP
125:           	S.button[SNULL].sw = SW_INVALID; // set a error condition for invalid button number
1BB48  0E02     MOVLW 0x2
1BB4A  0102     MOVLB 0x2
1BB4C  6F77     MOVWF 0x77, BANKED
126:           	EXT_INT1_InterruptEnable();
1BB4E  0139     MOVLB 0x39
1BB50  8195     BSF 0x95, 0, BANKED
127:           }
1BB52  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/daq.c  ---------------------------------------------------
1:             /*
2:              * 12-bit analog 64 sample average per channel on ports A and B
3:              * uses the compute burst average mode threshold interrupt to auto change
4:              * channels during interrupt after a repeat count
5:              */
6:             
7:             #include "daq.h"
8:             
9:             typedef struct R_data { // internal variables
10:            	adc_result_t raw_adc[ADC_BUFFER_SIZE];
11:            	int16_t n_offset[NUM_C_SENSORS];
12:            	float n_zero[NUM_C_SENSORS];
13:            	uint8_t scan_index;
14:            	uint16_t scan_select;
15:            	bool done;
16:            } R_data;
17:            
18:            static volatile R_data R = {
19:            	.done = false,
20:            	.scan_index = 0,
21:            	.n_offset[0] = N_OFFSET0,
22:            	.n_offset[1] = N_OFFSET1,
23:            	.n_zero[0] = 0.0,
24:            	.n_zero[1] = 0.0,
25:            };
26:            
27:            static void adc_int_handler(void);
28:            static void adc_int_t_handler(void);
29:            
30:            /*
31:             * start computed ADC results: 64 samples per average value per selected channel from
32:             * AN channel zero to LAST_ADC_CHAN
33:             * check_adc_scan returns true when sequence is complete
34:             */
35:            bool start_adc_scan(void)
36:            {
37:            	if (R.done)
1ACD8  0101     MOVLB 0x1
1ACDA  512F     MOVF 0x2F, W, BANKED
1ACDC  A4D8     BTFSS 0xFD8, 2, ACCESS
1ACDE  0012     RETURN 0
38:            		return false;
39:            
40:            	R.scan_index = 0;
1ACE0  6B2C     CLRF 0x2C, BANKED
41:            	R.scan_select = (uint16_t) ((ANSELB << 8) + ANSELA) & ADC_SCAN_CHAN; // skip digital pins PORT A and B
1ACE2  013A     MOVLB 0x3A
1ACE4  5140     MOVF esr_state, W, BANKED
1ACE8  F940     NOP
1ACEA  F001     NOP
1ACEC  6A02     CLRF ttemp5, ACCESS
1ACF0  F004     NOP
1ACF2  F002     NOP
1ACF4  6A01     CLRF ltemp0, ACCESS
1ACF6  2601     ADDWF ltemp0, F, ACCESS
1ACF8  0E00     MOVLW 0x0
1ACFA  2202     ADDWFC ttemp5, F, ACCESS
1ACFC  0E77     MOVLW 0x77
1ACFE  1401     ANDWF ltemp0, W, ACCESS
1AD00  0101     MOVLB 0x1
1AD02  6F2D     MOVWF 0x2D, BANKED
1AD04  0E3C     MOVLW 0x3C
1AD06  1402     ANDWF ttemp5, W, ACCESS
1AD08  6F2E     MOVWF 0x2E, BANKED
42:            	ADCC_SetADIInterruptHandler(adc_int_handler);
1AD0A  0EF6     MOVLW 0xF6
1AD0C  6EE6     MOVWF 0xFE6, ACCESS
1AD0E  0EBD     MOVLW 0xBD
1AD10  6EE6     MOVWF 0xFE6, ACCESS
1AD12  0E01     MOVLW 0x1
1AD14  6EE6     MOVWF 0xFE6, ACCESS
1AD16  ECBB     CALL 0x1B976, 0
1AD18  F0DC     NOP
43:            	ADCC_SetADTIInterruptHandler(adc_int_t_handler);
1AD1A  0E38     MOVLW 0x38
1AD1C  6EE6     MOVWF 0xFE6, ACCESS
1AD1E  0EAA     MOVLW 0xAA
1AD20  6EE6     MOVWF 0xFE6, ACCESS
1AD22  0E01     MOVLW 0x1
1AD24  6EE6     MOVWF 0xFE6, ACCESS
1AD26  ECA7     CALL 0x1B94E, 0
1AD28  F0DC     NOP
44:            	ADCC_DischargeSampleCapacitor(); // short ADC sample cap before channel sampling
1AD2A  ECD3     CALL 0x1BDA6, 0
1AD2C  F0DE     NOP
45:            	ADCC_StartConversion(R.scan_index & 0xf);
1AD2E  0101     MOVLB 0x1
1AD30  512C     MOVF 0x2C, W, BANKED
1AD32  0B0F     ANDLW 0xF
1AD34  6EE6     MOVWF 0xFE6, ACCESS
1AD36  EC62     CALL 0x1BCC4, 0
1AD38  F0DE     NOP
46:            #ifdef DEBUG_DAQ1
47:            	DEBUG1_SetHigh();
48:            #endif
49:            #ifdef DEBUG_DAQ2
50:            	DEBUG2_SetHigh();
51:            #endif
52:            	return true;
53:            }
1AD3A  0012     RETURN 0
54:            
55:            /*
56:             * check scan done flag
57:             */
58:            bool check_adc_scan(void)
59:            {
60:            	return R.done;
1BDB0  F4BC     NOP
1BDB2  F001     NOP
61:            }
1BDB4  0012     RETURN 0
62:            
63:            /*
64:             * clear scan done flag
65:             */
66:            void clear_adc_scan(void)
67:            {
68:            	R.done = false;
1BDCE  0101     MOVLB 0x1
1BDD0  6B2F     CLRF 0x2F, BANKED
69:            }
1BDD2  0012     RETURN 0
70:            
71:            /*
72:             * update the raw adc values
73:             */
74:            bool update_adc_result(void)
75:            {
76:            	if (R.done) {
1B452  0101     MOVLB 0x1
1B454  512F     MOVF 0x2F, W, BANKED
1B456  B4D8     BTFSC 0xFD8, 2, ACCESS
1B458  0012     RETURN 0
77:            		clear_adc_scan();
1B45A  ECE7     CALL 0x1BDCE, 0
1B45C  F0DE     NOP
78:            		start_adc_scan();
1B45E  EC6C     CALL 0x1ACD8, 0
1B460  F0D6     NOP
79:            		StartTimer(TMR_ADC, ADC_SCAN_SPEED);
1B462  0EC8     MOVLW 0xC8
1B464  6EE6     MOVWF 0xFE6, ACCESS
1B466  0E00     MOVLW 0x0
1B468  6EE6     MOVWF 0xFE6, ACCESS
1B46A  0E01     MOVLW 0x1
1B46C  6EE6     MOVWF 0xFE6, ACCESS
1B46E  EC6A     CALL 0x1B2D4, 0
1B470  F0D9     NOP
80:            		while (!TimerDone(TMR_ADC) && !check_adc_scan());
1B472  0E01     MOVLW 0x1
1B474  6EE6     MOVWF 0xFE6, ACCESS
1B476  ECF3     CALL 0x1B7E6, 0
1B478  F0DB     NOP
1B47A  5001     MOVF ltemp0, W, ACCESS
1B47C  A4D8     BTFSS 0xFD8, 2, ACCESS
1B47E  0012     RETURN 0
1B480  ECD7     CALL 0x1BDAE, 0
1B482  F0DE     NOP
1B484  5001     MOVF ltemp0, W, ACCESS
1B486  A4D8     BTFSS 0xFD8, 2, ACCESS
1B488  0012     RETURN 0
1B48A  D7F3     BRA 0xB472
81:            		return true;
82:            	} else {
83:            		return false;
84:            	}
85:            }
86:            
87:            /*
88:             * read average value of a channel after scan completion (done)
89:             */
90:            adc_result_t get_raw_result(const adcc_channel_t index)
91:            {
92:            	return R.raw_adc[index];
1BAF0  0EFF     MOVLW 0xFF
1BAF2  50E3     MOVF 0xFE3, W, ACCESS
1BAF4  0D02     MULLW 0x2
1BAF6  0E00     MOVLW 0x0
1BAF8  24F3     ADDWF 0xFF3, W, ACCESS
1BAFA  6ED9     MOVWF 0xFD9, ACCESS
1BAFC  0E01     MOVLW 0x1
1BAFE  20F4     ADDWFC 0xFF4, W, ACCESS
1BB00  6EDA     MOVWF 0xFDA, ACCESS
1BB04  FF78     NOP
1BB06  F001     NOP
1BB0A  FF74     NOP
1BB0C  F002     NOP
93:            }
1BB0E  52E5     MOVF 0xFE5, F, ACCESS
1BB10  0012     RETURN 0
94:            
95:            /*
96:             * turn ADC values into standard program values
97:             */
98:            float conv_raw_result(const adcc_channel_t chan, const adc_conv_t to_what)
99:            {
100:           
101:           	switch (to_what) {
1501C  D276     BRA 0x550A
102:           	case CONV:
103:           		if (!(ADC_SCAN_CHAN >> chan & 0x1))
1501E  0EFF     MOVLW 0xFF
15022  FF8C     NOP
15024  F00C     NOP
15026  0E77     MOVLW 0x77
15028  6E09     MOVWF ltemp2, ACCESS
1502A  0E3C     MOVLW 0x3C
1502C  6E0A     MOVWF ttemp3, ACCESS
1502E  2A0C     INCF 0xC, F, ACCESS
15030  D003     BRA 0x5038
15032  340A     RLCF ttemp3, W, ACCESS
15034  320A     RRCF ttemp3, F, ACCESS
15036  3209     RRCF ltemp2, F, ACCESS
15038  2E0C     DECFSZ 0xC, F, ACCESS
1503A  D7FB     BRA 0x5032
1503C  B009     BTFSC ltemp2, 0, ACCESS
1503E  D007     BRA 0x504E
104:           			return NAN;
15040  0EB9     MOVLW 0xB9
15042  6EE6     MOVWF 0xFE6, ACCESS
15044  0EFC     MOVLW 0xFC
15046  6EE6     MOVWF 0xFE6, ACCESS
15048  ECCF     CALL 0x1AD9E, 0
1504A  F0D6     NOP
1504C  D26E     BRA 0x552A
105:           
106:           		if (ADC_C_CHAN >> chan & 0x1) { // current conversion
1504E  0EFF     MOVLW 0xFF
15052  FF8C     NOP
15054  F00C     NOP
15056  0E03     MOVLW 0x3
15058  6E09     MOVWF ltemp2, ACCESS
1505A  0E00     MOVLW 0x0
1505C  6E0A     MOVWF ttemp3, ACCESS
1505E  2A0C     INCF 0xC, F, ACCESS
15060  D003     BRA 0x5068
15062  340A     RLCF ttemp3, W, ACCESS
15064  320A     RRCF ttemp3, F, ACCESS
15066  3209     RRCF ltemp2, F, ACCESS
15068  2E0C     DECFSZ 0xC, F, ACCESS
1506A  D7FB     BRA 0x5062
1506C  A009     BTFSS ltemp2, 0, ACCESS
1506E  D11F     BRA 0x52AE
107:           			if (ADC_C_CHAN_TYPE >> chan & 0x1) {
15070  0EFF     MOVLW 0xFF
15074  FF8C     NOP
15076  F00C     NOP
15078  0E01     MOVLW 0x1
1507A  6E09     MOVWF ltemp2, ACCESS
1507C  0E00     MOVLW 0x0
1507E  6E0A     MOVWF ttemp3, ACCESS
15080  2A0C     INCF 0xC, F, ACCESS
15082  D003     BRA 0x508A
15084  340A     RLCF ttemp3, W, ACCESS
15086  320A     RRCF ttemp3, F, ACCESS
15088  3209     RRCF ltemp2, F, ACCESS
1508A  2E0C     DECFSZ 0xC, F, ACCESS
1508C  D7FB     BRA 0x5084
1508E  A009     BTFSS ltemp2, 0, ACCESS
15090  D087     BRA 0x51A0
108:           				return R.n_zero[0]+((float) ((int16_t) get_raw_result(chan)) - R.n_offset[0]) * C_A200;
15094  F493     NOP
15096  FFE6     NOP
1509A  F497     NOP
1509C  FFE6     NOP
150A0  F49B     NOP
150A2  FFE6     NOP
150A6  F49F     NOP
150A8  FFE6     NOP
150AA  0E7B     MOVLW 0x7B
150AC  6EE6     MOVWF 0xFE6, ACCESS
150AE  0E14     MOVLW 0x14
150B0  6EE6     MOVWF 0xFE6, ACCESS
150B2  0EAE     MOVLW 0xAE
150B4  6EE6     MOVWF 0xFE6, ACCESS
150B6  0E3D     MOVLW 0x3D
150B8  6EE6     MOVWF 0xFE6, ACCESS
150BC  F480     NOP
150BE  F009     NOP
150C2  F484     NOP
150C4  F00A     NOP
150C6  0E00     MOVLW 0x0
150C8  BE0A     BTFSC ttemp3, 7, ACCESS
150CA  0EFF     MOVLW 0xFF
150CC  6E0B     MOVWF wtemp5, ACCESS
150CE  6E0C     MOVWF 0xC, ACCESS
150D2  F027     NOP
150D4  FFE6     NOP
150D8  F02B     NOP
150DA  FFE6     NOP
150DE  F02F     NOP
150E0  FFE6     NOP
150E4  F033     NOP
150E6  FFE6     NOP
150E8  0E01     MOVLW 0x1
150EA  6EE6     MOVWF 0xFE6, ACCESS
150EC  ECCA     CALL 0x18194, 0
150EE  F0C0     NOP
150F2  F007     NOP
150F4  FFE6     NOP
150F8  F00B     NOP
150FA  FFE6     NOP
150FE  F00F     NOP
15100  FFE6     NOP
15104  F013     NOP
15106  FFE6     NOP
15108  0EF3     MOVLW 0xF3
1510A  50E3     MOVF 0xFE3, W, ACCESS
1510C  6EE6     MOVWF 0xFE6, ACCESS
1510E  EC78     CALL 0x1BAF0, 0
15110  F0DD     NOP
15114  F004     NOP
15116  F00B     NOP
1511A  F008     NOP
1511C  F00C     NOP
1511E  500B     MOVF wtemp5, W, ACCESS
15120  6E05     MOVWF ltemp1, ACCESS
15122  500C     MOVF 0xC, W, ACCESS
15124  6E06     MOVWF 0x6, ACCESS
15126  6A07     CLRF ttemp2, ACCESS
15128  6A08     CLRF 0x8, ACCESS
1512C  F017     NOP
1512E  FFE6     NOP
15132  F01B     NOP
15134  FFE6     NOP
15138  F01F     NOP
1513A  FFE6     NOP
1513E  F023     NOP
15140  FFE6     NOP
15142  0E00     MOVLW 0x0
15144  6EE6     MOVWF 0xFE6, ACCESS
15146  ECCA     CALL 0x18194, 0
15148  F0C0     NOP
1514C  F007     NOP
1514E  FFE6     NOP
15152  F00B     NOP
15154  FFE6     NOP
15158  F00F     NOP
1515A  FFE6     NOP
1515E  F013     NOP
15160  FFE6     NOP
15162  EC04     CALL 0x1B208, 0
15164  F0D9     NOP
15168  F007     NOP
1516A  FFE6     NOP
1516E  F00B     NOP
15170  FFE6     NOP
15174  F00F     NOP
15176  FFE6     NOP
1517A  F013     NOP
1517C  FFE6     NOP
1517E  ECA0     CALL 0x13340, 0
15180  F099     NOP
15184  F007     NOP
15186  FFE6     NOP
1518A  F00B     NOP
1518C  FFE6     NOP
15190  F00F     NOP
15192  FFE6     NOP
15196  F013     NOP
15198  FFE6     NOP
1519A  ECB5     CALL 0x13B6A, 0
1519C  F09D     NOP
1519E  D1C5     BRA 0x552A
109:           			} else {
110:           				return R.n_zero[1]+((float) ((int16_t) get_raw_result(chan)) - R.n_offset[1]) * C_A100;
151A2  F4A3     NOP
151A4  FFE6     NOP
151A8  F4A7     NOP
151AA  FFE6     NOP
151AE  F4AB     NOP
151B0  FFE6     NOP
151B4  F4AF     NOP
151B6  FFE6     NOP
151B8  0E29     MOVLW 0x29
151BA  6EE6     MOVWF 0xFE6, ACCESS
151BC  0E5C     MOVLW 0x5C
151BE  6EE6     MOVWF 0xFE6, ACCESS
151C0  0E0F     MOVLW 0xF
151C2  6EE6     MOVWF 0xFE6, ACCESS
151C4  0E3D     MOVLW 0x3D
151C6  6EE6     MOVWF 0xFE6, ACCESS
151CA  F488     NOP
151CC  F009     NOP
151D0  F48C     NOP
151D2  F00A     NOP
151D4  0E00     MOVLW 0x0
151D6  BE0A     BTFSC ttemp3, 7, ACCESS
151D8  0EFF     MOVLW 0xFF
151DA  6E0B     MOVWF wtemp5, ACCESS
151DC  6E0C     MOVWF 0xC, ACCESS
151E0  F027     NOP
151E2  FFE6     NOP
151E6  F02B     NOP
151E8  FFE6     NOP
151EC  F02F     NOP
151EE  FFE6     NOP
151F2  F033     NOP
151F4  FFE6     NOP
151F6  0E01     MOVLW 0x1
151F8  6EE6     MOVWF 0xFE6, ACCESS
151FA  ECCA     CALL 0x18194, 0
151FC  F0C0     NOP
15200  F007     NOP
15202  FFE6     NOP
15206  F00B     NOP
15208  FFE6     NOP
1520C  F00F     NOP
1520E  FFE6     NOP
15212  F013     NOP
15214  FFE6     NOP
15216  0EF3     MOVLW 0xF3
15218  50E3     MOVF 0xFE3, W, ACCESS
1521A  6EE6     MOVWF 0xFE6, ACCESS
1521C  EC78     CALL 0x1BAF0, 0
1521E  F0DD     NOP
15222  F004     NOP
15224  F00B     NOP
15228  F008     NOP
1522A  F00C     NOP
1522C  500B     MOVF wtemp5, W, ACCESS
1522E  6E05     MOVWF ltemp1, ACCESS
15230  500C     MOVF 0xC, W, ACCESS
15232  6E06     MOVWF 0x6, ACCESS
15234  6A07     CLRF ttemp2, ACCESS
15236  6A08     CLRF 0x8, ACCESS
1523A  F017     NOP
1523C  FFE6     NOP
15240  F01B     NOP
15242  FFE6     NOP
15246  F01F     NOP
15248  FFE6     NOP
1524C  F023     NOP
1524E  FFE6     NOP
15250  0E00     MOVLW 0x0
15252  6EE6     MOVWF 0xFE6, ACCESS
15254  ECCA     CALL 0x18194, 0
15256  F0C0     NOP
1525A  F007     NOP
1525C  FFE6     NOP
15260  F00B     NOP
15262  FFE6     NOP
15266  F00F     NOP
15268  FFE6     NOP
1526C  F013     NOP
1526E  FFE6     NOP
15270  EC04     CALL 0x1B208, 0
15272  F0D9     NOP
15276  F007     NOP
15278  FFE6     NOP
1527C  F00B     NOP
1527E  FFE6     NOP
15282  F00F     NOP
15284  FFE6     NOP
15288  F013     NOP
1528A  FFE6     NOP
1528C  ECA0     CALL 0x13340, 0
1528E  F099     NOP
15292  F007     NOP
15294  FFE6     NOP
15298  F00B     NOP
1529A  FFE6     NOP
1529E  F00F     NOP
152A0  FFE6     NOP
152A4  F013     NOP
152A6  FFE6     NOP
152A8  ECB5     CALL 0x13B6A, 0
152AA  F09D     NOP
152AC  D13E     BRA 0x552A
111:           			}
112:           		} else {
113:           			if (ADC_T_CHAN >> chan & 0x1) { // temp conversion
152AE  0EFF     MOVLW 0xFF
152B2  FF8C     NOP
152B4  F00C     NOP
152B6  0E00     MOVLW 0x0
152B8  6E09     MOVWF ltemp2, ACCESS
152BA  0E08     MOVLW 0x8
152BC  6E0A     MOVWF ttemp3, ACCESS
152BE  2A0C     INCF 0xC, F, ACCESS
152C0  D003     BRA 0x52C8
152C2  340A     RLCF ttemp3, W, ACCESS
152C4  320A     RRCF ttemp3, F, ACCESS
152C6  3209     RRCF ltemp2, F, ACCESS
152C8  2E0C     DECFSZ 0xC, F, ACCESS
152CA  D7FB     BRA 0x52C2
152CC  A009     BTFSS ltemp2, 0, ACCESS
152CE  D008     BRA 0x52E0
114:           				return 25.0; // filler until sensor is selected
152D0  0E00     MOVLW 0x0
152D2  6E01     MOVWF ltemp0, ACCESS
152D4  0E00     MOVLW 0x0
152D6  6E02     MOVWF ttemp5, ACCESS
152D8  0EC8     MOVLW 0xC8
152DA  6E03     MOVWF wtemp1, ACCESS
152DC  0E41     MOVLW 0x41
152DE  D113     BRA 0x5506
115:           			} else { // voltage conversion
116:           				return((float) get_raw_result(chan) * V_SCALE) / 1000.0;
152E0  0E00     MOVLW 0x0
152E2  6EE6     MOVWF 0xFE6, ACCESS
152E4  0E00     MOVLW 0x0
152E6  6EE6     MOVWF 0xFE6, ACCESS
152E8  0E7A     MOVLW 0x7A
152EA  6EE6     MOVWF 0xFE6, ACCESS
152EC  0E44     MOVLW 0x44
152EE  6EE6     MOVWF 0xFE6, ACCESS
152F0  0E61     MOVLW 0x61
152F2  6EE6     MOVWF 0xFE6, ACCESS
152F4  0E03     MOVLW 0x3
152F6  6EE6     MOVWF 0xFE6, ACCESS
152F8  0E84     MOVLW 0x84
152FA  6EE6     MOVWF 0xFE6, ACCESS
152FC  0E40     MOVLW 0x40
152FE  6EE6     MOVWF 0xFE6, ACCESS
15300  0EF7     MOVLW 0xF7
15302  50E3     MOVF 0xFE3, W, ACCESS
15304  6EE6     MOVWF 0xFE6, ACCESS
15306  EC78     CALL 0x1BAF0, 0
15308  F0DD     NOP
1530C  F004     NOP
1530E  F00B     NOP
15312  F008     NOP
15314  F00C     NOP
15316  500B     MOVF wtemp5, W, ACCESS
15318  6E05     MOVWF ltemp1, ACCESS
1531A  500C     MOVF 0xC, W, ACCESS
1531C  6E06     MOVWF 0x6, ACCESS
1531E  6A07     CLRF ttemp2, ACCESS
15320  6A08     CLRF 0x8, ACCESS
15324  F017     NOP
15326  FFE6     NOP
1532A  F01B     NOP
1532C  FFE6     NOP
15330  F01F     NOP
15332  FFE6     NOP
15336  F023     NOP
15338  FFE6     NOP
1533A  0E00     MOVLW 0x0
1533C  6EE6     MOVWF 0xFE6, ACCESS
1533E  ECCA     CALL 0x18194, 0
15340  F0C0     NOP
15344  F007     NOP
15346  FFE6     NOP
1534A  F00B     NOP
1534C  FFE6     NOP
15350  F00F     NOP
15352  FFE6     NOP
15356  F013     NOP
15358  FFE6     NOP
1535A  ECA0     CALL 0x13340, 0
1535C  F099     NOP
15360  F007     NOP
15362  FFE6     NOP
15366  F00B     NOP
15368  FFE6     NOP
1536C  F00F     NOP
1536E  FFE6     NOP
15372  F013     NOP
15374  FFE6     NOP
15376  EC51     CALL 0x14AA2, 0
15378  F0A5     NOP
1537A  D0D7     BRA 0x552A
117:           			}
118:           		}
119:           		break;
120:           	case O_CONV:
121:           		if (ADC_C_CHAN >> chan & 0x1 || ADC_T_CHAN >> chan & 0x1)
1537C  0EFF     MOVLW 0xFF
15380  FF8C     NOP
15382  F00C     NOP
15384  0E03     MOVLW 0x3
15386  6E09     MOVWF ltemp2, ACCESS
15388  0E00     MOVLW 0x0
1538A  6E0A     MOVWF ttemp3, ACCESS
1538C  2A0C     INCF 0xC, F, ACCESS
1538E  D003     BRA 0x5396
15390  340A     RLCF ttemp3, W, ACCESS
15392  320A     RRCF ttemp3, F, ACCESS
15394  3209     RRCF ltemp2, F, ACCESS
15396  2E0C     DECFSZ 0xC, F, ACCESS
15398  D7FB     BRA 0x5390
1539A  B009     BTFSC ltemp2, 0, ACCESS
1539C  D011     BRA 0x53C0
1539E  0EFF     MOVLW 0xFF
153A2  FF8C     NOP
153A4  F00C     NOP
153A6  0E00     MOVLW 0x0
153A8  6E09     MOVWF ltemp2, ACCESS
153AA  0E08     MOVLW 0x8
153AC  6E0A     MOVWF ttemp3, ACCESS
153AE  2A0C     INCF 0xC, F, ACCESS
153B0  D003     BRA 0x53B8
153B2  340A     RLCF ttemp3, W, ACCESS
153B4  320A     RRCF ttemp3, F, ACCESS
153B6  3209     RRCF ltemp2, F, ACCESS
153B8  2E0C     DECFSZ 0xC, F, ACCESS
153BA  D7FB     BRA 0x53B2
153BC  A009     BTFSS ltemp2, 0, ACCESS
153BE  D04E     BRA 0x545C
122:           			return((float) get_raw_result(chan) * C_SCALE) / 1000.0;
153C0  0E00     MOVLW 0x0
153C2  6EE6     MOVWF 0xFE6, ACCESS
153C4  0E00     MOVLW 0x0
153C6  6EE6     MOVWF 0xFE6, ACCESS
153C8  0E7A     MOVLW 0x7A
153CA  6EE6     MOVWF 0xFE6, ACCESS
153CC  0E44     MOVLW 0x44
153CE  6EE6     MOVWF 0xFE6, ACCESS
153D0  0E00     MOVLW 0x0
153D2  6EE6     MOVWF 0xFE6, ACCESS
153D4  0E00     MOVLW 0x0
153D6  6EE6     MOVWF 0xFE6, ACCESS
153D8  0E20     MOVLW 0x20
153DA  6EE6     MOVWF 0xFE6, ACCESS
153DC  0E3F     MOVLW 0x3F
153DE  6EE6     MOVWF 0xFE6, ACCESS
153E0  0EF7     MOVLW 0xF7
153E2  50E3     MOVF 0xFE3, W, ACCESS
153E4  6EE6     MOVWF 0xFE6, ACCESS
153E6  EC78     CALL 0x1BAF0, 0
153E8  F0DD     NOP
153EC  F004     NOP
153EE  F00B     NOP
153F2  F008     NOP
153F4  F00C     NOP
153F6  500B     MOVF wtemp5, W, ACCESS
153F8  6E05     MOVWF ltemp1, ACCESS
153FA  500C     MOVF 0xC, W, ACCESS
153FC  6E06     MOVWF 0x6, ACCESS
153FE  6A07     CLRF ttemp2, ACCESS
15400  6A08     CLRF 0x8, ACCESS
15404  F017     NOP
15406  FFE6     NOP
1540A  F01B     NOP
1540C  FFE6     NOP
15410  F01F     NOP
15412  FFE6     NOP
15416  F023     NOP
15418  FFE6     NOP
1541A  0E00     MOVLW 0x0
1541C  6EE6     MOVWF 0xFE6, ACCESS
1541E  ECCA     CALL 0x18194, 0
15420  F0C0     NOP
15424  F007     NOP
15426  FFE6     NOP
1542A  F00B     NOP
1542C  FFE6     NOP
15430  F00F     NOP
15432  FFE6     NOP
15436  F013     NOP
15438  FFE6     NOP
1543A  ECA0     CALL 0x13340, 0
1543C  F099     NOP
15440  F007     NOP
15442  FFE6     NOP
15446  F00B     NOP
15448  FFE6     NOP
1544C  F00F     NOP
1544E  FFE6     NOP
15452  F013     NOP
15454  FFE6     NOP
15456  EC51     CALL 0x14AA2, 0
15458  F0A5     NOP
1545A  D067     BRA 0x552A
123:           
124:           		return((float) get_raw_result(chan) * V_SCALE) / 1000.0;
1545C  0E00     MOVLW 0x0
1545E  6EE6     MOVWF 0xFE6, ACCESS
15460  0E00     MOVLW 0x0
15462  6EE6     MOVWF 0xFE6, ACCESS
15464  0E7A     MOVLW 0x7A
15466  6EE6     MOVWF 0xFE6, ACCESS
15468  0E44     MOVLW 0x44
1546A  6EE6     MOVWF 0xFE6, ACCESS
1546C  0E61     MOVLW 0x61
1546E  6EE6     MOVWF 0xFE6, ACCESS
15470  0E03     MOVLW 0x3
15472  6EE6     MOVWF 0xFE6, ACCESS
15474  0E84     MOVLW 0x84
15476  6EE6     MOVWF 0xFE6, ACCESS
15478  0E40     MOVLW 0x40
1547A  6EE6     MOVWF 0xFE6, ACCESS
1547C  0EF7     MOVLW 0xF7
1547E  50E3     MOVF 0xFE3, W, ACCESS
15480  6EE6     MOVWF 0xFE6, ACCESS
15482  EC78     CALL 0x1BAF0, 0
15484  F0DD     NOP
15488  F004     NOP
1548A  F00B     NOP
1548E  F008     NOP
15490  F00C     NOP
15492  500B     MOVF wtemp5, W, ACCESS
15494  6E05     MOVWF ltemp1, ACCESS
15496  500C     MOVF 0xC, W, ACCESS
15498  6E06     MOVWF 0x6, ACCESS
1549A  6A07     CLRF ttemp2, ACCESS
1549C  6A08     CLRF 0x8, ACCESS
154A0  F017     NOP
154A2  FFE6     NOP
154A6  F01B     NOP
154A8  FFE6     NOP
154AC  F01F     NOP
154AE  FFE6     NOP
154B2  F023     NOP
154B4  FFE6     NOP
154B6  0E00     MOVLW 0x0
154B8  6EE6     MOVWF 0xFE6, ACCESS
154BA  ECCA     CALL 0x18194, 0
154BC  F0C0     NOP
154C0  F007     NOP
154C2  FFE6     NOP
154C6  F00B     NOP
154C8  FFE6     NOP
154CC  F00F     NOP
154CE  FFE6     NOP
154D2  F013     NOP
154D4  FFE6     NOP
154D6  ECA0     CALL 0x13340, 0
154D8  F099     NOP
154DC  F007     NOP
154DE  FFE6     NOP
154E2  F00B     NOP
154E4  FFE6     NOP
154E8  F00F     NOP
154EA  FFE6     NOP
154EE  F013     NOP
154F0  FFE6     NOP
154F2  EC51     CALL 0x14AA2, 0
154F4  F0A5     NOP
154F6  D019     BRA 0x552A
125:           		break;
126:           	default:
127:           		return 0.0;
154F8  0E00     MOVLW 0x0
154FA  6E01     MOVWF ltemp0, ACCESS
154FC  0E00     MOVLW 0x0
154FE  6E02     MOVWF ttemp5, ACCESS
15500  0E00     MOVLW 0x0
15502  6E03     MOVWF wtemp1, ACCESS
15504  0E00     MOVLW 0x0
15506  6E04     MOVWF ttemp1, ACCESS
15508  D010     BRA 0x552A
128:           		break;
129:           	}
1550A  0EFE     MOVLW 0xFE
1550C  50E3     MOVF 0xFE3, W, ACCESS
1550E  6E0B     MOVWF wtemp5, ACCESS
15510  6A0C     CLRF 0xC, ACCESS
15512  500C     MOVF 0xC, W, ACCESS
15514  0A00     XORLW 0x0
15516  A4D8     BTFSS 0xFD8, 2, ACCESS
15518  D7EF     BRA 0x54F8
1551A  500B     MOVF wtemp5, W, ACCESS
1551C  0A00     XORLW 0x0
1551E  B4D8     BTFSC 0xFD8, 2, ACCESS
15520  D57E     BRA 0x501E
15522  0A01     XORLW 0x1
15524  B4D8     BTFSC 0xFD8, 2, ACCESS
15526  D72A     BRA 0x537C
15528  D7E7     BRA 0x54F8
130:           	return 0.0;
131:           }
1552A  52E5     MOVF 0xFE5, F, ACCESS
1552C  52E5     MOVF 0xFE5, F, ACCESS
1552E  0012     RETURN 0
132:           
133:           /*
134:            * ADC per conversion interrupt
135:            */
136:           static void adc_int_handler(void)
137:           {
138:           #ifdef DEBUG_DAQ2
139:           	DEBUG2_Toggle();
140:           #endif
141:           }
1BDF6  0012     RETURN 0
142:           
143:           /*
144:            * ADC per channel average interrupt
145:            */
146:           static void adc_int_t_handler(void)
147:           {
148:           	/*
149:           	 * use the filter result buffer for raw adc data
150:           	 */
151:           	R.raw_adc[R.scan_index] = ((adc_result_t) ((ADFLTRH << 8) + ADFLTRL));
1AA38  013E     MOVLB 0x3E
1AA3A  51E6     MOVF 0xE6, W, BANKED
1AA3E  FB9C     NOP
1AA40  F001     NOP
1AA42  6A02     CLRF ttemp5, ACCESS
1AA46  F004     NOP
1AA48  F002     NOP
1AA4A  6A01     CLRF ltemp0, ACCESS
1AA4C  2601     ADDWF ltemp0, F, ACCESS
1AA4E  0E00     MOVLW 0x0
1AA50  2202     ADDWFC ttemp5, F, ACCESS
1AA52  0101     MOVLB 0x1
1AA54  512C     MOVF 0x2C, W, BANKED
1AA56  0D02     MULLW 0x2
1AA58  0E00     MOVLW 0x0
1AA5A  24F3     ADDWF 0xFF3, W, ACCESS
1AA5C  6ED9     MOVWF 0xFD9, ACCESS
1AA5E  0E01     MOVLW 0x1
1AA60  20F4     ADDWFC 0xFF4, W, ACCESS
1AA62  6EDA     MOVWF 0xFDA, ACCESS
1AA66  F007     NOP
1AA68  FFDE     NOP
1AA6C  F00B     NOP
1AA6E  FFDD     NOP
152:           	do {
153:           		if (++R.scan_index > LAST_ADC_CHAN) {
1AA70  0101     MOVLB 0x1
1AA72  2B2C     INCF 0x2C, F, BANKED
1AA74  0E0D     MOVLW 0xD
1AA76  652C     CPFSGT 0x2C, BANKED
1AA78  D003     BRA 0xAA80
154:           			R.done = true;
1AA7A  0E01     MOVLW 0x1
1AA7C  6F2F     MOVWF 0x2F, BANKED
1AA7E  0012     RETURN 0
155:           #ifdef DEBUG_DAQ1
156:           			DEBUG1_SetLow();
157:           #endif
158:           			return;
159:           		}
160:           	} while (!((R.scan_select >> R.scan_index) &0x1)); // check for analog port bit
1AA82  F4B0     NOP
1AA84  F00C     NOP
1AA86  EE20     LFSR 2, 0x12D
1AA88  F12D     NOP
1AA8C  FF78     NOP
1AA8E  F009     NOP
1AA92  FF74     NOP
1AA94  F00A     NOP
1AA96  2A0C     INCF 0xC, F, ACCESS
1AA98  D003     BRA 0xAAA0
1AA9A  90D8     BCF 0xFD8, 0, ACCESS
1AA9C  320A     RRCF ttemp3, F, ACCESS
1AA9E  3209     RRCF ltemp2, F, ACCESS
1AAA0  2E0C     DECFSZ 0xC, F, ACCESS
1AAA2  D7FB     BRA 0xAA9A
1AAA4  A009     BTFSS ltemp2, 0, ACCESS
1AAA6  D7E4     BRA 0xAA70
161:           	ADCC_DischargeSampleCapacitor(); // short ADC sample cap before next channel sampling
1AAA8  ECD3     CALL 0x1BDA6, 0
1AAAA  F0DE     NOP
162:           	ADCC_StartConversion(R.scan_index & 0xf);
1AAAC  0101     MOVLB 0x1
1AAAE  512C     MOVF 0x2C, W, BANKED
1AAB0  0B0F     ANDLW 0xF
1AAB2  6EE6     MOVWF 0xFE6, ACCESS
1AAB4  EC62     CALL 0x1BCC4, 0
1AAB6  F0DE     NOP
163:           #ifdef DEBUG_DAQ1
164:           	DEBUG1_Toggle();
165:           #endif
166:           }
1AAB8  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/bsoc.c  --------------------------------------------------
1:             #include "bsoc.h"
2:             #include "mcc_generated_files/interrupt_manager.h"
3:             
4:             extern C_data C;
5:             extern V_data V;
6:             
7:             const uint32_t BVSOC_TABLE[BVSOC_SLOTS][2] = {
8:             	23000, 5,
9:             	23400, 10,
10:            	23600, 20,
11:            	24120, 25,
12:            	24200, 30,
13:            	24440, 40,
14:            	24540, 45,
15:            	24600, 50,
16:            	24646, 53,
17:            	24700, 55,
18:            	24750, 57,
19:            	24800, 60,
20:            	24850, 63,
21:            	24925, 67,
22:            	25000, 70,
23:            	25020, 72,
24:            	25040, 75,
25:            	25050, 80,
26:            	25060, 85,
27:            	25080, 90,
28:            	25096, 92,
29:            	25122, 93,
30:            	25140, 95,
31:            	25160, 97,
32:            	25180, 100,
33:            	26500, 98 // charging voltage guess
34:            };
35:            
36:            /*
37:             * low-pri interrupt ISR the runs every second for simple coulomb counting
38:             */
39:            void calc_bsoc(void)
14326  52E6     MOVF 0xFE6, F, ACCESS
14328  52E6     MOVF 0xFE6, F, ACCESS
40:            {
41:            	uint8_t * log_ptr;
42:            	static uint8_t log_update_wait = 0;
43:            #ifdef DEBUG_BSOC1
44:            	DEBUG1_SetHigh();
1432A  82BE     BSF 0xFBE, 1, ACCESS
45:            #endif
46:            	C.dynamic_ah += (C.c_bat / SSLICE); // Ah
1432C  0E00     MOVLW 0x0
1432E  6EE6     MOVWF 0xFE6, ACCESS
14330  0E00     MOVLW 0x0
14332  6EE6     MOVWF 0xFE6, ACCESS
14334  0E61     MOVLW 0x61
14336  6EE6     MOVWF 0xFE6, ACCESS
14338  0E45     MOVLW 0x45
1433A  6EE6     MOVWF 0xFE6, ACCESS
1433C  EE21     LFSR 2, 0x743
1433E  F343     NOP
14342  FF7B     NOP
14344  FFE6     NOP
14348  FF7B     NOP
1434A  FFE6     NOP
1434E  FF7B     NOP
14350  FFE6     NOP
14354  FF7B     NOP
14356  FFE6     NOP
14358  EC51     CALL 0x14AA2, 0
1435A  F0A5     NOP
1435E  F007     NOP
14360  FFE6     NOP
14364  F00B     NOP
14366  FFE6     NOP
1436A  F00F     NOP
1436C  FFE6     NOP
14370  F013     NOP
14372  FFE6     NOP
14374  0E8F     MOVLW 0x8F
14376  6EE6     MOVWF 0xFE6, ACCESS
14378  0E07     MOVLW 0x7
1437A  6EE6     MOVWF 0xFE6, ACCESS
1437C  EC5D     CALL 0x1AABA, 0
1437E  F0D5     NOP
47:            	if (C.dynamic_ah > (C.bank_ah))
14380  EE21     LFSR 2, 0x78F
14382  F38F     NOP
14386  FF7B     NOP
14388  FFE6     NOP
1438C  FF7B     NOP
1438E  FFE6     NOP
14392  FF7B     NOP
14394  FFE6     NOP
14398  FF7B     NOP
1439A  FFE6     NOP
1439C  EE21     LFSR 2, 0x78B
1439E  F38B     NOP
143A2  FF7B     NOP
143A4  FFE6     NOP
143A8  FF7B     NOP
143AA  FFE6     NOP
143AE  FF7B     NOP
143B0  FFE6     NOP
143B4  FF7B     NOP
143B6  FFE6     NOP
143B8  EC81     CALL 0x18D02, 0
143BA  F0C6     NOP
143BC  B001     BTFSC ltemp0, 0, ACCESS
143BE  D00E     BRA 0x43DC
48:            		C.dynamic_ah = C.bank_ah;
143C0  EE21     LFSR 2, 0x78B
143C2  F38B     NOP
143C6  FF78     NOP
143C8  F78F     NOP
143CC  FF78     NOP
143CE  F790     NOP
143D2  FF78     NOP
143D4  F791     NOP
143D8  FF74     NOP
143DA  F792     NOP
49:            	if (C.dynamic_ah < 0.1)
143DC  0ECD     MOVLW 0xCD
143DE  6EE6     MOVWF 0xFE6, ACCESS
143E0  0ECC     MOVLW 0xCC
143E2  6EE6     MOVWF 0xFE6, ACCESS
143E4  0ECC     MOVLW 0xCC
143E6  6EE6     MOVWF 0xFE6, ACCESS
143E8  0E3D     MOVLW 0x3D
143EA  6EE6     MOVWF 0xFE6, ACCESS
143EC  EE21     LFSR 2, 0x78F
143EE  F38F     NOP
143F2  FF7B     NOP
143F4  FFE6     NOP
143F8  FF7B     NOP
143FA  FFE6     NOP
143FE  FF7B     NOP
14400  FFE6     NOP
14404  FF7B     NOP
14406  FFE6     NOP
14408  EC81     CALL 0x18D02, 0
1440A  F0C6     NOP
1440C  B001     BTFSC ltemp0, 0, ACCESS
1440E  D010     BRA 0x4430
50:            		C.dynamic_ah = 0.1;
14410  0ECD     MOVLW 0xCD
14414  FFA0     NOP
14416  F78F     NOP
14418  0ECC     MOVLW 0xCC
1441C  FFA0     NOP
1441E  F790     NOP
14420  0ECC     MOVLW 0xCC
14424  FFA0     NOP
14426  F791     NOP
14428  0E3D     MOVLW 0x3D
1442C  FFA0     NOP
1442E  F792     NOP
51:            
52:            	C.pv_ah += (C.c_pv / SSLICE);
14430  0E00     MOVLW 0x0
14432  6EE6     MOVWF 0xFE6, ACCESS
14434  0E00     MOVLW 0x0
14436  6EE6     MOVWF 0xFE6, ACCESS
14438  0E61     MOVLW 0x61
1443A  6EE6     MOVWF 0xFE6, ACCESS
1443C  0E45     MOVLW 0x45
1443E  6EE6     MOVWF 0xFE6, ACCESS
14440  EE21     LFSR 2, 0x747
14442  F347     NOP
14446  FF7B     NOP
14448  FFE6     NOP
1444C  FF7B     NOP
1444E  FFE6     NOP
14452  FF7B     NOP
14454  FFE6     NOP
14458  FF7B     NOP
1445A  FFE6     NOP
1445C  EC51     CALL 0x14AA2, 0
1445E  F0A5     NOP
14462  F007     NOP
14464  FFE6     NOP
14468  F00B     NOP
1446A  FFE6     NOP
1446E  F00F     NOP
14470  FFE6     NOP
14474  F013     NOP
14476  FFE6     NOP
14478  0E93     MOVLW 0x93
1447A  6EE6     MOVWF 0xFE6, ACCESS
1447C  0E07     MOVLW 0x7
1447E  6EE6     MOVWF 0xFE6, ACCESS
14480  EC5D     CALL 0x1AABA, 0
14482  F0D5     NOP
53:            	C.pvkw += (C.p_pv / SSLICE);
14484  0E00     MOVLW 0x0
14486  6EE6     MOVWF 0xFE6, ACCESS
14488  0E00     MOVLW 0x0
1448A  6EE6     MOVWF 0xFE6, ACCESS
1448C  0E61     MOVLW 0x61
1448E  6EE6     MOVWF 0xFE6, ACCESS
14490  0E45     MOVLW 0x45
14492  6EE6     MOVWF 0xFE6, ACCESS
14494  EE21     LFSR 2, 0x77B
14496  F37B     NOP
1449A  FF7B     NOP
1449C  FFE6     NOP
144A0  FF7B     NOP
144A2  FFE6     NOP
144A6  FF7B     NOP
144A8  FFE6     NOP
144AC  FF7B     NOP
144AE  FFE6     NOP
144B0  EC51     CALL 0x14AA2, 0
144B2  F0A5     NOP
144B6  F007     NOP
144B8  FFE6     NOP
144BC  F00B     NOP
144BE  FFE6     NOP
144C2  F00F     NOP
144C4  FFE6     NOP
144C8  F013     NOP
144CA  FFE6     NOP
144CC  0EA3     MOVLW 0xA3
144CE  6EE6     MOVWF 0xFE6, ACCESS
144D0  0E07     MOVLW 0x7
144D2  6EE6     MOVWF 0xFE6, ACCESS
144D4  EC5D     CALL 0x1AABA, 0
144D6  F0D5     NOP
54:            	C.invkw += (C.p_inverter / SSLICE);
144D8  0E00     MOVLW 0x0
144DA  6EE6     MOVWF 0xFE6, ACCESS
144DC  0E00     MOVLW 0x0
144DE  6EE6     MOVWF 0xFE6, ACCESS
144E0  0E61     MOVLW 0x61
144E2  6EE6     MOVWF 0xFE6, ACCESS
144E4  0E45     MOVLW 0x45
144E6  6EE6     MOVWF 0xFE6, ACCESS
144E8  EE21     LFSR 2, 0x777
144EA  F377     NOP
144EE  FF7B     NOP
144F0  FFE6     NOP
144F4  FF7B     NOP
144F6  FFE6     NOP
144FA  FF7B     NOP
144FC  FFE6     NOP
14500  FF7B     NOP
14502  FFE6     NOP
14504  EC51     CALL 0x14AA2, 0
14506  F0A5     NOP
1450A  F007     NOP
1450C  FFE6     NOP
14510  F00B     NOP
14512  FFE6     NOP
14516  F00F     NOP
14518  FFE6     NOP
1451C  F013     NOP
1451E  FFE6     NOP
14520  0EA7     MOVLW 0xA7
14522  6EE6     MOVWF 0xFE6, ACCESS
14524  0E07     MOVLW 0x7
14526  6EE6     MOVWF 0xFE6, ACCESS
14528  EC5D     CALL 0x1AABA, 0
1452A  F0D5     NOP
55:            	C.loadkw += (C.p_load / SSLICE);
1452C  0E00     MOVLW 0x0
1452E  6EE6     MOVWF 0xFE6, ACCESS
14530  0E00     MOVLW 0x0
14532  6EE6     MOVWF 0xFE6, ACCESS
14534  0E61     MOVLW 0x61
14536  6EE6     MOVWF 0xFE6, ACCESS
14538  0E45     MOVLW 0x45
1453A  6EE6     MOVWF 0xFE6, ACCESS
1453C  EE21     LFSR 2, 0x773
1453E  F373     NOP
14542  FF7B     NOP
14544  FFE6     NOP
14548  FF7B     NOP
1454A  FFE6     NOP
1454E  FF7B     NOP
14550  FFE6     NOP
14554  FF7B     NOP
14556  FFE6     NOP
14558  EC51     CALL 0x14AA2, 0
1455A  F0A5     NOP
1455E  F007     NOP
14560  FFE6     NOP
14564  F00B     NOP
14566  FFE6     NOP
1456A  F00F     NOP
1456C  FFE6     NOP
14570  F013     NOP
14572  FFE6     NOP
14574  0EAB     MOVLW 0xAB
14576  6EE6     MOVWF 0xFE6, ACCESS
14578  0E07     MOVLW 0x7
1457A  6EE6     MOVWF 0xFE6, ACCESS
1457C  EC5D     CALL 0x1AABA, 0
1457E  F0D5     NOP
56:            	if (C.p_bat > 0.0)
14580  EE21     LFSR 2, 0x77F
14582  F37F     NOP
14586  FF7B     NOP
14588  FFE6     NOP
1458C  FF7B     NOP
1458E  FFE6     NOP
14592  FF7B     NOP
14594  FFE6     NOP
14598  FF7B     NOP
1459A  FFE6     NOP
1459C  0E00     MOVLW 0x0
1459E  6EE6     MOVWF 0xFE6, ACCESS
145A0  0E00     MOVLW 0x0
145A2  6EE6     MOVWF 0xFE6, ACCESS
145A4  0E00     MOVLW 0x0
145A6  6EE6     MOVWF 0xFE6, ACCESS
145A8  0E00     MOVLW 0x0
145AA  6EE6     MOVWF 0xFE6, ACCESS
145AC  EC81     CALL 0x18D02, 0
145AE  F0C6     NOP
145B0  B001     BTFSC ltemp0, 0, ACCESS
145B2  D02A     BRA 0x4608
57:            		C.bkwi += (C.p_bat / SSLICE);
145B4  0E00     MOVLW 0x0
145B6  6EE6     MOVWF 0xFE6, ACCESS
145B8  0E00     MOVLW 0x0
145BA  6EE6     MOVWF 0xFE6, ACCESS
145BC  0E61     MOVLW 0x61
145BE  6EE6     MOVWF 0xFE6, ACCESS
145C0  0E45     MOVLW 0x45
145C2  6EE6     MOVWF 0xFE6, ACCESS
145C4  EE21     LFSR 2, 0x77F
145C6  F37F     NOP
145CA  FF7B     NOP
145CC  FFE6     NOP
145D0  FF7B     NOP
145D2  FFE6     NOP
145D6  FF7B     NOP
145D8  FFE6     NOP
145DC  FF7B     NOP
145DE  FFE6     NOP
145E0  EC51     CALL 0x14AA2, 0
145E2  F0A5     NOP
145E6  F007     NOP
145E8  FFE6     NOP
145EC  F00B     NOP
145EE  FFE6     NOP
145F2  F00F     NOP
145F4  FFE6     NOP
145F8  F013     NOP
145FA  FFE6     NOP
145FC  0E9B     MOVLW 0x9B
145FE  6EE6     MOVWF 0xFE6, ACCESS
14600  0E07     MOVLW 0x7
14602  6EE6     MOVWF 0xFE6, ACCESS
14604  EC5D     CALL 0x1AABA, 0
14606  F0D5     NOP
58:            	if (C.p_bat < 0.0)
14608  EE21     LFSR 2, 0x77F
1460A  F37F     NOP
1460C  0E03     MOVLW 0x3
1460E  AEDB     BTFSS 0xFDB, 7, ACCESS
14610  D038     BRA 0x4682
59:            		C.bkwo += fabs(C.p_bat / SSLICE);
14612  0E00     MOVLW 0x0
14614  6EE6     MOVWF 0xFE6, ACCESS
14616  0E00     MOVLW 0x0
14618  6EE6     MOVWF 0xFE6, ACCESS
1461A  0E61     MOVLW 0x61
1461C  6EE6     MOVWF 0xFE6, ACCESS
1461E  0E45     MOVLW 0x45
14620  6EE6     MOVWF 0xFE6, ACCESS
14622  EE21     LFSR 2, 0x77F
14624  F37F     NOP
14628  FF7B     NOP
1462A  FFE6     NOP
1462E  FF7B     NOP
14630  FFE6     NOP
14634  FF7B     NOP
14636  FFE6     NOP
1463A  FF7B     NOP
1463C  FFE6     NOP
1463E  EC51     CALL 0x14AA2, 0
14640  F0A5     NOP
14644  F007     NOP
14646  FFE6     NOP
1464A  F00B     NOP
1464C  FFE6     NOP
14650  F00F     NOP
14652  FFE6     NOP
14656  F013     NOP
14658  FFE6     NOP
1465A  EC87     CALL 0x1A30E, 0
1465C  F0D1     NOP
14660  F007     NOP
14662  FFE6     NOP
14666  F00B     NOP
14668  FFE6     NOP
1466C  F00F     NOP
1466E  FFE6     NOP
14672  F013     NOP
14674  FFE6     NOP
14676  0E9F     MOVLW 0x9F
14678  6EE6     MOVWF 0xFE6, ACCESS
1467A  0E07     MOVLW 0x7
1467C  6EE6     MOVWF 0xFE6, ACCESS
1467E  EC5D     CALL 0x1AABA, 0
14680  F0D5     NOP
60:            
61:            	C.soc = ((uint16_t) ((C.dynamic_ah / C.bank_ah)*100.0) + 1);
14682  0E00     MOVLW 0x0
14684  6EE6     MOVWF 0xFE6, ACCESS
14686  0E00     MOVLW 0x0
14688  6EE6     MOVWF 0xFE6, ACCESS
1468A  0EC8     MOVLW 0xC8
1468C  6EE6     MOVWF 0xFE6, ACCESS
1468E  0E42     MOVLW 0x42
14690  6EE6     MOVWF 0xFE6, ACCESS
14692  EE21     LFSR 2, 0x78B
14694  F38B     NOP
14698  FF7B     NOP
1469A  FFE6     NOP
1469E  FF7B     NOP
146A0  FFE6     NOP
146A4  FF7B     NOP
146A6  FFE6     NOP
146AA  FF7B     NOP
146AC  FFE6     NOP
146AE  EE21     LFSR 2, 0x78F
146B0  F38F     NOP
146B4  FF7B     NOP
146B6  FFE6     NOP
146BA  FF7B     NOP
146BC  FFE6     NOP
146C0  FF7B     NOP
146C2  FFE6     NOP
146C6  FF7B     NOP
146C8  FFE6     NOP
146CA  EC51     CALL 0x14AA2, 0
146CC  F0A5     NOP
146D0  F007     NOP
146D2  FFE6     NOP
146D6  F00B     NOP
146D8  FFE6     NOP
146DC  F00F     NOP
146DE  FFE6     NOP
146E2  F013     NOP
146E4  FFE6     NOP
146E6  ECA0     CALL 0x13340, 0
146E8  F099     NOP
146EC  F007     NOP
146EE  FFE6     NOP
146F2  F00B     NOP
146F4  FFE6     NOP
146F8  F00F     NOP
146FA  FFE6     NOP
146FE  F013     NOP
14700  FFE6     NOP
14702  ECC8     CALL 0x18B90, 0
14704  F0C5     NOP
14708  F004     NOP
1470A  F00B     NOP
1470E  F008     NOP
14710  F00C     NOP
14712  0E01     MOVLW 0x1
14714  260B     ADDWF wtemp5, F, ACCESS
14716  0E00     MOVLW 0x0
14718  220C     ADDWFC 0xC, F, ACCESS
1471C  F02C     NOP
1471E  F7B1     NOP
14722  F030     NOP
14724  F7B2     NOP
62:            	if (C.soc > 100)
14726  EE21     LFSR 2, 0x7B1
14728  F3B1     NOP
1472A  0E01     MOVLW 0x1
1472C  50DB     MOVF 0xFDB, W, ACCESS
1472E  E104     BNZ 0x4738
14730  0E65     MOVLW 0x65
14732  5CDE     SUBWF 0xFDE, W, ACCESS
14734  A0D8     BTFSS 0xFD8, 0, ACCESS
14736  D008     BRA 0x4748
63:            		C.soc = 100;
14738  0E64     MOVLW 0x64
1473C  FFA0     NOP
1473E  F7B1     NOP
14740  0E00     MOVLW 0x0
14744  FFA0     NOP
14746  F7B2     NOP
64:            
65:            	if (C.c_bat < 0.0) {
14748  EE21     LFSR 2, 0x743
1474A  F343     NOP
1474C  0E03     MOVLW 0x3
1474E  AEDB     BTFSS 0xFDB, 7, ACCESS
14750  D047     BRA 0x47E0
66:            		C.runtime = (uint16_t) (-(C.dynamic_ah / C.c_bat));
14752  EE21     LFSR 2, 0x743
14754  F343     NOP
14758  FF7B     NOP
1475A  FFE6     NOP
1475E  FF7B     NOP
14760  FFE6     NOP
14764  FF7B     NOP
14766  FFE6     NOP
1476A  FF7B     NOP
1476C  FFE6     NOP
1476E  EE21     LFSR 2, 0x78F
14770  F38F     NOP
14774  FF7B     NOP
14776  FFE6     NOP
1477A  FF7B     NOP
1477C  FFE6     NOP
14780  FF7B     NOP
14782  FFE6     NOP
14786  FF7B     NOP
14788  FFE6     NOP
1478A  EC51     CALL 0x14AA2, 0
1478C  F0A5     NOP
14790  F007     NOP
14792  FFE6     NOP
14796  F00B     NOP
14798  FFE6     NOP
1479C  F00F     NOP
1479E  FFE6     NOP
147A2  F013     NOP
147A4  FFE6     NOP
147A6  EC51     CALL 0x1B0A2, 0
147A8  F0D8     NOP
147AC  F007     NOP
147AE  FFE6     NOP
147B2  F00B     NOP
147B4  FFE6     NOP
147B8  F00F     NOP
147BA  FFE6     NOP
147BE  F013     NOP
147C0  FFE6     NOP
147C2  ECC8     CALL 0x18B90, 0
147C4  F0C5     NOP
147C8  F004     NOP
147CA  F00B     NOP
147CE  F008     NOP
147D0  F00C     NOP
147D4  F02C     NOP
147D6  F7AF     NOP
147DA  F030     NOP
147DC  F7B0     NOP
67:            	} else {
147DE  D008     BRA 0x47F0
68:            		C.runtime = 120;
147E0  0E78     MOVLW 0x78
147E4  FFA0     NOP
147E6  F7AF     NOP
147E8  0E00     MOVLW 0x0
147EC  FFA0     NOP
147EE  F7B0     NOP
69:            	}
70:            	if (C.runtime > 120)
147F0  EE21     LFSR 2, 0x7AF
147F2  F3AF     NOP
147F4  0E01     MOVLW 0x1
147F6  50DB     MOVF 0xFDB, W, ACCESS
147F8  E104     BNZ 0x4802
147FA  0E79     MOVLW 0x79
147FC  5CDE     SUBWF 0xFDE, W, ACCESS
147FE  A0D8     BTFSS 0xFD8, 0, ACCESS
14800  D008     BRA 0x4812
71:            		C.runtime = 120;
14802  0E78     MOVLW 0x78
14806  FFA0     NOP
14808  F7AF     NOP
1480A  0E00     MOVLW 0x0
1480E  FFA0     NOP
14810  F7B0     NOP
72:            
73:            	V.lowint_count++;
14812  0E01     MOVLW 0x1
14814  0101     MOVLB 0x1
14816  27E3     ADDWF 0xE3, F, BANKED
14818  0E00     MOVLW 0x0
1481A  23E4     ADDWFC 0xE4, F, BANKED
1481C  23E5     ADDWFC 0xE5, F, BANKED
1481E  23E6     ADDWFC 0xE6, F, BANKED
74:            
75:            	if (!log_update_wait++ && V.system_stable) {
14820  2A41     INCF log_update_wait, F, ACCESS
14822  0441     DECF log_update_wait, W, ACCESS
14824  A4D8     BTFSS 0xFD8, 2, ACCESS
14826  D131     BRA 0x4A8A
14828  51DE     MOVF 0xDE, W, BANKED
1482A  B4D8     BTFSC 0xFD8, 2, ACCESS
1482C  D12E     BRA 0x4A8A
76:            		log_ptr = port_data_dma_ptr();
1482E  ECBC     CALL 0x1BD78, 0
14830  F0DE     NOP
14832  0EFF     MOVLW 0xFF
14836  F00B     NOP
14838  FFE3     NOP
1483A  0EFE     MOVLW 0xFE
1483E  F007     NOP
14840  FFE3     NOP
77:            		sprintf((char*) log_ptr, " %c ,%lu,%4.4f,%4.4f,%4.4f,%4.4f,%4.3f,%4.3f,%4.3f,%4.3f,%4.3f,%4.3f,%d,%d,%2.6f,%4.3f,%d,%d,%lu,%lu\r\n",
14842  EE22     LFSR 2, 0x822
14844  F022     NOP
14848  FF7B     NOP
1484A  FFE6     NOP
1484E  FF7B     NOP
14850  FFE6     NOP
14854  FF7B     NOP
14856  FFE6     NOP
1485A  FF7B     NOP
1485C  FFE6     NOP
1485E  EE22     LFSR 2, 0x81E
14860  F01E     NOP
14864  FF7B     NOP
14866  FFE6     NOP
1486A  FF7B     NOP
1486C  FFE6     NOP
14870  FF7B     NOP
14872  FFE6     NOP
14876  FF7B     NOP
14878  FFE6     NOP
1487A  EE22     LFSR 2, 0x81D
1487C  F01D     NOP
1487E  50DF     MOVF 0xFDF, W, ACCESS
14880  6EE6     MOVWF 0xFE6, ACCESS
14882  0E00     MOVLW 0x0
14884  6EE6     MOVWF 0xFE6, ACCESS
14886  ECA0     CALL 0x1BD40, 0
14888  F0DE     NOP
1488A  5001     MOVF ltemp0, W, ACCESS
1488C  6EE6     MOVWF 0xFE6, ACCESS
1488E  0E00     MOVLW 0x0
14890  6EE6     MOVWF 0xFE6, ACCESS
14892  EE21     LFSR 2, 0x767
14894  F367     NOP
14898  FF7B     NOP
1489A  FFE6     NOP
1489E  FF7B     NOP
148A0  FFE6     NOP
148A4  FF7B     NOP
148A6  FFE6     NOP
148AA  FF7B     NOP
148AC  FFE6     NOP
148AE  EE21     LFSR 2, 0x787
148B0  F387     NOP
148B4  FF7B     NOP
148B6  FFE6     NOP
148BA  FF7B     NOP
148BC  FFE6     NOP
148C0  FF7B     NOP
148C2  FFE6     NOP
148C6  FF7B     NOP
148C8  FFE6     NOP
148CA  EE21     LFSR 2, 0x7AF
148CC  F3AF     NOP
148D0  FF78     NOP
148D2  F00B     NOP
148D6  FF74     NOP
148D8  F00C     NOP
148DC  F02F     NOP
148DE  FFE6     NOP
148E2  F033     NOP
148E4  FFE6     NOP
148E6  EE21     LFSR 2, 0x7B1
148E8  F3B1     NOP
148EC  FF78     NOP
148EE  F00B     NOP
148F2  FF74     NOP
148F4  F00C     NOP
148F8  F02F     NOP
148FA  FFE6     NOP
148FE  F033     NOP
14900  FFE6     NOP
14902  EE21     LFSR 2, 0x793
14904  F393     NOP
14908  FF7B     NOP
1490A  FFE6     NOP
1490E  FF7B     NOP
14910  FFE6     NOP
14914  FF7B     NOP
14916  FFE6     NOP
1491A  FF7B     NOP
1491C  FFE6     NOP
1491E  EE21     LFSR 2, 0x78F
14920  F38F     NOP
14924  FF7B     NOP
14926  FFE6     NOP
1492A  FF7B     NOP
1492C  FFE6     NOP
14930  FF7B     NOP
14932  FFE6     NOP
14936  FF7B     NOP
14938  FFE6     NOP
1493A  EE21     LFSR 2, 0x777
1493C  F377     NOP
14940  FF7B     NOP
14942  FFE6     NOP
14946  FF7B     NOP
14948  FFE6     NOP
1494C  FF7B     NOP
1494E  FFE6     NOP
14952  FF7B     NOP
14954  FFE6     NOP
14956  EE21     LFSR 2, 0x773
14958  F373     NOP
1495C  FF7B     NOP
1495E  FFE6     NOP
14962  FF7B     NOP
14964  FFE6     NOP
14968  FF7B     NOP
1496A  FFE6     NOP
1496E  FF7B     NOP
14970  FFE6     NOP
14972  EE21     LFSR 2, 0x77B
14974  F37B     NOP
14978  FF7B     NOP
1497A  FFE6     NOP
1497E  FF7B     NOP
14980  FFE6     NOP
14984  FF7B     NOP
14986  FFE6     NOP
1498A  FF7B     NOP
1498C  FFE6     NOP
1498E  EE21     LFSR 2, 0x77F
14990  F37F     NOP
14994  FF7B     NOP
14996  FFE6     NOP
1499A  FF7B     NOP
1499C  FFE6     NOP
149A0  FF7B     NOP
149A2  FFE6     NOP
149A6  FF7B     NOP
149A8  FFE6     NOP
149AA  EE21     LFSR 2, 0x763
149AC  F363     NOP
149B0  FF7B     NOP
149B2  FFE6     NOP
149B6  FF7B     NOP
149B8  FFE6     NOP
149BC  FF7B     NOP
149BE  FFE6     NOP
149C2  FF7B     NOP
149C4  FFE6     NOP
149C6  EE21     LFSR 2, 0x74B
149C8  F34B     NOP
149CC  FF7B     NOP
149CE  FFE6     NOP
149D2  FF7B     NOP
149D4  FFE6     NOP
149D8  FF7B     NOP
149DA  FFE6     NOP
149DE  FF7B     NOP
149E0  FFE6     NOP
149E2  EE21     LFSR 2, 0x74F
149E4  F34F     NOP
149E8  FF7B     NOP
149EA  FFE6     NOP
149EE  FF7B     NOP
149F0  FFE6     NOP
149F4  FF7B     NOP
149F6  FFE6     NOP
149FA  FF7B     NOP
149FC  FFE6     NOP
149FE  EE21     LFSR 2, 0x753
14A00  F353     NOP
14A04  FF7B     NOP
14A06  FFE6     NOP
14A0A  FF7B     NOP
14A0C  FFE6     NOP
14A10  FF7B     NOP
14A12  FFE6     NOP
14A16  FF7B     NOP
14A18  FFE6     NOP
14A1C  F6C7     NOP
14A1E  FFE6     NOP
14A22  F6CB     NOP
14A24  FFE6     NOP
14A28  F6CF     NOP
14A2A  FFE6     NOP
14A2E  F6D3     NOP
14A30  FFE6     NOP
14A32  0E31     MOVLW 0x31
14A34  6EE6     MOVWF 0xFE6, ACCESS
14A36  0E00     MOVLW 0x0
14A38  6EE6     MOVWF 0xFE6, ACCESS
14A3A  0E53     MOVLW 0x53
14A3C  6EE6     MOVWF 0xFE6, ACCESS
14A3E  0EFC     MOVLW 0xFC
14A40  6EE6     MOVWF 0xFE6, ACCESS
14A42  0EB6     MOVLW 0xB6
14A46  FF8F     NOP
14A48  FFE6     NOP
14A4C  FF8F     NOP
14A4E  FFE6     NOP
14A50  0E4A     MOVLW 0x4A
14A52  6EE6     MOVWF 0xFE6, ACCESS
14A54  EC1E     CALL 0x19A3C, 0
14A56  F0CD     NOP
78:            			D_CODE, V.ticks,
79:            			C.v_bat, C.v_pv, C.v_cc, C.v_inverter,
80:            			C.p_bat, C.p_pv, C.p_load, C.p_inverter,
81:            			C.dynamic_ah, C.pv_ah, C.soc, C.runtime,
82:            			C.esr, C.v_sensor, get_ac_charger_relay(), C.day, C.day_start, C.day_end);
83:            		StartTimer(TMR_DISPLAY, SOCDELAY); // sync the spi dma display updates
14A58  0E7D     MOVLW 0x7D
14A5A  6EE6     MOVWF 0xFE6, ACCESS
14A5C  0E00     MOVLW 0x0
14A5E  6EE6     MOVWF 0xFE6, ACCESS
14A60  0E0A     MOVLW 0xA
14A62  6EE6     MOVWF 0xFE6, ACCESS
14A64  EC6A     CALL 0x1B2D4, 0
14A66  F0D9     NOP
84:            		send_port_data_dma(strlen((char*) log_ptr));
14A68  0EFE     MOVLW 0xFE
14A6C  FF8F     NOP
14A6E  FFE6     NOP
14A72  FF8F     NOP
14A74  FFE6     NOP
14A76  ECDC     CALL 0x1A5B8, 0
14A78  F0D2     NOP
14A7C  F007     NOP
14A7E  FFE6     NOP
14A82  F00B     NOP
14A84  FFE6     NOP
14A86  ECDC     CALL 0x1AFB8, 0
14A88  F0D7     NOP
85:            	}
86:            	if (log_update_wait >= LOG_WAIT)
14A8A  0E09     MOVLW 0x9
14A8C  6441     CPFSGT log_update_wait, ACCESS
14A8E  D001     BRA 0x4A92
87:            		log_update_wait = 0;
14A90  6A41     CLRF log_update_wait, ACCESS
88:            
89:            	C.update = false;
14A92  0E00     MOVLW 0x0
14A96  FFA0     NOP
14A98  F7B3     NOP
90:            #ifdef DEBUG_BSOC1
91:            	DEBUG1_SetLow();
14A9A  92BE     BCF 0xFBE, 1, ACCESS
92:            #endif
93:            }
14A9C  52E5     MOVF 0xFE5, F, ACCESS
14A9E  52E5     MOVF 0xFE5, F, ACCESS
14AA0  0012     RETURN 0
94:            
95:            void init_bsoc(void)
96:            {
97:            	/*
98:            	 * use raw battery voltage
99:            	 */
100:           	C.soc = Volts_to_SOC((uint32_t) conv_raw_result(V_BAT, CONV) * 1000.0);
17B38  0E00     MOVLW 0x0
17B3A  6EE6     MOVWF 0xFE6, ACCESS
17B3C  0E00     MOVLW 0x0
17B3E  6EE6     MOVWF 0xFE6, ACCESS
17B40  0E7A     MOVLW 0x7A
17B42  6EE6     MOVWF 0xFE6, ACCESS
17B44  0E44     MOVLW 0x44
17B46  6EE6     MOVWF 0xFE6, ACCESS
17B48  0E00     MOVLW 0x0
17B4A  6EE6     MOVWF 0xFE6, ACCESS
17B4C  0E04     MOVLW 0x4
17B4E  6EE6     MOVWF 0xFE6, ACCESS
17B50  EC0E     CALL 0x1501C, 0
17B52  F0A8     NOP
17B56  F007     NOP
17B58  FFE6     NOP
17B5C  F00B     NOP
17B5E  FFE6     NOP
17B62  F00F     NOP
17B64  FFE6     NOP
17B68  F013     NOP
17B6A  FFE6     NOP
17B6C  ECC8     CALL 0x18B90, 0
17B6E  F0C5     NOP
17B72  F007     NOP
17B74  FFE6     NOP
17B78  F00B     NOP
17B7A  FFE6     NOP
17B7E  F00F     NOP
17B80  FFE6     NOP
17B84  F013     NOP
17B86  FFE6     NOP
17B88  0E00     MOVLW 0x0
17B8A  6EE6     MOVWF 0xFE6, ACCESS
17B8C  ECCA     CALL 0x18194, 0
17B8E  F0C0     NOP
17B92  F007     NOP
17B94  FFE6     NOP
17B98  F00B     NOP
17B9A  FFE6     NOP
17B9E  F00F     NOP
17BA0  FFE6     NOP
17BA4  F013     NOP
17BA6  FFE6     NOP
17BA8  ECA0     CALL 0x13340, 0
17BAA  F099     NOP
17BAE  F007     NOP
17BB0  FFE6     NOP
17BB4  F00B     NOP
17BB6  FFE6     NOP
17BBA  F00F     NOP
17BBC  FFE6     NOP
17BC0  F013     NOP
17BC2  FFE6     NOP
17BC4  ECC8     CALL 0x18B90, 0
17BC6  F0C5     NOP
17BCA  F007     NOP
17BCC  FFE6     NOP
17BD0  F00B     NOP
17BD2  FFE6     NOP
17BD6  F00F     NOP
17BD8  FFE6     NOP
17BDC  F013     NOP
17BDE  FFE6     NOP
17BE0  ECF3     CALL 0x195E6, 0
17BE2  F0CA     NOP
17BE6  F004     NOP
17BE8  F7B1     NOP
17BEC  F008     NOP
17BEE  F7B2     NOP
101:           	C.dynamic_ah = C.bank_ah * (Volts_to_SOC((uint32_t) conv_raw_result(V_BAT, CONV) * 1000.0) / 100.0);
17BF0  EE21     LFSR 2, 0x78B
17BF2  F38B     NOP
17BF6  FF7B     NOP
17BF8  FFE6     NOP
17BFC  FF7B     NOP
17BFE  FFE6     NOP
17C02  FF7B     NOP
17C04  FFE6     NOP
17C08  FF7B     NOP
17C0A  FFE6     NOP
17C0C  0E00     MOVLW 0x0
17C0E  6EE6     MOVWF 0xFE6, ACCESS
17C10  0E00     MOVLW 0x0
17C12  6EE6     MOVWF 0xFE6, ACCESS
17C14  0EC8     MOVLW 0xC8
17C16  6EE6     MOVWF 0xFE6, ACCESS
17C18  0E42     MOVLW 0x42
17C1A  6EE6     MOVWF 0xFE6, ACCESS
17C1C  0E00     MOVLW 0x0
17C1E  6EE6     MOVWF 0xFE6, ACCESS
17C20  0E00     MOVLW 0x0
17C22  6EE6     MOVWF 0xFE6, ACCESS
17C24  0E7A     MOVLW 0x7A
17C26  6EE6     MOVWF 0xFE6, ACCESS
17C28  0E44     MOVLW 0x44
17C2A  6EE6     MOVWF 0xFE6, ACCESS
17C2C  0E00     MOVLW 0x0
17C2E  6EE6     MOVWF 0xFE6, ACCESS
17C30  0E04     MOVLW 0x4
17C32  6EE6     MOVWF 0xFE6, ACCESS
17C34  EC0E     CALL 0x1501C, 0
17C36  F0A8     NOP
17C3A  F007     NOP
17C3C  FFE6     NOP
17C40  F00B     NOP
17C42  FFE6     NOP
17C46  F00F     NOP
17C48  FFE6     NOP
17C4C  F013     NOP
17C4E  FFE6     NOP
17C50  ECC8     CALL 0x18B90, 0
17C52  F0C5     NOP
17C56  F007     NOP
17C58  FFE6     NOP
17C5C  F00B     NOP
17C5E  FFE6     NOP
17C62  F00F     NOP
17C64  FFE6     NOP
17C68  F013     NOP
17C6A  FFE6     NOP
17C6C  0E00     MOVLW 0x0
17C6E  6EE6     MOVWF 0xFE6, ACCESS
17C70  ECCA     CALL 0x18194, 0
17C72  F0C0     NOP
17C76  F007     NOP
17C78  FFE6     NOP
17C7C  F00B     NOP
17C7E  FFE6     NOP
17C82  F00F     NOP
17C84  FFE6     NOP
17C88  F013     NOP
17C8A  FFE6     NOP
17C8C  ECA0     CALL 0x13340, 0
17C8E  F099     NOP
17C92  F007     NOP
17C94  FFE6     NOP
17C98  F00B     NOP
17C9A  FFE6     NOP
17C9E  F00F     NOP
17CA0  FFE6     NOP
17CA4  F013     NOP
17CA6  FFE6     NOP
17CA8  ECC8     CALL 0x18B90, 0
17CAA  F0C5     NOP
17CAE  F007     NOP
17CB0  FFE6     NOP
17CB4  F00B     NOP
17CB6  FFE6     NOP
17CBA  F00F     NOP
17CBC  FFE6     NOP
17CC0  F013     NOP
17CC2  FFE6     NOP
17CC4  ECF3     CALL 0x195E6, 0
17CC6  F0CA     NOP
17CCA  F004     NOP
17CCC  F00B     NOP
17CD0  F008     NOP
17CD2  F00C     NOP
17CD4  500B     MOVF wtemp5, W, ACCESS
17CD6  6E05     MOVWF ltemp1, ACCESS
17CD8  500C     MOVF 0xC, W, ACCESS
17CDA  6E06     MOVWF 0x6, ACCESS
17CDC  6A07     CLRF ttemp2, ACCESS
17CDE  6A08     CLRF 0x8, ACCESS
17CE2  F017     NOP
17CE4  FFE6     NOP
17CE8  F01B     NOP
17CEA  FFE6     NOP
17CEE  F01F     NOP
17CF0  FFE6     NOP
17CF4  F023     NOP
17CF6  FFE6     NOP
17CF8  0E00     MOVLW 0x0
17CFA  6EE6     MOVWF 0xFE6, ACCESS
17CFC  ECCA     CALL 0x18194, 0
17CFE  F0C0     NOP
17D02  F007     NOP
17D04  FFE6     NOP
17D08  F00B     NOP
17D0A  FFE6     NOP
17D0E  F00F     NOP
17D10  FFE6     NOP
17D14  F013     NOP
17D16  FFE6     NOP
17D18  EC51     CALL 0x14AA2, 0
17D1A  F0A5     NOP
17D1E  F007     NOP
17D20  FFE6     NOP
17D24  F00B     NOP
17D26  FFE6     NOP
17D2A  F00F     NOP
17D2C  FFE6     NOP
17D30  F013     NOP
17D32  FFE6     NOP
17D34  ECA0     CALL 0x13340, 0
17D36  F099     NOP
17D3A  F004     NOP
17D3C  F78F     NOP
17D40  F008     NOP
17D42  F790     NOP
17D46  F00C     NOP
17D48  F791     NOP
17D4C  F010     NOP
17D4E  F792     NOP
102:           	TMR3_SetInterruptHandler(calc_bsoc);
17D50  0E26     MOVLW 0x26
17D52  6EE6     MOVWF 0xFE6, ACCESS
17D54  0E43     MOVLW 0x43
17D56  6EE6     MOVWF 0xFE6, ACCESS
17D58  0E01     MOVLW 0x1
17D5A  6EE6     MOVWF 0xFE6, ACCESS
17D5C  EC6B     CALL 0x1B8D6, 0
17D5E  F0DC     NOP
103:           }
17D60  0012     RETURN 0
104:           
105:           void start_bsoc(void)
106:           {
107:           	// Enabling TMR3 interrupt.
108:           	PIE6bits.TMR3IE = 1;
1BB12  0139     MOVLB 0x39
1BB14  8D96     BSF utctime, 6, BANKED
109:           #ifdef DEBUG_BSOC2
110:           	DEBUG2_Toggle();
1BB16  A4BE     BTFSS 0xFBE, 2, ACCESS
1BB18  D002     BRA 0xBB1E
1BB1A  0E01     MOVLW 0x1
1BB1C  D001     BRA 0xBB20
1BB1E  0E00     MOVLW 0x0
1BB20  0AFF     XORLW 0xFF
1BB22  6E0C     MOVWF 0xC, ACCESS
1BB24  460C     RLNCF 0xC, F, ACCESS
1BB26  460C     RLNCF 0xC, F, ACCESS
1BB28  50BE     MOVF 0xFBE, W, ACCESS
1BB2A  180C     XORWF 0xC, W, ACCESS
1BB2C  0BFB     ANDLW 0xFB
1BB2E  180C     XORWF 0xC, W, ACCESS
1BB30  6EBE     MOVWF 0xFBE, ACCESS
111:           #endif
112:           }
1BB32  0012     RETURN 0
113:           
114:           void stop_bsoc(void)
115:           {
116:           	// Disabling TMR3 interrupt.
117:           	PIE6bits.TMR3IE = 0;
1BDE0  0139     MOVLB 0x39
1BDE2  9D96     BCF utctime, 6, BANKED
118:           }
1BDE4  0012     RETURN 0
119:           
120:           void reset_bsoc(R_CODES rmode)
121:           {
122:           	switch (rmode) {
123:           	default:
124:           		C.pv_ah = 0.0;
125:           		break;
126:           	}
127:           }
128:           
129:           /* Current is in 0.1A units */
130:           uint32_t peukert(uint16_t brate, float bcurrent, float peukert, int16_t bsoc)
131:           {
132:           	float t1, t2, t3, t4, t5, t6, t7, t_time;
133:           
134:           	t1 = (float) bcurrent; // Load on battery in 0.1A units
135:           	t1 /= 10.0; // convert back to A
136:           	if (t1 < 1.0) t1 = 1.0; // inverter current floor is 1.0 amp
137:           	t2 = (float) brate; // Battery capacity in 1.0A units
138:           	t3 = (float) ((float) bsoc / 100.0); // State of Charge
139:           	if (t3 > 0.0) t2 = t2 * t3; // only decrease battery Ah
140:           	if (t2 < 1.0) t2 = 1.0; // Ah floor is 1.0
141:           	t4 = t2 * (float) (pow((t2 / (float) 20.0), ((float) peukert - (float) 1.0)));
142:           	t_time = pow((t2 / (float) 20.0), peukert); // factor at 20h rate
143:           	t5 = pow(t1, peukert); // factor at load current rate
144:           	t6 = t4 / t5; // runtime in hours at the current draw
145:           	if (t6 > MAXRUNTIME) t6 = MAXRUNTIME; // max time is 4 days in hours
146:           	if (t6 < MINRUNTIME) t6 = MINRUNTIME;
147:           	t7 = t4 / t_time; // time at fixed 20h rate
148:           
149:           	C.hist[0].peukert_adj = t7 / t6; // Peukert factor to resize Ah usage, t7=runtime at the 20h current rate/t6=runtime at the inverter load current value
150:           	if (C.hist[0].peukert_adj < Perk_ADJ_FL)
151:           		C.hist[0].peukert_adj = Perk_ADJ_FL; // limit how LOW
152:           	if (C.hist[0].peukert_adj > Perk_ADJ_FH)
153:           		C.hist[0].peukert_adj = Perk_ADJ_FH; // limit how HIGH
154:           
155:           	t6 = t6 * 3600.0; // convert to seconds for runtime at current discharge rate
156:           	return(uint32_t) t6;
157:           }
158:           
159:           uint16_t Volts_to_SOC(uint32_t cvoltage)
195E6  0E05     MOVLW 0x5
195E8  26E1     ADDWF 0xFE1, F, ACCESS
195EA  0E00     MOVLW 0x0
195EC  22E2     ADDWFC 0xFE2, F, ACCESS
160:           {
161:           	uint8_t slot;
162:           	float soc = 0;
195EE  0E00     MOVLW 0x0
195F0  6E09     MOVWF ltemp2, ACCESS
195F2  0E00     MOVLW 0x0
195F4  6E0A     MOVWF ttemp3, ACCESS
195F6  0E00     MOVLW 0x0
195F8  6E0B     MOVWF wtemp5, ACCESS
195FA  0E00     MOVLW 0x0
195FC  6E0C     MOVWF 0xC, ACCESS
195FE  0EFB     MOVLW 0xFB
19602  F027     NOP
19604  FFE3     NOP
19606  0EFC     MOVLW 0xFC
1960A  F02B     NOP
1960C  FFE3     NOP
1960E  0EFD     MOVLW 0xFD
19612  F02F     NOP
19614  FFE3     NOP
19616  0EFE     MOVLW 0xFE
1961A  F033     NOP
1961C  FFE3     NOP
163:           
164:           	for (slot = 0; slot < BVSOC_SLOTS; slot++) {
1961E  0EFF     MOVLW 0xFF
19620  6AE3     CLRF 0xFE3, ACCESS
165:           		if (cvoltage > BVSOC_TABLE[slot][0]) {
19622  0EFF     MOVLW 0xFF
19624  50E3     MOVF 0xFE3, W, ACCESS
19626  0D08     MULLW 0x8
19628  0E67     MOVLW 0x67
1962A  24F3     ADDWF 0xFF3, W, ACCESS
1962C  6EF6     MOVWF 0xFF6, ACCESS
1962E  0EFA     MOVLW 0xFA
19630  20F4     ADDWFC 0xFF4, W, ACCESS
19632  6EF7     MOVWF 0xFF7, ACCESS
19634  6AF8     CLRF 0xFF8, ACCESS
19636  0E00     MOVLW 0x0
19638  22F8     ADDWFC 0xFF8, F, ACCESS
1963A  0EF7     MOVLW 0xF7
1963C  50E3     MOVF 0xFE3, W, ACCESS
1963E  0009     TBLRD*+
19640  5CF5     SUBWF 0xFF5, W, ACCESS
19642  0EF8     MOVLW 0xF8
19644  50E3     MOVF 0xFE3, W, ACCESS
19646  0009     TBLRD*+
19648  58F5     SUBWFB 0xFF5, W, ACCESS
1964A  0EF9     MOVLW 0xF9
1964C  50E3     MOVF 0xFE3, W, ACCESS
1964E  0009     TBLRD*+
19650  58F5     SUBWFB 0xFF5, W, ACCESS
19652  0EFA     MOVLW 0xFA
19654  50E3     MOVF 0xFE3, W, ACCESS
19656  0009     TBLRD*+
19658  58F5     SUBWFB 0xFF5, W, ACCESS
1965A  B0D8     BTFSC 0xFD8, 0, ACCESS
1965C  D034     BRA 0x96C6
166:           			soc = BVSOC_TABLE[slot][1];
1965E  0EFF     MOVLW 0xFF
19660  50E3     MOVF 0xFE3, W, ACCESS
19662  0D08     MULLW 0x8
19664  0E04     MOVLW 0x4
19666  26F3     ADDWF 0xFF3, F, ACCESS
19668  0E00     MOVLW 0x0
1966A  22F4     ADDWFC 0xFF4, F, ACCESS
1966C  0E67     MOVLW 0x67
1966E  24F3     ADDWF 0xFF3, W, ACCESS
19670  6EF6     MOVWF 0xFF6, ACCESS
19672  0EFA     MOVLW 0xFA
19674  20F4     ADDWFC 0xFF4, W, ACCESS
19676  6EF7     MOVWF 0xFF7, ACCESS
19678  6AF8     CLRF 0xFF8, ACCESS
1967A  0E00     MOVLW 0x0
1967C  22F8     ADDWFC 0xFF8, F, ACCESS
1967E  0009     TBLRD*+
19682  FFD7     NOP
19684  FFE6     NOP
19686  0009     TBLRD*+
1968A  FFD7     NOP
1968C  FFE6     NOP
1968E  0009     TBLRD*+
19692  FFD7     NOP
19694  FFE6     NOP
19696  0009     TBLRD*+
1969A  FFD7     NOP
1969C  FFE6     NOP
1969E  0E00     MOVLW 0x0
196A0  6EE6     MOVWF 0xFE6, ACCESS
196A2  ECCA     CALL 0x18194, 0
196A4  F0C0     NOP
196A6  0EFB     MOVLW 0xFB
196AA  F007     NOP
196AC  FFE3     NOP
196AE  0EFC     MOVLW 0xFC
196B2  F00B     NOP
196B4  FFE3     NOP
196B6  0EFD     MOVLW 0xFD
196BA  F00F     NOP
196BC  FFE3     NOP
196BE  0EFE     MOVLW 0xFE
196C2  F013     NOP
196C4  FFE3     NOP
167:           		}
168:           	}
196C6  0EFF     MOVLW 0xFF
196C8  2AE3     INCF 0xFE3, F, ACCESS
196CA  0EFF     MOVLW 0xFF
196CE  FF8C     NOP
196D0  F001     NOP
196D2  0E19     MOVLW 0x19
196D4  6401     CPFSGT ltemp0, ACCESS
196D6  D7A5     BRA 0x9622
169:           	return soc;
196D8  0EFB     MOVLW 0xFB
196DC  FF8F     NOP
196DE  FFE6     NOP
196E2  FF8F     NOP
196E4  FFE6     NOP
196E8  FF8F     NOP
196EA  FFE6     NOP
196EE  FF8F     NOP
196F0  FFE6     NOP
196F2  ECC8     CALL 0x18B90, 0
196F4  F0C5     NOP
170:           }
196F6  0EF7     MOVLW 0xF7
196F8  26E1     ADDWF 0xFE1, F, ACCESS
196FA  0EFF     MOVLW 0xFF
196FC  22E2     ADDWFC 0xFE2, F, ACCESS
196FE  0012     RETURN 0
171:           
172:           /*
173:            * check battery ESR, returns positive ESR value when done,
174:            * a negative number code when running the sequence and
175:            * -1.0 when each FSM sequence is done
176:            * (fsm 'true' will init the state machine and return the init code)
177:            */
178:           float esr_check(uint8_t fsm)
179:           {
180:           	static uint8_t esr_state = 0;
181:           
182:           	if (fsm) {
16E76  0EFF     MOVLW 0xFF
16E78  50E3     MOVF 0xFE3, W, ACCESS
16E7A  B4D8     BTFSC 0xFD8, 2, ACCESS
16E7C  D146     BRA 0x710A
183:           		esr_state = 0;
16E7E  6A40     CLRF esr_state, ACCESS
184:           		return -10.0;
16E80  0E00     MOVLW 0x0
16E82  6E01     MOVWF ltemp0, ACCESS
16E84  0E00     MOVLW 0x0
16E86  6E02     MOVWF ttemp5, ACCESS
16E88  0E20     MOVLW 0x20
16E8A  6E03     MOVWF wtemp1, ACCESS
16E8C  0EC1     MOVLW 0xC1
16E8E  D158     BRA 0x7140
185:           	}
186:           
187:           	switch (esr_state) {
188:           	case 0:
189:           		StartTimer(TMR_ESR, 10000); // start the sequence timer
16E90  0E10     MOVLW 0x10
16E92  6EE6     MOVWF 0xFE6, ACCESS
16E94  0E27     MOVLW 0x27
16E96  6EE6     MOVWF 0xFE6, ACCESS
16E98  0E0C     MOVLW 0xC
16E9A  6EE6     MOVWF 0xFE6, ACCESS
16E9C  EC6A     CALL 0x1B2D4, 0
16E9E  F0D9     NOP
190:           		esr_state++; // move to the next state of the FSM
16EA0  2A40     INCF esr_state, F, ACCESS
191:           		break;
16EA2  D147     BRA 0x7132
192:           	case 1:
193:           		/*
194:           		 * set the load resistors to all off
195:           		 */
196:           		set_load_relay_one(false);
16EA4  0E00     MOVLW 0x0
16EA6  6EE6     MOVWF 0xFE6, ACCESS
16EA8  EC73     CALL 0x1BCE6, 0
16EAA  F0DE     NOP
197:           		set_load_relay_two(false);
16EAC  0E00     MOVLW 0x0
16EAE  6EE6     MOVWF 0xFE6, ACCESS
16EB0  EC6B     CALL 0x1BCD6, 0
16EB2  F0DE     NOP
198:           		if (TimerDone(TMR_ESR)) { // check for expired timer
16EB4  0E0C     MOVLW 0xC
16EB6  6EE6     MOVWF 0xFE6, ACCESS
16EB8  ECF3     CALL 0x1B7E6, 0
16EBA  F0DB     NOP
16EBC  5001     MOVF ltemp0, W, ACCESS
16EBE  B4D8     BTFSC 0xFD8, 2, ACCESS
16EC0  D009     BRA 0x6ED4
199:           			StartTimer(TMR_ESR, 10000); // done, restart the timer, complete sequence, return -1.0
16EC2  0E10     MOVLW 0x10
16EC4  6EE6     MOVWF 0xFE6, ACCESS
16EC6  0E27     MOVLW 0x27
16EC8  6EE6     MOVWF 0xFE6, ACCESS
16ECA  0E0C     MOVLW 0xC
16ECC  6EE6     MOVWF 0xFE6, ACCESS
16ECE  EC6A     CALL 0x1B2D4, 0
16ED0  F0D9     NOP
200:           		} else {
16ED2  D006     BRA 0x6EE0
201:           			return -2.0; // nope, return with a progress code
16ED4  0E00     MOVLW 0x0
16ED6  6E01     MOVWF ltemp0, ACCESS
16ED8  0E00     MOVLW 0x0
16EDA  6E02     MOVWF ttemp5, ACCESS
16EDC  0E00     MOVLW 0x0
16EDE  D066     BRA 0x6FAC
202:           		}
203:           		/*
204:           		 * save unloaded battery voltage
205:           		 */
206:           		update_adc_result();
16EE0  EC29     CALL 0x1B452, 0
16EE2  F0DA     NOP
207:           		C.bv_noload = conv_raw_result(V_BAT, CONV);
16EE4  0E00     MOVLW 0x0
16EE6  6EE6     MOVWF 0xFE6, ACCESS
16EE8  0E04     MOVLW 0x4
16EEA  6EE6     MOVWF 0xFE6, ACCESS
16EEC  EC0E     CALL 0x1501C, 0
16EEE  F0A8     NOP
16EF2  F004     NOP
16EF4  F811     NOP
16EF8  F008     NOP
16EFA  F812     NOP
16EFE  F00C     NOP
16F00  F813     NOP
16F04  F010     NOP
16F06  F814     NOP
16F08  D7CB     BRA 0x6EA0
208:           		esr_state++; // move to the next state of the FSM
209:           		break;
210:           	case 2:
211:           		set_load_relay_one(true);
16F0A  0E01     MOVLW 0x1
16F0C  6EE6     MOVWF 0xFE6, ACCESS
16F0E  EC73     CALL 0x1BCE6, 0
16F10  F0DE     NOP
212:           		if (TimerDone(TMR_ESR)) {
16F12  0E0C     MOVLW 0xC
16F14  6EE6     MOVWF 0xFE6, ACCESS
16F16  ECF3     CALL 0x1B7E6, 0
16F18  F0DB     NOP
16F1A  5001     MOVF ltemp0, W, ACCESS
16F1C  B4D8     BTFSC 0xFD8, 2, ACCESS
16F1E  D009     BRA 0x6F32
213:           			StartTimer(TMR_ESR, 10000);
16F20  0E10     MOVLW 0x10
16F22  6EE6     MOVWF 0xFE6, ACCESS
16F24  0E27     MOVLW 0x27
16F26  6EE6     MOVWF 0xFE6, ACCESS
16F28  0E0C     MOVLW 0xC
16F2A  6EE6     MOVWF 0xFE6, ACCESS
16F2C  EC6A     CALL 0x1B2D4, 0
16F2E  F0D9     NOP
214:           		} else {
16F30  D006     BRA 0x6F3E
215:           			return -3.0;
16F32  0E00     MOVLW 0x0
16F34  6E01     MOVWF ltemp0, ACCESS
16F36  0E00     MOVLW 0x0
16F38  6E02     MOVWF ttemp5, ACCESS
16F3A  0E40     MOVLW 0x40
16F3C  D037     BRA 0x6FAC
216:           		}
217:           
218:           		update_adc_result();
16F3E  EC29     CALL 0x1B452, 0
16F40  F0DA     NOP
219:           		C.bv_one_load = conv_raw_result(V_BAT, CONV);
16F42  0E00     MOVLW 0x0
16F44  6EE6     MOVWF 0xFE6, ACCESS
16F46  0E04     MOVLW 0x4
16F48  6EE6     MOVWF 0xFE6, ACCESS
16F4A  EC0E     CALL 0x1501C, 0
16F4C  F0A8     NOP
16F50  F004     NOP
16F52  F815     NOP
16F56  F008     NOP
16F58  F816     NOP
16F5C  F00C     NOP
16F5E  F817     NOP
16F62  F010     NOP
16F64  F818     NOP
220:           		C.load_i1 = conv_raw_result(C_BATT, CONV); // get current
16F66  0E00     MOVLW 0x0
16F68  6EE6     MOVWF 0xFE6, ACCESS
16F6A  0E00     MOVLW 0x0
16F6C  6EE6     MOVWF 0xFE6, ACCESS
16F6E  EC0E     CALL 0x1501C, 0
16F70  F0A8     NOP
16F74  F004     NOP
16F76  F809     NOP
16F7A  F008     NOP
16F7C  F80A     NOP
16F80  F00C     NOP
16F82  F80B     NOP
16F86  F010     NOP
16F88  F80C     NOP
16F8A  D78A     BRA 0x6EA0
221:           		esr_state++;
222:           		break;
223:           	case 3:
224:           		set_load_relay_two(true);
16F8C  0E01     MOVLW 0x1
16F8E  6EE6     MOVWF 0xFE6, ACCESS
16F90  EC6B     CALL 0x1BCD6, 0
16F92  F0DE     NOP
225:           		if (!TimerDone(TMR_ESR))
16F94  0E0C     MOVLW 0xC
16F96  6EE6     MOVWF 0xFE6, ACCESS
16F98  ECF3     CALL 0x1B7E6, 0
16F9A  F0DB     NOP
16F9C  5001     MOVF ltemp0, W, ACCESS
16F9E  A4D8     BTFSS 0xFD8, 2, ACCESS
16FA0  D008     BRA 0x6FB2
226:           			return -4.0;
16FA2  0E00     MOVLW 0x0
16FA4  6E01     MOVWF ltemp0, ACCESS
16FA6  0E00     MOVLW 0x0
16FA8  6E02     MOVWF ttemp5, ACCESS
16FAA  0E80     MOVLW 0x80
16FAC  6E03     MOVWF wtemp1, ACCESS
16FAE  0EC0     MOVLW 0xC0
16FB0  D0C7     BRA 0x7140
227:           
228:           		update_adc_result();
16FB2  EC29     CALL 0x1B452, 0
16FB4  F0DA     NOP
229:           		C.bv_full_load = conv_raw_result(V_BAT, CONV);
16FB6  0E00     MOVLW 0x0
16FB8  6EE6     MOVWF 0xFE6, ACCESS
16FBA  0E04     MOVLW 0x4
16FBC  6EE6     MOVWF 0xFE6, ACCESS
16FBE  EC0E     CALL 0x1501C, 0
16FC0  F0A8     NOP
16FC4  F004     NOP
16FC6  F819     NOP
16FCA  F008     NOP
16FCC  F81A     NOP
16FD0  F00C     NOP
16FD2  F81B     NOP
16FD6  F010     NOP
16FD8  F81C     NOP
230:           		C.load_i2 = conv_raw_result(C_BATT, CONV); // get current
16FDA  0E00     MOVLW 0x0
16FDC  6EE6     MOVWF 0xFE6, ACCESS
16FDE  0E00     MOVLW 0x0
16FE0  6EE6     MOVWF 0xFE6, ACCESS
16FE2  EC0E     CALL 0x1501C, 0
16FE4  F0A8     NOP
16FE8  F004     NOP
16FEA  F80D     NOP
16FEE  F008     NOP
16FF0  F80E     NOP
16FF4  F00C     NOP
16FF6  F80F     NOP
16FFA  F010     NOP
16FFC  F810     NOP
231:           
232:           		C.esr = fabs((C.bv_one_load - C.bv_full_load) / (C.load_i1 - C.load_i2)); // find internal resistance causing voltage drop (sorta)
16FFE  EE22     LFSR 2, 0x80D
17000  F00D     NOP
17004  FF7B     NOP
17006  FFE6     NOP
1700A  FF7B     NOP
1700C  FFE6     NOP
17010  FF7B     NOP
17012  FFE6     NOP
17016  FF7B     NOP
17018  FFE6     NOP
1701A  EE22     LFSR 2, 0x809
1701C  F009     NOP
17020  FF7B     NOP
17022  FFE6     NOP
17026  FF7B     NOP
17028  FFE6     NOP
1702C  FF7B     NOP
1702E  FFE6     NOP
17032  FF7B     NOP
17034  FFE6     NOP
17036  EC04     CALL 0x1B208, 0
17038  F0D9     NOP
1703C  F007     NOP
1703E  FFE6     NOP
17042  F00B     NOP
17044  FFE6     NOP
17048  F00F     NOP
1704A  FFE6     NOP
1704E  F013     NOP
17050  FFE6     NOP
17052  EE22     LFSR 2, 0x819
17054  F019     NOP
17058  FF7B     NOP
1705A  FFE6     NOP
1705E  FF7B     NOP
17060  FFE6     NOP
17064  FF7B     NOP
17066  FFE6     NOP
1706A  FF7B     NOP
1706C  FFE6     NOP
1706E  EE22     LFSR 2, 0x815
17070  F015     NOP
17074  FF7B     NOP
17076  FFE6     NOP
1707A  FF7B     NOP
1707C  FFE6     NOP
17080  FF7B     NOP
17082  FFE6     NOP
17086  FF7B     NOP
17088  FFE6     NOP
1708A  EC04     CALL 0x1B208, 0
1708C  F0D9     NOP
17090  F007     NOP
17092  FFE6     NOP
17096  F00B     NOP
17098  FFE6     NOP
1709C  F00F     NOP
1709E  FFE6     NOP
170A2  F013     NOP
170A4  FFE6     NOP
170A6  EC51     CALL 0x14AA2, 0
170A8  F0A5     NOP
170AC  F007     NOP
170AE  FFE6     NOP
170B2  F00B     NOP
170B4  FFE6     NOP
170B8  F00F     NOP
170BA  FFE6     NOP
170BE  F013     NOP
170C0  FFE6     NOP
170C2  EC87     CALL 0x1A30E, 0
170C4  F0D1     NOP
170C8  F004     NOP
170CA  F787     NOP
170CE  F008     NOP
170D0  F788     NOP
170D4  F00C     NOP
170D6  F789     NOP
170DA  F010     NOP
170DC  F78A     NOP
233:           		set_load_relay_one(false);
170DE  0E00     MOVLW 0x0
170E0  6EE6     MOVWF 0xFE6, ACCESS
170E2  EC73     CALL 0x1BCE6, 0
170E4  F0DE     NOP
234:           		set_load_relay_two(false);
170E6  0E00     MOVLW 0x0
170E8  6EE6     MOVWF 0xFE6, ACCESS
170EA  EC6B     CALL 0x1BCD6, 0
170EC  F0DE     NOP
235:           		esr_state = 0;
170EE  6A40     CLRF esr_state, ACCESS
236:           		return C.esr;
170F2  FE1C     NOP
170F4  F001     NOP
170F8  FE20     NOP
170FA  F002     NOP
170FE  FE24     NOP
17100  F003     NOP
17104  FE28     NOP
17106  F004     NOP
17108  D01C     BRA 0x7142
237:           		break;
238:           	default:
239:           		break;
240:           	}
1710A  5040     MOVF esr_state, W, ACCESS
1710C  6E0B     MOVWF wtemp5, ACCESS
1710E  6A0C     CLRF 0xC, ACCESS
17110  500C     MOVF 0xC, W, ACCESS
17112  0A00     XORLW 0x0
17114  A4D8     BTFSS 0xFD8, 2, ACCESS
17116  D00D     BRA 0x7132
17118  500B     MOVF wtemp5, W, ACCESS
1711A  0A00     XORLW 0x0
1711C  B4D8     BTFSC 0xFD8, 2, ACCESS
1711E  D6B8     BRA 0x6E90
17120  0A01     XORLW 0x1
17122  B4D8     BTFSC 0xFD8, 2, ACCESS
17124  D6BF     BRA 0x6EA4
17126  0A03     XORLW 0x3
17128  B4D8     BTFSC 0xFD8, 2, ACCESS
1712A  D6EF     BRA 0x6F0A
1712C  0A01     XORLW 0x1
1712E  B4D8     BTFSC 0xFD8, 2, ACCESS
17130  D72D     BRA 0x6F8C
241:           	return -1.0;
17132  0E00     MOVLW 0x0
17134  6E01     MOVWF ltemp0, ACCESS
17136  0E00     MOVLW 0x0
17138  6E02     MOVWF ttemp5, ACCESS
1713A  0E80     MOVLW 0x80
1713C  6E03     MOVWF wtemp1, ACCESS
1713E  0EBF     MOVLW 0xBF
17140  6E04     MOVWF ttemp1, ACCESS
242:           }
17142  52E5     MOVF 0xFE5, F, ACCESS
17144  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/pic18/asfladd.c  ------------------------------------------
1:             #include <inline.h>
2:             
3:             extern double __fladd(double, double);
4:             
5:             double _INLINE
6:             __asfladd(double * f1p, double f2)
7:             {
8:             	return *f1p = __fladd(*f1p, f2);
1AABA  0EFA     MOVLW 0xFA
1AABE  FF8F     NOP
1AAC0  FFE6     NOP
1AAC4  FF8F     NOP
1AAC6  FFE6     NOP
1AACA  FF8F     NOP
1AACC  FFE6     NOP
1AAD0  FF8F     NOP
1AAD2  FFE6     NOP
1AAD4  0EFA     MOVLW 0xFA
1AAD8  FF8F     NOP
1AADA  FFD9     NOP
1AADC  0EFB     MOVLW 0xFB
1AAE0  FF8F     NOP
1AAE2  FFDA     NOP
1AAE6  FF7B     NOP
1AAE8  FFE6     NOP
1AAEC  FF7B     NOP
1AAEE  FFE6     NOP
1AAF2  FF7B     NOP
1AAF4  FFE6     NOP
1AAF8  FF7B     NOP
1AAFA  FFE6     NOP
1AAFC  ECB5     CALL 0x13B6A, 0
1AAFE  F09D     NOP
1AB00  0EFE     MOVLW 0xFE
1AB04  FF8F     NOP
1AB06  FFD9     NOP
1AB08  0EFF     MOVLW 0xFF
1AB0C  FF8F     NOP
1AB0E  FFDA     NOP
1AB12  F007     NOP
1AB14  FFDE     NOP
1AB18  F00B     NOP
1AB1A  FFDE     NOP
1AB1E  F00F     NOP
1AB20  FFDE     NOP
1AB24  F013     NOP
1AB26  FFDE     NOP
9:             }
1AB28  0EFA     MOVLW 0xFA
1BD50  EE14     LFSR 1, 0x115C
10:            
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/xxtofl.c  ------------------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
18194  0E05     MOVLW 0x5
18196  26E1     ADDWF 0xFE1, F, ACCESS
18198  0E00     MOVLW 0x0
1819A  22E2     ADDWFC 0xFE2, F, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
1819C  0EFA     MOVLW 0xFA
1819E  50E3     MOVF 0xFE3, W, ACCESS
181A0  B4D8     BTFSC 0xFD8, 2, ACCESS
181A2  D01D     BRA 0x81DE
181A4  0EF9     MOVLW 0xF9
181A6  AEE3     BTFSS 0xFE3, 7, ACCESS
181A8  D01A     BRA 0x81DE
16:            		arg = -val;
181AA  0EF6     MOVLW 0xF6
181AE  FF8C     NOP
181B0  F009     NOP
181B2  0EF7     MOVLW 0xF7
181B6  FF8C     NOP
181B8  F00A     NOP
181BA  0EF8     MOVLW 0xF8
181BE  FF8C     NOP
181C0  F00B     NOP
181C2  0EF9     MOVLW 0xF9
181C6  FF8C     NOP
181C8  F00C     NOP
181CA  1E09     COMF ltemp2, F, ACCESS
181CC  1E0A     COMF ttemp3, F, ACCESS
181CE  1E0B     COMF wtemp5, F, ACCESS
181D0  1E0C     COMF 0xC, F, ACCESS
181D2  2A09     INCF ltemp2, F, ACCESS
181D4  0E00     MOVLW 0x0
181D6  220A     ADDWFC ttemp3, F, ACCESS
181D8  220B     ADDWFC wtemp5, F, ACCESS
181DA  220C     ADDWFC 0xC, F, ACCESS
181DC  D010     BRA 0x81FE
17:            	}
18:            	else {
19:            		arg = val;
181DE  0EF6     MOVLW 0xF6
181E2  FF8C     NOP
181E4  F009     NOP
181E6  0EF7     MOVLW 0xF7
181EA  FF8C     NOP
181EC  F00A     NOP
181EE  0EF8     MOVLW 0xF8
181F2  FF8C     NOP
181F4  F00B     NOP
181F6  0EF9     MOVLW 0xF9
181FA  FF8C     NOP
181FC  F00C     NOP
181FE  0EFB     MOVLW 0xFB
18202  F027     NOP
18204  FFE3     NOP
18206  0EFC     MOVLW 0xFC
1820A  F02B     NOP
1820C  FFE3     NOP
1820E  0EFD     MOVLW 0xFD
18212  F02F     NOP
18214  FFE3     NOP
18216  0EFE     MOVLW 0xFE
1821A  F033     NOP
1821C  FFE3     NOP
20:            	}
21:            	if(val == 0)
1821E  0EF6     MOVLW 0xF6
18220  50E3     MOVF 0xFE3, W, ACCESS
18222  E113     BNZ 0x824A
18224  0EF7     MOVLW 0xF7
18226  50E3     MOVF 0xFE3, W, ACCESS
18228  E110     BNZ 0x824A
1822A  0EF8     MOVLW 0xF8
1822C  50E3     MOVF 0xFE3, W, ACCESS
1822E  E10D     BNZ 0x824A
18230  0EF9     MOVLW 0xF9
18232  50E3     MOVF 0xFE3, W, ACCESS
18234  A4D8     BTFSS 0xFD8, 2, ACCESS
18236  D009     BRA 0x824A
22:            		return 0.0;
18238  0E00     MOVLW 0x0
1823A  6E01     MOVWF ltemp0, ACCESS
1823C  0E00     MOVLW 0x0
1823E  6E02     MOVWF ttemp5, ACCESS
18240  0E00     MOVLW 0x0
18242  6E03     MOVWF wtemp1, ACCESS
18244  0E00     MOVLW 0x0
18246  6E04     MOVWF ttemp1, ACCESS
18248  D0A2     BRA 0x838E
23:            	exp = (127 + 23);
1824A  0E96     MOVLW 0x96
1824C  6E0C     MOVWF 0xC, ACCESS
1824E  0EFF     MOVLW 0xFF
18252  F033     NOP
18254  FFE3     NOP
24:            	while(arg & ~0x1FFFFFFUL) {
18256  D00B     BRA 0x826E
1826E  50E1     MOVF 0xFE1, W, ACCESS
18270  0FFB     ADDLW 0xFB
18272  6ED9     MOVWF 0xFD9, ACCESS
18274  50E2     MOVF 0xFE2, W, ACCESS
18276  6EDA     MOVWF 0xFDA, ACCESS
18278  0EFF     MOVLW 0xFF
1827A  22DA     ADDWFC 0xFDA, F, ACCESS
1827C  52DE     MOVF 0xFDE, F, ACCESS
1827E  52DE     MOVF 0xFDE, F, ACCESS
18280  52DE     MOVF 0xFDE, F, ACCESS
18282  0EFE     MOVLW 0xFE
18284  14DD     ANDWF 0xFDD, W, ACCESS
18286  B4D8     BTFSC 0xFD8, 2, ACCESS
18288  D018     BRA 0x82BA
1828A  D7E6     BRA 0x8258
25:            		++exp;
18258  0EFF     MOVLW 0xFF
1825A  2AE3     INCF 0xFE3, F, ACCESS
26:            		arg >>= 1;
1825C  90D8     BCF 0xFD8, 0, ACCESS
1825E  0EFE     MOVLW 0xFE
18260  32E3     RRCF 0xFE3, F, ACCESS
18262  0EFD     MOVLW 0xFD
18264  32E3     RRCF 0xFE3, F, ACCESS
18266  0EFC     MOVLW 0xFC
18268  32E3     RRCF 0xFE3, F, ACCESS
1826A  0EFB     MOVLW 0xFB
1826C  32E3     RRCF 0xFE3, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
182BA  50E1     MOVF 0xFE1, W, ACCESS
182BC  0FFB     ADDLW 0xFB
182BE  6ED9     MOVWF 0xFD9, ACCESS
182C0  50E2     MOVF 0xFE2, W, ACCESS
182C2  6EDA     MOVWF 0xFDA, ACCESS
182C4  0EFF     MOVLW 0xFF
182C6  22DA     ADDWFC 0xFDA, F, ACCESS
182C8  52DE     MOVF 0xFDE, F, ACCESS
182CA  52DE     MOVF 0xFDE, F, ACCESS
182CC  52DE     MOVF 0xFDE, F, ACCESS
182CE  0EFF     MOVLW 0xFF
182D0  14DD     ANDWF 0xFDD, W, ACCESS
182D2  B4D8     BTFSC 0xFD8, 2, ACCESS
182D4  D00C     BRA 0x82EE
182D6  D7DA     BRA 0x828C
29:            		++exp;
1828C  0EFF     MOVLW 0xFF
1828E  2AE3     INCF 0xFE3, F, ACCESS
30:            		++arg;
18290  50E1     MOVF 0xFE1, W, ACCESS
18292  0FFB     ADDLW 0xFB
18294  6ED9     MOVWF 0xFD9, ACCESS
18296  50E2     MOVF 0xFE2, W, ACCESS
18298  6EDA     MOVWF 0xFDA, ACCESS
1829A  0EFF     MOVLW 0xFF
1829C  22DA     ADDWFC 0xFDA, F, ACCESS
1829E  2ADE     INCF 0xFDE, F, ACCESS
182A0  0E00     MOVLW 0x0
182A2  22DE     ADDWFC 0xFDE, F, ACCESS
182A4  22DE     ADDWFC 0xFDE, F, ACCESS
182A6  22DE     ADDWFC 0xFDE, F, ACCESS
31:            		arg >>= 1;
182A8  90D8     BCF 0xFD8, 0, ACCESS
182AA  0EFE     MOVLW 0xFE
182AC  32E3     RRCF 0xFE3, F, ACCESS
182AE  0EFD     MOVLW 0xFD
182B0  32E3     RRCF 0xFE3, F, ACCESS
182B2  0EFC     MOVLW 0xFC
182B4  32E3     RRCF 0xFE3, F, ACCESS
182B6  0EFB     MOVLW 0xFB
182B8  32E3     RRCF 0xFE3, F, ACCESS
32:            	}
33:            	while(!(arg & 0x800000UL) && exp > 1) {
182EE  0EFD     MOVLW 0xFD
182F0  BEE3     BTFSC 0xFE3, 7, ACCESS
182F2  D007     BRA 0x8302
182F4  0EFF     MOVLW 0xFF
182F8  FF8C     NOP
182FA  F001     NOP
182FC  0E02     MOVLW 0x2
182FE  6001     CPFSLT ltemp0, ACCESS
18300  D7EB     BRA 0x82D8
34:            		--exp;
182D8  0EFF     MOVLW 0xFF
182DA  06E3     DECF 0xFE3, F, ACCESS
35:            		arg <<= 1;
182DC  90D8     BCF 0xFD8, 0, ACCESS
182DE  0EFB     MOVLW 0xFB
182E0  36E3     RLCF 0xFE3, F, ACCESS
182E2  0EFC     MOVLW 0xFC
182E4  36E3     RLCF 0xFE3, F, ACCESS
182E6  0EFD     MOVLW 0xFD
182E8  36E3     RLCF 0xFE3, F, ACCESS
182EA  0EFE     MOVLW 0xFE
182EC  36E3     RLCF 0xFE3, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
18302  0EFF     MOVLW 0xFF
18304  B0E3     BTFSC 0xFE3, 0, ACCESS
18306  D002     BRA 0x830C
38:            		arg &= ~0x800000UL;
18308  0EFD     MOVLW 0xFD
1830A  9EE3     BCF 0xFE3, 7, ACCESS
39:            	exp >>= 1;
1830C  50E1     MOVF 0xFE1, W, ACCESS
1830E  0FFF     ADDLW 0xFF
18310  6ED9     MOVWF 0xFD9, ACCESS
18312  50E2     MOVF 0xFE2, W, ACCESS
18314  6EDA     MOVWF 0xFDA, ACCESS
18316  0EFF     MOVLW 0xFF
18318  22DA     ADDWFC 0xFDA, F, ACCESS
1831A  90D8     BCF 0xFD8, 0, ACCESS
1831C  32DF     RRCF 0xFDF, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
1831E  0EFF     MOVLW 0xFF
18322  FF8C     NOP
18324  F00C     NOP
18328  F030     NOP
1832A  F005     NOP
1832C  6A06     CLRF 0x6, ACCESS
1832E  6A07     CLRF ttemp2, ACCESS
18330  6A08     CLRF 0x8, ACCESS
18334  F014     NOP
18336  F008     NOP
18338  6A07     CLRF ttemp2, ACCESS
1833A  6A06     CLRF 0x6, ACCESS
1833C  6A05     CLRF ltemp1, ACCESS
1833E  50E1     MOVF 0xFE1, W, ACCESS
18340  0FFB     ADDLW 0xFB
18342  6ED9     MOVWF 0xFD9, ACCESS
18344  50E2     MOVF 0xFE2, W, ACCESS
18346  6EDA     MOVWF 0xFDA, ACCESS
18348  0EFF     MOVLW 0xFF
1834A  22DA     ADDWFC 0xFDA, F, ACCESS
1834C  5005     MOVF ltemp1, W, ACCESS
1834E  12DE     IORWF 0xFDE, F, ACCESS
18350  5006     MOVF 0x6, W, ACCESS
18352  12DE     IORWF 0xFDE, F, ACCESS
18354  5007     MOVF ttemp2, W, ACCESS
18356  12DE     IORWF 0xFDE, F, ACCESS
18358  5008     MOVF 0x8, W, ACCESS
1835A  12DE     IORWF 0xFDE, F, ACCESS
41:            	if(sign && val < 0)
1835C  0EFA     MOVLW 0xFA
1835E  50E3     MOVF 0xFE3, W, ACCESS
18360  B4D8     BTFSC 0xFD8, 2, ACCESS
18362  D005     BRA 0x836E
18364  0EF9     MOVLW 0xF9
18366  AEE3     BTFSS 0xFE3, 7, ACCESS
18368  D002     BRA 0x836E
42:            		arg |= 0x80000000UL;
1836A  0EFE     MOVLW 0xFE
1836C  8EE3     BSF 0xFE3, 7, ACCESS
43:            	return *(double *)&arg;
1836E  0EFB     MOVLW 0xFB
18372  FF8C     NOP
18374  F001     NOP
18376  0EFC     MOVLW 0xFC
1837A  FF8C     NOP
1837C  F002     NOP
1837E  0EFD     MOVLW 0xFD
18382  FF8C     NOP
18384  F003     NOP
18386  0EFE     MOVLW 0xFE
1838A  FF8C     NOP
1838C  F004     NOP
44:            }
1838E  0EF6     MOVLW 0xF6
18390  26E1     ADDWF 0xFE1, F, ACCESS
18392  0EFF     MOVLW 0xFF
18394  22E2     ADDWFC 0xFE2, F, ACCESS
18396  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/toupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
1A930  52E6     MOVF 0xFE6, F, ACCESS
1A932  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	if (islower(c)) return c & 0x5f;
1A934  0EFC     MOVLW 0xFC
1A936  50E3     MOVF 0xFE3, W, ACCESS
1A938  0F9F     ADDLW 0x9F
1A93A  6E0B     MOVWF wtemp5, ACCESS
1A93C  0EFD     MOVLW 0xFD
1A940  FF8C     NOP
1A942  F00C     NOP
1A944  0EFF     MOVLW 0xFF
1A946  220C     ADDWFC 0xC, F, ACCESS
1A948  500C     MOVF 0xC, W, ACCESS
1A94A  E106     BNZ 0xA958
1A94C  0E1A     MOVLW 0x1A
1A94E  5C0B     SUBWF wtemp5, W, ACCESS
1A950  B0D8     BTFSC 0xFD8, 0, ACCESS
1A952  D002     BRA 0xA958
1A954  0E01     MOVLW 0x1
1A956  D001     BRA 0xA95A
1A958  0E00     MOVLW 0x0
1A95A  6E0B     MOVWF wtemp5, ACCESS
1A95C  6A0C     CLRF 0xC, ACCESS
1A95E  0EFE     MOVLW 0xFE
1A962  F02F     NOP
1A964  FFE3     NOP
1A966  0EFF     MOVLW 0xFF
1A96A  F033     NOP
1A96C  FFE3     NOP
1A96E  0EFE     MOVLW 0xFE
1A972  FF8C     NOP
1A974  F001     NOP
1A976  0EFF     MOVLW 0xFF
1A978  50E3     MOVF 0xFE3, W, ACCESS
1A97A  1001     IORWF ltemp0, W, ACCESS
1A97C  B4D8     BTFSC 0xFD8, 2, ACCESS
1A97E  D00D     BRA 0xA99A
1A980  0EFC     MOVLW 0xFC
1A984  FF8C     NOP
1A986  F001     NOP
1A988  0EFD     MOVLW 0xFD
1A98C  FF8C     NOP
1A98E  F002     NOP
1A990  0E5F     MOVLW 0x5F
1A992  1601     ANDWF ltemp0, F, ACCESS
1A994  0E00     MOVLW 0x0
1A996  1602     ANDWF ttemp5, F, ACCESS
1A998  D008     BRA 0xA9AA
7:             	return c;
1A99A  0EFC     MOVLW 0xFC
1A99E  FF8C     NOP
1A9A0  F001     NOP
1A9A2  0EFD     MOVLW 0xFD
1A9A6  FF8C     NOP
1A9A8  F002     NOP
8:             }
1A9AA  52E5     MOVF 0xFE5, F, ACCESS
1A9AC  52E5     MOVF 0xFE5, F, ACCESS
1A9AE  52E5     MOVF 0xFE5, F, ACCESS
1A9B0  52E5     MOVF 0xFE5, F, ACCESS
1A9B2  0012     RETURN 0
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/tolower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int tolower(int c)
1A9B4  52E6     MOVF 0xFE6, F, ACCESS
1A9B6  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	if (isupper(c)) return c | 32;
1A9B8  0EFC     MOVLW 0xFC
1A9BA  50E3     MOVF 0xFE3, W, ACCESS
1A9BC  0FBF     ADDLW 0xBF
1A9BE  6E0B     MOVWF wtemp5, ACCESS
1A9C0  0EFD     MOVLW 0xFD
1A9C4  FF8C     NOP
1A9C6  F00C     NOP
1A9C8  0EFF     MOVLW 0xFF
1A9CA  220C     ADDWFC 0xC, F, ACCESS
1A9CC  500C     MOVF 0xC, W, ACCESS
1A9CE  E106     BNZ 0xA9DC
1A9D0  0E1A     MOVLW 0x1A
1A9D2  5C0B     SUBWF wtemp5, W, ACCESS
1A9D4  B0D8     BTFSC 0xFD8, 0, ACCESS
1A9D6  D002     BRA 0xA9DC
1A9D8  0E01     MOVLW 0x1
1A9DA  D001     BRA 0xA9DE
1A9DC  0E00     MOVLW 0x0
1A9DE  6E0B     MOVWF wtemp5, ACCESS
1A9E0  6A0C     CLRF 0xC, ACCESS
1A9E2  0EFE     MOVLW 0xFE
1A9E6  F02F     NOP
1A9E8  FFE3     NOP
1A9EA  0EFF     MOVLW 0xFF
1A9EE  F033     NOP
1A9F0  FFE3     NOP
1A9F2  0EFE     MOVLW 0xFE
1A9F6  FF8C     NOP
1A9F8  F001     NOP
1A9FA  0EFF     MOVLW 0xFF
1A9FC  50E3     MOVF 0xFE3, W, ACCESS
1A9FE  1001     IORWF ltemp0, W, ACCESS
1AA00  B4D8     BTFSC 0xFD8, 2, ACCESS
1AA02  D00D     BRA 0xAA1E
1AA04  0EFC     MOVLW 0xFC
1AA08  FF8C     NOP
1AA0A  F001     NOP
1AA0C  0EFD     MOVLW 0xFD
1AA10  FF8C     NOP
1AA12  F002     NOP
1AA14  0E20     MOVLW 0x20
1AA16  1201     IORWF ltemp0, F, ACCESS
1AA18  0E00     MOVLW 0x0
1AA1A  1202     IORWF ttemp5, F, ACCESS
1AA1C  D008     BRA 0xAA2E
7:             	return c;
1AA1E  0EFC     MOVLW 0xFC
1AA22  FF8C     NOP
1AA24  F001     NOP
1AA26  0EFD     MOVLW 0xFD
1AA2A  FF8C     NOP
1AA2C  F002     NOP
8:             }
1AA2E  52E5     MOVF 0xFE5, F, ACCESS
1AA30  52E5     MOVF 0xFE5, F, ACCESS
1AA32  52E5     MOVF 0xFE5, F, ACCESS
1AA34  52E5     MOVF 0xFE5, F, ACCESS
1AA36  0012     RETURN 0
9:             
10:            int __tolower_l(int c, locale_t l)
11:            {
12:            	return tolower(c);
13:            }
14:            
15:            weak_alias(__tolower_l, tolower_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/strncmp.c  -----------------------------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
17D62  52E6     MOVF 0xFE6, F, ACCESS
17D64  52E6     MOVF 0xFE6, F, ACCESS
17D66  52E6     MOVF 0xFE6, F, ACCESS
17D68  52E6     MOVF 0xFE6, F, ACCESS
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
17D6A  0EFA     MOVLW 0xFA
17D6E  FF8C     NOP
17D70  F00B     NOP
17D72  0EFB     MOVLW 0xFB
17D76  FF8C     NOP
17D78  F00C     NOP
17D7A  0EFF     MOVLW 0xFF
17D7E  F033     NOP
17D80  FFE3     NOP
17D82  0EFE     MOVLW 0xFE
17D86  F02F     NOP
17D88  FFE3     NOP
17D8A  0EF8     MOVLW 0xF8
17D8E  FF8C     NOP
17D90  F00B     NOP
17D92  0EF9     MOVLW 0xF9
17D96  FF8C     NOP
17D98  F00C     NOP
17D9A  0EFD     MOVLW 0xFD
17D9E  F033     NOP
17DA0  FFE3     NOP
17DA2  0EFC     MOVLW 0xFC
17DA6  F02F     NOP
17DA8  FFE3     NOP
6:             	if (!n--) return 0;
17DAA  0EF6     MOVLW 0xF6
17DAE  FF8C     NOP
17DB0  F001     NOP
17DB2  0E01     MOVLW 0x1
17DB4  5E01     SUBWF ltemp0, F, ACCESS
17DB6  0EF6     MOVLW 0xF6
17DBA  F007     NOP
17DBC  FFE3     NOP
17DBE  0EF7     MOVLW 0xF7
17DC2  FF8C     NOP
17DC4  F001     NOP
17DC6  0E00     MOVLW 0x0
17DC8  5A01     SUBWFB ltemp0, F, ACCESS
17DCA  0EF7     MOVLW 0xF7
17DCE  F007     NOP
17DD0  FFE3     NOP
17DD2  0EF6     MOVLW 0xF6
17DD4  28E3     INCF 0xFE3, W, ACCESS
17DD6  E13F     BNZ 0x7E56
17DD8  0EF7     MOVLW 0xF7
17DDA  28E3     INCF 0xFE3, W, ACCESS
17DDC  A4D8     BTFSS 0xFD8, 2, ACCESS
17DDE  D03B     BRA 0x7E56
17DE0  0E00     MOVLW 0x0
17DE2  6E01     MOVWF ltemp0, ACCESS
17DE4  0E00     MOVLW 0x0
17DE6  6E02     MOVWF ttemp5, ACCESS
17DE8  D0C7     BRA 0x7F78
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
17DEA  0EFE     MOVLW 0xFE
17DEC  50E3     MOVF 0xFE3, W, ACCESS
17DEE  0F01     ADDLW 0x1
17DF0  6E01     MOVWF ltemp0, ACCESS
17DF2  0EFE     MOVLW 0xFE
17DF6  F007     NOP
17DF8  FFE3     NOP
17DFA  6A01     CLRF ltemp0, ACCESS
17DFC  0EFF     MOVLW 0xFF
17DFE  50E3     MOVF 0xFE3, W, ACCESS
17E00  2001     ADDWFC ltemp0, W, ACCESS
17E02  6E01     MOVWF ltemp0, ACCESS
17E04  0EFF     MOVLW 0xFF
17E08  F007     NOP
17E0A  FFE3     NOP
17E0C  0EFC     MOVLW 0xFC
17E0E  50E3     MOVF 0xFE3, W, ACCESS
17E10  0F01     ADDLW 0x1
17E12  6E01     MOVWF ltemp0, ACCESS
17E14  0EFC     MOVLW 0xFC
17E18  F007     NOP
17E1A  FFE3     NOP
17E1C  6A01     CLRF ltemp0, ACCESS
17E1E  0EFD     MOVLW 0xFD
17E20  50E3     MOVF 0xFE3, W, ACCESS
17E22  2001     ADDWFC ltemp0, W, ACCESS
17E24  6E01     MOVWF ltemp0, ACCESS
17E26  0EFD     MOVLW 0xFD
17E2A  F007     NOP
17E2C  FFE3     NOP
17E2E  0EF6     MOVLW 0xF6
17E32  FF8C     NOP
17E34  F001     NOP
17E36  0E01     MOVLW 0x1
17E38  5E01     SUBWF ltemp0, F, ACCESS
17E3A  0EF6     MOVLW 0xF6
17E3E  F007     NOP
17E40  FFE3     NOP
17E42  0EF7     MOVLW 0xF7
17E46  FF8C     NOP
17E48  F001     NOP
17E4A  0E00     MOVLW 0x0
17E4C  5A01     SUBWFB ltemp0, F, ACCESS
17E4E  0EF7     MOVLW 0xF7
17E52  F007     NOP
17E54  FFE3     NOP
17E56  0EFE     MOVLW 0xFE
17E5A  FF8F     NOP
17E5C  FFF6     NOP
17E5E  0EFF     MOVLW 0xFF
17E62  FF8F     NOP
17E64  FFF7     NOP
17E66  0E00     MOVLW 0x0
17E68  6EF8     MOVWF 0xFF8, ACCESS
17E6A  0E1F     MOVLW 0x1F
17E6C  64F7     CPFSGT 0xFF7, ACCESS
17E6E  D003     BRA 0x7E76
17E70  0008     TBLRD*
17E72  50F5     MOVF 0xFF5, W, ACCESS
17E74  D007     BRA 0x7E84
17E78  FFDB     NOP
17E7A  FFE9     NOP
17E7E  FFDF     NOP
17E80  FFEA     NOP
17E82  50EF     MOVF 0xFEF, W, ACCESS
17E84  0900     IORLW 0x0
17E86  B4D8     BTFSC 0xFD8, 2, ACCESS
17E88  D04A     BRA 0x7F1E
17E8A  50E1     MOVF 0xFE1, W, ACCESS
17E8C  0FFC     ADDLW 0xFC
17E8E  6ED9     MOVWF 0xFD9, ACCESS
17E90  50E2     MOVF 0xFE2, W, ACCESS
17E92  6EDA     MOVWF 0xFDA, ACCESS
17E94  0EFF     MOVLW 0xFF
17E96  22DA     ADDWFC 0xFDA, F, ACCESS
17E9A  FF7B     NOP
17E9C  FFF6     NOP
17EA0  FF77     NOP
17EA2  FFF7     NOP
17EA4  0E00     MOVLW 0x0
17EA6  6EF8     MOVWF 0xFF8, ACCESS
17EA8  0008     TBLRD*
17EAA  50F5     MOVF 0xFF5, W, ACCESS
17EAC  0900     IORLW 0x0
17EAE  B4D8     BTFSC 0xFD8, 2, ACCESS
17EB0  D036     BRA 0x7F1E
17EB2  0EF6     MOVLW 0xF6
17EB6  FF8C     NOP
17EB8  F001     NOP
17EBA  0EF7     MOVLW 0xF7
17EBC  50E3     MOVF 0xFE3, W, ACCESS
17EBE  1001     IORWF ltemp0, W, ACCESS
17EC0  B4D8     BTFSC 0xFD8, 2, ACCESS
17EC2  D02D     BRA 0x7F1E
17EC4  50E1     MOVF 0xFE1, W, ACCESS
17EC6  0FFC     ADDLW 0xFC
17EC8  6ED9     MOVWF 0xFD9, ACCESS
17ECA  50E2     MOVF 0xFE2, W, ACCESS
17ECC  6EDA     MOVWF 0xFDA, ACCESS
17ECE  0EFF     MOVLW 0xFF
17ED0  22DA     ADDWFC 0xFDA, F, ACCESS
17ED4  FF7B     NOP
17ED6  FFF6     NOP
17EDA  FF77     NOP
17EDC  FFF7     NOP
17EDE  0E00     MOVLW 0x0
17EE0  6EF8     MOVWF 0xFF8, ACCESS
17EE2  0008     TBLRD*
17EE6  FFD4     NOP
17EE8  F00C     NOP
17EEA  0EFE     MOVLW 0xFE
17EEE  FF8F     NOP
17EF0  FFF6     NOP
17EF2  0EFF     MOVLW 0xFF
17EF6  FF8F     NOP
17EF8  FFF7     NOP
17EFA  0E00     MOVLW 0x0
17EFC  6EF8     MOVWF 0xFF8, ACCESS
17EFE  0E1F     MOVLW 0x1F
17F00  64F7     CPFSGT 0xFF7, ACCESS
17F02  D003     BRA 0x7F0A
17F04  0008     TBLRD*
17F06  50F5     MOVF 0xFF5, W, ACCESS
17F08  D007     BRA 0x7F18
17F0C  FFDB     NOP
17F0E  FFE9     NOP
17F12  FFDF     NOP
17F14  FFEA     NOP
17F16  50EF     MOVF 0xFEF, W, ACCESS
17F18  180C     XORWF 0xC, W, ACCESS
17F1A  B4D8     BTFSC 0xFD8, 2, ACCESS
17F1C  D766     BRA 0x7DEA
8:             	return *l - *r;
17F1E  0EFE     MOVLW 0xFE
17F22  FF8F     NOP
17F24  FFF6     NOP
17F26  0EFF     MOVLW 0xFF
17F2A  FF8F     NOP
17F2C  FFF7     NOP
17F2E  0E00     MOVLW 0x0
17F30  6EF8     MOVWF 0xFF8, ACCESS
17F32  0E1F     MOVLW 0x1F
17F34  64F7     CPFSGT 0xFF7, ACCESS
17F36  D003     BRA 0x7F3E
17F38  0008     TBLRD*
17F3A  50F5     MOVF 0xFF5, W, ACCESS
17F3C  D007     BRA 0x7F4C
17F40  FFDB     NOP
17F42  FFE9     NOP
17F46  FFDF     NOP
17F48  FFEA     NOP
17F4A  50EF     MOVF 0xFEF, W, ACCESS
17F4C  6E01     MOVWF ltemp0, ACCESS
17F4E  6A02     CLRF ttemp5, ACCESS
17F50  50E1     MOVF 0xFE1, W, ACCESS
17F52  0FFC     ADDLW 0xFC
17F54  6ED9     MOVWF 0xFD9, ACCESS
17F56  50E2     MOVF 0xFE2, W, ACCESS
17F58  6EDA     MOVWF 0xFDA, ACCESS
17F5A  0EFF     MOVLW 0xFF
17F5C  22DA     ADDWFC 0xFDA, F, ACCESS
17F60  FF7B     NOP
17F62  FFF6     NOP
17F66  FF77     NOP
17F68  FFF7     NOP
17F6A  0E00     MOVLW 0x0
17F6C  6EF8     MOVWF 0xFF8, ACCESS
17F6E  0008     TBLRD*
17F70  50F5     MOVF 0xFF5, W, ACCESS
17F72  5E01     SUBWF ltemp0, F, ACCESS
17F74  0E00     MOVLW 0x0
17F76  5A02     SUBWFB ttemp5, F, ACCESS
9:             }
17F78  0EF6     MOVLW 0xF6
17F7A  26E1     ADDWF 0xFE1, F, ACCESS
17F7C  0EFF     MOVLW 0xFF
17F7E  22E2     ADDWFC 0xFE2, F, ACCESS
17F80  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
1A5B8  52E6     MOVF 0xFE6, F, ACCESS
1A5BA  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	const char *a = s;
1A5BC  0EFC     MOVLW 0xFC
1A5C0  FF8C     NOP
1A5C2  F00B     NOP
1A5C4  0EFD     MOVLW 0xFD
1A5C8  FF8C     NOP
1A5CA  F00C     NOP
1A5CC  0EFF     MOVLW 0xFF
1A5D0  F033     NOP
1A5D2  FFE3     NOP
1A5D4  0EFE     MOVLW 0xFE
1A5D8  F02F     NOP
1A5DA  FFE3     NOP
8:             	while(*s) {
1A5DC  D011     BRA 0xA600
1A600  0EFC     MOVLW 0xFC
1A604  FF8F     NOP
1A606  FFF6     NOP
1A608  0EFD     MOVLW 0xFD
1A60C  FF8F     NOP
1A60E  FFF7     NOP
1A610  0E00     MOVLW 0x0
1A612  6EF8     MOVWF 0xFF8, ACCESS
1A614  0E1F     MOVLW 0x1F
1A616  64F7     CPFSGT 0xFF7, ACCESS
1A618  D003     BRA 0xA620
1A61A  0008     TBLRD*
1A61C  50F5     MOVF 0xFF5, W, ACCESS
1A61E  D007     BRA 0xA62E
1A622  FFDB     NOP
1A624  FFE9     NOP
1A628  FFDF     NOP
1A62A  FFEA     NOP
1A62C  50EF     MOVF 0xFEF, W, ACCESS
1A62E  0900     IORLW 0x0
1A630  A4D8     BTFSS 0xFD8, 2, ACCESS
1A632  D7D5     BRA 0xA5DE
9:             		s++;
1A5DE  0EFC     MOVLW 0xFC
1A5E0  50E3     MOVF 0xFE3, W, ACCESS
1A5E2  0F01     ADDLW 0x1
1A5E4  6E01     MOVWF ltemp0, ACCESS
1A5E6  0EFC     MOVLW 0xFC
1A5EA  F007     NOP
1A5EC  FFE3     NOP
1A5EE  6A01     CLRF ltemp0, ACCESS
1A5F0  0EFD     MOVLW 0xFD
1A5F2  50E3     MOVF 0xFE3, W, ACCESS
1A5F4  2001     ADDWFC ltemp0, W, ACCESS
1A5F6  6E01     MOVWF ltemp0, ACCESS
1A5F8  0EFD     MOVLW 0xFD
1A5FC  F007     NOP
1A5FE  FFE3     NOP
10:            	}
11:            	return s-a;
1A634  0EFC     MOVLW 0xFC
1A638  FF8C     NOP
1A63A  F001     NOP
1A63C  0EFD     MOVLW 0xFD
1A640  FF8C     NOP
1A642  F002     NOP
1A644  0EFE     MOVLW 0xFE
1A646  50E3     MOVF 0xFE3, W, ACCESS
1A648  5E01     SUBWF ltemp0, F, ACCESS
1A64A  0EFF     MOVLW 0xFF
1A64C  50E3     MOVF 0xFE3, W, ACCESS
1A64E  5A02     SUBWFB ttemp5, F, ACCESS
12:            }
1A650  52E5     MOVF 0xFE5, F, ACCESS
1A652  52E5     MOVF 0xFE5, F, ACCESS
1A654  52E5     MOVF 0xFE5, F, ACCESS
1A656  52E5     MOVF 0xFE5, F, ACCESS
1A658  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/strcpy.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             char *strcpy(char *restrict dest, const char *restrict src)
1A0BE  52E6     MOVF 0xFE6, F, ACCESS
1A0C0  52E6     MOVF 0xFE6, F, ACCESS
1A0C2  52E6     MOVF 0xFE6, F, ACCESS
1A0C4  52E6     MOVF 0xFE6, F, ACCESS
4:             {
5:             	const char *s = src;
1A0C6  0EF8     MOVLW 0xF8
1A0CA  FF8C     NOP
1A0CC  F00B     NOP
1A0CE  0EF9     MOVLW 0xF9
1A0D2  FF8C     NOP
1A0D4  F00C     NOP
1A0D6  0EFF     MOVLW 0xFF
1A0DA  F033     NOP
1A0DC  FFE3     NOP
1A0DE  0EFE     MOVLW 0xFE
1A0E2  F02F     NOP
1A0E4  FFE3     NOP
6:             	char *d = dest;
1A0E6  0EFA     MOVLW 0xFA
1A0EA  FF8C     NOP
1A0EC  F00B     NOP
1A0EE  0EFB     MOVLW 0xFB
1A0F2  FF8C     NOP
1A0F4  F00C     NOP
1A0F6  0EFD     MOVLW 0xFD
1A0FA  F033     NOP
1A0FC  FFE3     NOP
1A0FE  0EFC     MOVLW 0xFC
1A102  F02F     NOP
1A104  FFE3     NOP
7:             	while ((*d++ = *s++));
1A106  50E1     MOVF 0xFE1, W, ACCESS
1A108  0FFE     ADDLW 0xFE
1A10A  6ED9     MOVWF 0xFD9, ACCESS
1A10C  50E2     MOVF 0xFE2, W, ACCESS
1A10E  6EDA     MOVWF 0xFDA, ACCESS
1A110  0EFF     MOVLW 0xFF
1A112  22DA     ADDWFC 0xFDA, F, ACCESS
1A116  FF7C     NOP
1A118  F00B     NOP
1A11A  0E01     MOVLW 0x1
1A11C  26DE     ADDWF 0xFDE, F, ACCESS
1A120  FF7C     NOP
1A122  F00C     NOP
1A124  0E00     MOVLW 0x0
1A126  22DD     ADDWFC 0xFDD, F, ACCESS
1A12A  F02F     NOP
1A12C  FFF6     NOP
1A130  F033     NOP
1A132  FFF7     NOP
1A134  0E00     MOVLW 0x0
1A136  6EF8     MOVWF 0xFF8, ACCESS
1A138  50E1     MOVF 0xFE1, W, ACCESS
1A13A  0FFC     ADDLW 0xFC
1A13C  6ED9     MOVWF 0xFD9, ACCESS
1A13E  50E2     MOVF 0xFE2, W, ACCESS
1A140  6EDA     MOVWF 0xFDA, ACCESS
1A142  0EFF     MOVLW 0xFF
1A144  22DA     ADDWFC 0xFDA, F, ACCESS
1A148  FF7C     NOP
1A14A  F00B     NOP
1A14C  0E01     MOVLW 0x1
1A14E  26DE     ADDWF 0xFDE, F, ACCESS
1A152  FF7C     NOP
1A154  F00C     NOP
1A156  0E00     MOVLW 0x0
1A158  22DD     ADDWFC 0xFDD, F, ACCESS
1A15C  F02F     NOP
1A15E  FFD9     NOP
1A162  F033     NOP
1A164  FFDA     NOP
1A166  0E1F     MOVLW 0x1F
1A168  64F7     CPFSGT 0xFF7, ACCESS
1A16A  D003     BRA 0xA172
1A16C  0008     TBLRD*
1A16E  50F5     MOVF 0xFF5, W, ACCESS
1A170  D007     BRA 0xA180
1A174  FFDB     NOP
1A176  FFE9     NOP
1A17A  FFDF     NOP
1A17C  FFEA     NOP
1A17E  50EF     MOVF 0xFEF, W, ACCESS
1A180  6EDF     MOVWF 0xFDF, ACCESS
1A182  50DF     MOVF 0xFDF, W, ACCESS
1A184  A4D8     BTFSS 0xFD8, 2, ACCESS
1A186  D7BF     BRA 0xA106
8:             	return dest;
9:             }
1A188  0EF8     MOVLW 0xF8
1A18A  26E1     ADDWF 0xFE1, F, ACCESS
1A18C  0EFF     MOVLW 0xFF
1A18E  22E2     ADDWFC 0xFE2, F, ACCESS
1A190  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/sprcmul.c  -----------------------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
13340  0E0D     MOVLW 0xD
13342  26E1     ADDWF 0xFE1, F, ACCESS
13344  0E00     MOVLW 0x0
13346  22E2     ADDWFC 0xFE2, F, ACCESS
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
13348  0EF2     MOVLW 0xF2
1334A  24E1     ADDWF 0xFE1, W, ACCESS
1334C  6ED9     MOVWF 0xFD9, ACCESS
1334E  0EFF     MOVLW 0xFF
13350  20E2     ADDWFC 0xFE2, W, ACCESS
13352  6EDA     MOVWF 0xFDA, ACCESS
13354  50DF     MOVF 0xFDF, W, ACCESS
13356  6E0C     MOVWF 0xC, ACCESS
13358  0E80     MOVLW 0x80
1335A  160C     ANDWF 0xC, F, ACCESS
1335C  0EFF     MOVLW 0xFF
13360  F033     NOP
13362  FFE3     NOP
18:            	bexp = ((*(SFP *) & b).fAsBytes.d) << 1;
13364  0EF2     MOVLW 0xF2
13366  24E1     ADDWF 0xFE1, W, ACCESS
13368  6ED9     MOVWF 0xFD9, ACCESS
1336A  0EFF     MOVLW 0xFF
1336C  20E2     ADDWFC 0xFE2, W, ACCESS
1336E  6EDA     MOVWF 0xFDA, ACCESS
13370  50DF     MOVF 0xFDF, W, ACCESS
13372  6E0C     MOVWF 0xC, ACCESS
13374  90D8     BCF 0xFD8, 0, ACCESS
13376  340C     RLCF 0xC, W, ACCESS
13378  6E0B     MOVWF wtemp5, ACCESS
1337A  0EFD     MOVLW 0xFD
1337E  F02F     NOP
13380  FFE3     NOP
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
13382  0EF1     MOVLW 0xF1
13384  24E1     ADDWF 0xFE1, W, ACCESS
13386  6ED9     MOVWF 0xFD9, ACCESS
13388  0EFF     MOVLW 0xFF
1338A  20E2     ADDWFC 0xFE2, W, ACCESS
1338C  6EDA     MOVWF 0xFDA, ACCESS
1338E  AEDF     BTFSS 0xFDF, 7, ACCESS
13390  D002     BRA 0x3396
20:            		bexp |= 0x1;
13392  0EFD     MOVLW 0xFD
13394  80E3     BSF 0xFE3, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
13396  0EFD     MOVLW 0xFD
13398  50E3     MOVF 0xFE3, W, ACCESS
1339A  B4D8     BTFSC 0xFD8, 2, ACCESS
1339C  D01F     BRA 0x33DC
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
1339E  0EFD     MOVLW 0xFD
133A0  28E3     INCF 0xFE3, W, ACCESS
133A2  A4D8     BTFSS 0xFD8, 2, ACCESS
133A4  D018     BRA 0x33D6
27:            			/* Make it inf */
28:            			b = 0;
133A6  0E00     MOVLW 0x0
133A8  6E09     MOVWF ltemp2, ACCESS
133AA  0E00     MOVLW 0x0
133AC  6E0A     MOVWF ttemp3, ACCESS
133AE  0E00     MOVLW 0x0
133B0  6E0B     MOVWF wtemp5, ACCESS
133B2  0E00     MOVLW 0x0
133B4  6E0C     MOVWF 0xC, ACCESS
133B6  0EEF     MOVLW 0xEF
133BA  F027     NOP
133BC  FFE3     NOP
133BE  0EF0     MOVLW 0xF0
133C2  F02B     NOP
133C4  FFE3     NOP
133C6  0EF1     MOVLW 0xF1
133CA  F02F     NOP
133CC  FFE3     NOP
133CE  0EF2     MOVLW 0xF2
133D2  F033     NOP
133D4  FFE3     NOP
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
133D6  0EF1     MOVLW 0xF1
133D8  8EE3     BSF 0xFE3, 7, ACCESS
32:            
33:            	}
133DA  D018     BRA 0x340C
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
133DC  0E00     MOVLW 0x0
133DE  6E09     MOVWF ltemp2, ACCESS
133E0  0E00     MOVLW 0x0
133E2  6E0A     MOVWF ttemp3, ACCESS
133E4  0E00     MOVLW 0x0
133E6  6E0B     MOVWF wtemp5, ACCESS
133E8  0E00     MOVLW 0x0
133EA  6E0C     MOVWF 0xC, ACCESS
133EC  0EEF     MOVLW 0xEF
133F0  F027     NOP
133F2  FFE3     NOP
133F4  0EF0     MOVLW 0xF0
133F8  F02B     NOP
133FA  FFE3     NOP
133FC  0EF1     MOVLW 0xF1
13400  F02F     NOP
13402  FFE3     NOP
13404  0EF2     MOVLW 0xF2
13408  F033     NOP
1340A  FFE3     NOP
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
1340C  0EEE     MOVLW 0xEE
1340E  24E1     ADDWF 0xFE1, W, ACCESS
13410  6ED9     MOVWF 0xFD9, ACCESS
13412  0EFF     MOVLW 0xFF
13414  20E2     ADDWFC 0xFE2, W, ACCESS
13416  6EDA     MOVWF 0xFDA, ACCESS
13418  50DF     MOVF 0xFDF, W, ACCESS
1341A  6E0C     MOVWF 0xC, ACCESS
1341C  0E80     MOVLW 0x80
1341E  160C     ANDWF 0xC, F, ACCESS
13420  50E1     MOVF 0xFE1, W, ACCESS
13422  0FFF     ADDLW 0xFF
13424  6ED9     MOVWF 0xFD9, ACCESS
13426  50E2     MOVF 0xFE2, W, ACCESS
13428  6EDA     MOVWF 0xFDA, ACCESS
1342A  0EFF     MOVLW 0xFF
1342C  22DA     ADDWFC 0xFDA, F, ACCESS
1342E  500C     MOVF 0xC, W, ACCESS
13430  1ADF     XORWF 0xFDF, F, ACCESS
40:            	aexp = ((*(SFP *) & a).fAsBytes.d) << 1;
13432  0EEE     MOVLW 0xEE
13434  24E1     ADDWF 0xFE1, W, ACCESS
13436  6ED9     MOVWF 0xFD9, ACCESS
13438  0EFF     MOVLW 0xFF
1343A  20E2     ADDWFC 0xFE2, W, ACCESS
1343C  6EDA     MOVWF 0xFDA, ACCESS
1343E  50DF     MOVF 0xFDF, W, ACCESS
13440  6E0C     MOVWF 0xC, ACCESS
13442  90D8     BCF 0xFD8, 0, ACCESS
13444  340C     RLCF 0xC, W, ACCESS
13446  6E0B     MOVWF wtemp5, ACCESS
13448  0EFE     MOVLW 0xFE
1344C  F02F     NOP
1344E  FFE3     NOP
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
13450  0EED     MOVLW 0xED
13452  24E1     ADDWF 0xFE1, W, ACCESS
13454  6ED9     MOVWF 0xFD9, ACCESS
13456  0EFF     MOVLW 0xFF
13458  20E2     ADDWFC 0xFE2, W, ACCESS
1345A  6EDA     MOVWF 0xFDA, ACCESS
1345C  AEDF     BTFSS 0xFDF, 7, ACCESS
1345E  D002     BRA 0x3464
42:            		aexp |= 0x1;
13460  0EFE     MOVLW 0xFE
13462  80E3     BSF 0xFE3, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
13464  0EFE     MOVLW 0xFE
13466  50E3     MOVF 0xFE3, W, ACCESS
13468  B4D8     BTFSC 0xFD8, 2, ACCESS
1346A  D01F     BRA 0x34AA
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
1346C  0EFE     MOVLW 0xFE
1346E  28E3     INCF 0xFE3, W, ACCESS
13470  A4D8     BTFSS 0xFD8, 2, ACCESS
13472  D018     BRA 0x34A4
49:            			/* Make it inf */
50:            			a = 0;
13474  0E00     MOVLW 0x0
13476  6E09     MOVWF ltemp2, ACCESS
13478  0E00     MOVLW 0x0
1347A  6E0A     MOVWF ttemp3, ACCESS
1347C  0E00     MOVLW 0x0
1347E  6E0B     MOVWF wtemp5, ACCESS
13480  0E00     MOVLW 0x0
13482  6E0C     MOVWF 0xC, ACCESS
13484  0EEB     MOVLW 0xEB
13488  F027     NOP
1348A  FFE3     NOP
1348C  0EEC     MOVLW 0xEC
13490  F02B     NOP
13492  FFE3     NOP
13494  0EED     MOVLW 0xED
13498  F02F     NOP
1349A  FFE3     NOP
1349C  0EEE     MOVLW 0xEE
134A0  F033     NOP
134A2  FFE3     NOP
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
134A4  0EED     MOVLW 0xED
134A6  8EE3     BSF 0xFE3, 7, ACCESS
54:            	}
134A8  D018     BRA 0x34DA
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
134AA  0E00     MOVLW 0x0
134AC  6E09     MOVWF ltemp2, ACCESS
134AE  0E00     MOVLW 0x0
134B0  6E0A     MOVWF ttemp3, ACCESS
134B2  0E00     MOVLW 0x0
134B4  6E0B     MOVWF wtemp5, ACCESS
134B6  0E00     MOVLW 0x0
134B8  6E0C     MOVWF 0xC, ACCESS
134BA  0EEB     MOVLW 0xEB
134BE  F027     NOP
134C0  FFE3     NOP
134C2  0EEC     MOVLW 0xEC
134C6  F02B     NOP
134C8  FFE3     NOP
134CA  0EED     MOVLW 0xED
134CE  F02F     NOP
134D0  FFE3     NOP
134D2  0EEE     MOVLW 0xEE
134D6  F033     NOP
134D8  FFE3     NOP
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
134DA  0EFE     MOVLW 0xFE
134DC  50E3     MOVF 0xFE3, W, ACCESS
134DE  B4D8     BTFSC 0xFD8, 2, ACCESS
134E0  D004     BRA 0x34EA
134E2  0EFD     MOVLW 0xFD
134E4  50E3     MOVF 0xFE3, W, ACCESS
134E6  A4D8     BTFSS 0xFD8, 2, ACCESS
134E8  D009     BRA 0x34FC
66:            		return 0.0;
134EA  0E00     MOVLW 0x0
134EC  6E01     MOVWF ltemp0, ACCESS
134EE  0E00     MOVLW 0x0
134F0  6E02     MOVWF ttemp5, ACCESS
134F2  0E00     MOVLW 0x0
134F4  6E03     MOVWF wtemp1, ACCESS
134F6  0E00     MOVLW 0x0
134F8  6E04     MOVWF ttemp1, ACCESS
134FA  D332     BRA 0x3B60
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
134FC  0EEF     MOVLW 0xEF
13500  FF8C     NOP
13502  F00C     NOP
13504  0EED     MOVLW 0xED
13506  24E1     ADDWF 0xFE1, W, ACCESS
13508  6ED9     MOVWF 0xFD9, ACCESS
1350A  0EFF     MOVLW 0xFF
1350C  20E2     ADDWFC 0xFE2, W, ACCESS
1350E  6EDA     MOVWF 0xFDA, ACCESS
13510  50DF     MOVF 0xFDF, W, ACCESS
13512  020C     MULWF 0xC, ACCESS
13514  0EFB     MOVLW 0xFB
13518  FFCF     NOP
1351A  FFE3     NOP
1351C  0EFC     MOVLW 0xFC
13520  FFD3     NOP
13522  FFE3     NOP
96:            	grs = temp.nAsBytes.a;
13524  0EFB     MOVLW 0xFB
13528  FF8C     NOP
1352A  F00C     NOP
1352E  F030     NOP
13530  F005     NOP
13532  6A06     CLRF 0x6, ACCESS
13534  6A07     CLRF ttemp2, ACCESS
13536  6A08     CLRF 0x8, ACCESS
13538  0EF7     MOVLW 0xF7
1353C  F017     NOP
1353E  FFE3     NOP
13540  0EF8     MOVLW 0xF8
13544  F01B     NOP
13546  FFE3     NOP
13548  0EF9     MOVLW 0xF9
1354C  F01F     NOP
1354E  FFE3     NOP
13550  0EFA     MOVLW 0xFA
13554  F023     NOP
13556  FFE3     NOP
97:            	prod.i = temp.nAsBytes.b;
13558  0EFC     MOVLW 0xFC
1355A  24E1     ADDWF 0xFE1, W, ACCESS
1355C  6ED9     MOVWF 0xFD9, ACCESS
1355E  0EFF     MOVLW 0xFF
13560  20E2     ADDWFC 0xFE2, W, ACCESS
13562  6EDA     MOVWF 0xFDA, ACCESS
13564  50DF     MOVF 0xFDF, W, ACCESS
13566  6E0C     MOVWF 0xC, ACCESS
1356A  F030     NOP
1356C  F005     NOP
1356E  6A06     CLRF 0x6, ACCESS
13570  6A07     CLRF ttemp2, ACCESS
13572  6A08     CLRF 0x8, ACCESS
13574  0EF3     MOVLW 0xF3
13578  F017     NOP
1357A  FFE3     NOP
1357C  0EF4     MOVLW 0xF4
13580  F01B     NOP
13582  FFE3     NOP
13584  0EF5     MOVLW 0xF5
13588  F01F     NOP
1358A  FFE3     NOP
1358C  0EF6     MOVLW 0xF6
13590  F023     NOP
13592  FFE3     NOP
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
13594  0EF0     MOVLW 0xF0
13596  24E1     ADDWF 0xFE1, W, ACCESS
13598  6ED9     MOVWF 0xFD9, ACCESS
1359A  0EFF     MOVLW 0xFF
1359C  20E2     ADDWFC 0xFE2, W, ACCESS
1359E  6EDA     MOVWF 0xFDA, ACCESS
135A0  50DF     MOVF 0xFDF, W, ACCESS
135A2  6E0C     MOVWF 0xC, ACCESS
135A4  0EEC     MOVLW 0xEC
135A6  24E1     ADDWF 0xFE1, W, ACCESS
135A8  6ED9     MOVWF 0xFD9, ACCESS
135AA  0EFF     MOVLW 0xFF
135AC  20E2     ADDWFC 0xFE2, W, ACCESS
135AE  6EDA     MOVWF 0xFDA, ACCESS
135B0  50DF     MOVF 0xFDF, W, ACCESS
135B2  020C     MULWF 0xC, ACCESS
135B4  0EFB     MOVLW 0xFB
135B8  FFCF     NOP
135BA  FFE3     NOP
135BC  0EFC     MOVLW 0xFC
135C0  FFD3     NOP
135C2  FFE3     NOP
99:            	grs += temp.nAsBytes.a;
135C4  50E1     MOVF 0xFE1, W, ACCESS
135C6  0FF7     ADDLW 0xF7
135C8  6ED9     MOVWF 0xFD9, ACCESS
135CA  50E2     MOVF 0xFE2, W, ACCESS
135CC  6EDA     MOVWF 0xFDA, ACCESS
135CE  0EFF     MOVLW 0xFF
135D0  22DA     ADDWFC 0xFDA, F, ACCESS
135D2  0EFB     MOVLW 0xFB
135D4  50E3     MOVF 0xFE3, W, ACCESS
135D6  26DE     ADDWF 0xFDE, F, ACCESS
135D8  0E00     MOVLW 0x0
135DA  22DE     ADDWFC 0xFDE, F, ACCESS
135DC  22DE     ADDWFC 0xFDE, F, ACCESS
135DE  22DE     ADDWFC 0xFDE, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
135E0  50E1     MOVF 0xFE1, W, ACCESS
135E2  0FF3     ADDLW 0xF3
135E4  6ED9     MOVWF 0xFD9, ACCESS
135E6  50E2     MOVF 0xFE2, W, ACCESS
135E8  6EDA     MOVWF 0xFDA, ACCESS
135EA  0EFF     MOVLW 0xFF
135EC  22DA     ADDWFC 0xFDA, F, ACCESS
135EE  0EFC     MOVLW 0xFC
135F0  24E1     ADDWF 0xFE1, W, ACCESS
135F2  6EE9     MOVWF 0xFE9, ACCESS
135F4  0EFF     MOVLW 0xFF
135F6  20E2     ADDWFC 0xFE2, W, ACCESS
135F8  6EEA     MOVWF 0xFEA, ACCESS
135FA  50EF     MOVF 0xFEF, W, ACCESS
135FC  26DE     ADDWF 0xFDE, F, ACCESS
135FE  0E00     MOVLW 0x0
13600  22DE     ADDWFC 0xFDE, F, ACCESS
13602  22DE     ADDWFC 0xFDE, F, ACCESS
13604  22DE     ADDWFC 0xFDE, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
13606  0EF1     MOVLW 0xF1
13608  24E1     ADDWF 0xFE1, W, ACCESS
1360A  6ED9     MOVWF 0xFD9, ACCESS
1360C  0EFF     MOVLW 0xFF
1360E  20E2     ADDWFC 0xFE2, W, ACCESS
13610  6EDA     MOVWF 0xFDA, ACCESS
13612  50DF     MOVF 0xFDF, W, ACCESS
13614  6E0C     MOVWF 0xC, ACCESS
13616  0EEB     MOVLW 0xEB
13618  50E3     MOVF 0xFE3, W, ACCESS
1361A  020C     MULWF 0xC, ACCESS
1361C  0EFB     MOVLW 0xFB
13620  FFCF     NOP
13622  FFE3     NOP
13624  0EFC     MOVLW 0xFC
13628  FFD3     NOP
1362A  FFE3     NOP
102:           	grs += temp.nAsBytes.a;
1362C  50E1     MOVF 0xFE1, W, ACCESS
1362E  0FF7     ADDLW 0xF7
13630  6ED9     MOVWF 0xFD9, ACCESS
13632  50E2     MOVF 0xFE2, W, ACCESS
13634  6EDA     MOVWF 0xFDA, ACCESS
13636  0EFF     MOVLW 0xFF
13638  22DA     ADDWFC 0xFDA, F, ACCESS
1363A  0EFB     MOVLW 0xFB
1363C  50E3     MOVF 0xFE3, W, ACCESS
1363E  26DE     ADDWF 0xFDE, F, ACCESS
13640  0E00     MOVLW 0x0
13642  22DE     ADDWFC 0xFDE, F, ACCESS
13644  22DE     ADDWFC 0xFDE, F, ACCESS
13646  22DE     ADDWFC 0xFDE, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
13648  50E1     MOVF 0xFE1, W, ACCESS
1364A  0FF3     ADDLW 0xF3
1364C  6ED9     MOVWF 0xFD9, ACCESS
1364E  50E2     MOVF 0xFE2, W, ACCESS
13650  6EDA     MOVWF 0xFDA, ACCESS
13652  0EFF     MOVLW 0xFF
13654  22DA     ADDWFC 0xFDA, F, ACCESS
13656  0EFC     MOVLW 0xFC
13658  24E1     ADDWF 0xFE1, W, ACCESS
1365A  6EE9     MOVWF 0xFE9, ACCESS
1365C  0EFF     MOVLW 0xFF
1365E  20E2     ADDWFC 0xFE2, W, ACCESS
13660  6EEA     MOVWF 0xFEA, ACCESS
13662  50EF     MOVF 0xFEF, W, ACCESS
13664  26DE     ADDWF 0xFDE, F, ACCESS
13666  0E00     MOVLW 0x0
13668  22DE     ADDWFC 0xFDE, F, ACCESS
1366A  22DE     ADDWFC 0xFDE, F, ACCESS
1366C  22DE     ADDWFC 0xFDE, F, ACCESS
104:           	grs <<= 8;
1366E  50E1     MOVF 0xFE1, W, ACCESS
13670  0FF7     ADDLW 0xF7
13672  6ED9     MOVWF 0xFD9, ACCESS
13674  50E2     MOVF 0xFE2, W, ACCESS
13676  6EDA     MOVWF 0xFDA, ACCESS
13678  0EFF     MOVLW 0xFF
1367A  22DA     ADDWFC 0xFDA, F, ACCESS
1367C  0E08     MOVLW 0x8
1367E  90D8     BCF 0xFD8, 0, ACCESS
13680  36DE     RLCF 0xFDE, F, ACCESS
13682  36DE     RLCF 0xFDE, F, ACCESS
13684  36DE     RLCF 0xFDE, F, ACCESS
13686  36DD     RLCF 0xFDD, F, ACCESS
13688  52DD     MOVF 0xFDD, F, ACCESS
1368A  52DD     MOVF 0xFDD, F, ACCESS
1368C  2EE8     DECFSZ 0xFE8, F, ACCESS
1368E  D7F7     BRA 0x367E
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
13690  0EF0     MOVLW 0xF0
13692  24E1     ADDWF 0xFE1, W, ACCESS
13694  6ED9     MOVWF 0xFD9, ACCESS
13696  0EFF     MOVLW 0xFF
13698  20E2     ADDWFC 0xFE2, W, ACCESS
1369A  6EDA     MOVWF 0xFDA, ACCESS
1369C  50DF     MOVF 0xFDF, W, ACCESS
1369E  6E0C     MOVWF 0xC, ACCESS
136A0  0EEB     MOVLW 0xEB
136A2  50E3     MOVF 0xFE3, W, ACCESS
136A4  020C     MULWF 0xC, ACCESS
136A6  0EFB     MOVLW 0xFB
136AA  FFCF     NOP
136AC  FFE3     NOP
136AE  0EFC     MOVLW 0xFC
136B2  FFD3     NOP
136B4  FFE3     NOP
106:           	grs += (unsigned long)temp.n;
136B6  0EFB     MOVLW 0xFB
136BA  FF8C     NOP
136BC  F00B     NOP
136BE  0EFC     MOVLW 0xFC
136C2  FF8C     NOP
136C4  F00C     NOP
136C6  50E1     MOVF 0xFE1, W, ACCESS
136C8  0FF7     ADDLW 0xF7
136CA  6ED9     MOVWF 0xFD9, ACCESS
136CC  50E2     MOVF 0xFE2, W, ACCESS
136CE  6EDA     MOVWF 0xFDA, ACCESS
136D0  0EFF     MOVLW 0xFF
136D2  22DA     ADDWFC 0xFDA, F, ACCESS
136D4  500B     MOVF wtemp5, W, ACCESS
136D6  26DE     ADDWF 0xFDE, F, ACCESS
136D8  500C     MOVF 0xC, W, ACCESS
136DA  22DE     ADDWFC 0xFDE, F, ACCESS
136DC  0E00     MOVLW 0x0
136DE  22DE     ADDWFC 0xFDE, F, ACCESS
136E0  22DE     ADDWFC 0xFDE, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
136E2  0EEF     MOVLW 0xEF
136E6  FF8C     NOP
136E8  F00C     NOP
136EA  0EEC     MOVLW 0xEC
136EC  24E1     ADDWF 0xFE1, W, ACCESS
136EE  6ED9     MOVWF 0xFD9, ACCESS
136F0  0EFF     MOVLW 0xFF
136F2  20E2     ADDWFC 0xFE2, W, ACCESS
136F4  6EDA     MOVWF 0xFDA, ACCESS
136F6  50DF     MOVF 0xFDF, W, ACCESS
136F8  020C     MULWF 0xC, ACCESS
136FA  0EFB     MOVLW 0xFB
136FE  FFCF     NOP
13700  FFE3     NOP
13702  0EFC     MOVLW 0xFC
13706  FFD3     NOP
13708  FFE3     NOP
108:           	grs += (unsigned long)temp.n;
1370A  0EFB     MOVLW 0xFB
1370E  FF8C     NOP
13710  F00B     NOP
13712  0EFC     MOVLW 0xFC
13716  FF8C     NOP
13718  F00C     NOP
1371A  50E1     MOVF 0xFE1, W, ACCESS
1371C  0FF7     ADDLW 0xF7
1371E  6ED9     MOVWF 0xFD9, ACCESS
13720  50E2     MOVF 0xFE2, W, ACCESS
13722  6EDA     MOVWF 0xFDA, ACCESS
13724  0EFF     MOVLW 0xFF
13726  22DA     ADDWFC 0xFDA, F, ACCESS
13728  500B     MOVF wtemp5, W, ACCESS
1372A  26DE     ADDWF 0xFDE, F, ACCESS
1372C  500C     MOVF 0xC, W, ACCESS
1372E  22DE     ADDWFC 0xFDE, F, ACCESS
13730  0E00     MOVLW 0x0
13732  22DE     ADDWFC 0xFDE, F, ACCESS
13734  22DE     ADDWFC 0xFDE, F, ACCESS
109:           	grs <<= 8;
13736  50E1     MOVF 0xFE1, W, ACCESS
13738  0FF7     ADDLW 0xF7
1373A  6ED9     MOVWF 0xFD9, ACCESS
1373C  50E2     MOVF 0xFE2, W, ACCESS
1373E  6EDA     MOVWF 0xFDA, ACCESS
13740  0EFF     MOVLW 0xFF
13742  22DA     ADDWFC 0xFDA, F, ACCESS
13744  0E08     MOVLW 0x8
13746  90D8     BCF 0xFD8, 0, ACCESS
13748  36DE     RLCF 0xFDE, F, ACCESS
1374A  36DE     RLCF 0xFDE, F, ACCESS
1374C  36DE     RLCF 0xFDE, F, ACCESS
1374E  36DD     RLCF 0xFDD, F, ACCESS
13750  52DD     MOVF 0xFDD, F, ACCESS
13752  52DD     MOVF 0xFDD, F, ACCESS
13754  2EE8     DECFSZ 0xFE8, F, ACCESS
13756  D7F7     BRA 0x3746
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
13758  0EEF     MOVLW 0xEF
1375C  FF8C     NOP
1375E  F00C     NOP
13760  0EEB     MOVLW 0xEB
13762  50E3     MOVF 0xFE3, W, ACCESS
13764  020C     MULWF 0xC, ACCESS
13766  0EFB     MOVLW 0xFB
1376A  FFCF     NOP
1376C  FFE3     NOP
1376E  0EFC     MOVLW 0xFC
13772  FFD3     NOP
13774  FFE3     NOP
111:           	grs += (unsigned long)temp.n;
13776  0EFB     MOVLW 0xFB
1377A  FF8C     NOP
1377C  F00B     NOP
1377E  0EFC     MOVLW 0xFC
13782  FF8C     NOP
13784  F00C     NOP
13786  50E1     MOVF 0xFE1, W, ACCESS
13788  0FF7     ADDLW 0xF7
1378A  6ED9     MOVWF 0xFD9, ACCESS
1378C  50E2     MOVF 0xFE2, W, ACCESS
1378E  6EDA     MOVWF 0xFDA, ACCESS
13790  0EFF     MOVLW 0xFF
13792  22DA     ADDWFC 0xFDA, F, ACCESS
13794  500B     MOVF wtemp5, W, ACCESS
13796  26DE     ADDWF 0xFDE, F, ACCESS
13798  500C     MOVF 0xC, W, ACCESS
1379A  22DE     ADDWFC 0xFDE, F, ACCESS
1379C  0E00     MOVLW 0x0
1379E  22DE     ADDWFC 0xFDE, F, ACCESS
137A0  22DE     ADDWFC 0xFDE, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
137A2  0EF0     MOVLW 0xF0
137A4  24E1     ADDWF 0xFE1, W, ACCESS
137A6  6ED9     MOVWF 0xFD9, ACCESS
137A8  0EFF     MOVLW 0xFF
137AA  20E2     ADDWFC 0xFE2, W, ACCESS
137AC  6EDA     MOVWF 0xFDA, ACCESS
137AE  50DF     MOVF 0xFDF, W, ACCESS
137B0  6E0C     MOVWF 0xC, ACCESS
137B2  0EED     MOVLW 0xED
137B4  24E1     ADDWF 0xFE1, W, ACCESS
137B6  6ED9     MOVWF 0xFD9, ACCESS
137B8  0EFF     MOVLW 0xFF
137BA  20E2     ADDWFC 0xFE2, W, ACCESS
137BC  6EDA     MOVWF 0xFDA, ACCESS
137BE  50DF     MOVF 0xFDF, W, ACCESS
137C0  020C     MULWF 0xC, ACCESS
137C2  0EFB     MOVLW 0xFB
137C6  FFCF     NOP
137C8  FFE3     NOP
137CA  0EFC     MOVLW 0xFC
137CE  FFD3     NOP
137D0  FFE3     NOP
113:           	prod.i += (unsigned long)temp.n;
137D2  0EFB     MOVLW 0xFB
137D6  FF8C     NOP
137D8  F00B     NOP
137DA  0EFC     MOVLW 0xFC
137DE  FF8C     NOP
137E0  F00C     NOP
137E2  50E1     MOVF 0xFE1, W, ACCESS
137E4  0FF3     ADDLW 0xF3
137E6  6ED9     MOVWF 0xFD9, ACCESS
137E8  50E2     MOVF 0xFE2, W, ACCESS
137EA  6EDA     MOVWF 0xFDA, ACCESS
137EC  0EFF     MOVLW 0xFF
137EE  22DA     ADDWFC 0xFDA, F, ACCESS
137F0  500B     MOVF wtemp5, W, ACCESS
137F2  26DE     ADDWF 0xFDE, F, ACCESS
137F4  500C     MOVF 0xC, W, ACCESS
137F6  22DE     ADDWFC 0xFDE, F, ACCESS
137F8  0E00     MOVLW 0x0
137FA  22DE     ADDWFC 0xFDE, F, ACCESS
137FC  22DE     ADDWFC 0xFDE, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
137FE  0EF1     MOVLW 0xF1
13800  24E1     ADDWF 0xFE1, W, ACCESS
13802  6ED9     MOVWF 0xFD9, ACCESS
13804  0EFF     MOVLW 0xFF
13806  20E2     ADDWFC 0xFE2, W, ACCESS
13808  6EDA     MOVWF 0xFDA, ACCESS
1380A  50DF     MOVF 0xFDF, W, ACCESS
1380C  6E0C     MOVWF 0xC, ACCESS
1380E  0EEC     MOVLW 0xEC
13810  24E1     ADDWF 0xFE1, W, ACCESS
13812  6ED9     MOVWF 0xFD9, ACCESS
13814  0EFF     MOVLW 0xFF
13816  20E2     ADDWFC 0xFE2, W, ACCESS
13818  6EDA     MOVWF 0xFDA, ACCESS
1381A  50DF     MOVF 0xFDF, W, ACCESS
1381C  020C     MULWF 0xC, ACCESS
1381E  0EFB     MOVLW 0xFB
13822  FFCF     NOP
13824  FFE3     NOP
13826  0EFC     MOVLW 0xFC
1382A  FFD3     NOP
1382C  FFE3     NOP
115:           	prod.i += (unsigned long)temp.n;
1382E  0EFB     MOVLW 0xFB
13832  FF8C     NOP
13834  F00B     NOP
13836  0EFC     MOVLW 0xFC
1383A  FF8C     NOP
1383C  F00C     NOP
1383E  50E1     MOVF 0xFE1, W, ACCESS
13840  0FF3     ADDLW 0xF3
13842  6ED9     MOVWF 0xFD9, ACCESS
13844  50E2     MOVF 0xFE2, W, ACCESS
13846  6EDA     MOVWF 0xFDA, ACCESS
13848  0EFF     MOVLW 0xFF
1384A  22DA     ADDWFC 0xFDA, F, ACCESS
1384C  500B     MOVF wtemp5, W, ACCESS
1384E  26DE     ADDWF 0xFDE, F, ACCESS
13850  500C     MOVF 0xC, W, ACCESS
13852  22DE     ADDWFC 0xFDE, F, ACCESS
13854  0E00     MOVLW 0x0
13856  22DE     ADDWFC 0xFDE, F, ACCESS
13858  22DE     ADDWFC 0xFDE, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
1385A  0EF1     MOVLW 0xF1
1385C  24E1     ADDWF 0xFE1, W, ACCESS
1385E  6ED9     MOVWF 0xFD9, ACCESS
13860  0EFF     MOVLW 0xFF
13862  20E2     ADDWFC 0xFE2, W, ACCESS
13864  6EDA     MOVWF 0xFDA, ACCESS
13866  50DF     MOVF 0xFDF, W, ACCESS
13868  6E0C     MOVWF 0xC, ACCESS
1386A  0EED     MOVLW 0xED
1386C  24E1     ADDWF 0xFE1, W, ACCESS
1386E  6ED9     MOVWF 0xFD9, ACCESS
13870  0EFF     MOVLW 0xFF
13872  20E2     ADDWFC 0xFE2, W, ACCESS
13874  6EDA     MOVWF 0xFDA, ACCESS
13876  50DF     MOVF 0xFDF, W, ACCESS
13878  020C     MULWF 0xC, ACCESS
1387A  0EFB     MOVLW 0xFB
1387E  FFCF     NOP
13880  FFE3     NOP
13882  0EFC     MOVLW 0xFC
13886  FFD3     NOP
13888  FFE3     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
1388A  0EFB     MOVLW 0xFB
1388E  FF8C     NOP
13890  F00B     NOP
13892  0EFC     MOVLW 0xFC
13896  FF8C     NOP
13898  F00C     NOP
1389A  500B     MOVF wtemp5, W, ACCESS
1389C  6E05     MOVWF ltemp1, ACCESS
1389E  500C     MOVF 0xC, W, ACCESS
138A0  6E06     MOVWF 0x6, ACCESS
138A2  6A07     CLRF ttemp2, ACCESS
138A4  6A08     CLRF 0x8, ACCESS
138A8  F01C     NOP
138AA  F008     NOP
138AE  F018     NOP
138B0  F007     NOP
138B4  F014     NOP
138B6  F006     NOP
138B8  6A05     CLRF ltemp1, ACCESS
138BA  50E1     MOVF 0xFE1, W, ACCESS
138BC  0FF3     ADDLW 0xF3
138BE  6ED9     MOVWF 0xFD9, ACCESS
138C0  50E2     MOVF 0xFE2, W, ACCESS
138C2  6EDA     MOVWF 0xFDA, ACCESS
138C4  0EFF     MOVLW 0xFF
138C6  22DA     ADDWFC 0xFDA, F, ACCESS
138C8  5005     MOVF ltemp1, W, ACCESS
138CA  26DE     ADDWF 0xFDE, F, ACCESS
138CC  5006     MOVF 0x6, W, ACCESS
138CE  22DE     ADDWFC 0xFDE, F, ACCESS
138D0  5007     MOVF ttemp2, W, ACCESS
138D2  22DE     ADDWFC 0xFDE, F, ACCESS
138D4  5008     MOVF 0x8, W, ACCESS
138D6  22DE     ADDWFC 0xFDE, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
138D8  50E1     MOVF 0xFE1, W, ACCESS
138DA  0FF3     ADDLW 0xF3
138DC  6ED9     MOVWF 0xFD9, ACCESS
138DE  50E2     MOVF 0xFE2, W, ACCESS
138E0  6EDA     MOVWF 0xFDA, ACCESS
138E2  0EFF     MOVLW 0xFF
138E4  22DA     ADDWFC 0xFDA, F, ACCESS
138E6  0EFA     MOVLW 0xFA
138E8  24E1     ADDWF 0xFE1, W, ACCESS
138EA  6EE9     MOVWF 0xFE9, ACCESS
138EC  0EFF     MOVLW 0xFF
138EE  20E2     ADDWFC 0xFE2, W, ACCESS
138F0  6EEA     MOVWF 0xFEA, ACCESS
138F2  50EF     MOVF 0xFEF, W, ACCESS
138F4  26DE     ADDWF 0xFDE, F, ACCESS
138F6  0E00     MOVLW 0x0
138F8  22DE     ADDWFC 0xFDE, F, ACCESS
138FA  22DE     ADDWFC 0xFDE, F, ACCESS
138FC  22DE     ADDWFC 0xFDE, F, ACCESS
146:           	grs <<= 8;
138FE  50E1     MOVF 0xFE1, W, ACCESS
13900  0FF7     ADDLW 0xF7
13902  6ED9     MOVWF 0xFD9, ACCESS
13904  50E2     MOVF 0xFE2, W, ACCESS
13906  6EDA     MOVWF 0xFDA, ACCESS
13908  0EFF     MOVLW 0xFF
1390A  22DA     ADDWFC 0xFDA, F, ACCESS
1390C  0E08     MOVLW 0x8
1390E  90D8     BCF 0xFD8, 0, ACCESS
13910  36DE     RLCF 0xFDE, F, ACCESS
13912  36DE     RLCF 0xFDE, F, ACCESS
13914  36DE     RLCF 0xFDE, F, ACCESS
13916  36DD     RLCF 0xFDD, F, ACCESS
13918  52DD     MOVF 0xFDD, F, ACCESS
1391A  52DD     MOVF 0xFDD, F, ACCESS
1391C  2EE8     DECFSZ 0xFE8, F, ACCESS
1391E  D7F7     BRA 0x390E
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
13920  0E82     MOVLW 0x82
13922  6E0B     MOVWF wtemp5, ACCESS
13924  0EFF     MOVLW 0xFF
13926  6E0C     MOVWF 0xC, ACCESS
13928  0EFD     MOVLW 0xFD
1392A  50E3     MOVF 0xFE3, W, ACCESS
1392C  6E09     MOVWF ltemp2, ACCESS
1392E  6A0A     CLRF ttemp3, ACCESS
13930  0EFE     MOVLW 0xFE
13932  50E3     MOVF 0xFE3, W, ACCESS
13934  2609     ADDWF ltemp2, F, ACCESS
13936  0E00     MOVLW 0x0
13938  220A     ADDWFC ttemp3, F, ACCESS
1393A  500B     MOVF wtemp5, W, ACCESS
1393C  2609     ADDWF ltemp2, F, ACCESS
1393E  500C     MOVF 0xC, W, ACCESS
13940  220A     ADDWFC ttemp3, F, ACCESS
13942  0EFB     MOVLW 0xFB
13946  F027     NOP
13948  FFE3     NOP
1394A  0EFC     MOVLW 0xFC
1394E  F02B     NOP
13950  FFE3     NOP
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
13952  D021     BRA 0x3996
13996  0EF5     MOVLW 0xF5
13998  AEE3     BTFSS 0xFE3, 7, ACCESS
1399A  D7DC     BRA 0x3954
153:           		prod.i <<= 1;
13954  90D8     BCF 0xFD8, 0, ACCESS
13956  0EF3     MOVLW 0xF3
13958  36E3     RLCF 0xFE3, F, ACCESS
1395A  0EF4     MOVLW 0xF4
1395C  36E3     RLCF 0xFE3, F, ACCESS
1395E  0EF5     MOVLW 0xF5
13960  36E3     RLCF 0xFE3, F, ACCESS
13962  0EF6     MOVLW 0xF6
13964  36E3     RLCF 0xFE3, F, ACCESS
154:           		if (grs & 0x80000000) {
13966  0EFA     MOVLW 0xFA
13968  AEE3     BTFSS 0xFE3, 7, ACCESS
1396A  D002     BRA 0x3970
155:           			prod.i |= 0x1;
1396C  0EF3     MOVLW 0xF3
1396E  80E3     BSF 0xFE3, 0, ACCESS
156:           		}
157:           		grs <<= 1;
13970  90D8     BCF 0xFD8, 0, ACCESS
13972  0EF7     MOVLW 0xF7
13974  36E3     RLCF 0xFE3, F, ACCESS
13976  0EF8     MOVLW 0xF8
13978  36E3     RLCF 0xFE3, F, ACCESS
1397A  0EF9     MOVLW 0xF9
1397C  36E3     RLCF 0xFE3, F, ACCESS
1397E  0EFA     MOVLW 0xFA
13980  36E3     RLCF 0xFE3, F, ACCESS
158:           		--temp.i;
13982  50E1     MOVF 0xFE1, W, ACCESS
13984  0FFB     ADDLW 0xFB
13986  6ED9     MOVWF 0xFD9, ACCESS
13988  50E2     MOVF 0xFE2, W, ACCESS
1398A  6EDA     MOVWF 0xFDA, ACCESS
1398C  0EFF     MOVLW 0xFF
1398E  22DA     ADDWFC 0xFDA, F, ACCESS
13990  06DE     DECF 0xFDE, F, ACCESS
13992  0E00     MOVLW 0x0
13994  5ADD     SUBWFB 0xFDD, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
1399C  0EFE     MOVLW 0xFE
1399E  6AE3     CLRF 0xFE3, ACCESS
164:           	if (grs & 0x80000000) {
139A0  0EFA     MOVLW 0xFA
139A2  AEE3     BTFSS 0xFE3, 7, ACCESS
139A4  D020     BRA 0x39E6
165:           		if (grs & 0x7FFFFFFF) {
139A6  50E1     MOVF 0xFE1, W, ACCESS
139A8  0FF7     ADDLW 0xF7
139AA  6ED9     MOVWF 0xFD9, ACCESS
139AC  50E2     MOVF 0xFE2, W, ACCESS
139AE  6EDA     MOVWF 0xFDA, ACCESS
139B0  0EFF     MOVLW 0xFF
139B2  22DA     ADDWFC 0xFDA, F, ACCESS
139B4  0EFF     MOVLW 0xFF
139B6  14DE     ANDWF 0xFDE, W, ACCESS
139B8  6E09     MOVWF ltemp2, ACCESS
139BA  0EFF     MOVLW 0xFF
139BC  14DE     ANDWF 0xFDE, W, ACCESS
139BE  6E0A     MOVWF ttemp3, ACCESS
139C0  0EFF     MOVLW 0xFF
139C2  14DE     ANDWF 0xFDE, W, ACCESS
139C4  6E0B     MOVWF wtemp5, ACCESS
139C6  0E7F     MOVLW 0x7F
139C8  14DE     ANDWF 0xFDE, W, ACCESS
139CA  6E0C     MOVWF 0xC, ACCESS
139CC  5009     MOVF ltemp2, W, ACCESS
139CE  100A     IORWF ttemp3, W, ACCESS
139D0  100B     IORWF wtemp5, W, ACCESS
139D2  100C     IORWF 0xC, W, ACCESS
139D4  B4D8     BTFSC 0xFD8, 2, ACCESS
139D6  D004     BRA 0x39E0
166:           			aexp = 1;
139D8  0EFE     MOVLW 0xFE
139DA  6AE3     CLRF 0xFE3, ACCESS
139DC  2AE3     INCF 0xFE3, F, ACCESS
167:           		}
139DE  D003     BRA 0x39E6
168:           		else {
169:           			if (prod.i & 1) {
139E0  0EF3     MOVLW 0xF3
139E2  B0E3     BTFSC 0xFE3, 0, ACCESS
139E4  D7F9     BRA 0x39D8
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
139E6  0EFE     MOVLW 0xFE
139E8  50E3     MOVF 0xFE3, W, ACCESS
139EA  B4D8     BTFSC 0xFD8, 2, ACCESS
139EC  D036     BRA 0x3A5A
175:           		++prod.i;
139EE  50E1     MOVF 0xFE1, W, ACCESS
139F0  0FF3     ADDLW 0xF3
139F2  6ED9     MOVWF 0xFD9, ACCESS
139F4  50E2     MOVF 0xFE2, W, ACCESS
139F6  6EDA     MOVWF 0xFDA, ACCESS
139F8  0EFF     MOVLW 0xFF
139FA  22DA     ADDWFC 0xFDA, F, ACCESS
139FC  2ADE     INCF 0xFDE, F, ACCESS
139FE  0E00     MOVLW 0x0
13A00  22DE     ADDWFC 0xFDE, F, ACCESS
13A02  22DE     ADDWFC 0xFDE, F, ACCESS
13A04  22DE     ADDWFC 0xFDE, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
13A06  0EF6     MOVLW 0xF6
13A08  A0E3     BTFSS 0xFE3, 0, ACCESS
13A0A  D027     BRA 0x3A5A
177:           			prod.i = prod.i >> 1;
13A0C  0E01     MOVLW 0x1
13A0E  6E0C     MOVWF 0xC, ACCESS
13A10  50E1     MOVF 0xFE1, W, ACCESS
13A12  0FF3     ADDLW 0xF3
13A14  6ED9     MOVWF 0xFD9, ACCESS
13A16  50E2     MOVF 0xFE2, W, ACCESS
13A18  6EDA     MOVWF 0xFDA, ACCESS
13A1A  0EFF     MOVLW 0xFF
13A1C  22DA     ADDWFC 0xFDA, F, ACCESS
13A1E  280C     INCF 0xC, W, ACCESS
13A20  52DE     MOVF 0xFDE, F, ACCESS
13A22  D008     BRA 0x3A34
13A24  52DE     MOVF 0xFDE, F, ACCESS
13A26  90D8     BCF 0xFD8, 0, ACCESS
13A28  BEDC     BTFSC 0xFDC, 7, ACCESS
13A2A  80D8     BSF 0xFD8, 0, ACCESS
13A2C  32DD     RRCF 0xFDD, F, ACCESS
13A2E  32DD     RRCF 0xFDD, F, ACCESS
13A30  32DD     RRCF 0xFDD, F, ACCESS
13A32  32DE     RRCF 0xFDE, F, ACCESS
13A34  2EE8     DECFSZ 0xFE8, F, ACCESS
13A36  D7F6     BRA 0x3A24
178:           			++temp.i;
13A38  0EFB     MOVLW 0xFB
13A3A  50E3     MOVF 0xFE3, W, ACCESS
13A3C  0F01     ADDLW 0x1
13A3E  6E01     MOVWF ltemp0, ACCESS
13A40  0EFB     MOVLW 0xFB
13A44  F007     NOP
13A46  FFE3     NOP
13A48  6A01     CLRF ltemp0, ACCESS
13A4A  0EFC     MOVLW 0xFC
13A4C  50E3     MOVF 0xFE3, W, ACCESS
13A4E  2001     ADDWFC ltemp0, W, ACCESS
13A50  6E01     MOVWF ltemp0, ACCESS
13A52  0EFC     MOVLW 0xFC
13A56  F007     NOP
13A58  FFE3     NOP
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
13A5A  0EFC     MOVLW 0xFC
13A5C  BEE3     BTFSC 0xFE3, 7, ACCESS
13A5E  D020     BRA 0x3AA0
13A60  0EFC     MOVLW 0xFC
13A62  50E3     MOVF 0xFE3, W, ACCESS
13A64  E104     BNZ 0x3A6E
13A66  0EFB     MOVLW 0xFB
13A68  28E3     INCF 0xFE3, W, ACCESS
13A6A  A0D8     BTFSS 0xFD8, 0, ACCESS
13A6C  D019     BRA 0x3AA0
184:           		prod.i = 0x7F800000;
13A6E  0E00     MOVLW 0x0
13A70  6E09     MOVWF ltemp2, ACCESS
13A72  0E00     MOVLW 0x0
13A74  6E0A     MOVWF ttemp3, ACCESS
13A76  0E80     MOVLW 0x80
13A78  6E0B     MOVWF wtemp5, ACCESS
13A7A  0E7F     MOVLW 0x7F
13A7C  6E0C     MOVWF 0xC, ACCESS
13A7E  0EF3     MOVLW 0xF3
13A82  F027     NOP
13A84  FFE3     NOP
13A86  0EF4     MOVLW 0xF4
13A8A  F02B     NOP
13A8C  FFE3     NOP
13A8E  0EF5     MOVLW 0xF5
13A92  F02F     NOP
13A94  FFE3     NOP
13A96  0EF6     MOVLW 0xF6
13A9A  F033     NOP
13A9C  FFE3     NOP
185:           	}
13A9E  D044     BRA 0x3B28
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
13AA0  0EFC     MOVLW 0xFC
13AA2  BEE3     BTFSC 0xFE3, 7, ACCESS
13AA4  D007     BRA 0x3AB4
13AA6  0EFC     MOVLW 0xFC
13AA8  50E3     MOVF 0xFE3, W, ACCESS
13AAA  E10F     BNZ 0x3ACA
13AAC  0EFB     MOVLW 0xFB
13AAE  04E3     DECF 0xFE3, W, ACCESS
13AB0  B0D8     BTFSC 0xFD8, 0, ACCESS
13AB2  D00B     BRA 0x3ACA
188:           		prod.i = 0;
13AB4  0EF3     MOVLW 0xF3
13AB6  6AE3     CLRF 0xFE3, ACCESS
13AB8  0EF4     MOVLW 0xF4
13ABA  6AE3     CLRF 0xFE3, ACCESS
13ABC  0EF5     MOVLW 0xF5
13ABE  6AE3     CLRF 0xFE3, ACCESS
13AC0  0EF6     MOVLW 0xF6
13AC2  6AE3     CLRF 0xFE3, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
13AC4  0EFF     MOVLW 0xFF
13AC6  6AE3     CLRF 0xFE3, ACCESS
191:           	}
13AC8  D02F     BRA 0x3B28
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = temp.i;	// it fits in 8 bits !
13ACA  0EFB     MOVLW 0xFB
13ACE  FF8C     NOP
13AD0  F001     NOP
13AD2  0EFD     MOVLW 0xFD
13AD6  F007     NOP
13AD8  FFE3     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
13ADA  50E1     MOVF 0xFE1, W, ACCESS
13ADC  0FF3     ADDLW 0xF3
13ADE  6ED9     MOVWF 0xFD9, ACCESS
13AE0  50E2     MOVF 0xFE2, W, ACCESS
13AE2  6EDA     MOVWF 0xFDA, ACCESS
13AE4  0EFF     MOVLW 0xFF
13AE6  22DA     ADDWFC 0xFDA, F, ACCESS
13AE8  0EFF     MOVLW 0xFF
13AEA  16DE     ANDWF 0xFDE, F, ACCESS
13AEC  0EFF     MOVLW 0xFF
13AEE  16DE     ANDWF 0xFDE, F, ACCESS
13AF0  0E7F     MOVLW 0x7F
13AF2  16DE     ANDWF 0xFDE, F, ACCESS
13AF4  0E00     MOVLW 0x0
13AF6  16DE     ANDWF 0xFDE, F, ACCESS
196:           		if (bexp & 0x1) {
13AF8  0EFD     MOVLW 0xFD
13AFA  A0E3     BTFSS 0xFE3, 0, ACCESS
13AFC  D008     BRA 0x3B0E
197:           			prod.fAsBytes.c |= 0x80;
13AFE  0EF5     MOVLW 0xF5
13B00  24E1     ADDWF 0xFE1, W, ACCESS
13B02  6ED9     MOVWF 0xFD9, ACCESS
13B04  0EFF     MOVLW 0xFF
13B06  20E2     ADDWFC 0xFE2, W, ACCESS
13B08  6EDA     MOVWF 0xFDA, ACCESS
13B0A  0E00     MOVLW 0x0
13B0C  8EDB     BSF 0xFDB, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
13B0E  0EF6     MOVLW 0xF6
13B10  24E1     ADDWF 0xFE1, W, ACCESS
13B12  6ED9     MOVWF 0xFD9, ACCESS
13B14  0EFF     MOVLW 0xFF
13B16  20E2     ADDWFC 0xFE2, W, ACCESS
13B18  6EDA     MOVWF 0xFDA, ACCESS
13B1A  0EFD     MOVLW 0xFD
13B1E  FF8C     NOP
13B20  F00C     NOP
13B22  90D8     BCF 0xFD8, 0, ACCESS
13B24  300C     RRCF 0xC, W, ACCESS
13B26  6EDF     MOVWF 0xFDF, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
13B28  0EFF     MOVLW 0xFF
13B2C  FF8C     NOP
13B2E  F00C     NOP
13B30  0EF6     MOVLW 0xF6
13B32  24E1     ADDWF 0xFE1, W, ACCESS
13B34  6ED9     MOVWF 0xFD9, ACCESS
13B36  0EFF     MOVLW 0xFF
13B38  20E2     ADDWFC 0xFE2, W, ACCESS
13B3A  6EDA     MOVWF 0xFDA, ACCESS
13B3C  500C     MOVF 0xC, W, ACCESS
13B3E  12DF     IORWF 0xFDF, F, ACCESS
202:           
203:           	return prod.f;
13B40  0EF3     MOVLW 0xF3
13B44  FF8C     NOP
13B46  F001     NOP
13B48  0EF4     MOVLW 0xF4
13B4C  FF8C     NOP
13B4E  F002     NOP
13B50  0EF5     MOVLW 0xF5
13B54  FF8C     NOP
13B56  F003     NOP
13B58  0EF6     MOVLW 0xF6
13B5C  FF8C     NOP
13B5E  F004     NOP
204:           
205:           }
13B60  0EEB     MOVLW 0xEB
13B62  26E1     ADDWF 0xFE1, F, ACCESS
13B64  0EFF     MOVLW 0xFF
13B66  22E2     ADDWFC 0xFE2, F, ACCESS
13B68  0012     RETURN 0
206:           
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/sprcdiv.c  -----------------------------------------
1:             /* SP relaxed compliance floating point divide intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Divide */
6:             #ifdef __PICC__
7:             SP
8:             SPDIV(SP a, SP b)
9:             #else
10:            SP
11:            SPDIV(SP b, SP a)
14AA2  0E0D     MOVLW 0xD
14AA4  26E1     ADDWF 0xFE1, F, ACCESS
14AA6  0E00     MOVLW 0x0
14AA8  22E2     ADDWFC 0xFE2, F, ACCESS
12:            #endif
13:            {
14:            #define A_FRACTION    (*(SFP *)&a)
15:            #define B_FRACTION    (*(SFP *)&b)
16:            	unsigned char sign;	/* sign of result */
17:            
18:            	unsigned char bexp;	/* Dst exponent */
19:            	unsigned char aexp;	/* Src exponent */
20:            	int16_t new_exp;
21:            	uint32_t grs;		/* Guard, round, sticky */
22:            	uint32_t rem;
23:            
24:            	/* Unpack and check operands */
25:            	// put b's sign as the result sign ...
26:            	sign = B_FRACTION.fAsBytes.d & 0x80;
14AAA  0EF2     MOVLW 0xF2
14AAC  24E1     ADDWF 0xFE1, W, ACCESS
14AAE  6ED9     MOVWF 0xFD9, ACCESS
14AB0  0EFF     MOVLW 0xFF
14AB2  20E2     ADDWFC 0xFE2, W, ACCESS
14AB4  6EDA     MOVWF 0xFDA, ACCESS
14AB6  50DF     MOVF 0xFDF, W, ACCESS
14AB8  6E0C     MOVWF 0xC, ACCESS
14ABA  0E80     MOVLW 0x80
14ABC  160C     ANDWF 0xC, F, ACCESS
14ABE  0EFF     MOVLW 0xFF
14AC2  F033     NOP
14AC4  FFE3     NOP
27:            	bexp = B_FRACTION.fAsBytes.d << 1;
14AC6  0EF2     MOVLW 0xF2
14AC8  24E1     ADDWF 0xFE1, W, ACCESS
14ACA  6ED9     MOVWF 0xFD9, ACCESS
14ACC  0EFF     MOVLW 0xFF
14ACE  20E2     ADDWFC 0xFE2, W, ACCESS
14AD0  6EDA     MOVWF 0xFDA, ACCESS
14AD2  50DF     MOVF 0xFDF, W, ACCESS
14AD4  6E0C     MOVWF 0xC, ACCESS
14AD6  90D8     BCF 0xFD8, 0, ACCESS
14AD8  340C     RLCF 0xC, W, ACCESS
14ADA  6E0B     MOVWF wtemp5, ACCESS
14ADC  0EFE     MOVLW 0xFE
14AE0  F02F     NOP
14AE2  FFE3     NOP
28:            	if (B_FRACTION.fAsBytes.c & 0x80) {
14AE4  0EF1     MOVLW 0xF1
14AE6  24E1     ADDWF 0xFE1, W, ACCESS
14AE8  6ED9     MOVWF 0xFD9, ACCESS
14AEA  0EFF     MOVLW 0xFF
14AEC  20E2     ADDWFC 0xFE2, W, ACCESS
14AEE  6EDA     MOVWF 0xFDA, ACCESS
14AF0  AEDF     BTFSS 0xFDF, 7, ACCESS
14AF2  D002     BRA 0x4AF8
29:            		bexp |= 0x1;
14AF4  0EFE     MOVLW 0xFE
14AF6  80E3     BSF 0xFE3, 0, ACCESS
30:            	}
31:            
32:            	/* Destination normal ? */
33:            	if (bexp) {
14AF8  0EFE     MOVLW 0xFE
14AFA  50E3     MOVF 0xFE3, W, ACCESS
14AFC  B4D8     BTFSC 0xFD8, 2, ACCESS
14AFE  D027     BRA 0x4B4E
34:            		/* Destination inf or NaN ? */
35:            		if (bexp == 0xFF) {
14B00  0EFE     MOVLW 0xFE
14B02  28E3     INCF 0xFE3, W, ACCESS
14B04  A4D8     BTFSS 0xFD8, 2, ACCESS
14B06  D018     BRA 0x4B38
36:            			/* Make it inf */
37:            			b = 0;
14B08  0E00     MOVLW 0x0
14B0A  6E09     MOVWF ltemp2, ACCESS
14B0C  0E00     MOVLW 0x0
14B0E  6E0A     MOVWF ttemp3, ACCESS
14B10  0E00     MOVLW 0x0
14B12  6E0B     MOVWF wtemp5, ACCESS
14B14  0E00     MOVLW 0x0
14B16  6E0C     MOVWF 0xC, ACCESS
14B18  0EEF     MOVLW 0xEF
14B1C  F027     NOP
14B1E  FFE3     NOP
14B20  0EF0     MOVLW 0xF0
14B24  F02B     NOP
14B26  FFE3     NOP
14B28  0EF1     MOVLW 0xF1
14B2C  F02F     NOP
14B2E  FFE3     NOP
14B30  0EF2     MOVLW 0xF2
14B34  F033     NOP
14B36  FFE3     NOP
38:            		}
39:            		// OR in the hidden 1-bit to b's fraction
40:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
14B38  0EF1     MOVLW 0xF1
14B3A  8EE3     BSF 0xFE3, 7, ACCESS
41:            		// and zero out the upper byte so we can safely shift
42:            		B_FRACTION.fAsBytes.d = 0;
14B3C  0EF2     MOVLW 0xF2
14B3E  24E1     ADDWF 0xFE1, W, ACCESS
14B40  6ED9     MOVWF 0xFD9, ACCESS
14B42  0EFF     MOVLW 0xFF
14B44  20E2     ADDWFC 0xFE2, W, ACCESS
14B46  6EDA     MOVWF 0xFDA, ACCESS
14B48  0E00     MOVLW 0x0
14B4A  6EDF     MOVWF 0xFDF, ACCESS
43:            	}
14B4C  D018     BRA 0x4B7E
44:            	else {
45:            		/* Make it zero */
46:            		b = 0;
14B4E  0E00     MOVLW 0x0
14B50  6E09     MOVWF ltemp2, ACCESS
14B52  0E00     MOVLW 0x0
14B54  6E0A     MOVWF ttemp3, ACCESS
14B56  0E00     MOVLW 0x0
14B58  6E0B     MOVWF wtemp5, ACCESS
14B5A  0E00     MOVLW 0x0
14B5C  6E0C     MOVWF 0xC, ACCESS
14B5E  0EEF     MOVLW 0xEF
14B62  F027     NOP
14B64  FFE3     NOP
14B66  0EF0     MOVLW 0xF0
14B6A  F02B     NOP
14B6C  FFE3     NOP
14B6E  0EF1     MOVLW 0xF1
14B72  F02F     NOP
14B74  FFE3     NOP
14B76  0EF2     MOVLW 0xF2
14B7A  F033     NOP
14B7C  FFE3     NOP
47:            	}
48:            	// xor a's sign into the result sign
49:            	sign ^= A_FRACTION.fAsBytes.d & 0x80;
14B7E  0EEE     MOVLW 0xEE
14B80  24E1     ADDWF 0xFE1, W, ACCESS
14B82  6ED9     MOVWF 0xFD9, ACCESS
14B84  0EFF     MOVLW 0xFF
14B86  20E2     ADDWFC 0xFE2, W, ACCESS
14B88  6EDA     MOVWF 0xFDA, ACCESS
14B8A  50DF     MOVF 0xFDF, W, ACCESS
14B8C  6E0C     MOVWF 0xC, ACCESS
14B8E  0E80     MOVLW 0x80
14B90  160C     ANDWF 0xC, F, ACCESS
14B92  50E1     MOVF 0xFE1, W, ACCESS
14B94  0FFF     ADDLW 0xFF
14B96  6ED9     MOVWF 0xFD9, ACCESS
14B98  50E2     MOVF 0xFE2, W, ACCESS
14B9A  6EDA     MOVWF 0xFDA, ACCESS
14B9C  0EFF     MOVLW 0xFF
14B9E  22DA     ADDWFC 0xFDA, F, ACCESS
14BA0  500C     MOVF 0xC, W, ACCESS
14BA2  1ADF     XORWF 0xFDF, F, ACCESS
50:            	aexp = A_FRACTION.fAsBytes.d << 1;
14BA4  0EEE     MOVLW 0xEE
14BA6  24E1     ADDWF 0xFE1, W, ACCESS
14BA8  6ED9     MOVWF 0xFD9, ACCESS
14BAA  0EFF     MOVLW 0xFF
14BAC  20E2     ADDWFC 0xFE2, W, ACCESS
14BAE  6EDA     MOVWF 0xFDA, ACCESS
14BB0  50DF     MOVF 0xFDF, W, ACCESS
14BB2  6E0C     MOVWF 0xC, ACCESS
14BB4  90D8     BCF 0xFD8, 0, ACCESS
14BB6  340C     RLCF 0xC, W, ACCESS
14BB8  6E0B     MOVWF wtemp5, ACCESS
14BBA  0EFD     MOVLW 0xFD
14BBE  F02F     NOP
14BC0  FFE3     NOP
51:            	if (A_FRACTION.fAsBytes.c & 0x80) {
14BC2  0EED     MOVLW 0xED
14BC4  24E1     ADDWF 0xFE1, W, ACCESS
14BC6  6ED9     MOVWF 0xFD9, ACCESS
14BC8  0EFF     MOVLW 0xFF
14BCA  20E2     ADDWFC 0xFE2, W, ACCESS
14BCC  6EDA     MOVWF 0xFDA, ACCESS
14BCE  AEDF     BTFSS 0xFDF, 7, ACCESS
14BD0  D002     BRA 0x4BD6
52:            		aexp |= 0x1;
14BD2  0EFD     MOVLW 0xFD
14BD4  80E3     BSF 0xFE3, 0, ACCESS
53:            	}
54:            
55:            	/* Destination normal ? */
56:            	if (aexp) {
14BD6  0EFD     MOVLW 0xFD
14BD8  50E3     MOVF 0xFE3, W, ACCESS
14BDA  B4D8     BTFSC 0xFD8, 2, ACCESS
14BDC  D027     BRA 0x4C2C
57:            		/* Destination inf or NaN ? */
58:            		if (aexp == 0xFF) {
14BDE  0EFD     MOVLW 0xFD
14BE0  28E3     INCF 0xFE3, W, ACCESS
14BE2  A4D8     BTFSS 0xFD8, 2, ACCESS
14BE4  D018     BRA 0x4C16
59:            			/* Make it inf */
60:            			a = 0;
14BE6  0E00     MOVLW 0x0
14BE8  6E09     MOVWF ltemp2, ACCESS
14BEA  0E00     MOVLW 0x0
14BEC  6E0A     MOVWF ttemp3, ACCESS
14BEE  0E00     MOVLW 0x0
14BF0  6E0B     MOVWF wtemp5, ACCESS
14BF2  0E00     MOVLW 0x0
14BF4  6E0C     MOVWF 0xC, ACCESS
14BF6  0EEB     MOVLW 0xEB
14BFA  F027     NOP
14BFC  FFE3     NOP
14BFE  0EEC     MOVLW 0xEC
14C02  F02B     NOP
14C04  FFE3     NOP
14C06  0EED     MOVLW 0xED
14C0A  F02F     NOP
14C0C  FFE3     NOP
14C0E  0EEE     MOVLW 0xEE
14C12  F033     NOP
14C14  FFE3     NOP
61:            		}
62:            		// OR in the hidden 1-bit to a's fraction
63:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
14C16  0EED     MOVLW 0xED
14C18  8EE3     BSF 0xFE3, 7, ACCESS
64:            		// and zero out the upper bits so we can safely shift
65:            		A_FRACTION.fAsBytes.d = 0;
14C1A  0EEE     MOVLW 0xEE
14C1C  24E1     ADDWF 0xFE1, W, ACCESS
14C1E  6ED9     MOVWF 0xFD9, ACCESS
14C20  0EFF     MOVLW 0xFF
14C22  20E2     ADDWFC 0xFE2, W, ACCESS
14C24  6EDA     MOVWF 0xFDA, ACCESS
14C26  0E00     MOVLW 0x0
14C28  6EDF     MOVWF 0xFDF, ACCESS
66:            	}
14C2A  D018     BRA 0x4C5C
67:            	else {
68:            		/* Make it zero */
69:            		a = 0;
14C2C  0E00     MOVLW 0x0
14C2E  6E09     MOVWF ltemp2, ACCESS
14C30  0E00     MOVLW 0x0
14C32  6E0A     MOVWF ttemp3, ACCESS
14C34  0E00     MOVLW 0x0
14C36  6E0B     MOVWF wtemp5, ACCESS
14C38  0E00     MOVLW 0x0
14C3A  6E0C     MOVWF 0xC, ACCESS
14C3C  0EEB     MOVLW 0xEB
14C40  F027     NOP
14C42  FFE3     NOP
14C44  0EEC     MOVLW 0xEC
14C48  F02B     NOP
14C4A  FFE3     NOP
14C4C  0EED     MOVLW 0xED
14C50  F02F     NOP
14C52  FFE3     NOP
14C54  0EEE     MOVLW 0xEE
14C58  F033     NOP
14C5A  FFE3     NOP
70:            	}
71:            
72:            	/* Special operand check */
73:            
74:            	/* Denominator zero ? Result infinity */
75:            	if (A_FRACTION.i == 0) {
14C5C  0EEB     MOVLW 0xEB
14C5E  50E3     MOVF 0xFE3, W, ACCESS
14C60  E139     BNZ 0x4CD4
14C62  0EEC     MOVLW 0xEC
14C64  50E3     MOVF 0xFE3, W, ACCESS
14C66  E136     BNZ 0x4CD4
14C68  0EED     MOVLW 0xED
14C6A  50E3     MOVF 0xFE3, W, ACCESS
14C6C  E133     BNZ 0x4CD4
14C6E  0EEE     MOVLW 0xEE
14C70  50E3     MOVF 0xFE3, W, ACCESS
14C72  A4D8     BTFSS 0xFD8, 2, ACCESS
14C74  D02F     BRA 0x4CD4
76:            		B_FRACTION.i = 0;
14C76  0EEF     MOVLW 0xEF
14C78  6AE3     CLRF 0xFE3, ACCESS
14C7A  0EF0     MOVLW 0xF0
14C7C  6AE3     CLRF 0xFE3, ACCESS
14C7E  0EF1     MOVLW 0xF1
14C80  6AE3     CLRF 0xFE3, ACCESS
14C82  0EF2     MOVLW 0xF2
14C84  6AE3     CLRF 0xFE3, ACCESS
77:            		B_FRACTION.fAsWords.wordB |= (SPEXPM << 7);
14C86  0EF1     MOVLW 0xF1
14C88  24E1     ADDWF 0xFE1, W, ACCESS
14C8A  6ED9     MOVWF 0xFD9, ACCESS
14C8C  0EFF     MOVLW 0xFF
14C8E  20E2     ADDWFC 0xFE2, W, ACCESS
14C90  6EDA     MOVWF 0xFDA, ACCESS
14C92  0E80     MOVLW 0x80
14C94  12DE     IORWF 0xFDE, F, ACCESS
14C96  0E7F     MOVLW 0x7F
14C98  12DD     IORWF 0xFDD, F, ACCESS
78:            		B_FRACTION.fAsBytes.d |= sign;
14C9A  0EFF     MOVLW 0xFF
14C9E  FF8C     NOP
14CA0  F00C     NOP
14CA2  0EF2     MOVLW 0xF2
14CA4  24E1     ADDWF 0xFE1, W, ACCESS
14CA6  6ED9     MOVWF 0xFD9, ACCESS
14CA8  0EFF     MOVLW 0xFF
14CAA  20E2     ADDWFC 0xFE2, W, ACCESS
14CAC  6EDA     MOVWF 0xFDA, ACCESS
14CAE  500C     MOVF 0xC, W, ACCESS
14CB0  12DF     IORWF 0xFDF, F, ACCESS
79:            		return b;
14CB2  0EEF     MOVLW 0xEF
14CB6  FF8C     NOP
14CB8  F001     NOP
14CBA  0EF0     MOVLW 0xF0
14CBE  FF8C     NOP
14CC0  F002     NOP
14CC2  0EF1     MOVLW 0xF1
14CC6  FF8C     NOP
14CC8  F003     NOP
14CCA  0EF2     MOVLW 0xF2
14CCE  FF8C     NOP
14CD0  F004     NOP
14CD2  D19F     BRA 0x5012
80:            	}
81:            
82:            	/* Numerator zero ? Result zero */
83:            	if (!bexp) {
14CD4  0EFE     MOVLW 0xFE
14CD6  50E3     MOVF 0xFE3, W, ACCESS
14CD8  A4D8     BTFSS 0xFD8, 2, ACCESS
14CDA  D009     BRA 0x4CEE
84:            		B_FRACTION.i = 0;
85:            		return b;
14CDC  0E00     MOVLW 0x0
14CDE  6E01     MOVWF ltemp0, ACCESS
14CE0  0E00     MOVLW 0x0
14CE2  6E02     MOVWF ttemp5, ACCESS
14CE4  0E00     MOVLW 0x0
14CE6  6E03     MOVWF wtemp1, ACCESS
14CE8  0E00     MOVLW 0x0
14CEA  6E04     MOVWF ttemp1, ACCESS
14CEC  D192     BRA 0x5012
86:            	}
87:            
88:            	/* Subtract denominator exponent, minus bias */
89:            	new_exp = bexp - aexp + 127;
14CEE  0EFE     MOVLW 0xFE
14CF0  50E3     MOVF 0xFE3, W, ACCESS
14CF2  6E0B     MOVWF wtemp5, ACCESS
14CF4  6A0C     CLRF 0xC, ACCESS
14CF6  0EFD     MOVLW 0xFD
14CF8  50E3     MOVF 0xFE3, W, ACCESS
14CFA  5E0B     SUBWF wtemp5, F, ACCESS
14CFC  0E00     MOVLW 0x0
14CFE  5A0C     SUBWFB 0xC, F, ACCESS
14D00  0E7F     MOVLW 0x7F
14D02  260B     ADDWF wtemp5, F, ACCESS
14D04  0E00     MOVLW 0x0
14D06  220C     ADDWFC 0xC, F, ACCESS
14D08  0EFB     MOVLW 0xFB
14D0C  F02F     NOP
14D0E  FFE3     NOP
14D10  0EFC     MOVLW 0xFC
14D14  F033     NOP
14D16  FFE3     NOP
90:            
91:            	/* Divide loop */
92:            	rem = B_FRACTION.i;
14D18  0EEF     MOVLW 0xEF
14D1C  FF8C     NOP
14D1E  F009     NOP
14D20  0EF0     MOVLW 0xF0
14D24  FF8C     NOP
14D26  F00A     NOP
14D28  0EF1     MOVLW 0xF1
14D2C  FF8C     NOP
14D2E  F00B     NOP
14D30  0EF2     MOVLW 0xF2
14D34  FF8C     NOP
14D36  F00C     NOP
14D38  0EF7     MOVLW 0xF7
14D3C  F027     NOP
14D3E  FFE3     NOP
14D40  0EF8     MOVLW 0xF8
14D44  F02B     NOP
14D46  FFE3     NOP
14D48  0EF9     MOVLW 0xF9
14D4C  F02F     NOP
14D4E  FFE3     NOP
14D50  0EFA     MOVLW 0xFA
14D54  F033     NOP
14D56  FFE3     NOP
93:            	B_FRACTION.i = 0;
14D58  0EEF     MOVLW 0xEF
14D5A  6AE3     CLRF 0xFE3, ACCESS
14D5C  0EF0     MOVLW 0xF0
14D5E  6AE3     CLRF 0xFE3, ACCESS
14D60  0EF1     MOVLW 0xF1
14D62  6AE3     CLRF 0xFE3, ACCESS
14D64  0EF2     MOVLW 0xF2
14D66  6AE3     CLRF 0xFE3, ACCESS
94:            	grs = 0;
14D68  0EF3     MOVLW 0xF3
14D6A  6AE3     CLRF 0xFE3, ACCESS
14D6C  0EF4     MOVLW 0xF4
14D6E  6AE3     CLRF 0xFE3, ACCESS
14D70  0EF5     MOVLW 0xF5
14D72  6AE3     CLRF 0xFE3, ACCESS
14D74  0EF6     MOVLW 0xF6
14D76  6AE3     CLRF 0xFE3, ACCESS
95:            	// reuse aexp as the loop counter ...
96:            	aexp = 0;
14D78  0EFD     MOVLW 0xFD
14D7A  6AE3     CLRF 0xFE3, ACCESS
97:            	while (aexp < 26) {
14D7C  D050     BRA 0x4E1E
14E1E  0EFD     MOVLW 0xFD
14E22  FF8C     NOP
14E24  F001     NOP
14E26  0E19     MOVLW 0x19
14E28  6401     CPFSGT ltemp0, ACCESS
14E2A  D7A9     BRA 0x4D7E
98:            
99:            		/* Shift remainder, quotient left */
100:           		if (aexp) {
14D7E  0EFD     MOVLW 0xFD
14D80  50E3     MOVF 0xFE3, W, ACCESS
14D82  B4D8     BTFSC 0xFD8, 2, ACCESS
14D84  D020     BRA 0x4DC6
101:           			rem <<= 1;
14D86  90D8     BCF 0xFD8, 0, ACCESS
14D88  0EF7     MOVLW 0xF7
14D8A  36E3     RLCF 0xFE3, F, ACCESS
14D8C  0EF8     MOVLW 0xF8
14D8E  36E3     RLCF 0xFE3, F, ACCESS
14D90  0EF9     MOVLW 0xF9
14D92  36E3     RLCF 0xFE3, F, ACCESS
14D94  0EFA     MOVLW 0xFA
14D96  36E3     RLCF 0xFE3, F, ACCESS
102:           			B_FRACTION.i <<= 1;
14D98  90D8     BCF 0xFD8, 0, ACCESS
14D9A  0EEF     MOVLW 0xEF
14D9C  36E3     RLCF 0xFE3, F, ACCESS
14D9E  0EF0     MOVLW 0xF0
14DA0  36E3     RLCF 0xFE3, F, ACCESS
14DA2  0EF1     MOVLW 0xF1
14DA4  36E3     RLCF 0xFE3, F, ACCESS
14DA6  0EF2     MOVLW 0xF2
14DA8  36E3     RLCF 0xFE3, F, ACCESS
103:           			if (grs & 0x80000000) {
14DAA  0EF6     MOVLW 0xF6
14DAC  AEE3     BTFSS 0xFE3, 7, ACCESS
14DAE  D002     BRA 0x4DB4
104:           				B_FRACTION.i |= 0x1;
14DB0  0EEF     MOVLW 0xEF
14DB2  80E3     BSF 0xFE3, 0, ACCESS
105:           			}
106:           			grs <<= 1;
14DB4  90D8     BCF 0xFD8, 0, ACCESS
14DB6  0EF3     MOVLW 0xF3
14DB8  36E3     RLCF 0xFE3, F, ACCESS
14DBA  0EF4     MOVLW 0xF4
14DBC  36E3     RLCF 0xFE3, F, ACCESS
14DBE  0EF5     MOVLW 0xF5
14DC0  36E3     RLCF 0xFE3, F, ACCESS
14DC2  0EF6     MOVLW 0xF6
14DC4  36E3     RLCF 0xFE3, F, ACCESS
107:           		}
108:           
109:           		/* Restoring divide */
110:           
111:           		/* Remainder not less than divisor ? */
112:           		if (!(rem < A_FRACTION.i)) {
14DC6  50E1     MOVF 0xFE1, W, ACCESS
14DC8  0FF7     ADDLW 0xF7
14DCA  6ED9     MOVWF 0xFD9, ACCESS
14DCC  50E2     MOVF 0xFE2, W, ACCESS
14DCE  6EDA     MOVWF 0xFDA, ACCESS
14DD0  0EFF     MOVLW 0xFF
14DD2  22DA     ADDWFC 0xFDA, F, ACCESS
14DD4  0EEB     MOVLW 0xEB
14DD6  50E3     MOVF 0xFE3, W, ACCESS
14DD8  5CDE     SUBWF 0xFDE, W, ACCESS
14DDA  0EEC     MOVLW 0xEC
14DDC  50E3     MOVF 0xFE3, W, ACCESS
14DDE  58DE     SUBWFB 0xFDE, W, ACCESS
14DE0  0EED     MOVLW 0xED
14DE2  50E3     MOVF 0xFE3, W, ACCESS
14DE4  58DE     SUBWFB 0xFDE, W, ACCESS
14DE6  0EEE     MOVLW 0xEE
14DE8  50E3     MOVF 0xFE3, W, ACCESS
14DEA  58DE     SUBWFB 0xFDE, W, ACCESS
14DEC  A0D8     BTFSS 0xFD8, 0, ACCESS
14DEE  D015     BRA 0x4E1A
113:           
114:           			/* Set quotient bit, subtract divisor */
115:           			grs |= 0x40000000;
14DF0  0EF6     MOVLW 0xF6
14DF2  8CE3     BSF 0xFE3, 6, ACCESS
116:           			rem -= A_FRACTION.i;
14DF4  50E1     MOVF 0xFE1, W, ACCESS
14DF6  0FF7     ADDLW 0xF7
14DF8  6ED9     MOVWF 0xFD9, ACCESS
14DFA  50E2     MOVF 0xFE2, W, ACCESS
14DFC  6EDA     MOVWF 0xFDA, ACCESS
14DFE  0EFF     MOVLW 0xFF
14E00  22DA     ADDWFC 0xFDA, F, ACCESS
14E02  0EEB     MOVLW 0xEB
14E04  50E3     MOVF 0xFE3, W, ACCESS
14E06  5EDE     SUBWF 0xFDE, F, ACCESS
14E08  0EEC     MOVLW 0xEC
14E0A  50E3     MOVF 0xFE3, W, ACCESS
14E0C  5ADE     SUBWFB 0xFDE, F, ACCESS
14E0E  0EED     MOVLW 0xED
14E10  50E3     MOVF 0xFE3, W, ACCESS
14E12  5ADE     SUBWFB 0xFDE, F, ACCESS
14E14  0EEE     MOVLW 0xEE
14E16  50E3     MOVF 0xFE3, W, ACCESS
14E18  5ADE     SUBWFB 0xFDE, F, ACCESS
117:           		}
118:           		++aexp;
14E1A  0EFD     MOVLW 0xFD
14E1C  2AE3     INCF 0xFE3, F, ACCESS
119:           	}
120:           
121:           	/* Sticky bit is nonzero remainder */
122:           	if (rem) {
14E2C  0EF7     MOVLW 0xF7
14E2E  50E3     MOVF 0xFE3, W, ACCESS
14E30  E10A     BNZ 0x4E46
14E32  0EF8     MOVLW 0xF8
14E34  50E3     MOVF 0xFE3, W, ACCESS
14E36  E107     BNZ 0x4E46
14E38  0EF9     MOVLW 0xF9
14E3A  50E3     MOVF 0xFE3, W, ACCESS
14E3C  E104     BNZ 0x4E46
14E3E  0EFA     MOVLW 0xFA
14E40  50E3     MOVF 0xFE3, W, ACCESS
14E42  B4D8     BTFSC 0xFD8, 2, ACCESS
14E44  D024     BRA 0x4E8E
123:           		grs |= 1;
14E46  0EF3     MOVLW 0xF3
14E48  80E3     BSF 0xFE3, 0, ACCESS
14E4A  D021     BRA 0x4E8E
124:           	}
125:           
126:           	/* Renormalize */
127:           	while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
14E8E  0EF1     MOVLW 0xF1
14E90  AEE3     BTFSS 0xFE3, 7, ACCESS
14E92  D7DC     BRA 0x4E4C
128:           		B_FRACTION.i <<= 1;
14E4C  90D8     BCF 0xFD8, 0, ACCESS
14E4E  0EEF     MOVLW 0xEF
14E50  36E3     RLCF 0xFE3, F, ACCESS
14E52  0EF0     MOVLW 0xF0
14E54  36E3     RLCF 0xFE3, F, ACCESS
14E56  0EF1     MOVLW 0xF1
14E58  36E3     RLCF 0xFE3, F, ACCESS
14E5A  0EF2     MOVLW 0xF2
14E5C  36E3     RLCF 0xFE3, F, ACCESS
129:           		if (grs & 0x80000000) {
14E5E  0EF6     MOVLW 0xF6
14E60  AEE3     BTFSS 0xFE3, 7, ACCESS
14E62  D002     BRA 0x4E68
130:           			B_FRACTION.i |= 0x1;
14E64  0EEF     MOVLW 0xEF
14E66  80E3     BSF 0xFE3, 0, ACCESS
131:           		}
132:           		grs <<= 1;
14E68  90D8     BCF 0xFD8, 0, ACCESS
14E6A  0EF3     MOVLW 0xF3
14E6C  36E3     RLCF 0xFE3, F, ACCESS
14E6E  0EF4     MOVLW 0xF4
14E70  36E3     RLCF 0xFE3, F, ACCESS
14E72  0EF5     MOVLW 0xF5
14E74  36E3     RLCF 0xFE3, F, ACCESS
14E76  0EF6     MOVLW 0xF6
14E78  36E3     RLCF 0xFE3, F, ACCESS
133:           		--new_exp;
14E7A  50E1     MOVF 0xFE1, W, ACCESS
14E7C  0FFB     ADDLW 0xFB
14E7E  6ED9     MOVWF 0xFD9, ACCESS
14E80  50E2     MOVF 0xFE2, W, ACCESS
14E82  6EDA     MOVWF 0xFDA, ACCESS
14E84  0EFF     MOVLW 0xFF
14E86  22DA     ADDWFC 0xFDA, F, ACCESS
14E88  06DE     DECF 0xFDE, F, ACCESS
14E8A  0E00     MOVLW 0x0
14E8C  5ADD     SUBWFB 0xFDD, F, ACCESS
134:           	}
135:           
136:           	/* Round result and check overflow, underflow */
137:           	/* Round */
138:           	// reuse aexp again as the round-up flag ...
139:           	aexp = 0;
14E94  0EFD     MOVLW 0xFD
14E96  6AE3     CLRF 0xFE3, ACCESS
140:           	if (grs & ((uint32_t) 1 << 31)) {
14E98  0EF6     MOVLW 0xF6
14E9A  AEE3     BTFSS 0xFE3, 7, ACCESS
14E9C  D020     BRA 0x4EDE
141:           		if (grs & (((uint32_t) 1 << 31) - 1)) {
14E9E  50E1     MOVF 0xFE1, W, ACCESS
14EA0  0FF3     ADDLW 0xF3
14EA2  6ED9     MOVWF 0xFD9, ACCESS
14EA4  50E2     MOVF 0xFE2, W, ACCESS
14EA6  6EDA     MOVWF 0xFDA, ACCESS
14EA8  0EFF     MOVLW 0xFF
14EAA  22DA     ADDWFC 0xFDA, F, ACCESS
14EAC  0EFF     MOVLW 0xFF
14EAE  14DE     ANDWF 0xFDE, W, ACCESS
14EB0  6E09     MOVWF ltemp2, ACCESS
14EB2  0EFF     MOVLW 0xFF
14EB4  14DE     ANDWF 0xFDE, W, ACCESS
14EB6  6E0A     MOVWF ttemp3, ACCESS
14EB8  0EFF     MOVLW 0xFF
14EBA  14DE     ANDWF 0xFDE, W, ACCESS
14EBC  6E0B     MOVWF wtemp5, ACCESS
14EBE  0E7F     MOVLW 0x7F
14EC0  14DE     ANDWF 0xFDE, W, ACCESS
14EC2  6E0C     MOVWF 0xC, ACCESS
14EC4  5009     MOVF ltemp2, W, ACCESS
14EC6  100A     IORWF ttemp3, W, ACCESS
14EC8  100B     IORWF wtemp5, W, ACCESS
14ECA  100C     IORWF 0xC, W, ACCESS
14ECC  B4D8     BTFSC 0xFD8, 2, ACCESS
14ECE  D004     BRA 0x4ED8
142:           			aexp = 1;
14ED0  0EFD     MOVLW 0xFD
14ED2  6AE3     CLRF 0xFE3, ACCESS
14ED4  2AE3     INCF 0xFE3, F, ACCESS
143:           		}
14ED6  D003     BRA 0x4EDE
144:           		else {
145:           			if (B_FRACTION.i & 1) {
14ED8  0EEF     MOVLW 0xEF
14EDA  B0E3     BTFSC 0xFE3, 0, ACCESS
14EDC  D7F9     BRA 0x4ED0
146:           				aexp = 1;
147:           			}
148:           		}
149:           	}
150:           	if (aexp) {
14EDE  0EFD     MOVLW 0xFD
14EE0  50E3     MOVF 0xFE3, W, ACCESS
14EE2  B4D8     BTFSC 0xFD8, 2, ACCESS
14EE4  D036     BRA 0x4F52
151:           		++B_FRACTION.i;
14EE6  50E1     MOVF 0xFE1, W, ACCESS
14EE8  0FEF     ADDLW 0xEF
14EEA  6ED9     MOVWF 0xFD9, ACCESS
14EEC  50E2     MOVF 0xFE2, W, ACCESS
14EEE  6EDA     MOVWF 0xFDA, ACCESS
14EF0  0EFF     MOVLW 0xFF
14EF2  22DA     ADDWFC 0xFDA, F, ACCESS
14EF4  2ADE     INCF 0xFDE, F, ACCESS
14EF6  0E00     MOVLW 0x0
14EF8  22DE     ADDWFC 0xFDE, F, ACCESS
14EFA  22DE     ADDWFC 0xFDE, F, ACCESS
14EFC  22DE     ADDWFC 0xFDE, F, ACCESS
152:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
14EFE  0EF2     MOVLW 0xF2
14F00  A0E3     BTFSS 0xFE3, 0, ACCESS
14F02  D027     BRA 0x4F52
153:           			B_FRACTION.i = B_FRACTION.i >> 1;
14F04  0E01     MOVLW 0x1
14F06  6E0C     MOVWF 0xC, ACCESS
14F08  50E1     MOVF 0xFE1, W, ACCESS
14F0A  0FEF     ADDLW 0xEF
14F0C  6ED9     MOVWF 0xFD9, ACCESS
14F0E  50E2     MOVF 0xFE2, W, ACCESS
14F10  6EDA     MOVWF 0xFDA, ACCESS
14F12  0EFF     MOVLW 0xFF
14F14  22DA     ADDWFC 0xFDA, F, ACCESS
14F16  280C     INCF 0xC, W, ACCESS
14F18  52DE     MOVF 0xFDE, F, ACCESS
14F1A  D008     BRA 0x4F2C
14F1C  52DE     MOVF 0xFDE, F, ACCESS
14F1E  90D8     BCF 0xFD8, 0, ACCESS
14F20  BEDC     BTFSC 0xFDC, 7, ACCESS
14F22  80D8     BSF 0xFD8, 0, ACCESS
14F24  32DD     RRCF 0xFDD, F, ACCESS
14F26  32DD     RRCF 0xFDD, F, ACCESS
14F28  32DD     RRCF 0xFDD, F, ACCESS
14F2A  32DE     RRCF 0xFDE, F, ACCESS
14F2C  2EE8     DECFSZ 0xFE8, F, ACCESS
14F2E  D7F6     BRA 0x4F1C
154:           			++new_exp;
14F30  0EFB     MOVLW 0xFB
14F32  50E3     MOVF 0xFE3, W, ACCESS
14F34  0F01     ADDLW 0x1
14F36  6E01     MOVWF ltemp0, ACCESS
14F38  0EFB     MOVLW 0xFB
14F3C  F007     NOP
14F3E  FFE3     NOP
14F40  6A01     CLRF ltemp0, ACCESS
14F42  0EFC     MOVLW 0xFC
14F44  50E3     MOVF 0xFE3, W, ACCESS
14F46  2001     ADDWFC ltemp0, W, ACCESS
14F48  6E01     MOVWF ltemp0, ACCESS
14F4A  0EFC     MOVLW 0xFC
14F4E  F007     NOP
14F50  FFE3     NOP
155:           		}
156:           	}
157:           
158:           	/* Overflow ? Return infinity */
159:           	if (!(new_exp < SPEXPM)) {
14F52  0EFC     MOVLW 0xFC
14F54  BEE3     BTFSC 0xFE3, 7, ACCESS
14F56  D01B     BRA 0x4F8E
14F58  0EFC     MOVLW 0xFC
14F5A  50E3     MOVF 0xFE3, W, ACCESS
14F5C  E104     BNZ 0x4F66
14F5E  0EFB     MOVLW 0xFB
14F60  28E3     INCF 0xFE3, W, ACCESS
14F62  A0D8     BTFSS 0xFD8, 0, ACCESS
14F64  D014     BRA 0x4F8E
160:           		new_exp = SPEXPM;
14F66  0EFF     MOVLW 0xFF
14F68  6E0B     MOVWF wtemp5, ACCESS
14F6A  0E00     MOVLW 0x0
14F6C  6E0C     MOVWF 0xC, ACCESS
14F6E  0EFB     MOVLW 0xFB
14F72  F02F     NOP
14F74  FFE3     NOP
14F76  0EFC     MOVLW 0xFC
14F7A  F033     NOP
14F7C  FFE3     NOP
161:           		B_FRACTION.i = 0;
14F7E  0EEF     MOVLW 0xEF
14F80  6AE3     CLRF 0xFE3, ACCESS
14F82  0EF0     MOVLW 0xF0
14F84  6AE3     CLRF 0xFE3, ACCESS
14F86  0EF1     MOVLW 0xF1
14F88  6AE3     CLRF 0xFE3, ACCESS
14F8A  0EF2     MOVLW 0xF2
14F8C  6AE3     CLRF 0xFE3, ACCESS
162:           	}
163:           
164:           	/* Underflow ? Flush to zero */
165:           	if (!(0 < new_exp)) {
14F8E  0EFC     MOVLW 0xFC
14F90  BEE3     BTFSC 0xFE3, 7, ACCESS
14F92  D007     BRA 0x4FA2
14F94  0EFC     MOVLW 0xFC
14F96  50E3     MOVF 0xFE3, W, ACCESS
14F98  E112     BNZ 0x4FBE
14F9A  0EFB     MOVLW 0xFB
14F9C  04E3     DECF 0xFE3, W, ACCESS
14F9E  B0D8     BTFSC 0xFD8, 0, ACCESS
14FA0  D00E     BRA 0x4FBE
166:           		new_exp = 0;
14FA2  0EFB     MOVLW 0xFB
14FA4  6AE3     CLRF 0xFE3, ACCESS
14FA6  0EFC     MOVLW 0xFC
14FA8  6AE3     CLRF 0xFE3, ACCESS
167:           		B_FRACTION.i = 0;
14FAA  0EEF     MOVLW 0xEF
14FAC  6AE3     CLRF 0xFE3, ACCESS
14FAE  0EF0     MOVLW 0xF0
14FB0  6AE3     CLRF 0xFE3, ACCESS
14FB2  0EF1     MOVLW 0xF1
14FB4  6AE3     CLRF 0xFE3, ACCESS
14FB6  0EF2     MOVLW 0xF2
14FB8  6AE3     CLRF 0xFE3, ACCESS
168:                           // no negative fp 0 for now
169:                           sign = 0;
14FBA  0EFF     MOVLW 0xFF
14FBC  6AE3     CLRF 0xFE3, ACCESS
170:           	}
171:           
172:           	/* Pack and return result */
173:           	bexp = new_exp;
14FBE  0EFB     MOVLW 0xFB
14FC2  FF8C     NOP
14FC4  F001     NOP
14FC6  0EFE     MOVLW 0xFE
14FCA  F007     NOP
14FCC  FFE3     NOP
174:           	// set the low bit of the exponent ...
175:           	if (bexp & 0x1) {
14FCE  0EFE     MOVLW 0xFE
14FD0  A0E3     BTFSS 0xFE3, 0, ACCESS
14FD2  D009     BRA 0x4FE6
176:           		B_FRACTION.fAsBytes.c |= 0x80;
14FD4  0EF1     MOVLW 0xF1
14FD6  24E1     ADDWF 0xFE1, W, ACCESS
14FD8  6ED9     MOVWF 0xFD9, ACCESS
14FDA  0EFF     MOVLW 0xFF
14FDC  20E2     ADDWFC 0xFE2, W, ACCESS
14FDE  6EDA     MOVWF 0xFDA, ACCESS
14FE0  0E00     MOVLW 0x0
14FE2  8EDB     BSF 0xFDB, 7, ACCESS
177:           	}
14FE4  D008     BRA 0x4FF6
178:           	// AND out the leading 1
179:           	else {
180:           		B_FRACTION.fAsBytes.c &= 0x7F;
14FE6  0EF1     MOVLW 0xF1
14FE8  24E1     ADDWF 0xFE1, W, ACCESS
14FEA  6ED9     MOVWF 0xFD9, ACCESS
14FEC  0EFF     MOVLW 0xFF
14FEE  20E2     ADDWFC 0xFE2, W, ACCESS
14FF0  6EDA     MOVWF 0xFDA, ACCESS
14FF2  0E7F     MOVLW 0x7F
14FF4  16DF     ANDWF 0xFDF, F, ACCESS
181:           	}
182:           	B_FRACTION.fAsBytes.d = bexp >> 1;
14FF6  0EF2     MOVLW 0xF2
14FF8  24E1     ADDWF 0xFE1, W, ACCESS
14FFA  6ED9     MOVWF 0xFD9, ACCESS
14FFC  0EFF     MOVLW 0xFF
14FFE  20E2     ADDWFC 0xFE2, W, ACCESS
15000  6EDA     MOVWF 0xFDA, ACCESS
15002  0EFE     MOVLW 0xFE
15006  FF8C     NOP
15008  F00C     NOP
1500A  90D8     BCF 0xFD8, 0, ACCESS
1500C  300C     RRCF 0xC, W, ACCESS
1500E  6EDF     MOVWF 0xFDF, ACCESS
15010  D644     BRA 0x4C9A
183:           	B_FRACTION.fAsBytes.d |= sign;
184:           	return b;
185:           }
15012  0EEB     MOVLW 0xEB
15014  26E1     ADDWF 0xFE1, F, ACCESS
15016  0EFF     MOVLW 0xFF
15018  22E2     ADDWFC 0xFE2, F, ACCESS
1501A  0012     RETURN 0
186:           
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/sprcadd.c  -----------------------------------------
1:             /* SP relaxed compliance floating point add intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             
6:             // single monlithic add function
7:             
8:             /* SP Add */
9:             SP
10:            SPADD(SP b, SP a) {
13B6A  52E6     MOVF 0xFE6, F, ACCESS
13B6C  52E6     MOVF 0xFE6, F, ACCESS
13B6E  52E6     MOVF 0xFE6, F, ACCESS
13B70  52E6     MOVF 0xFE6, F, ACCESS
11:            #define A_FRACTION    (*(SFP *)&a)
12:            #define B_FRACTION    (*(SFP *)&b)
13:            	unsigned char signs;	/* leftmost bit stores sign of b, next bit stores
14:            				   0 if and only if a and b have the same sign  */
15:            	unsigned char bexp;	/* Dst exponent */
16:            	unsigned char aexp;	/* Src exponent */
17:            	unsigned char grs;	/* Guard, round, sticky */
18:            
19:            
20:            	/* Unpack and check operands */
21:            	signs = B_FRACTION.fAsBytes.d & 0x80;
13B72  0EFB     MOVLW 0xFB
13B74  24E1     ADDWF 0xFE1, W, ACCESS
13B76  6ED9     MOVWF 0xFD9, ACCESS
13B78  0EFF     MOVLW 0xFF
13B7A  20E2     ADDWFC 0xFE2, W, ACCESS
13B7C  6EDA     MOVWF 0xFDA, ACCESS
13B7E  50DF     MOVF 0xFDF, W, ACCESS
13B80  6E0C     MOVWF 0xC, ACCESS
13B82  0E80     MOVLW 0x80
13B84  160C     ANDWF 0xC, F, ACCESS
13B86  0EFF     MOVLW 0xFF
13B8A  F033     NOP
13B8C  FFE3     NOP
22:            	bexp = B_FRACTION.fAsBytes.d << 1;
13B8E  0EFB     MOVLW 0xFB
13B90  24E1     ADDWF 0xFE1, W, ACCESS
13B92  6ED9     MOVWF 0xFD9, ACCESS
13B94  0EFF     MOVLW 0xFF
13B96  20E2     ADDWFC 0xFE2, W, ACCESS
13B98  6EDA     MOVWF 0xFDA, ACCESS
13B9A  50DF     MOVF 0xFDF, W, ACCESS
13B9C  6E0C     MOVWF 0xC, ACCESS
13B9E  90D8     BCF 0xFD8, 0, ACCESS
13BA0  340C     RLCF 0xC, W, ACCESS
13BA2  6E0B     MOVWF wtemp5, ACCESS
13BA4  0EFD     MOVLW 0xFD
13BA8  F02F     NOP
13BAA  FFE3     NOP
23:            	if (B_FRACTION.fAsBytes.c & 0x80) {
13BAC  0EFA     MOVLW 0xFA
13BAE  24E1     ADDWF 0xFE1, W, ACCESS
13BB0  6ED9     MOVWF 0xFD9, ACCESS
13BB2  0EFF     MOVLW 0xFF
13BB4  20E2     ADDWFC 0xFE2, W, ACCESS
13BB6  6EDA     MOVWF 0xFDA, ACCESS
13BB8  AEDF     BTFSS 0xFDF, 7, ACCESS
13BBA  D002     BRA 0x3BC0
24:            		bexp |= 0x1;
13BBC  0EFD     MOVLW 0xFD
13BBE  80E3     BSF 0xFE3, 0, ACCESS
25:            	}
26:            
27:            	/* Destination normal ? */
28:            	if (bexp) {
13BC0  0EFD     MOVLW 0xFD
13BC2  50E3     MOVF 0xFE3, W, ACCESS
13BC4  B4D8     BTFSC 0xFD8, 2, ACCESS
13BC6  D027     BRA 0x3C16
29:            		/* Destination inf or NaN ? */
30:            		if (bexp == 0xFF) {
13BC8  0EFD     MOVLW 0xFD
13BCA  28E3     INCF 0xFE3, W, ACCESS
13BCC  A4D8     BTFSS 0xFD8, 2, ACCESS
13BCE  D018     BRA 0x3C00
31:            			/* Make it inf */
32:            			b = 0;
13BD0  0E00     MOVLW 0x0
13BD2  6E09     MOVWF ltemp2, ACCESS
13BD4  0E00     MOVLW 0x0
13BD6  6E0A     MOVWF ttemp3, ACCESS
13BD8  0E00     MOVLW 0x0
13BDA  6E0B     MOVWF wtemp5, ACCESS
13BDC  0E00     MOVLW 0x0
13BDE  6E0C     MOVWF 0xC, ACCESS
13BE0  0EF8     MOVLW 0xF8
13BE4  F027     NOP
13BE6  FFE3     NOP
13BE8  0EF9     MOVLW 0xF9
13BEC  F02B     NOP
13BEE  FFE3     NOP
13BF0  0EFA     MOVLW 0xFA
13BF4  F02F     NOP
13BF6  FFE3     NOP
13BF8  0EFB     MOVLW 0xFB
13BFC  F033     NOP
13BFE  FFE3     NOP
33:            		}
34:            		// OR in the hidden 1-bit to b's fraction
35:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
13C00  0EFA     MOVLW 0xFA
13C02  8EE3     BSF 0xFE3, 7, ACCESS
36:            		// and zero out the upper byte so we can safely shift
37:            		B_FRACTION.fAsBytes.d = 0;
13C04  0EFB     MOVLW 0xFB
13C06  24E1     ADDWF 0xFE1, W, ACCESS
13C08  6ED9     MOVWF 0xFD9, ACCESS
13C0A  0EFF     MOVLW 0xFF
13C0C  20E2     ADDWFC 0xFE2, W, ACCESS
13C0E  6EDA     MOVWF 0xFDA, ACCESS
13C10  0E00     MOVLW 0x0
13C12  6EDF     MOVWF 0xFDF, ACCESS
38:            	}
13C14  D018     BRA 0x3C46
39:            	else {
40:            		/* Make it zero */
41:            		b = 0;
13C16  0E00     MOVLW 0x0
13C18  6E09     MOVWF ltemp2, ACCESS
13C1A  0E00     MOVLW 0x0
13C1C  6E0A     MOVWF ttemp3, ACCESS
13C1E  0E00     MOVLW 0x0
13C20  6E0B     MOVWF wtemp5, ACCESS
13C22  0E00     MOVLW 0x0
13C24  6E0C     MOVWF 0xC, ACCESS
13C26  0EF8     MOVLW 0xF8
13C2A  F027     NOP
13C2C  FFE3     NOP
13C2E  0EF9     MOVLW 0xF9
13C32  F02B     NOP
13C34  FFE3     NOP
13C36  0EFA     MOVLW 0xFA
13C3A  F02F     NOP
13C3C  FFE3     NOP
13C3E  0EFB     MOVLW 0xFB
13C42  F033     NOP
13C44  FFE3     NOP
42:            	}
43:            
44:            	aexp = A_FRACTION.fAsBytes.d & 0x80;
13C46  0EF7     MOVLW 0xF7
13C48  24E1     ADDWF 0xFE1, W, ACCESS
13C4A  6ED9     MOVWF 0xFD9, ACCESS
13C4C  0EFF     MOVLW 0xFF
13C4E  20E2     ADDWFC 0xFE2, W, ACCESS
13C50  6EDA     MOVWF 0xFDA, ACCESS
13C52  50DF     MOVF 0xFDF, W, ACCESS
13C54  6E0C     MOVWF 0xC, ACCESS
13C56  0E80     MOVLW 0x80
13C58  160C     ANDWF 0xC, F, ACCESS
13C5A  0EFE     MOVLW 0xFE
13C5E  F033     NOP
13C60  FFE3     NOP
45:            	// sign of a different from sign of b?
46:            	if (aexp != signs) {
13C62  50E1     MOVF 0xFE1, W, ACCESS
13C64  0FFE     ADDLW 0xFE
13C66  6ED9     MOVWF 0xFD9, ACCESS
13C68  50E2     MOVF 0xFE2, W, ACCESS
13C6A  6EDA     MOVWF 0xFDA, ACCESS
13C6C  0EFF     MOVLW 0xFF
13C6E  22DA     ADDWFC 0xFDA, F, ACCESS
13C70  0EFF     MOVLW 0xFF
13C72  50E3     MOVF 0xFE3, W, ACCESS
13C74  18DE     XORWF 0xFDE, W, ACCESS
13C76  B4D8     BTFSC 0xFD8, 2, ACCESS
13C78  D002     BRA 0x3C7E
47:            		signs |= 0x40;
13C7A  0EFF     MOVLW 0xFF
13C7C  8CE3     BSF 0xFE3, 6, ACCESS
48:            	}
49:            	aexp = A_FRACTION.fAsBytes.d << 1;
13C7E  0EF7     MOVLW 0xF7
13C80  24E1     ADDWF 0xFE1, W, ACCESS
13C82  6ED9     MOVWF 0xFD9, ACCESS
13C84  0EFF     MOVLW 0xFF
13C86  20E2     ADDWFC 0xFE2, W, ACCESS
13C88  6EDA     MOVWF 0xFDA, ACCESS
13C8A  50DF     MOVF 0xFDF, W, ACCESS
13C8C  6E0C     MOVWF 0xC, ACCESS
13C8E  90D8     BCF 0xFD8, 0, ACCESS
13C90  340C     RLCF 0xC, W, ACCESS
13C92  6E0B     MOVWF wtemp5, ACCESS
13C94  0EFE     MOVLW 0xFE
13C98  F02F     NOP
13C9A  FFE3     NOP
50:            	if (A_FRACTION.fAsBytes.c & 0x80) {
13C9C  0EF6     MOVLW 0xF6
13C9E  24E1     ADDWF 0xFE1, W, ACCESS
13CA0  6ED9     MOVWF 0xFD9, ACCESS
13CA2  0EFF     MOVLW 0xFF
13CA4  20E2     ADDWFC 0xFE2, W, ACCESS
13CA6  6EDA     MOVWF 0xFDA, ACCESS
13CA8  AEDF     BTFSS 0xFDF, 7, ACCESS
13CAA  D002     BRA 0x3CB0
51:            		aexp |= 0x1;
13CAC  0EFE     MOVLW 0xFE
13CAE  80E3     BSF 0xFE3, 0, ACCESS
52:            	}
53:            
54:            	/* Destination normal ? */
55:            	if (aexp) {
13CB0  0EFE     MOVLW 0xFE
13CB2  50E3     MOVF 0xFE3, W, ACCESS
13CB4  B4D8     BTFSC 0xFD8, 2, ACCESS
13CB6  D027     BRA 0x3D06
56:            		/* Destination inf or NaN ? */
57:            		if (aexp == 0xFF) {
13CB8  0EFE     MOVLW 0xFE
13CBA  28E3     INCF 0xFE3, W, ACCESS
13CBC  A4D8     BTFSS 0xFD8, 2, ACCESS
13CBE  D018     BRA 0x3CF0
58:            			/* Make it inf */
59:            			a = 0;
13CC0  0E00     MOVLW 0x0
13CC2  6E09     MOVWF ltemp2, ACCESS
13CC4  0E00     MOVLW 0x0
13CC6  6E0A     MOVWF ttemp3, ACCESS
13CC8  0E00     MOVLW 0x0
13CCA  6E0B     MOVWF wtemp5, ACCESS
13CCC  0E00     MOVLW 0x0
13CCE  6E0C     MOVWF 0xC, ACCESS
13CD0  0EF4     MOVLW 0xF4
13CD4  F027     NOP
13CD6  FFE3     NOP
13CD8  0EF5     MOVLW 0xF5
13CDC  F02B     NOP
13CDE  FFE3     NOP
13CE0  0EF6     MOVLW 0xF6
13CE4  F02F     NOP
13CE6  FFE3     NOP
13CE8  0EF7     MOVLW 0xF7
13CEC  F033     NOP
13CEE  FFE3     NOP
60:            		}
61:            		// OR in the hidden 1-bit to a's fraction
62:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
13CF0  0EF6     MOVLW 0xF6
13CF2  8EE3     BSF 0xFE3, 7, ACCESS
63:            		// and zero out the upper bits so we can safely shift
64:            		A_FRACTION.fAsBytes.d = 0;
13CF4  0EF7     MOVLW 0xF7
13CF6  24E1     ADDWF 0xFE1, W, ACCESS
13CF8  6ED9     MOVWF 0xFD9, ACCESS
13CFA  0EFF     MOVLW 0xFF
13CFC  20E2     ADDWFC 0xFE2, W, ACCESS
13CFE  6EDA     MOVWF 0xFDA, ACCESS
13D00  0E00     MOVLW 0x0
13D02  6EDF     MOVWF 0xFDF, ACCESS
65:            	}
13D04  D018     BRA 0x3D36
66:            	else {
67:            		/* Make it zero */
68:            		a = 0;
13D06  0E00     MOVLW 0x0
13D08  6E09     MOVWF ltemp2, ACCESS
13D0A  0E00     MOVLW 0x0
13D0C  6E0A     MOVWF ttemp3, ACCESS
13D0E  0E00     MOVLW 0x0
13D10  6E0B     MOVWF wtemp5, ACCESS
13D12  0E00     MOVLW 0x0
13D14  6E0C     MOVWF 0xC, ACCESS
13D16  0EF4     MOVLW 0xF4
13D1A  F027     NOP
13D1C  FFE3     NOP
13D1E  0EF5     MOVLW 0xF5
13D22  F02B     NOP
13D24  FFE3     NOP
13D26  0EF6     MOVLW 0xF6
13D2A  F02F     NOP
13D2C  FFE3     NOP
13D2E  0EF7     MOVLW 0xF7
13D32  F033     NOP
13D34  FFE3     NOP
69:            	}
70:            
71:            	/* Add */
72:            
73:            	/* Get smaller operand in b */
74:            
75:            	if (aexp < bexp) {
13D36  50E1     MOVF 0xFE1, W, ACCESS
13D38  0FFE     ADDLW 0xFE
13D3A  6ED9     MOVWF 0xFD9, ACCESS
13D3C  50E2     MOVF 0xFE2, W, ACCESS
13D3E  6EDA     MOVWF 0xFDA, ACCESS
13D40  0EFF     MOVLW 0xFF
13D42  22DA     ADDWFC 0xFDA, F, ACCESS
13D44  0EFD     MOVLW 0xFD
13D46  50E3     MOVF 0xFE3, W, ACCESS
13D48  5CDE     SUBWF 0xFDE, W, ACCESS
13D4A  B0D8     BTFSC 0xFD8, 0, ACCESS
13D4C  D0A4     BRA 0x3E96
76:            		// do I need to reverse the sign?
77:            		if (signs & 0x40) {
13D4E  0EFF     MOVLW 0xFF
13D50  ACE3     BTFSS 0xFE3, 6, ACCESS
13D52  D002     BRA 0x3D58
78:            			signs ^= 0x80;
13D54  0EFF     MOVLW 0xFF
13D56  7EE3     BTG 0xFE3, 7, ACCESS
79:            		}
80:            		// use  grs as swap space
81:            		grs = bexp;
13D58  0EFD     MOVLW 0xFD
13D5C  FF8C     NOP
13D5E  F001     NOP
13D60  0EFC     MOVLW 0xFC
13D64  F007     NOP
13D66  FFE3     NOP
82:            		bexp = aexp;
13D68  0EFE     MOVLW 0xFE
13D6C  FF8C     NOP
13D6E  F001     NOP
13D70  0EFD     MOVLW 0xFD
13D74  F007     NOP
13D76  FFE3     NOP
83:            		aexp = grs;
13D78  0EFC     MOVLW 0xFC
13D7C  FF8C     NOP
13D7E  F001     NOP
13D80  0EFE     MOVLW 0xFE
13D84  F007     NOP
13D86  FFE3     NOP
84:            		grs = B_FRACTION.fAsBytes.a;
13D88  0EF8     MOVLW 0xF8
13D8C  FF8C     NOP
13D8E  F001     NOP
13D90  0EFC     MOVLW 0xFC
13D94  F007     NOP
13D96  FFE3     NOP
85:            		B_FRACTION.fAsBytes.a = A_FRACTION.fAsBytes.a;
13D98  0EF4     MOVLW 0xF4
13D9C  FF8C     NOP
13D9E  F001     NOP
13DA0  0EF8     MOVLW 0xF8
13DA4  F007     NOP
13DA6  FFE3     NOP
86:            		A_FRACTION.fAsBytes.a = grs;
13DA8  0EFC     MOVLW 0xFC
13DAC  FF8C     NOP
13DAE  F001     NOP
13DB0  0EF4     MOVLW 0xF4
13DB4  F007     NOP
13DB6  FFE3     NOP
87:            		grs = B_FRACTION.fAsBytes.b;
13DB8  0EF9     MOVLW 0xF9
13DBA  24E1     ADDWF 0xFE1, W, ACCESS
13DBC  6ED9     MOVWF 0xFD9, ACCESS
13DBE  0EFF     MOVLW 0xFF
13DC0  20E2     ADDWFC 0xFE2, W, ACCESS
13DC2  6EDA     MOVWF 0xFDA, ACCESS
13DC4  50DF     MOVF 0xFDF, W, ACCESS
13DC6  6E0C     MOVWF 0xC, ACCESS
13DC8  0EFC     MOVLW 0xFC
13DCC  F033     NOP
13DCE  FFE3     NOP
88:            		B_FRACTION.fAsBytes.b = A_FRACTION.fAsBytes.b;
13DD0  0EF5     MOVLW 0xF5
13DD2  24E1     ADDWF 0xFE1, W, ACCESS
13DD4  6ED9     MOVWF 0xFD9, ACCESS
13DD6  0EFF     MOVLW 0xFF
13DD8  20E2     ADDWFC 0xFE2, W, ACCESS
13DDA  6EDA     MOVWF 0xFDA, ACCESS
13DDC  0EF9     MOVLW 0xF9
13DDE  24E1     ADDWF 0xFE1, W, ACCESS
13DE0  6EE9     MOVWF 0xFE9, ACCESS
13DE2  0EFF     MOVLW 0xFF
13DE4  20E2     ADDWFC 0xFE2, W, ACCESS
13DE6  6EEA     MOVWF 0xFEA, ACCESS
13DEA  FF7F     NOP
13DEC  FFEF     NOP
89:            		A_FRACTION.fAsBytes.b = grs;
13DEE  0EF5     MOVLW 0xF5
13DF0  24E1     ADDWF 0xFE1, W, ACCESS
13DF2  6ED9     MOVWF 0xFD9, ACCESS
13DF4  0EFF     MOVLW 0xFF
13DF6  20E2     ADDWFC 0xFE2, W, ACCESS
13DF8  6EDA     MOVWF 0xFDA, ACCESS
13DFA  0EFC     MOVLW 0xFC
13DFE  FF8F     NOP
13E00  FFDF     NOP
90:            		grs = B_FRACTION.fAsBytes.c;
13E02  0EFA     MOVLW 0xFA
13E04  24E1     ADDWF 0xFE1, W, ACCESS
13E06  6ED9     MOVWF 0xFD9, ACCESS
13E08  0EFF     MOVLW 0xFF
13E0A  20E2     ADDWFC 0xFE2, W, ACCESS
13E0C  6EDA     MOVWF 0xFDA, ACCESS
13E0E  50DF     MOVF 0xFDF, W, ACCESS
13E10  6E0C     MOVWF 0xC, ACCESS
13E12  0EFC     MOVLW 0xFC
13E16  F033     NOP
13E18  FFE3     NOP
91:            		B_FRACTION.fAsBytes.c = A_FRACTION.fAsBytes.c;
13E1A  0EF6     MOVLW 0xF6
13E1C  24E1     ADDWF 0xFE1, W, ACCESS
13E1E  6ED9     MOVWF 0xFD9, ACCESS
13E20  0EFF     MOVLW 0xFF
13E22  20E2     ADDWFC 0xFE2, W, ACCESS
13E24  6EDA     MOVWF 0xFDA, ACCESS
13E26  0EFA     MOVLW 0xFA
13E28  24E1     ADDWF 0xFE1, W, ACCESS
13E2A  6EE9     MOVWF 0xFE9, ACCESS
13E2C  0EFF     MOVLW 0xFF
13E2E  20E2     ADDWFC 0xFE2, W, ACCESS
13E30  6EEA     MOVWF 0xFEA, ACCESS
13E34  FF7F     NOP
13E36  FFEF     NOP
92:            		A_FRACTION.fAsBytes.c = grs;
13E38  0EF6     MOVLW 0xF6
13E3A  24E1     ADDWF 0xFE1, W, ACCESS
13E3C  6ED9     MOVWF 0xFD9, ACCESS
13E3E  0EFF     MOVLW 0xFF
13E40  20E2     ADDWFC 0xFE2, W, ACCESS
13E42  6EDA     MOVWF 0xFDA, ACCESS
13E44  0EFC     MOVLW 0xFC
13E48  FF8F     NOP
13E4A  FFDF     NOP
93:            		grs = B_FRACTION.fAsBytes.d;
13E4C  0EFB     MOVLW 0xFB
13E4E  24E1     ADDWF 0xFE1, W, ACCESS
13E50  6ED9     MOVWF 0xFD9, ACCESS
13E52  0EFF     MOVLW 0xFF
13E54  20E2     ADDWFC 0xFE2, W, ACCESS
13E56  6EDA     MOVWF 0xFDA, ACCESS
13E58  50DF     MOVF 0xFDF, W, ACCESS
13E5A  6E0C     MOVWF 0xC, ACCESS
13E5C  0EFC     MOVLW 0xFC
13E60  F033     NOP
13E62  FFE3     NOP
94:            		B_FRACTION.fAsBytes.d = A_FRACTION.fAsBytes.d;
13E64  0EF7     MOVLW 0xF7
13E66  24E1     ADDWF 0xFE1, W, ACCESS
13E68  6ED9     MOVWF 0xFD9, ACCESS
13E6A  0EFF     MOVLW 0xFF
13E6C  20E2     ADDWFC 0xFE2, W, ACCESS
13E6E  6EDA     MOVWF 0xFDA, ACCESS
13E70  0EFB     MOVLW 0xFB
13E72  24E1     ADDWF 0xFE1, W, ACCESS
13E74  6EE9     MOVWF 0xFE9, ACCESS
13E76  0EFF     MOVLW 0xFF
13E78  20E2     ADDWFC 0xFE2, W, ACCESS
13E7A  6EEA     MOVWF 0xFEA, ACCESS
13E7E  FF7F     NOP
13E80  FFEF     NOP
95:            		A_FRACTION.fAsBytes.d = grs;
13E82  0EF7     MOVLW 0xF7
13E84  24E1     ADDWF 0xFE1, W, ACCESS
13E86  6ED9     MOVWF 0xFD9, ACCESS
13E88  0EFF     MOVLW 0xFF
13E8A  20E2     ADDWFC 0xFE2, W, ACCESS
13E8C  6EDA     MOVWF 0xFDA, ACCESS
13E8E  0EFC     MOVLW 0xFC
13E92  FF8F     NOP
13E94  FFDF     NOP
96:            	}
97:            
98:            	grs = 0;
13E96  0EFC     MOVLW 0xFC
13E98  6AE3     CLRF 0xFE3, ACCESS
99:            	/* If all ones will shift through G,R, then S = significand nonzero */
100:           	if ((aexp - bexp) > (SPFRCB + 2)) {
13E9A  0EFE     MOVLW 0xFE
13E9C  50E3     MOVF 0xFE3, W, ACCESS
13E9E  6E0B     MOVWF wtemp5, ACCESS
13EA0  6A0C     CLRF 0xC, ACCESS
13EA2  0EFD     MOVLW 0xFD
13EA4  50E3     MOVF 0xFE3, W, ACCESS
13EA6  5E0B     SUBWF wtemp5, F, ACCESS
13EA8  0E00     MOVLW 0x0
13EAA  5A0C     SUBWFB 0xC, F, ACCESS
13EAC  BE0C     BTFSC 0xC, 7, ACCESS
13EAE  D062     BRA 0x3F74
13EB0  500C     MOVF 0xC, W, ACCESS
13EB2  E104     BNZ 0x3EBC
13EB4  0E1A     MOVLW 0x1A
13EB6  5C0B     SUBWF wtemp5, W, ACCESS
13EB8  A0D8     BTFSS 0xFD8, 0, ACCESS
13EBA  D05C     BRA 0x3F74
101:           		grs = B_FRACTION.i ? 1 : 0;
13EBC  0EF8     MOVLW 0xF8
13EBE  50E3     MOVF 0xFE3, W, ACCESS
13EC0  E10A     BNZ 0x3ED6
13EC2  0EF9     MOVLW 0xF9
13EC4  50E3     MOVF 0xFE3, W, ACCESS
13EC6  E107     BNZ 0x3ED6
13EC8  0EFA     MOVLW 0xFA
13ECA  50E3     MOVF 0xFE3, W, ACCESS
13ECC  E104     BNZ 0x3ED6
13ECE  0EFB     MOVLW 0xFB
13ED0  50E3     MOVF 0xFE3, W, ACCESS
13ED2  B4D8     BTFSC 0xFD8, 2, ACCESS
13ED4  D003     BRA 0x3EDC
13ED6  6A0C     CLRF 0xC, ACCESS
13ED8  2A0C     INCF 0xC, F, ACCESS
13EDA  D001     BRA 0x3EDE
13EDC  6A0C     CLRF 0xC, ACCESS
13EDE  0EFC     MOVLW 0xFC
13EE2  F033     NOP
13EE4  FFE3     NOP
102:           		B_FRACTION.i = 0;
13EE6  0EF8     MOVLW 0xF8
13EE8  6AE3     CLRF 0xFE3, ACCESS
13EEA  0EF9     MOVLW 0xF9
13EEC  6AE3     CLRF 0xFE3, ACCESS
13EEE  0EFA     MOVLW 0xFA
13EF0  6AE3     CLRF 0xFE3, ACCESS
13EF2  0EFB     MOVLW 0xFB
13EF4  6AE3     CLRF 0xFE3, ACCESS
103:           		bexp = aexp;
13EF6  0EFE     MOVLW 0xFE
13EFA  FF8C     NOP
13EFC  F001     NOP
13EFE  0EFD     MOVLW 0xFD
13F02  F007     NOP
13F04  FFE3     NOP
104:           	}
13F06  D042     BRA 0x3F8C
105:           	else {
106:           		while (bexp < aexp) {
13F74  50E1     MOVF 0xFE1, W, ACCESS
13F76  0FFD     ADDLW 0xFD
13F78  6ED9     MOVWF 0xFD9, ACCESS
13F7A  50E2     MOVF 0xFE2, W, ACCESS
13F7C  6EDA     MOVWF 0xFDA, ACCESS
13F7E  0EFF     MOVLW 0xFF
13F80  22DA     ADDWFC 0xFDA, F, ACCESS
13F82  0EFE     MOVLW 0xFE
13F84  50E3     MOVF 0xFE3, W, ACCESS
13F86  5CDE     SUBWF 0xFDE, W, ACCESS
13F88  A0D8     BTFSS 0xFD8, 0, ACCESS
13F8A  D7BE     BRA 0x3F08
107:           			/* Shift smaller operand right until exponents equal */
108:           			/* save the bits shifted out in grs    */
109:           			if (grs & 1) {
13F08  0EFC     MOVLW 0xFC
13F0A  A0E3     BTFSS 0xFE3, 0, ACCESS
13F0C  D00D     BRA 0x3F28
110:           				grs = (grs >> 1) | 0x1;
13F0E  0EFC     MOVLW 0xFC
13F12  FF8C     NOP
13F14  F00C     NOP
13F16  90D8     BCF 0xFD8, 0, ACCESS
13F18  320C     RRCF 0xC, F, ACCESS
13F1A  0E01     MOVLW 0x1
13F1C  120C     IORWF 0xC, F, ACCESS
13F1E  0EFC     MOVLW 0xFC
13F22  F033     NOP
13F24  FFE3     NOP
111:           			}
13F26  D009     BRA 0x3F3A
112:           			else {
113:           				grs >>= 1;
13F28  50E1     MOVF 0xFE1, W, ACCESS
13F2A  0FFC     ADDLW 0xFC
13F2C  6ED9     MOVWF 0xFD9, ACCESS
13F2E  50E2     MOVF 0xFE2, W, ACCESS
13F30  6EDA     MOVWF 0xFDA, ACCESS
13F32  0EFF     MOVLW 0xFF
13F34  22DA     ADDWFC 0xFDA, F, ACCESS
13F36  90D8     BCF 0xFD8, 0, ACCESS
13F38  32DF     RRCF 0xFDF, F, ACCESS
114:           			}
115:           			if (B_FRACTION.i & 0x1) {
13F3A  0EF8     MOVLW 0xF8
13F3C  A0E3     BTFSS 0xFE3, 0, ACCESS
13F3E  D002     BRA 0x3F44
116:           				grs |= 0x80;
13F40  0EFC     MOVLW 0xFC
13F42  8EE3     BSF 0xFE3, 7, ACCESS
117:           			}
118:           			B_FRACTION.i >>= 1;
13F44  0E01     MOVLW 0x1
13F46  6E0C     MOVWF 0xC, ACCESS
13F48  50E1     MOVF 0xFE1, W, ACCESS
13F4A  0FF8     ADDLW 0xF8
13F4C  6ED9     MOVWF 0xFD9, ACCESS
13F4E  50E2     MOVF 0xFE2, W, ACCESS
13F50  6EDA     MOVWF 0xFDA, ACCESS
13F52  0EFF     MOVLW 0xFF
13F54  22DA     ADDWFC 0xFDA, F, ACCESS
13F56  280C     INCF 0xC, W, ACCESS
13F58  52DE     MOVF 0xFDE, F, ACCESS
13F5A  D008     BRA 0x3F6C
13F5C  52DE     MOVF 0xFDE, F, ACCESS
13F5E  90D8     BCF 0xFD8, 0, ACCESS
13F60  BEDC     BTFSC 0xFDC, 7, ACCESS
13F62  80D8     BSF 0xFD8, 0, ACCESS
13F64  32DD     RRCF 0xFDD, F, ACCESS
13F66  32DD     RRCF 0xFDD, F, ACCESS
13F68  32DD     RRCF 0xFDD, F, ACCESS
13F6A  32DE     RRCF 0xFDE, F, ACCESS
13F6C  2EE8     DECFSZ 0xFE8, F, ACCESS
13F6E  D7F6     BRA 0x3F5C
119:           			bexp++;
13F70  0EFD     MOVLW 0xFD
13F72  2AE3     INCF 0xFE3, F, ACCESS
120:           		}
121:           	}
122:           
123:           	/* Add or subtract magnitude ? */
124:           	if (!(signs & 0x40)) {
13F8C  0EFF     MOVLW 0xFF
13F8E  BCE3     BTFSC 0xFE3, 6, ACCESS
13F90  D066     BRA 0x405E
125:           
126:           		/* Quick exit for 0 + 0, same sign */
127:           		if (!bexp) {
13F92  0EFD     MOVLW 0xFD
13F94  50E3     MOVF 0xFE3, W, ACCESS
13F96  B4D8     BTFSC 0xFD8, 2, ACCESS
128:           			return 0.0;
13F98  D0F2     BRA 0x417E
129:           		}
130:           
131:           		/* Add magnitude */
132:           		B_FRACTION.i += A_FRACTION.i;
13F9A  0EF8     MOVLW 0xF8
13F9C  50E3     MOVF 0xFE3, W, ACCESS
13F9E  6E01     MOVWF ltemp0, ACCESS
13FA0  0EF4     MOVLW 0xF4
13FA2  50E3     MOVF 0xFE3, W, ACCESS
13FA4  2601     ADDWF ltemp0, F, ACCESS
13FA6  0EF8     MOVLW 0xF8
13FAA  F007     NOP
13FAC  FFE3     NOP
13FAE  0EF9     MOVLW 0xF9
13FB0  50E3     MOVF 0xFE3, W, ACCESS
13FB2  6E01     MOVWF ltemp0, ACCESS
13FB4  0EF5     MOVLW 0xF5
13FB6  50E3     MOVF 0xFE3, W, ACCESS
13FB8  2201     ADDWFC ltemp0, F, ACCESS
13FBA  0EF9     MOVLW 0xF9
13FBE  F007     NOP
13FC0  FFE3     NOP
13FC2  0EFA     MOVLW 0xFA
13FC4  50E3     MOVF 0xFE3, W, ACCESS
13FC6  6E01     MOVWF ltemp0, ACCESS
13FC8  0EF6     MOVLW 0xF6
13FCA  50E3     MOVF 0xFE3, W, ACCESS
13FCC  2201     ADDWFC ltemp0, F, ACCESS
13FCE  0EFA     MOVLW 0xFA
13FD2  F007     NOP
13FD4  FFE3     NOP
13FD6  0EFB     MOVLW 0xFB
13FD8  50E3     MOVF 0xFE3, W, ACCESS
13FDA  6E01     MOVWF ltemp0, ACCESS
13FDC  0EF7     MOVLW 0xF7
13FDE  50E3     MOVF 0xFE3, W, ACCESS
13FE0  2201     ADDWFC ltemp0, F, ACCESS
13FE2  0EFB     MOVLW 0xFB
13FE6  F007     NOP
13FE8  FFE3     NOP
133:           		// did it overflow?
134:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
13FEA  0EFB     MOVLW 0xFB
13FEC  A0E3     BTFSS 0xFE3, 0, ACCESS
13FEE  D101     BRA 0x41F2
135:           			if (grs & 1) {
13FF0  0EFC     MOVLW 0xFC
13FF2  A0E3     BTFSS 0xFE3, 0, ACCESS
13FF4  D00D     BRA 0x4010
136:           				grs = (grs >> 1) | 0x1;
13FF6  0EFC     MOVLW 0xFC
13FFA  FF8C     NOP
13FFC  F00C     NOP
13FFE  90D8     BCF 0xFD8, 0, ACCESS
14000  320C     RRCF 0xC, F, ACCESS
14002  0E01     MOVLW 0x1
14004  120C     IORWF 0xC, F, ACCESS
14006  0EFC     MOVLW 0xFC
1400A  F033     NOP
1400C  FFE3     NOP
137:           			}
1400E  D009     BRA 0x4022
138:           			else {
139:           				grs >>= 1;
14010  50E1     MOVF 0xFE1, W, ACCESS
14012  0FFC     ADDLW 0xFC
14014  6ED9     MOVWF 0xFD9, ACCESS
14016  50E2     MOVF 0xFE2, W, ACCESS
14018  6EDA     MOVWF 0xFDA, ACCESS
1401A  0EFF     MOVLW 0xFF
1401C  22DA     ADDWFC 0xFDA, F, ACCESS
1401E  90D8     BCF 0xFD8, 0, ACCESS
14020  32DF     RRCF 0xFDF, F, ACCESS
140:           			}
141:           			if (B_FRACTION.i & 1) {
14022  0EF8     MOVLW 0xF8
14024  A0E3     BTFSS 0xFE3, 0, ACCESS
14026  D002     BRA 0x402C
142:           				grs |= 0x80;
14028  0EFC     MOVLW 0xFC
1402A  8EE3     BSF 0xFE3, 7, ACCESS
143:           			}
144:           			B_FRACTION.i >>= 1;
1402C  0E01     MOVLW 0x1
1402E  6E0C     MOVWF 0xC, ACCESS
14030  50E1     MOVF 0xFE1, W, ACCESS
14032  0FF8     ADDLW 0xF8
14034  6ED9     MOVWF 0xFD9, ACCESS
14036  50E2     MOVF 0xFE2, W, ACCESS
14038  6EDA     MOVWF 0xFDA, ACCESS
1403A  0EFF     MOVLW 0xFF
1403C  22DA     ADDWFC 0xFDA, F, ACCESS
1403E  280C     INCF 0xC, W, ACCESS
14040  52DE     MOVF 0xFDE, F, ACCESS
14042  D008     BRA 0x4054
14044  52DE     MOVF 0xFDE, F, ACCESS
14046  90D8     BCF 0xFD8, 0, ACCESS
14048  BEDC     BTFSC 0xFDC, 7, ACCESS
1404A  80D8     BSF 0xFD8, 0, ACCESS
1404C  32DD     RRCF 0xFDD, F, ACCESS
1404E  32DD     RRCF 0xFDD, F, ACCESS
14050  32DD     RRCF 0xFDD, F, ACCESS
14052  32DE     RRCF 0xFDE, F, ACCESS
14054  2EE8     DECFSZ 0xFE8, F, ACCESS
14056  D7F6     BRA 0x4044
145:           			++bexp;
14058  0EFD     MOVLW 0xFD
1405A  2AE3     INCF 0xFE3, F, ACCESS
1405C  D0CA     BRA 0x41F2
146:           		}
147:           
148:           	}
149:           	else {
150:           
151:           		/* Subtract magnitude */
152:           
153:           		if (B_FRACTION.i < A_FRACTION.i) {
1405E  50E1     MOVF 0xFE1, W, ACCESS
14060  0FF8     ADDLW 0xF8
14062  6ED9     MOVWF 0xFD9, ACCESS
14064  50E2     MOVF 0xFE2, W, ACCESS
14066  6EDA     MOVWF 0xFDA, ACCESS
14068  0EFF     MOVLW 0xFF
1406A  22DA     ADDWFC 0xFDA, F, ACCESS
1406C  0EF4     MOVLW 0xF4
1406E  50E3     MOVF 0xFE3, W, ACCESS
14070  5CDE     SUBWF 0xFDE, W, ACCESS
14072  0EF5     MOVLW 0xF5
14074  50E3     MOVF 0xFE3, W, ACCESS
14076  58DE     SUBWFB 0xFDE, W, ACCESS
14078  0EF6     MOVLW 0xF6
1407A  50E3     MOVF 0xFE3, W, ACCESS
1407C  58DE     SUBWFB 0xFDE, W, ACCESS
1407E  50DE     MOVF 0xFDE, W, ACCESS
14080  0A80     XORLW 0x80
14082  6E01     MOVWF ltemp0, ACCESS
14084  0EF7     MOVLW 0xF7
14086  50E3     MOVF 0xFE3, W, ACCESS
14088  0A80     XORLW 0x80
1408A  5801     SUBWFB ltemp0, W, ACCESS
1408C  B0D8     BTFSC 0xFD8, 0, ACCESS
1408E  D053     BRA 0x4136
154:           			B_FRACTION.i = A_FRACTION.i - B_FRACTION.i - 1;
14090  0EF4     MOVLW 0xF4
14094  FF8C     NOP
14096  F009     NOP
14098  0EF5     MOVLW 0xF5
1409C  FF8C     NOP
1409E  F00A     NOP
140A0  0EF6     MOVLW 0xF6
140A4  FF8C     NOP
140A6  F00B     NOP
140A8  0EF7     MOVLW 0xF7
140AC  FF8C     NOP
140AE  F00C     NOP
140B0  0EF8     MOVLW 0xF8
140B2  50E3     MOVF 0xFE3, W, ACCESS
140B4  5E09     SUBWF ltemp2, F, ACCESS
140B6  0EF9     MOVLW 0xF9
140B8  50E3     MOVF 0xFE3, W, ACCESS
140BA  5A0A     SUBWFB ttemp3, F, ACCESS
140BC  0EFA     MOVLW 0xFA
140BE  50E3     MOVF 0xFE3, W, ACCESS
140C0  5A0B     SUBWFB wtemp5, F, ACCESS
140C2  0EFB     MOVLW 0xFB
140C4  50E3     MOVF 0xFE3, W, ACCESS
140C6  5A0C     SUBWFB 0xC, F, ACCESS
140C8  0EFF     MOVLW 0xFF
140CA  2409     ADDWF ltemp2, W, ACCESS
140CC  6E05     MOVWF ltemp1, ACCESS
140CE  0EFF     MOVLW 0xFF
140D0  200A     ADDWFC ttemp3, W, ACCESS
140D2  6E06     MOVWF 0x6, ACCESS
140D4  0EFF     MOVLW 0xFF
140D6  200B     ADDWFC wtemp5, W, ACCESS
140D8  6E07     MOVWF ttemp2, ACCESS
140DA  0EFF     MOVLW 0xFF
140DC  200C     ADDWFC 0xC, W, ACCESS
140DE  6E08     MOVWF 0x8, ACCESS
140E0  0EF8     MOVLW 0xF8
140E4  F017     NOP
140E6  FFE3     NOP
140E8  0EF9     MOVLW 0xF9
140EC  F01B     NOP
140EE  FFE3     NOP
140F0  0EFA     MOVLW 0xFA
140F4  F01F     NOP
140F6  FFE3     NOP
140F8  0EFB     MOVLW 0xFB
140FC  F023     NOP
140FE  FFE3     NOP
155:           			signs ^= 0x80;
14100  0EFF     MOVLW 0xFF
14102  7EE3     BTG 0xFE3, 7, ACCESS
156:           			grs = ~grs + 1;
14104  0EFC     MOVLW 0xFC
14106  50E3     MOVF 0xFE3, W, ACCESS
14108  0800     SUBLW 0x0
1410A  6E0C     MOVWF 0xC, ACCESS
1410C  0EFC     MOVLW 0xFC
14110  F033     NOP
14112  FFE3     NOP
157:           			if (!grs) {
14114  0EFC     MOVLW 0xFC
14116  50E3     MOVF 0xFE3, W, ACCESS
14118  A4D8     BTFSS 0xFD8, 2, ACCESS
1411A  D020     BRA 0x415C
158:           				++B_FRACTION.i;
1411C  50E1     MOVF 0xFE1, W, ACCESS
1411E  0FF8     ADDLW 0xF8
14120  6ED9     MOVWF 0xFD9, ACCESS
14122  50E2     MOVF 0xFE2, W, ACCESS
14124  6EDA     MOVWF 0xFDA, ACCESS
14126  0EFF     MOVLW 0xFF
14128  22DA     ADDWFC 0xFDA, F, ACCESS
1412A  2ADE     INCF 0xFDE, F, ACCESS
1412C  0E00     MOVLW 0x0
1412E  22DE     ADDWFC 0xFDE, F, ACCESS
14130  22DE     ADDWFC 0xFDE, F, ACCESS
14132  22DE     ADDWFC 0xFDE, F, ACCESS
14134  D013     BRA 0x415C
159:           			}
160:           		}
161:           		else {
162:           			B_FRACTION.i -= A_FRACTION.i;
14136  50E1     MOVF 0xFE1, W, ACCESS
14138  0FF8     ADDLW 0xF8
1413A  6ED9     MOVWF 0xFD9, ACCESS
1413C  50E2     MOVF 0xFE2, W, ACCESS
1413E  6EDA     MOVWF 0xFDA, ACCESS
14140  0EFF     MOVLW 0xFF
14142  22DA     ADDWFC 0xFDA, F, ACCESS
14144  0EF4     MOVLW 0xF4
14146  50E3     MOVF 0xFE3, W, ACCESS
14148  5EDE     SUBWF 0xFDE, F, ACCESS
1414A  0EF5     MOVLW 0xF5
1414C  50E3     MOVF 0xFE3, W, ACCESS
1414E  5ADE     SUBWFB 0xFDE, F, ACCESS
14150  0EF6     MOVLW 0xF6
14152  50E3     MOVF 0xFE3, W, ACCESS
14154  5ADE     SUBWFB 0xFDE, F, ACCESS
14156  0EF7     MOVLW 0xF7
14158  50E3     MOVF 0xFE3, W, ACCESS
1415A  5ADE     SUBWFB 0xFDE, F, ACCESS
163:           		}
164:           
165:           		/* True zero ? */
166:           		if (!B_FRACTION.i && !grs) {
1415C  0EF8     MOVLW 0xF8
1415E  50E3     MOVF 0xFE3, W, ACCESS
14160  E145     BNZ 0x41EC
14162  0EF9     MOVLW 0xF9
14164  50E3     MOVF 0xFE3, W, ACCESS
14166  E142     BNZ 0x41EC
14168  0EFA     MOVLW 0xFA
1416A  50E3     MOVF 0xFE3, W, ACCESS
1416C  E13F     BNZ 0x41EC
1416E  0EFB     MOVLW 0xFB
14170  50E3     MOVF 0xFE3, W, ACCESS
14172  A4D8     BTFSS 0xFD8, 2, ACCESS
14174  D03B     BRA 0x41EC
14176  0EFC     MOVLW 0xFC
14178  50E3     MOVF 0xFE3, W, ACCESS
1417A  A4D8     BTFSS 0xFD8, 2, ACCESS
1417C  D037     BRA 0x41EC
167:           			return 0.0;
1417E  0E00     MOVLW 0x0
14180  6E01     MOVWF ltemp0, ACCESS
14182  0E00     MOVLW 0x0
14184  6E02     MOVWF ttemp5, ACCESS
14186  0E00     MOVLW 0x0
14188  6E03     MOVWF wtemp1, ACCESS
1418A  0E00     MOVLW 0x0
1418C  6E04     MOVWF ttemp1, ACCESS
1418E  D0C6     BRA 0x431C
168:           		}
169:           
170:           		/* Renormalize */
171:           		while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
141EC  0EFA     MOVLW 0xFA
141EE  AEE3     BTFSS 0xFE3, 7, ACCESS
141F0  D7CF     BRA 0x4190
172:           			B_FRACTION.i <<= 1;
14190  90D8     BCF 0xFD8, 0, ACCESS
14192  0EF8     MOVLW 0xF8
14194  36E3     RLCF 0xFE3, F, ACCESS
14196  0EF9     MOVLW 0xF9
14198  36E3     RLCF 0xFE3, F, ACCESS
1419A  0EFA     MOVLW 0xFA
1419C  36E3     RLCF 0xFE3, F, ACCESS
1419E  0EFB     MOVLW 0xFB
141A0  36E3     RLCF 0xFE3, F, ACCESS
173:           			if (grs & 0x80) {
141A2  0EFC     MOVLW 0xFC
141A4  AEE3     BTFSS 0xFE3, 7, ACCESS
141A6  D002     BRA 0x41AC
174:           				B_FRACTION.i |= 0x1;
141A8  0EF8     MOVLW 0xF8
141AA  80E3     BSF 0xFE3, 0, ACCESS
175:           			}
176:           			if (grs & 1) {
141AC  0EFC     MOVLW 0xFC
141AE  A0E3     BTFSS 0xFE3, 0, ACCESS
141B0  D00E     BRA 0x41CE
177:           				grs = (grs << 1) | 0x1;
141B2  0EFC     MOVLW 0xFC
141B6  FF8C     NOP
141B8  F00C     NOP
141BA  90D8     BCF 0xFD8, 0, ACCESS
141BC  340C     RLCF 0xC, W, ACCESS
141BE  6E0B     MOVWF wtemp5, ACCESS
141C0  0E01     MOVLW 0x1
141C2  120B     IORWF wtemp5, F, ACCESS
141C4  0EFC     MOVLW 0xFC
141C8  F02F     NOP
141CA  FFE3     NOP
178:           			}
141CC  D009     BRA 0x41E0
179:           			else {
180:           				grs <<= 1;
141CE  50E1     MOVF 0xFE1, W, ACCESS
141D0  0FFC     ADDLW 0xFC
141D2  6ED9     MOVWF 0xFD9, ACCESS
141D4  50E2     MOVF 0xFE2, W, ACCESS
141D6  6EDA     MOVWF 0xFDA, ACCESS
141D8  0EFF     MOVLW 0xFF
141DA  22DA     ADDWFC 0xFDA, F, ACCESS
141DC  90D8     BCF 0xFD8, 0, ACCESS
141DE  36DF     RLCF 0xFDF, F, ACCESS
181:           			}
182:           			if (bexp) {
141E0  0EFD     MOVLW 0xFD
141E2  50E3     MOVF 0xFE3, W, ACCESS
141E4  B4D8     BTFSC 0xFD8, 2, ACCESS
141E6  D002     BRA 0x41EC
183:           				--bexp;
141E8  0EFD     MOVLW 0xFD
141EA  06E3     DECF 0xFE3, F, ACCESS
184:           			}
185:           		}
186:           	}
187:           
188:           	/* Round, check overflow, underflow */
189:           
190:           	/* Round */
191:           	// reuse aexp as the rounding flag ...
192:           	aexp = 0;
141F2  0EFE     MOVLW 0xFE
141F4  6AE3     CLRF 0xFE3, ACCESS
193:           	if (grs & 0x80) {
141F6  0EFC     MOVLW 0xFC
141F8  AEE3     BTFSS 0xFE3, 7, ACCESS
141FA  D00F     BRA 0x421A
194:           		if (grs & 0x7f) {
141FC  0EFC     MOVLW 0xFC
14200  FF8C     NOP
14202  F00C     NOP
14204  0E7F     MOVLW 0x7F
14206  160C     ANDWF 0xC, F, ACCESS
14208  B4D8     BTFSC 0xFD8, 2, ACCESS
1420A  D004     BRA 0x4214
195:           			aexp = 1;
1420C  0EFE     MOVLW 0xFE
1420E  6AE3     CLRF 0xFE3, ACCESS
14210  2AE3     INCF 0xFE3, F, ACCESS
196:           		}
14212  D003     BRA 0x421A
197:           		else {
198:           			if (B_FRACTION.i & 1) {
14214  0EF8     MOVLW 0xF8
14216  B0E3     BTFSC 0xFE3, 0, ACCESS
14218  D7F9     BRA 0x420C
199:           				aexp = 1;
200:           			}
201:           		}
202:           	}
203:           	if (aexp) {
1421A  0EFE     MOVLW 0xFE
1421C  50E3     MOVF 0xFE3, W, ACCESS
1421E  B4D8     BTFSC 0xFD8, 2, ACCESS
14220  D02B     BRA 0x4278
204:           		++B_FRACTION.i;
14222  50E1     MOVF 0xFE1, W, ACCESS
14224  0FF8     ADDLW 0xF8
14226  6ED9     MOVWF 0xFD9, ACCESS
14228  50E2     MOVF 0xFE2, W, ACCESS
1422A  6EDA     MOVWF 0xFDA, ACCESS
1422C  0EFF     MOVLW 0xFF
1422E  22DA     ADDWFC 0xFDA, F, ACCESS
14230  2ADE     INCF 0xFDE, F, ACCESS
14232  0E00     MOVLW 0x0
14234  22DE     ADDWFC 0xFDE, F, ACCESS
14236  22DE     ADDWFC 0xFDE, F, ACCESS
14238  22DE     ADDWFC 0xFDE, F, ACCESS
205:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
1423A  0EFB     MOVLW 0xFB
1423C  A0E3     BTFSS 0xFE3, 0, ACCESS
1423E  D01C     BRA 0x4278
206:           			B_FRACTION.i = B_FRACTION.i >> 1;
14240  0E01     MOVLW 0x1
14242  6E0C     MOVWF 0xC, ACCESS
14244  50E1     MOVF 0xFE1, W, ACCESS
14246  0FF8     ADDLW 0xF8
14248  6ED9     MOVWF 0xFD9, ACCESS
1424A  50E2     MOVF 0xFE2, W, ACCESS
1424C  6EDA     MOVWF 0xFDA, ACCESS
1424E  0EFF     MOVLW 0xFF
14250  22DA     ADDWFC 0xFDA, F, ACCESS
14252  280C     INCF 0xC, W, ACCESS
14254  52DE     MOVF 0xFDE, F, ACCESS
14256  D008     BRA 0x4268
14258  52DE     MOVF 0xFDE, F, ACCESS
1425A  90D8     BCF 0xFD8, 0, ACCESS
1425C  BEDC     BTFSC 0xFDC, 7, ACCESS
1425E  80D8     BSF 0xFD8, 0, ACCESS
14260  32DD     RRCF 0xFDD, F, ACCESS
14262  32DD     RRCF 0xFDD, F, ACCESS
14264  32DD     RRCF 0xFDD, F, ACCESS
14266  32DE     RRCF 0xFDE, F, ACCESS
14268  2EE8     DECFSZ 0xFE8, F, ACCESS
1426A  D7F6     BRA 0x4258
207:           			if (!(bexp == 0xFF)) {
1426C  0EFD     MOVLW 0xFD
1426E  28E3     INCF 0xFE3, W, ACCESS
14270  B4D8     BTFSC 0xFD8, 2, ACCESS
14272  D002     BRA 0x4278
208:           				++bexp;
14274  0EFD     MOVLW 0xFD
14276  2AE3     INCF 0xFE3, F, ACCESS
209:           			}
210:           		}
211:           	}
212:           
213:           	/* Overflow ? Return infinity */
214:           	/* Underflow ? Flush to zero */
215:           	if (bexp == 0xFF || bexp == 0) {
14278  0EFD     MOVLW 0xFD
1427A  28E3     INCF 0xFE3, W, ACCESS
1427C  B4D8     BTFSC 0xFD8, 2, ACCESS
1427E  D004     BRA 0x4288
14280  0EFD     MOVLW 0xFD
14282  50E3     MOVF 0xFE3, W, ACCESS
14284  A4D8     BTFSS 0xFD8, 2, ACCESS
14286  D00E     BRA 0x42A4
216:           		B_FRACTION.i = 0;
14288  0EF8     MOVLW 0xF8
1428A  6AE3     CLRF 0xFE3, ACCESS
1428C  0EF9     MOVLW 0xF9
1428E  6AE3     CLRF 0xFE3, ACCESS
14290  0EFA     MOVLW 0xFA
14292  6AE3     CLRF 0xFE3, ACCESS
14294  0EFB     MOVLW 0xFB
14296  6AE3     CLRF 0xFE3, ACCESS
217:                           // no negative 0 for now
218:                           if (bexp == 0) {
14298  0EFD     MOVLW 0xFD
1429A  50E3     MOVF 0xFE3, W, ACCESS
1429C  A4D8     BTFSS 0xFD8, 2, ACCESS
1429E  D002     BRA 0x42A4
219:           		        signs=0;
142A0  0EFF     MOVLW 0xFF
142A2  6AE3     CLRF 0xFE3, ACCESS
220:                           }
221:           	}
222:           
223:           	/* Pack and return result */
224:           	// set the low bit of the exponent ...
225:           	if (bexp & 0x1) {
142A4  0EFD     MOVLW 0xFD
142A6  A0E3     BTFSS 0xFE3, 0, ACCESS
142A8  D009     BRA 0x42BC
226:           		B_FRACTION.fAsBytes.c |= 0x80;
142AA  0EFA     MOVLW 0xFA
142AC  24E1     ADDWF 0xFE1, W, ACCESS
142AE  6ED9     MOVWF 0xFD9, ACCESS
142B0  0EFF     MOVLW 0xFF
142B2  20E2     ADDWFC 0xFE2, W, ACCESS
142B4  6EDA     MOVWF 0xFDA, ACCESS
142B6  0E00     MOVLW 0x0
142B8  8EDB     BSF 0xFDB, 7, ACCESS
227:           	}
142BA  D008     BRA 0x42CC
228:           	// AND out the leading 1
229:           	else {
230:           		B_FRACTION.fAsBytes.c &= 0x7F;
142BC  0EFA     MOVLW 0xFA
142BE  24E1     ADDWF 0xFE1, W, ACCESS
142C0  6ED9     MOVWF 0xFD9, ACCESS
142C2  0EFF     MOVLW 0xFF
142C4  20E2     ADDWFC 0xFE2, W, ACCESS
142C6  6EDA     MOVWF 0xFDA, ACCESS
142C8  0E7F     MOVLW 0x7F
142CA  16DF     ANDWF 0xFDF, F, ACCESS
231:           	}
232:           	B_FRACTION.fAsBytes.d = bexp >> 1;
142CC  0EFB     MOVLW 0xFB
142CE  24E1     ADDWF 0xFE1, W, ACCESS
142D0  6ED9     MOVWF 0xFD9, ACCESS
142D2  0EFF     MOVLW 0xFF
142D4  20E2     ADDWFC 0xFE2, W, ACCESS
142D6  6EDA     MOVWF 0xFDA, ACCESS
142D8  0EFD     MOVLW 0xFD
142DC  FF8C     NOP
142DE  F00C     NOP
142E0  90D8     BCF 0xFD8, 0, ACCESS
142E2  300C     RRCF 0xC, W, ACCESS
142E4  6EDF     MOVWF 0xFDF, ACCESS
233:           	if (signs & 0x80) {
142E6  0EFF     MOVLW 0xFF
142E8  AEE3     BTFSS 0xFE3, 7, ACCESS
142EA  D008     BRA 0x42FC
234:           		B_FRACTION.fAsBytes.d |= 0x80;
142EC  0EFB     MOVLW 0xFB
142EE  24E1     ADDWF 0xFE1, W, ACCESS
142F0  6ED9     MOVWF 0xFD9, ACCESS
142F2  0EFF     MOVLW 0xFF
142F4  20E2     ADDWFC 0xFE2, W, ACCESS
142F6  6EDA     MOVWF 0xFDA, ACCESS
142F8  0E00     MOVLW 0x0
142FA  8EDB     BSF 0xFDB, 7, ACCESS
235:           	}
236:           	return b;
142FC  0EF8     MOVLW 0xF8
14300  FF8C     NOP
14302  F001     NOP
14304  0EF9     MOVLW 0xF9
14308  FF8C     NOP
1430A  F002     NOP
1430C  0EFA     MOVLW 0xFA
14310  FF8C     NOP
14312  F003     NOP
14314  0EFB     MOVLW 0xFB
14318  FF8C     NOP
1431A  F004     NOP
237:           }
1431C  0EF4     MOVLW 0xF4
1431E  26E1     ADDWF 0xFE1, F, ACCESS
14320  0EFF     MOVLW 0xFF
14322  22E2     ADDWFC 0xFE2, F, ACCESS
14324  0012     RETURN 0
238:           
239:           /* SP Subtract */
240:           #ifdef __PICC__
241:           SP
242:           SPSUB(SP a, SP b)
243:           #else
244:           SP
245:           SPSUB(SP b, SP a)
246:           #endif
247:           {
248:           	(*(SFP *) & a).i ^= 0x80000000; 
1B208  0EFB     MOVLW 0xFB
1B20A  7EE3     BTG 0xFE3, 7, ACCESS
249:           	return __fladd(b, a);
1B20C  0EF8     MOVLW 0xF8
1B210  FF8F     NOP
1B212  FFE6     NOP
1B216  FF8F     NOP
1B218  FFE6     NOP
1B21C  FF8F     NOP
1B21E  FFE6     NOP
1B222  FF8F     NOP
1B224  FFE6     NOP
1B226  0EF8     MOVLW 0xF8
1B22A  FF8F     NOP
1B22C  FFE6     NOP
1B230  FF8F     NOP
1B232  FFE6     NOP
1B236  FF8F     NOP
1B238  FFE6     NOP
1B23C  FF8F     NOP
1B23E  FFE6     NOP
1B240  ECB5     CALL 0x13B6A, 0
1B242  F09D     NOP
250:           }
1B244  0EF8     MOVLW 0xF8
1B246  26E1     ADDWF 0xFE1, F, ACCESS
1B248  0EFF     MOVLW 0xFF
1B24A  22E2     ADDWFC 0xFE2, F, ACCESS
1B24C  0012     RETURN 0
251:           
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/rand.c  --------------------------------------------
1:             #include <stdlib.h>
2:             #include <stdint.h>
3:             
4:             #if __SIZEOF_LONG_LONG__ == 4
5:             static uint32_t seed;
6:             #else
7:             static uint64_t seed;
8:             #endif
9:             
10:            void srand(unsigned s)
11:            {
12:            	seed = s-1;
1B568  0EFE     MOVLW 0xFE
1B56A  50E3     MOVF 0xFE3, W, ACCESS
1B56C  0FFF     ADDLW 0xFF
1B56E  6E0B     MOVWF wtemp5, ACCESS
1B570  0EFF     MOVLW 0xFF
1B574  FF8C     NOP
1B576  F00C     NOP
1B578  0EFF     MOVLW 0xFF
1B57A  220C     ADDWFC 0xC, F, ACCESS
1B57E  F02C     NOP
1B580  F0CF     NOP
1B584  F030     NOP
1B586  F0D0     NOP
1B588  0100     MOVLB 0x0
1B58A  6BD1     CLRF 0xD1, BANKED
1B58C  6BD2     CLRF 0xD2, BANKED
1B58E  6BD3     CLRF 0xD3, BANKED
1B590  6BD4     CLRF 0xD4, BANKED
1B592  6BD5     CLRF 0xD5, BANKED
1B594  6BD6     CLRF 0xD6, BANKED
13:            }
1B596  52E5     MOVF 0xFE5, F, ACCESS
1B598  52E5     MOVF 0xFE5, F, ACCESS
1B59A  0012     RETURN 0
14:            
15:            int rand(void)
16:            {
17:            #if __SIZEOF_LONG_LONG__ == 4
18:            	seed = 1284865837UL*seed + 1;
19:            #else
20:            	seed = 6364136223846793005ULL*seed + 1;
21:            #endif
22:            	return seed >> (((sizeof seed) * 8)- (sizeof(int)*8) + 1);
23:            }
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/printf.c  ------------------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
1AD3C  52E6     MOVF 0xFE6, F, ACCESS
1AD3E  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
1AD40  0EFB     MOVLW 0xFB
1AD42  24E1     ADDWF 0xFE1, W, ACCESS
1AD44  6E0B     MOVWF wtemp5, ACCESS
1AD46  0EFF     MOVLW 0xFF
1AD48  20E2     ADDWFC 0xFE2, W, ACCESS
1AD4A  6E0C     MOVWF 0xC, ACCESS
1AD4C  0EFF     MOVLW 0xFF
1AD50  F033     NOP
1AD52  FFE3     NOP
1AD54  0EFE     MOVLW 0xFE
1AD58  F02F     NOP
1AD5A  FFE3     NOP
10:            	ret = vfprintf(stdout, fmt, ap);
1AD5C  0EFE     MOVLW 0xFE
1AD5E  24E1     ADDWF 0xFE1, W, ACCESS
1AD60  6E01     MOVWF ltemp0, ACCESS
1AD62  0EFF     MOVLW 0xFF
1AD64  20E2     ADDWFC 0xFE2, W, ACCESS
1AD66  6E02     MOVWF ttemp5, ACCESS
1AD6A  F007     NOP
1AD6C  FFE6     NOP
1AD70  F00B     NOP
1AD72  FFE6     NOP
1AD74  0EF9     MOVLW 0xF9
1AD78  FF8F     NOP
1AD7A  FFE6     NOP
1AD7E  FF8F     NOP
1AD80  FFE6     NOP
1AD82  0E00     MOVLW 0x0
1AD84  6EE6     MOVWF 0xFE6, ACCESS
1AD86  0E00     MOVLW 0x0
1AD88  6EE6     MOVWF 0xFE6, ACCESS
1AD8A  ECDE     CALL 0x1A3BC, 0
1AD8C  F0D1     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
1AD8E  52E5     MOVF 0xFE5, F, ACCESS
1AD90  52E5     MOVF 0xFE5, F, ACCESS
1AD92  52E5     MOVF 0xFE5, F, ACCESS
1AD94  50E7     MOVF 0xFE7, W, ACCESS
1AD96  5EE1     SUBWF 0xFE1, F, ACCESS
1AD98  0E00     MOVLW 0x0
1AD9A  5AE2     SUBWFB 0xFE2, F, ACCESS
1AD9C  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nf_sprintf.c  --------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
19A3C  0E08     MOVLW 0x8
19A3E  26E1     ADDWF 0xFE1, F, ACCESS
19A40  0E00     MOVLW 0x0
19A42  22E2     ADDWFC 0xFE2, F, ACCESS
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
19A44  0EFE     MOVLW 0xFE
19A46  6E0B     MOVWF wtemp5, ACCESS
19A48  0EFF     MOVLW 0xFF
19A4A  6E0C     MOVWF 0xC, ACCESS
19A4C  0EF5     MOVLW 0xF5
19A4E  24E1     ADDWF 0xFE1, W, ACCESS
19A50  6E09     MOVWF ltemp2, ACCESS
19A52  0EFF     MOVLW 0xFF
19A54  20E2     ADDWFC 0xFE2, W, ACCESS
19A56  6E0A     MOVWF ttemp3, ACCESS
19A58  500B     MOVF wtemp5, W, ACCESS
19A5A  2609     ADDWF ltemp2, F, ACCESS
19A5C  500C     MOVF 0xC, W, ACCESS
19A5E  220A     ADDWFC ttemp3, F, ACCESS
19A60  0EFF     MOVLW 0xFF
19A64  F02B     NOP
19A66  FFE3     NOP
19A68  0EFE     MOVLW 0xFE
19A6C  F027     NOP
19A6E  FFE3     NOP
16:            	f.buffer = s;
19A70  0EF5     MOVLW 0xF5
19A74  FF8C     NOP
19A76  F00B     NOP
19A78  0EF6     MOVLW 0xF6
19A7C  FF8C     NOP
19A7E  F00C     NOP
19A80  0EF9     MOVLW 0xF9
19A84  F033     NOP
19A86  FFE3     NOP
19A88  0EF8     MOVLW 0xF8
19A8C  F02F     NOP
19A8E  FFE3     NOP
17:            	f.count = 0;
19A90  0EFA     MOVLW 0xFA
19A92  24E1     ADDWF 0xFE1, W, ACCESS
19A94  6ED9     MOVWF 0xFD9, ACCESS
19A96  0EFF     MOVLW 0xFF
19A98  20E2     ADDWFC 0xFE2, W, ACCESS
19A9A  6EDA     MOVWF 0xFDA, ACCESS
19A9C  0E00     MOVLW 0x0
19A9E  6EDE     MOVWF 0xFDE, ACCESS
19AA0  0E00     MOVLW 0x0
19AA2  6EDD     MOVWF 0xFDD, ACCESS
18:            	f.limit = 0;
19AA4  0EFC     MOVLW 0xFC
19AA6  24E1     ADDWF 0xFE1, W, ACCESS
19AA8  6ED9     MOVWF 0xFD9, ACCESS
19AAA  0EFF     MOVLW 0xFF
19AAC  20E2     ADDWFC 0xFE2, W, ACCESS
19AAE  6EDA     MOVWF 0xFDA, ACCESS
19AB0  0E00     MOVLW 0x0
19AB2  6EDE     MOVWF 0xFDE, ACCESS
19AB4  0E00     MOVLW 0x0
19AB6  6EDD     MOVWF 0xFDD, ACCESS
19:            	ret = vfprintf(&f, fmt, ap);
19AB8  0EFE     MOVLW 0xFE
19ABA  24E1     ADDWF 0xFE1, W, ACCESS
19ABC  6E01     MOVWF ltemp0, ACCESS
19ABE  0EFF     MOVLW 0xFF
19AC0  20E2     ADDWFC 0xFE2, W, ACCESS
19AC2  6E02     MOVWF ttemp5, ACCESS
19AC6  F007     NOP
19AC8  FFE6     NOP
19ACC  F00B     NOP
19ACE  FFE6     NOP
19AD0  0EF1     MOVLW 0xF1
19AD4  FF8F     NOP
19AD6  FFE6     NOP
19ADA  FF8F     NOP
19ADC  FFE6     NOP
19ADE  0EF4     MOVLW 0xF4
19AE0  24E1     ADDWF 0xFE1, W, ACCESS
19AE2  6E01     MOVWF ltemp0, ACCESS
19AE4  0EFF     MOVLW 0xFF
19AE6  20E2     ADDWFC 0xFE2, W, ACCESS
19AE8  6E02     MOVWF ttemp5, ACCESS
19AEC  F007     NOP
19AEE  FFE6     NOP
19AF2  F00B     NOP
19AF4  FFE6     NOP
19AF6  ECDE     CALL 0x1A3BC, 0
19AF8  F0D1     NOP
20:            	s[f.count] = '\0';
19AFA  0EFA     MOVLW 0xFA
19AFC  24E1     ADDWF 0xFE1, W, ACCESS
19AFE  6ED9     MOVWF 0xFD9, ACCESS
19B00  0EFF     MOVLW 0xFF
19B02  20E2     ADDWFC 0xFE2, W, ACCESS
19B04  6EDA     MOVWF 0xFDA, ACCESS
19B08  FF78     NOP
19B0A  F00B     NOP
19B0E  FF74     NOP
19B10  F00C     NOP
19B12  0EF5     MOVLW 0xF5
19B16  FF8C     NOP
19B18  F009     NOP
19B1A  0EF6     MOVLW 0xF6
19B1E  FF8C     NOP
19B20  F00A     NOP
19B22  500B     MOVF wtemp5, W, ACCESS
19B24  2409     ADDWF ltemp2, W, ACCESS
19B26  6ED9     MOVWF 0xFD9, ACCESS
19B28  500C     MOVF 0xC, W, ACCESS
19B2A  200A     ADDWFC ttemp3, W, ACCESS
19B2C  6EDA     MOVWF 0xFDA, ACCESS
19B2E  0E00     MOVLW 0x0
19B30  6EDF     MOVWF 0xFDF, ACCESS
21:            	va_end(ap);
22:            	return ret;
23:            }
19B32  0EF8     MOVLW 0xF8
19B34  26E1     ADDWF 0xFE1, F, ACCESS
19B36  0EFF     MOVLW 0xFF
19B38  22E2     ADDWFC 0xFE2, F, ACCESS
19B3A  52E5     MOVF 0xFE5, F, ACCESS
19B3C  50E7     MOVF 0xFE7, W, ACCESS
19B3E  5EE1     SUBWF 0xFE1, F, ACCESS
19B40  0E00     MOVLW 0x0
19B42  5AE2     SUBWFB 0xFE2, F, ACCESS
19B44  0012     RETURN 0
24:            
25:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nf_fputs.c  ----------------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
1A65A  52E6     MOVF 0xFE6, F, ACCESS
1A65C  52E6     MOVF 0xFE6, F, ACCESS
1A65E  52E6     MOVF 0xFE6, F, ACCESS
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
1A660  0EFD     MOVLW 0xFD
1A662  6AE3     CLRF 0xFE3, ACCESS
1A664  0EFE     MOVLW 0xFE
1A666  6AE3     CLRF 0xFE3, ACCESS
14:                while ((c = *(s + i))) {
1A668  D01F     BRA 0xA6A8
1A6A8  0EFD     MOVLW 0xFD
1A6AC  FF8C     NOP
1A6AE  F00B     NOP
1A6B0  0EFE     MOVLW 0xFE
1A6B4  FF8C     NOP
1A6B6  F00C     NOP
1A6B8  0EFB     MOVLW 0xFB
1A6BC  FF8C     NOP
1A6BE  F009     NOP
1A6C0  0EFC     MOVLW 0xFC
1A6C4  FF8C     NOP
1A6C6  F00A     NOP
1A6C8  500B     MOVF wtemp5, W, ACCESS
1A6CA  2409     ADDWF ltemp2, W, ACCESS
1A6CC  6ED9     MOVWF 0xFD9, ACCESS
1A6CE  500C     MOVF 0xC, W, ACCESS
1A6D0  200A     ADDWFC ttemp3, W, ACCESS
1A6D2  6EDA     MOVWF 0xFDA, ACCESS
1A6D4  50DF     MOVF 0xFDF, W, ACCESS
1A6D6  6E0C     MOVWF 0xC, ACCESS
1A6D8  0EFF     MOVLW 0xFF
1A6DC  F033     NOP
1A6DE  FFE3     NOP
1A6E0  0EFF     MOVLW 0xFF
1A6E2  50E3     MOVF 0xFE3, W, ACCESS
1A6E4  A4D8     BTFSS 0xFD8, 2, ACCESS
1A6E6  D7C1     BRA 0xA66A
15:            	fputc(c,fp);
1A66A  0EF9     MOVLW 0xF9
1A66E  FF8F     NOP
1A670  FFE6     NOP
1A674  FF8F     NOP
1A676  FFE6     NOP
1A678  0EFD     MOVLW 0xFD
1A67A  50E3     MOVF 0xFE3, W, ACCESS
1A67C  6EE6     MOVWF 0xFE6, ACCESS
1A67E  0E00     MOVLW 0x0
1A680  6EE6     MOVWF 0xFE6, ACCESS
1A682  EC61     CALL 0x194C2, 0
1A684  F0CA     NOP
16:                    ++i;
1A686  0EFD     MOVLW 0xFD
1A688  50E3     MOVF 0xFE3, W, ACCESS
1A68A  0F01     ADDLW 0x1
1A68C  6E01     MOVWF ltemp0, ACCESS
1A68E  0EFD     MOVLW 0xFD
1A692  F007     NOP
1A694  FFE3     NOP
1A696  6A01     CLRF ltemp0, ACCESS
1A698  0EFE     MOVLW 0xFE
1A69A  50E3     MOVF 0xFE3, W, ACCESS
1A69C  2001     ADDWFC ltemp0, W, ACCESS
1A69E  6E01     MOVWF ltemp0, ACCESS
1A6A0  0EFE     MOVLW 0xFE
1A6A4  F007     NOP
1A6A6  FFE3     NOP
17:                }
18:                return i;
19:            }
1A6E8  0EF9     MOVLW 0xF9
1A6EA  26E1     ADDWF 0xFE1, F, ACCESS
1A6EC  0EFF     MOVLW 0xFF
1A6EE  22E2     ADDWFC 0xFE2, F, ACCESS
1A6F0  0012     RETURN 0
20:            
21:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
194C2  0EFC     MOVLW 0xFC
194C6  FF8C     NOP
194C8  F001     NOP
194CA  0EFD     MOVLW 0xFD
194CC  50E3     MOVF 0xFE3, W, ACCESS
194CE  1001     IORWF ltemp0, W, ACCESS
194D0  B4D8     BTFSC 0xFD8, 2, ACCESS
194D2  D009     BRA 0x94E6
194D4  0EFC     MOVLW 0xFC
194D8  FF8C     NOP
194DA  F001     NOP
194DC  0EFD     MOVLW 0xFD
194DE  50E3     MOVF 0xFE3, W, ACCESS
194E0  1001     IORWF ltemp0, W, ACCESS
194E2  A4D8     BTFSS 0xFD8, 2, ACCESS
194E4  D006     BRA 0x94F2
13:                    putch(c);
194E6  0EFE     MOVLW 0xFE
194E8  50E3     MOVF 0xFE3, W, ACCESS
194EA  6EE6     MOVWF 0xFE6, ACCESS
194EC  EC04     CALL 0x1BC08, 0
194EE  F0DE     NOP
14:                } else {
194F0  D075     BRA 0x95DC
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
194F2  0EFC     MOVLW 0xFC
194F6  FF8C     NOP
194F8  F00B     NOP
194FA  0EFD     MOVLW 0xFD
194FE  FF8C     NOP
19500  F00C     NOP
19502  0E04     MOVLW 0x4
19504  240B     ADDWF wtemp5, W, ACCESS
19506  6ED9     MOVWF 0xFD9, ACCESS
19508  0E00     MOVLW 0x0
1950A  200C     ADDWFC 0xC, W, ACCESS
1950C  6EDA     MOVWF 0xFDA, ACCESS
1950E  50DE     MOVF 0xFDE, W, ACCESS
19510  10DE     IORWF 0xFDE, W, ACCESS
19512  B4D8     BTFSC 0xFD8, 2, ACCESS
19514  D026     BRA 0x9562
19516  0EFC     MOVLW 0xFC
1951A  FF8C     NOP
1951C  F00B     NOP
1951E  0EFD     MOVLW 0xFD
19522  FF8C     NOP
19524  F00C     NOP
19526  0E04     MOVLW 0x4
19528  240B     ADDWF wtemp5, W, ACCESS
1952A  6ED9     MOVWF 0xFD9, ACCESS
1952C  0E00     MOVLW 0x0
1952E  200C     ADDWFC 0xC, W, ACCESS
19530  6EDA     MOVWF 0xFDA, ACCESS
19532  0EFC     MOVLW 0xFC
19536  FF8C     NOP
19538  F00B     NOP
1953A  0EFD     MOVLW 0xFD
1953E  FF8C     NOP
19540  F00C     NOP
19542  0E02     MOVLW 0x2
19544  240B     ADDWF wtemp5, W, ACCESS
19546  6EE9     MOVWF 0xFE9, ACCESS
19548  0E00     MOVLW 0x0
1954A  200C     ADDWFC 0xC, W, ACCESS
1954C  6EEA     MOVWF 0xFEA, ACCESS
1954E  50DE     MOVF 0xFDE, W, ACCESS
19550  5CEE     SUBWF 0xFEE, W, ACCESS
19552  50EE     MOVF 0xFEE, W, ACCESS
19554  0A80     XORLW 0x80
19556  6E01     MOVWF ltemp0, ACCESS
19558  50DE     MOVF 0xFDE, W, ACCESS
1955A  0A80     XORLW 0x80
1955C  5801     SUBWFB ltemp0, W, ACCESS
1955E  B0D8     BTFSC 0xFD8, 0, ACCESS
19560  D03D     BRA 0x95DC
16:            	        fp->buffer[fp->count] = (char)c;
19562  0EFC     MOVLW 0xFC
19566  FF8C     NOP
19568  F00B     NOP
1956A  0EFD     MOVLW 0xFD
1956E  FF8C     NOP
19570  F00C     NOP
19572  0E02     MOVLW 0x2
19574  240B     ADDWF wtemp5, W, ACCESS
19576  6ED9     MOVWF 0xFD9, ACCESS
19578  0E00     MOVLW 0x0
1957A  200C     ADDWFC 0xC, W, ACCESS
1957C  6EDA     MOVWF 0xFDA, ACCESS
19580  FF78     NOP
19582  F00B     NOP
19586  FF74     NOP
19588  F00C     NOP
1958A  0EFC     MOVLW 0xFC
1958E  FF8F     NOP
19590  FFD9     NOP
19592  0EFD     MOVLW 0xFD
19596  FF8F     NOP
19598  FFDA     NOP
1959C  FF78     NOP
1959E  F009     NOP
195A2  FF74     NOP
195A4  F00A     NOP
195A6  500B     MOVF wtemp5, W, ACCESS
195A8  2409     ADDWF ltemp2, W, ACCESS
195AA  6ED9     MOVWF 0xFD9, ACCESS
195AC  500C     MOVF 0xC, W, ACCESS
195AE  200A     ADDWFC ttemp3, W, ACCESS
195B0  6EDA     MOVWF 0xFDA, ACCESS
195B2  0EFE     MOVLW 0xFE
195B6  FF8F     NOP
195B8  FFDF     NOP
17:            		++fp->count;
195BA  0EFC     MOVLW 0xFC
195BE  FF8C     NOP
195C0  F00B     NOP
195C2  0EFD     MOVLW 0xFD
195C6  FF8C     NOP
195C8  F00C     NOP
195CA  0E02     MOVLW 0x2
195CC  240B     ADDWF wtemp5, W, ACCESS
195CE  6ED9     MOVWF 0xFD9, ACCESS
195D0  0E00     MOVLW 0x0
195D2  200C     ADDWFC 0xC, W, ACCESS
195D4  6EDA     MOVWF 0xFDA, ACCESS
195D6  2ADE     INCF 0xFDE, F, ACCESS
195D8  0E00     MOVLW 0x0
195DA  22DD     ADDWFC 0xFDD, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
195DC  52E5     MOVF 0xFE5, F, ACCESS
195DE  52E5     MOVF 0xFE5, F, ACCESS
195E0  52E5     MOVF 0xFE5, F, ACCESS
195E2  52E5     MOVF 0xFE5, F, ACCESS
195E4  0012     RETURN 0
22:            
23:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nanf.c  --------------------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             float nanf(const char *s)
1AD9E  52E6     MOVF 0xFE6, F, ACCESS
1ADA0  52E6     MOVF 0xFE6, F, ACCESS
1ADA2  52E6     MOVF 0xFE6, F, ACCESS
1ADA4  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u;
7:             	u.i = 0x7FFFFFFF;
1ADA6  0EFF     MOVLW 0xFF
1ADA8  6E09     MOVWF ltemp2, ACCESS
1ADAA  0EFF     MOVLW 0xFF
1ADAC  6E0A     MOVWF ttemp3, ACCESS
1ADAE  0EFF     MOVLW 0xFF
1ADB0  6E0B     MOVWF wtemp5, ACCESS
1ADB2  0E7F     MOVLW 0x7F
1ADB4  6E0C     MOVWF 0xC, ACCESS
1ADB6  0EFC     MOVLW 0xFC
1ADBA  F027     NOP
1ADBC  FFE3     NOP
1ADBE  0EFD     MOVLW 0xFD
1ADC2  F02B     NOP
1ADC4  FFE3     NOP
1ADC6  0EFE     MOVLW 0xFE
1ADCA  F02F     NOP
1ADCC  FFE3     NOP
1ADCE  0EFF     MOVLW 0xFF
1ADD2  F033     NOP
1ADD4  FFE3     NOP
8:             	return u.f;
1ADD6  0EFC     MOVLW 0xFC
1ADDA  FF8C     NOP
1ADDC  F001     NOP
1ADDE  0EFD     MOVLW 0xFD
1ADE2  FF8C     NOP
1ADE4  F002     NOP
1ADE6  0EFE     MOVLW 0xFE
1ADEA  FF8C     NOP
1ADEC  F003     NOP
1ADEE  0EFF     MOVLW 0xFF
1ADF2  FF8C     NOP
1ADF4  F004     NOP
9:             }
1ADF6  0EFA     MOVLW 0xFA
1ADF8  26E1     ADDWF 0xFE1, F, ACCESS
1ADFA  0EFF     MOVLW 0xFF
1ADFC  22E2     ADDWFC 0xFE2, F, ACCESS
1ADFE  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/memset.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
16B8A  52E6     MOVF 0xFE6, F, ACCESS
16B8C  52E6     MOVF 0xFE6, F, ACCESS
16B8E  52E6     MOVF 0xFE6, F, ACCESS
16B90  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	unsigned char *s = dest;
16B92  0EFA     MOVLW 0xFA
16B96  FF8C     NOP
16B98  F00B     NOP
16B9A  0EFB     MOVLW 0xFB
16B9E  FF8C     NOP
16BA0  F00C     NOP
16BA2  0EFD     MOVLW 0xFD
16BA6  F033     NOP
16BA8  FFE3     NOP
16BAA  0EFC     MOVLW 0xFC
16BAE  F02F     NOP
16BB0  FFE3     NOP
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
16BB2  0EF6     MOVLW 0xF6
16BB6  FF8C     NOP
16BB8  F001     NOP
16BBA  0EF7     MOVLW 0xF7
16BBC  50E3     MOVF 0xFE3, W, ACCESS
16BBE  1001     IORWF ltemp0, W, ACCESS
16BC0  B4D8     BTFSC 0xFD8, 2, ACCESS
16BC2  D154     BRA 0x6E6C
14:            	s[0] = c;
16BC4  0EFC     MOVLW 0xFC
16BC8  FF8F     NOP
16BCA  FFD9     NOP
16BCC  0EFD     MOVLW 0xFD
16BD0  FF8F     NOP
16BD2  FFDA     NOP
16BD4  0EF8     MOVLW 0xF8
16BD8  FF8F     NOP
16BDA  FFDF     NOP
15:            	s[n-1] = c;
16BDC  0EFC     MOVLW 0xFC
16BE0  FF8C     NOP
16BE2  F00B     NOP
16BE4  0EFD     MOVLW 0xFD
16BE8  FF8C     NOP
16BEA  F00C     NOP
16BEC  0EF6     MOVLW 0xF6
16BEE  50E3     MOVF 0xFE3, W, ACCESS
16BF0  260B     ADDWF wtemp5, F, ACCESS
16BF2  0EF7     MOVLW 0xF7
16BF4  50E3     MOVF 0xFE3, W, ACCESS
16BF6  220C     ADDWFC 0xC, F, ACCESS
16BF8  0EFF     MOVLW 0xFF
16BFA  240B     ADDWF wtemp5, W, ACCESS
16BFC  6ED9     MOVWF 0xFD9, ACCESS
16BFE  0EFF     MOVLW 0xFF
16C00  200C     ADDWFC 0xC, W, ACCESS
16C02  6EDA     MOVWF 0xFDA, ACCESS
16C04  0EF8     MOVLW 0xF8
16C08  FF8F     NOP
16C0A  FFDF     NOP
16:            	if (n <= 2) return dest;
16C0C  0EF7     MOVLW 0xF7
16C0E  50E3     MOVF 0xFE3, W, ACCESS
16C10  E108     BNZ 0x6C22
16C12  0EF6     MOVLW 0xF6
16C16  FF8C     NOP
16C18  F001     NOP
16C1A  0E03     MOVLW 0x3
16C1C  5E01     SUBWF ltemp0, F, ACCESS
16C1E  A0D8     BTFSS 0xFD8, 0, ACCESS
16C20  D125     BRA 0x6E6C
17:            	s[1] = c;
16C22  0EFC     MOVLW 0xFC
16C26  FF8C     NOP
16C28  F00B     NOP
16C2A  0EFD     MOVLW 0xFD
16C2E  FF8C     NOP
16C30  F00C     NOP
16C32  0E01     MOVLW 0x1
16C34  240B     ADDWF wtemp5, W, ACCESS
16C36  6ED9     MOVWF 0xFD9, ACCESS
16C38  0E00     MOVLW 0x0
16C3A  200C     ADDWFC 0xC, W, ACCESS
16C3C  6EDA     MOVWF 0xFDA, ACCESS
16C3E  0EF8     MOVLW 0xF8
16C42  FF8F     NOP
16C44  FFDF     NOP
18:            	s[2] = c;
16C46  0EFC     MOVLW 0xFC
16C4A  FF8C     NOP
16C4C  F00B     NOP
16C4E  0EFD     MOVLW 0xFD
16C52  FF8C     NOP
16C54  F00C     NOP
16C56  0E02     MOVLW 0x2
16C58  240B     ADDWF wtemp5, W, ACCESS
16C5A  6ED9     MOVWF 0xFD9, ACCESS
16C5C  0E00     MOVLW 0x0
16C5E  200C     ADDWFC 0xC, W, ACCESS
16C60  6EDA     MOVWF 0xFDA, ACCESS
16C62  0EF8     MOVLW 0xF8
16C66  FF8F     NOP
16C68  FFDF     NOP
19:            	s[n-2] = c;
16C6A  0EFC     MOVLW 0xFC
16C6E  FF8C     NOP
16C70  F00B     NOP
16C72  0EFD     MOVLW 0xFD
16C76  FF8C     NOP
16C78  F00C     NOP
16C7A  0EF6     MOVLW 0xF6
16C7C  50E3     MOVF 0xFE3, W, ACCESS
16C7E  260B     ADDWF wtemp5, F, ACCESS
16C80  0EF7     MOVLW 0xF7
16C82  50E3     MOVF 0xFE3, W, ACCESS
16C84  220C     ADDWFC 0xC, F, ACCESS
16C86  0EFE     MOVLW 0xFE
16C88  240B     ADDWF wtemp5, W, ACCESS
16C8A  6ED9     MOVWF 0xFD9, ACCESS
16C8C  0EFF     MOVLW 0xFF
16C8E  200C     ADDWFC 0xC, W, ACCESS
16C90  6EDA     MOVWF 0xFDA, ACCESS
16C92  0EF8     MOVLW 0xF8
16C96  FF8F     NOP
16C98  FFDF     NOP
20:            	s[n-3] = c;
16C9A  0EFC     MOVLW 0xFC
16C9E  FF8C     NOP
16CA0  F00B     NOP
16CA2  0EFD     MOVLW 0xFD
16CA6  FF8C     NOP
16CA8  F00C     NOP
16CAA  0EF6     MOVLW 0xF6
16CAC  50E3     MOVF 0xFE3, W, ACCESS
16CAE  260B     ADDWF wtemp5, F, ACCESS
16CB0  0EF7     MOVLW 0xF7
16CB2  50E3     MOVF 0xFE3, W, ACCESS
16CB4  220C     ADDWFC 0xC, F, ACCESS
16CB6  0EFD     MOVLW 0xFD
16CB8  240B     ADDWF wtemp5, W, ACCESS
16CBA  6ED9     MOVWF 0xFD9, ACCESS
16CBC  0EFF     MOVLW 0xFF
16CBE  200C     ADDWFC 0xC, W, ACCESS
16CC0  6EDA     MOVWF 0xFDA, ACCESS
16CC2  0EF8     MOVLW 0xF8
16CC6  FF8F     NOP
16CC8  FFDF     NOP
21:            	if (n <= 6) return dest;
16CCA  0EF7     MOVLW 0xF7
16CCC  50E3     MOVF 0xFE3, W, ACCESS
16CCE  E108     BNZ 0x6CE0
16CD0  0EF6     MOVLW 0xF6
16CD4  FF8C     NOP
16CD6  F001     NOP
16CD8  0E07     MOVLW 0x7
16CDA  5E01     SUBWF ltemp0, F, ACCESS
16CDC  A0D8     BTFSS 0xFD8, 0, ACCESS
16CDE  D0C6     BRA 0x6E6C
22:            	s[3] = c;
16CE0  0EFC     MOVLW 0xFC
16CE4  FF8C     NOP
16CE6  F00B     NOP
16CE8  0EFD     MOVLW 0xFD
16CEC  FF8C     NOP
16CEE  F00C     NOP
16CF0  0E03     MOVLW 0x3
16CF2  240B     ADDWF wtemp5, W, ACCESS
16CF4  6ED9     MOVWF 0xFD9, ACCESS
16CF6  0E00     MOVLW 0x0
16CF8  200C     ADDWFC 0xC, W, ACCESS
16CFA  6EDA     MOVWF 0xFDA, ACCESS
16CFC  0EF8     MOVLW 0xF8
16D00  FF8F     NOP
16D02  FFDF     NOP
23:            	s[n-4] = c;
16D04  0EFC     MOVLW 0xFC
16D08  FF8C     NOP
16D0A  F00B     NOP
16D0C  0EFD     MOVLW 0xFD
16D10  FF8C     NOP
16D12  F00C     NOP
16D14  0EF6     MOVLW 0xF6
16D16  50E3     MOVF 0xFE3, W, ACCESS
16D18  260B     ADDWF wtemp5, F, ACCESS
16D1A  0EF7     MOVLW 0xF7
16D1C  50E3     MOVF 0xFE3, W, ACCESS
16D1E  220C     ADDWFC 0xC, F, ACCESS
16D20  0EFC     MOVLW 0xFC
16D22  240B     ADDWF wtemp5, W, ACCESS
16D24  6ED9     MOVWF 0xFD9, ACCESS
16D26  0EFF     MOVLW 0xFF
16D28  200C     ADDWFC 0xC, W, ACCESS
16D2A  6EDA     MOVWF 0xFDA, ACCESS
16D2C  0EF8     MOVLW 0xF8
16D30  FF8F     NOP
16D32  FFDF     NOP
24:            	if (n <= 8) return dest;
16D34  0EF7     MOVLW 0xF7
16D36  50E3     MOVF 0xFE3, W, ACCESS
16D38  E108     BNZ 0x6D4A
16D3A  0EF6     MOVLW 0xF6
16D3E  FF8C     NOP
16D40  F001     NOP
16D42  0E09     MOVLW 0x9
16D44  5E01     SUBWF ltemp0, F, ACCESS
16D46  A0D8     BTFSS 0xFD8, 0, ACCESS
16D48  D091     BRA 0x6E6C
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
16D4A  0EFC     MOVLW 0xFC
16D4E  FF8C     NOP
16D50  F00B     NOP
16D52  1E0B     COMF wtemp5, F, ACCESS
16D54  0EFD     MOVLW 0xFD
16D58  FF8C     NOP
16D5A  F00C     NOP
16D5C  1E0C     COMF 0xC, F, ACCESS
16D5E  2A0B     INCF wtemp5, F, ACCESS
16D60  B4D8     BTFSC 0xFD8, 2, ACCESS
16D62  2A0C     INCF 0xC, F, ACCESS
16D64  0E03     MOVLW 0x3
16D66  160B     ANDWF wtemp5, F, ACCESS
16D68  0E00     MOVLW 0x0
16D6A  160C     ANDWF 0xC, F, ACCESS
16D6C  0EFE     MOVLW 0xFE
16D70  F02F     NOP
16D72  FFE3     NOP
16D74  0EFF     MOVLW 0xFF
16D78  F033     NOP
16D7A  FFE3     NOP
32:            	s += k;
16D7C  0EFC     MOVLW 0xFC
16D7E  50E3     MOVF 0xFE3, W, ACCESS
16D80  6E01     MOVWF ltemp0, ACCESS
16D82  0EFE     MOVLW 0xFE
16D84  50E3     MOVF 0xFE3, W, ACCESS
16D86  2601     ADDWF ltemp0, F, ACCESS
16D88  0EFC     MOVLW 0xFC
16D8C  F007     NOP
16D8E  FFE3     NOP
16D90  0EFD     MOVLW 0xFD
16D92  50E3     MOVF 0xFE3, W, ACCESS
16D94  6E01     MOVWF ltemp0, ACCESS
16D96  0EFF     MOVLW 0xFF
16D98  50E3     MOVF 0xFE3, W, ACCESS
16D9A  2201     ADDWFC ltemp0, F, ACCESS
16D9C  0EFD     MOVLW 0xFD
16DA0  F007     NOP
16DA2  FFE3     NOP
33:            	n -= k;
16DA4  0EF6     MOVLW 0xF6
16DA6  50E3     MOVF 0xFE3, W, ACCESS
16DA8  6E01     MOVWF ltemp0, ACCESS
16DAA  0EFE     MOVLW 0xFE
16DAC  50E3     MOVF 0xFE3, W, ACCESS
16DAE  5E01     SUBWF ltemp0, F, ACCESS
16DB0  0EF6     MOVLW 0xF6
16DB4  F007     NOP
16DB6  FFE3     NOP
16DB8  0EF7     MOVLW 0xF7
16DBA  50E3     MOVF 0xFE3, W, ACCESS
16DBC  6E01     MOVWF ltemp0, ACCESS
16DBE  0EFF     MOVLW 0xFF
16DC0  50E3     MOVF 0xFE3, W, ACCESS
16DC2  5A01     SUBWFB ltemp0, F, ACCESS
16DC4  0EF7     MOVLW 0xF7
16DC8  F007     NOP
16DCA  FFE3     NOP
34:            	n &= -4;
16DCC  0EFC     MOVLW 0xFC
16DCE  6E0B     MOVWF wtemp5, ACCESS
16DD0  0EFF     MOVLW 0xFF
16DD2  6E0C     MOVWF 0xC, ACCESS
16DD4  0EF6     MOVLW 0xF6
16DD8  FF8C     NOP
16DDA  F001     NOP
16DDC  500B     MOVF wtemp5, W, ACCESS
16DDE  1601     ANDWF ltemp0, F, ACCESS
16DE0  0EF6     MOVLW 0xF6
16DE4  F007     NOP
16DE6  FFE3     NOP
16DE8  0EF7     MOVLW 0xF7
16DEC  FF8C     NOP
16DEE  F001     NOP
16DF0  500C     MOVF 0xC, W, ACCESS
16DF2  1601     ANDWF ltemp0, F, ACCESS
16DF4  0EF7     MOVLW 0xF7
16DF6  D02E     BRA 0x6E54
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = c;
16DF8  0EFC     MOVLW 0xFC
16DFC  FF8F     NOP
16DFE  FFD9     NOP
16E00  0EFD     MOVLW 0xFD
16E04  FF8F     NOP
16E06  FFDA     NOP
16E08  0EF8     MOVLW 0xF8
16E0C  FF8F     NOP
16E0E  FFDF     NOP
16E10  0EF6     MOVLW 0xF6
16E14  FF8C     NOP
16E16  F001     NOP
16E18  0E01     MOVLW 0x1
16E1A  5E01     SUBWF ltemp0, F, ACCESS
16E1C  0EF6     MOVLW 0xF6
16E20  F007     NOP
16E22  FFE3     NOP
16E24  0EF7     MOVLW 0xF7
16E28  FF8C     NOP
16E2A  F001     NOP
16E2C  0E00     MOVLW 0x0
16E2E  5A01     SUBWFB ltemp0, F, ACCESS
16E30  0EF7     MOVLW 0xF7
16E34  F007     NOP
16E36  FFE3     NOP
16E38  0EFC     MOVLW 0xFC
16E3A  50E3     MOVF 0xFE3, W, ACCESS
16E3C  0F01     ADDLW 0x1
16E3E  6E01     MOVWF ltemp0, ACCESS
16E40  0EFC     MOVLW 0xFC
16E44  F007     NOP
16E46  FFE3     NOP
16E48  6A01     CLRF ltemp0, ACCESS
16E4A  0EFD     MOVLW 0xFD
16E4C  50E3     MOVF 0xFE3, W, ACCESS
16E4E  2001     ADDWFC ltemp0, W, ACCESS
16E50  6E01     MOVWF ltemp0, ACCESS
16E52  0EFD     MOVLW 0xFD
16E56  F007     NOP
16E58  FFE3     NOP
16E5A  0EF6     MOVLW 0xF6
16E5E  FF8C     NOP
16E60  F001     NOP
16E62  0EF7     MOVLW 0xF7
16E64  50E3     MOVF 0xFE3, W, ACCESS
16E66  1001     IORWF ltemp0, W, ACCESS
16E68  A4D8     BTFSS 0xFD8, 2, ACCESS
16E6A  D7C6     BRA 0x6DF8
87:            #endif
88:            
89:            	return dest;
90:            }
16E6C  0EF6     MOVLW 0xF6
16E6E  26E1     ADDWF 0xFE1, F, ACCESS
16E70  0EFF     MOVLW 0xFF
16E72  22E2     ADDWFC 0xFE2, F, ACCESS
16E74  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/lomod.c  -------------------------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
19114  52E6     MOVF 0xFE6, F, ACCESS
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
19116  0EEF     MOVLW 0xEF
19118  50E3     MOVF 0xFE3, W, ACCESS
1911A  E116     BNZ 0x9148
1911C  0EF0     MOVLW 0xF0
1911E  50E3     MOVF 0xFE3, W, ACCESS
19120  E113     BNZ 0x9148
19122  0EF1     MOVLW 0xF1
19124  50E3     MOVF 0xFE3, W, ACCESS
19126  E110     BNZ 0x9148
19128  0EF2     MOVLW 0xF2
1912A  50E3     MOVF 0xFE3, W, ACCESS
1912C  E10D     BNZ 0x9148
1912E  0EF3     MOVLW 0xF3
19130  50E3     MOVF 0xFE3, W, ACCESS
19132  E10A     BNZ 0x9148
19134  0EF4     MOVLW 0xF4
19136  50E3     MOVF 0xFE3, W, ACCESS
19138  E107     BNZ 0x9148
1913A  0EF5     MOVLW 0xF5
1913C  50E3     MOVF 0xFE3, W, ACCESS
1913E  E104     BNZ 0x9148
19140  0EF6     MOVLW 0xF6
19142  50E3     MOVF 0xFE3, W, ACCESS
19144  B4D8     BTFSC 0xFD8, 2, ACCESS
19146  D075     BRA 0x9232
15:            		counter = 1;
19148  0EFF     MOVLW 0xFF
1914A  6AE3     CLRF 0xFE3, ACCESS
1914C  D012     BRA 0x9172
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
19174  0EF6     MOVLW 0xF6
19176  AEE3     BTFSS 0xFE3, 7, ACCESS
19178  D7EA     BRA 0x914E
17:            			divisor <<= 1;
1914E  90D8     BCF 0xFD8, 0, ACCESS
19150  0EEF     MOVLW 0xEF
19152  36E3     RLCF 0xFE3, F, ACCESS
19154  0EF0     MOVLW 0xF0
19156  36E3     RLCF 0xFE3, F, ACCESS
19158  0EF1     MOVLW 0xF1
1915A  36E3     RLCF 0xFE3, F, ACCESS
1915C  0EF2     MOVLW 0xF2
1915E  36E3     RLCF 0xFE3, F, ACCESS
19160  0EF3     MOVLW 0xF3
19162  36E3     RLCF 0xFE3, F, ACCESS
19164  0EF4     MOVLW 0xF4
19166  36E3     RLCF 0xFE3, F, ACCESS
19168  0EF5     MOVLW 0xF5
1916A  36E3     RLCF 0xFE3, F, ACCESS
1916C  0EF6     MOVLW 0xF6
1916E  36E3     RLCF 0xFE3, F, ACCESS
18:            			counter++;
19170  0EFF     MOVLW 0xFF
19172  2AE3     INCF 0xFE3, F, ACCESS
19:            		}
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
1917A  50E1     MOVF 0xFE1, W, ACCESS
1917C  0FF7     ADDLW 0xF7
1917E  6ED9     MOVWF 0xFD9, ACCESS
19180  50E2     MOVF 0xFE2, W, ACCESS
19182  6EDA     MOVWF 0xFDA, ACCESS
19184  0EFF     MOVLW 0xFF
19186  22DA     ADDWFC 0xFDA, F, ACCESS
19188  0EEF     MOVLW 0xEF
1918A  50E3     MOVF 0xFE3, W, ACCESS
1918C  5CDE     SUBWF 0xFDE, W, ACCESS
1918E  0EF0     MOVLW 0xF0
19190  50E3     MOVF 0xFE3, W, ACCESS
19192  58DE     SUBWFB 0xFDE, W, ACCESS
19194  0EF1     MOVLW 0xF1
19196  50E3     MOVF 0xFE3, W, ACCESS
19198  58DE     SUBWFB 0xFDE, W, ACCESS
1919A  0EF2     MOVLW 0xF2
1919C  50E3     MOVF 0xFE3, W, ACCESS
1919E  58DE     SUBWFB 0xFDE, W, ACCESS
191A0  0EF3     MOVLW 0xF3
191A2  50E3     MOVF 0xFE3, W, ACCESS
191A4  58DE     SUBWFB 0xFDE, W, ACCESS
191A6  0EF4     MOVLW 0xF4
191A8  50E3     MOVF 0xFE3, W, ACCESS
191AA  58DE     SUBWFB 0xFDE, W, ACCESS
191AC  0EF5     MOVLW 0xF5
191AE  50E3     MOVF 0xFE3, W, ACCESS
191B0  58DE     SUBWFB 0xFDE, W, ACCESS
191B2  0EF6     MOVLW 0xF6
191B4  50E3     MOVF 0xFE3, W, ACCESS
191B6  58DE     SUBWFB 0xFDE, W, ACCESS
191B8  A0D8     BTFSS 0xFD8, 0, ACCESS
191BA  D01F     BRA 0x91FA
22:            				dividend -= divisor;
191BC  50E1     MOVF 0xFE1, W, ACCESS
191BE  0FF7     ADDLW 0xF7
191C0  6ED9     MOVWF 0xFD9, ACCESS
191C2  50E2     MOVF 0xFE2, W, ACCESS
191C4  6EDA     MOVWF 0xFDA, ACCESS
191C6  0EFF     MOVLW 0xFF
191C8  22DA     ADDWFC 0xFDA, F, ACCESS
191CA  0EEF     MOVLW 0xEF
191CC  50E3     MOVF 0xFE3, W, ACCESS
191CE  5EDE     SUBWF 0xFDE, F, ACCESS
191D0  0EF0     MOVLW 0xF0
191D2  50E3     MOVF 0xFE3, W, ACCESS
191D4  5ADE     SUBWFB 0xFDE, F, ACCESS
191D6  0EF1     MOVLW 0xF1
191D8  50E3     MOVF 0xFE3, W, ACCESS
191DA  5ADE     SUBWFB 0xFDE, F, ACCESS
191DC  0EF2     MOVLW 0xF2
191DE  50E3     MOVF 0xFE3, W, ACCESS
191E0  5ADE     SUBWFB 0xFDE, F, ACCESS
191E2  0EF3     MOVLW 0xF3
191E4  50E3     MOVF 0xFE3, W, ACCESS
191E6  5ADE     SUBWFB 0xFDE, F, ACCESS
191E8  0EF4     MOVLW 0xF4
191EA  50E3     MOVF 0xFE3, W, ACCESS
191EC  5ADE     SUBWFB 0xFDE, F, ACCESS
191EE  0EF5     MOVLW 0xF5
191F0  50E3     MOVF 0xFE3, W, ACCESS
191F2  5ADE     SUBWFB 0xFDE, F, ACCESS
191F4  0EF6     MOVLW 0xF6
191F6  50E3     MOVF 0xFE3, W, ACCESS
191F8  5ADE     SUBWFB 0xFDE, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
191FA  90D8     BCF 0xFD8, 0, ACCESS
191FC  0EF6     MOVLW 0xF6
191FE  32E3     RRCF 0xFE3, F, ACCESS
19200  0EF5     MOVLW 0xF5
19202  32E3     RRCF 0xFE3, F, ACCESS
19204  0EF4     MOVLW 0xF4
19206  32E3     RRCF 0xFE3, F, ACCESS
19208  0EF3     MOVLW 0xF3
1920A  32E3     RRCF 0xFE3, F, ACCESS
1920C  0EF2     MOVLW 0xF2
1920E  32E3     RRCF 0xFE3, F, ACCESS
19210  0EF1     MOVLW 0xF1
19212  32E3     RRCF 0xFE3, F, ACCESS
19214  0EF0     MOVLW 0xF0
19216  32E3     RRCF 0xFE3, F, ACCESS
19218  0EEF     MOVLW 0xEF
1921A  32E3     RRCF 0xFE3, F, ACCESS
24:            		} while(--counter != 0);
1921C  0EFF     MOVLW 0xFF
1921E  50E3     MOVF 0xFE3, W, ACCESS
19220  6E01     MOVWF ltemp0, ACCESS
19222  0E01     MOVLW 0x1
19224  5E01     SUBWF ltemp0, F, ACCESS
19226  0EFF     MOVLW 0xFF
1922A  F007     NOP
1922C  FFE3     NOP
1922E  A4D8     BTFSS 0xFD8, 2, ACCESS
19230  D7A4     BRA 0x917A
25:            	}
26:            	return dividend;
19232  0EF7     MOVLW 0xF7
19234  24E1     ADDWF 0xFE1, W, ACCESS
19236  6ED9     MOVWF 0xFD9, ACCESS
19238  0EFF     MOVLW 0xFF
1923A  20E2     ADDWFC 0xFE2, W, ACCESS
1923C  6EDA     MOVWF 0xFDA, ACCESS
1923E  0E08     MOVLW 0x8
19240  6E01     MOVWF ltemp0, ACCESS
19242  0EF7     MOVLW 0xF7
19246  FF7B     NOP
19248  FFE3     NOP
1924A  28E8     INCF 0xFE8, W, ACCESS
1924C  2E01     DECFSZ ltemp0, F, ACCESS
1924E  D7FA     BRA 0x9244
27:            }
19250  52E5     MOVF 0xFE5, F, ACCESS
19252  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/lodiv.c  -------------------------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
18A10  0E09     MOVLW 0x9
18A12  26E1     ADDWF 0xFE1, F, ACCESS
18A14  0E00     MOVLW 0x0
18A16  22E2     ADDWFC 0xFE2, F, ACCESS
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
18A18  0E07     MOVLW 0x7
18A1A  6E01     MOVWF ltemp0, ACCESS
18A1C  0EF7     MOVLW 0xF7
18A1E  6AE3     CLRF 0xFE3, ACCESS
18A20  2AE8     INCF 0xFE8, F, ACCESS
18A22  0601     DECF ltemp0, F, ACCESS
18A24  E2FC     BC 0x8A1E
16:            	if(divisor != 0) {
18A26  0EE7     MOVLW 0xE7
18A28  50E3     MOVF 0xFE3, W, ACCESS
18A2A  E116     BNZ 0x8A58
18A2C  0EE8     MOVLW 0xE8
18A2E  50E3     MOVF 0xFE3, W, ACCESS
18A30  E113     BNZ 0x8A58
18A32  0EE9     MOVLW 0xE9
18A34  50E3     MOVF 0xFE3, W, ACCESS
18A36  E110     BNZ 0x8A58
18A38  0EEA     MOVLW 0xEA
18A3A  50E3     MOVF 0xFE3, W, ACCESS
18A3C  E10D     BNZ 0x8A58
18A3E  0EEB     MOVLW 0xEB
18A40  50E3     MOVF 0xFE3, W, ACCESS
18A42  E10A     BNZ 0x8A58
18A44  0EEC     MOVLW 0xEC
18A46  50E3     MOVF 0xFE3, W, ACCESS
18A48  E107     BNZ 0x8A58
18A4A  0EED     MOVLW 0xED
18A4C  50E3     MOVF 0xFE3, W, ACCESS
18A4E  E104     BNZ 0x8A58
18A50  0EEE     MOVLW 0xEE
18A52  50E3     MOVF 0xFE3, W, ACCESS
18A54  B4D8     BTFSC 0xFD8, 2, ACCESS
18A56  D088     BRA 0x8B68
17:            		counter = 1;
18A58  0EFF     MOVLW 0xFF
18A5A  6AE3     CLRF 0xFE3, ACCESS
18A5C  D012     BRA 0x8A82
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
18A84  0EEE     MOVLW 0xEE
18A86  AEE3     BTFSS 0xFE3, 7, ACCESS
18A88  D7EA     BRA 0x8A5E
19:            			divisor <<= 1;
18A5E  90D8     BCF 0xFD8, 0, ACCESS
18A60  0EE7     MOVLW 0xE7
18A62  36E3     RLCF 0xFE3, F, ACCESS
18A64  0EE8     MOVLW 0xE8
18A66  36E3     RLCF 0xFE3, F, ACCESS
18A68  0EE9     MOVLW 0xE9
18A6A  36E3     RLCF 0xFE3, F, ACCESS
18A6C  0EEA     MOVLW 0xEA
18A6E  36E3     RLCF 0xFE3, F, ACCESS
18A70  0EEB     MOVLW 0xEB
18A72  36E3     RLCF 0xFE3, F, ACCESS
18A74  0EEC     MOVLW 0xEC
18A76  36E3     RLCF 0xFE3, F, ACCESS
18A78  0EED     MOVLW 0xED
18A7A  36E3     RLCF 0xFE3, F, ACCESS
18A7C  0EEE     MOVLW 0xEE
18A7E  36E3     RLCF 0xFE3, F, ACCESS
20:            			counter++;
18A80  0EFF     MOVLW 0xFF
18A82  2AE3     INCF 0xFE3, F, ACCESS
21:            		}
22:            		do {
23:            			quotient <<= 1;
18A8A  90D8     BCF 0xFD8, 0, ACCESS
18A8C  0EF7     MOVLW 0xF7
18A8E  36E3     RLCF 0xFE3, F, ACCESS
18A90  0EF8     MOVLW 0xF8
18A92  36E3     RLCF 0xFE3, F, ACCESS
18A94  0EF9     MOVLW 0xF9
18A96  36E3     RLCF 0xFE3, F, ACCESS
18A98  0EFA     MOVLW 0xFA
18A9A  36E3     RLCF 0xFE3, F, ACCESS
18A9C  0EFB     MOVLW 0xFB
18A9E  36E3     RLCF 0xFE3, F, ACCESS
18AA0  0EFC     MOVLW 0xFC
18AA2  36E3     RLCF 0xFE3, F, ACCESS
18AA4  0EFD     MOVLW 0xFD
18AA6  36E3     RLCF 0xFE3, F, ACCESS
18AA8  0EFE     MOVLW 0xFE
18AAA  36E3     RLCF 0xFE3, F, ACCESS
24:            			if(divisor <= dividend) {
18AAC  50E1     MOVF 0xFE1, W, ACCESS
18AAE  0FEF     ADDLW 0xEF
18AB0  6ED9     MOVWF 0xFD9, ACCESS
18AB2  50E2     MOVF 0xFE2, W, ACCESS
18AB4  6EDA     MOVWF 0xFDA, ACCESS
18AB6  0EFF     MOVLW 0xFF
18AB8  22DA     ADDWFC 0xFDA, F, ACCESS
18ABA  0EE7     MOVLW 0xE7
18ABC  50E3     MOVF 0xFE3, W, ACCESS
18ABE  5CDE     SUBWF 0xFDE, W, ACCESS
18AC0  0EE8     MOVLW 0xE8
18AC2  50E3     MOVF 0xFE3, W, ACCESS
18AC4  58DE     SUBWFB 0xFDE, W, ACCESS
18AC6  0EE9     MOVLW 0xE9
18AC8  50E3     MOVF 0xFE3, W, ACCESS
18ACA  58DE     SUBWFB 0xFDE, W, ACCESS
18ACC  0EEA     MOVLW 0xEA
18ACE  50E3     MOVF 0xFE3, W, ACCESS
18AD0  58DE     SUBWFB 0xFDE, W, ACCESS
18AD2  0EEB     MOVLW 0xEB
18AD4  50E3     MOVF 0xFE3, W, ACCESS
18AD6  58DE     SUBWFB 0xFDE, W, ACCESS
18AD8  0EEC     MOVLW 0xEC
18ADA  50E3     MOVF 0xFE3, W, ACCESS
18ADC  58DE     SUBWFB 0xFDE, W, ACCESS
18ADE  0EED     MOVLW 0xED
18AE0  50E3     MOVF 0xFE3, W, ACCESS
18AE2  58DE     SUBWFB 0xFDE, W, ACCESS
18AE4  0EEE     MOVLW 0xEE
18AE6  50E3     MOVF 0xFE3, W, ACCESS
18AE8  58DE     SUBWFB 0xFDE, W, ACCESS
18AEA  A0D8     BTFSS 0xFD8, 0, ACCESS
18AEC  D021     BRA 0x8B30
25:            				dividend -= divisor;
18AEE  50E1     MOVF 0xFE1, W, ACCESS
18AF0  0FEF     ADDLW 0xEF
18AF2  6ED9     MOVWF 0xFD9, ACCESS
18AF4  50E2     MOVF 0xFE2, W, ACCESS
18AF6  6EDA     MOVWF 0xFDA, ACCESS
18AF8  0EFF     MOVLW 0xFF
18AFA  22DA     ADDWFC 0xFDA, F, ACCESS
18AFC  0EE7     MOVLW 0xE7
18AFE  50E3     MOVF 0xFE3, W, ACCESS
18B00  5EDE     SUBWF 0xFDE, F, ACCESS
18B02  0EE8     MOVLW 0xE8
18B04  50E3     MOVF 0xFE3, W, ACCESS
18B06  5ADE     SUBWFB 0xFDE, F, ACCESS
18B08  0EE9     MOVLW 0xE9
18B0A  50E3     MOVF 0xFE3, W, ACCESS
18B0C  5ADE     SUBWFB 0xFDE, F, ACCESS
18B0E  0EEA     MOVLW 0xEA
18B10  50E3     MOVF 0xFE3, W, ACCESS
18B12  5ADE     SUBWFB 0xFDE, F, ACCESS
18B14  0EEB     MOVLW 0xEB
18B16  50E3     MOVF 0xFE3, W, ACCESS
18B18  5ADE     SUBWFB 0xFDE, F, ACCESS
18B1A  0EEC     MOVLW 0xEC
18B1C  50E3     MOVF 0xFE3, W, ACCESS
18B1E  5ADE     SUBWFB 0xFDE, F, ACCESS
18B20  0EED     MOVLW 0xED
18B22  50E3     MOVF 0xFE3, W, ACCESS
18B24  5ADE     SUBWFB 0xFDE, F, ACCESS
18B26  0EEE     MOVLW 0xEE
18B28  50E3     MOVF 0xFE3, W, ACCESS
18B2A  5ADE     SUBWFB 0xFDE, F, ACCESS
26:            				quotient |= 1;
18B2C  0EF7     MOVLW 0xF7
18B2E  80E3     BSF 0xFE3, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
18B30  90D8     BCF 0xFD8, 0, ACCESS
18B32  0EEE     MOVLW 0xEE
18B34  32E3     RRCF 0xFE3, F, ACCESS
18B36  0EED     MOVLW 0xED
18B38  32E3     RRCF 0xFE3, F, ACCESS
18B3A  0EEC     MOVLW 0xEC
18B3C  32E3     RRCF 0xFE3, F, ACCESS
18B3E  0EEB     MOVLW 0xEB
18B40  32E3     RRCF 0xFE3, F, ACCESS
18B42  0EEA     MOVLW 0xEA
18B44  32E3     RRCF 0xFE3, F, ACCESS
18B46  0EE9     MOVLW 0xE9
18B48  32E3     RRCF 0xFE3, F, ACCESS
18B4A  0EE8     MOVLW 0xE8
18B4C  32E3     RRCF 0xFE3, F, ACCESS
18B4E  0EE7     MOVLW 0xE7
18B50  32E3     RRCF 0xFE3, F, ACCESS
29:            		} while(--counter != 0);
18B52  0EFF     MOVLW 0xFF
18B54  50E3     MOVF 0xFE3, W, ACCESS
18B56  6E01     MOVWF ltemp0, ACCESS
18B58  0E01     MOVLW 0x1
18B5A  5E01     SUBWF ltemp0, F, ACCESS
18B5C  0EFF     MOVLW 0xFF
18B60  F007     NOP
18B62  FFE3     NOP
18B64  A4D8     BTFSS 0xFD8, 2, ACCESS
18B66  D791     BRA 0x8A8A
30:            	}
31:            	return quotient;
18B68  0EF7     MOVLW 0xF7
18B6A  24E1     ADDWF 0xFE1, W, ACCESS
18B6C  6ED9     MOVWF 0xFD9, ACCESS
18B6E  0EFF     MOVLW 0xFF
18B70  20E2     ADDWFC 0xFE2, W, ACCESS
18B72  6EDA     MOVWF 0xFDA, ACCESS
18B74  0E08     MOVLW 0x8
18B76  6E01     MOVWF ltemp0, ACCESS
18B78  0EEF     MOVLW 0xEF
18B7C  FF7B     NOP
18B7E  FFE3     NOP
18B80  28E8     INCF 0xFE8, W, ACCESS
18B82  2E01     DECFSZ ltemp0, F, ACCESS
18B84  D7FA     BRA 0x8B7A
32:            }
18B86  0EF7     MOVLW 0xF7
18B88  26E1     ADDWF 0xFE1, F, ACCESS
18B8A  0EFF     MOVLW 0xFF
18B8C  22E2     ADDWFC 0xFE2, F, ACCESS
18B8E  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
1B630  0EFE     MOVLW 0xFE
1B632  50E3     MOVF 0xFE3, W, ACCESS
1B634  0FBF     ADDLW 0xBF
1B636  6E0B     MOVWF wtemp5, ACCESS
1B638  0EFF     MOVLW 0xFF
1B63C  FF8C     NOP
1B63E  F00C     NOP
1B640  0EFF     MOVLW 0xFF
1B642  220C     ADDWFC 0xC, F, ACCESS
1B644  500C     MOVF 0xC, W, ACCESS
1B646  E106     BNZ 0xB654
1B648  0E1A     MOVLW 0x1A
1B64A  5C0B     SUBWF wtemp5, W, ACCESS
1B64C  B0D8     BTFSC 0xFD8, 0, ACCESS
1B64E  D002     BRA 0xB654
1B650  0E01     MOVLW 0x1
1B652  D001     BRA 0xB656
1B654  0E00     MOVLW 0x0
1B656  6E01     MOVWF ltemp0, ACCESS
1B658  6A02     CLRF ttemp5, ACCESS
8:             }
1B65A  52E5     MOVF 0xFE5, F, ACCESS
1B65C  52E5     MOVF 0xFE5, F, ACCESS
1B65E  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isspace.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
1AF66  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
1AF68  0EFF     MOVLW 0xFF
1AF6A  6AE3     CLRF 0xFE3, ACCESS
1AF6C  2AE3     INCF 0xFE3, F, ACCESS
1AF6E  0EFD     MOVLW 0xFD
1AF72  FF8C     NOP
1AF74  F001     NOP
1AF76  0E20     MOVLW 0x20
1AF78  1801     XORWF ltemp0, W, ACCESS
1AF7A  E104     BNZ 0xAF84
1AF7C  0EFE     MOVLW 0xFE
1AF7E  50E3     MOVF 0xFE3, W, ACCESS
1AF80  B4D8     BTFSC 0xFD8, 2, ACCESS
1AF82  D012     BRA 0xAFA8
1AF84  0EFD     MOVLW 0xFD
1AF86  50E3     MOVF 0xFE3, W, ACCESS
1AF88  0FF7     ADDLW 0xF7
1AF8A  6E0B     MOVWF wtemp5, ACCESS
1AF8C  0EFE     MOVLW 0xFE
1AF90  FF8C     NOP
1AF92  F00C     NOP
1AF94  0EFF     MOVLW 0xFF
1AF96  220C     ADDWFC 0xC, F, ACCESS
1AF98  500C     MOVF 0xC, W, ACCESS
1AF9A  E104     BNZ 0xAFA4
1AF9C  0E05     MOVLW 0x5
1AF9E  5C0B     SUBWF wtemp5, W, ACCESS
1AFA0  A0D8     BTFSS 0xFD8, 0, ACCESS
1AFA2  D002     BRA 0xAFA8
1AFA4  0EFF     MOVLW 0xFF
1AFA6  6AE3     CLRF 0xFE3, ACCESS
1AFA8  0EFF     MOVLW 0xFF
1AFAA  50E3     MOVF 0xFE3, W, ACCESS
1AFAC  6E01     MOVWF ltemp0, ACCESS
1AFAE  6A02     CLRF ttemp5, ACCESS
8:             }
1AFB0  52E5     MOVF 0xFE5, F, ACCESS
1AFB2  52E5     MOVF 0xFE5, F, ACCESS
1AFB4  52E5     MOVF 0xFE5, F, ACCESS
1AFB6  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/islower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
6:             {
7:             	return (unsigned)c-'a' < 26;
1B600  0EFE     MOVLW 0xFE
1B602  50E3     MOVF 0xFE3, W, ACCESS
1B604  0F9F     ADDLW 0x9F
1B606  6E0B     MOVWF wtemp5, ACCESS
1B608  0EFF     MOVLW 0xFF
1B60C  FF8C     NOP
1B60E  F00C     NOP
1B610  0EFF     MOVLW 0xFF
1B612  220C     ADDWFC 0xC, F, ACCESS
1B614  500C     MOVF 0xC, W, ACCESS
1B616  E106     BNZ 0xB624
1B618  0E1A     MOVLW 0x1A
1B61A  5C0B     SUBWF wtemp5, W, ACCESS
1B61C  B0D8     BTFSC 0xFD8, 0, ACCESS
1B61E  D002     BRA 0xB624
1B620  0E01     MOVLW 0x1
1B622  D001     BRA 0xB626
1B624  0E00     MOVLW 0x0
1B626  6E01     MOVWF ltemp0, ACCESS
1B628  6A02     CLRF ttemp5, ACCESS
8:             }
1B62A  52E5     MOVF 0xFE5, F, ACCESS
1B62C  52E5     MOVF 0xFE5, F, ACCESS
1B62E  0012     RETURN 0
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isdigit.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
1B660  0EFE     MOVLW 0xFE
1B662  50E3     MOVF 0xFE3, W, ACCESS
1B664  0FD0     ADDLW 0xD0
1B666  6E0B     MOVWF wtemp5, ACCESS
1B668  0EFF     MOVLW 0xFF
1B66C  FF8C     NOP
1B66E  F00C     NOP
1B670  0EFF     MOVLW 0xFF
1B672  220C     ADDWFC 0xC, F, ACCESS
1B674  500C     MOVF 0xC, W, ACCESS
1B676  E106     BNZ 0xB684
1B678  0E0A     MOVLW 0xA
1B67A  5C0B     SUBWF wtemp5, W, ACCESS
1B67C  B0D8     BTFSC 0xFD8, 0, ACCESS
1B67E  D002     BRA 0xB684
1B680  0E01     MOVLW 0x1
1B682  D001     BRA 0xB686
1B684  0E00     MOVLW 0x0
1B686  6E01     MOVWF ltemp0, ACCESS
1B688  6A02     CLRF ttemp5, ACCESS
8:             }
1B68A  52E5     MOVF 0xFE5, F, ACCESS
1B68C  52E5     MOVF 0xFE5, F, ACCESS
1B68E  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isalpha.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
1B24E  0E9F     MOVLW 0x9F
1B250  6E0B     MOVWF wtemp5, ACCESS
1B252  0EFF     MOVLW 0xFF
1B254  6E0C     MOVWF 0xC, ACCESS
1B256  0EFE     MOVLW 0xFE
1B25A  FF8C     NOP
1B25C  F009     NOP
1B25E  0EFF     MOVLW 0xFF
1B262  FF8C     NOP
1B264  F00A     NOP
1B266  0E20     MOVLW 0x20
1B268  1209     IORWF ltemp2, F, ACCESS
1B26A  0E00     MOVLW 0x0
1B26C  120A     IORWF ttemp3, F, ACCESS
1B26E  500B     MOVF wtemp5, W, ACCESS
1B270  2609     ADDWF ltemp2, F, ACCESS
1B272  500C     MOVF 0xC, W, ACCESS
1B274  220A     ADDWFC ttemp3, F, ACCESS
1B276  500A     MOVF ttemp3, W, ACCESS
1B278  E106     BNZ 0xB286
1B27A  0E1A     MOVLW 0x1A
1B27C  5C09     SUBWF ltemp2, W, ACCESS
1B27E  B0D8     BTFSC 0xFD8, 0, ACCESS
1B280  D002     BRA 0xB286
1B282  0E01     MOVLW 0x1
1B284  D001     BRA 0xB288
1B286  0E00     MOVLW 0x0
1B288  6E01     MOVWF ltemp0, ACCESS
1B28A  6A02     CLRF ttemp5, ACCESS
8:             }
1B28C  52E5     MOVF 0xFE5, F, ACCESS
1B28E  52E5     MOVF 0xFE5, F, ACCESS
1B290  0012     RETURN 0
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/fltol.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
18B90  52E6     MOVF 0xFE6, F, ACCESS
18B92  52E6     MOVF 0xFE6, F, ACCESS
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
18B94  0EFA     MOVLW 0xFA
18B98  FF8C     NOP
18B9A  F009     NOP
18B9C  0EFB     MOVLW 0xFB
18BA0  FF8C     NOP
18BA2  F00A     NOP
18BA4  0EFC     MOVLW 0xFC
18BA8  FF8C     NOP
18BAA  F00B     NOP
18BAC  0EFD     MOVLW 0xFD
18BB0  FF8C     NOP
18BB2  F00C     NOP
18BB4  0E18     MOVLW 0x18
18BB6  D005     BRA 0x8BC2
18BB8  90D8     BCF 0xFD8, 0, ACCESS
18BBA  320C     RRCF 0xC, F, ACCESS
18BBC  320B     RRCF wtemp5, F, ACCESS
18BBE  320A     RRCF ttemp3, F, ACCESS
18BC0  3209     RRCF ltemp2, F, ACCESS
18BC2  2EE8     DECFSZ 0xFE8, F, ACCESS
18BC4  D7F9     BRA 0x8BB8
18BC6  0EFE     MOVLW 0xFE
18BCA  F027     NOP
18BCC  FFE3     NOP
18BCE  0EFE     MOVLW 0xFE
18BD0  50E3     MOVF 0xFE3, W, ACCESS
18BD2  A4D8     BTFSS 0xFD8, 2, ACCESS
18BD4  D006     BRA 0x8BE2
48:            		return 0;
18BD6  0E00     MOVLW 0x0
18BD8  6E01     MOVWF ltemp0, ACCESS
18BDA  6A02     CLRF ttemp5, ACCESS
18BDC  6A03     CLRF wtemp1, ACCESS
18BDE  6A04     CLRF ttemp1, ACCESS
18BE0  D08B     BRA 0x8CF8
49:            	sign1 = f1_as_mant1 >> 31;
18BE2  0EFA     MOVLW 0xFA
18BE6  FF8C     NOP
18BE8  F009     NOP
18BEA  0EFB     MOVLW 0xFB
18BEE  FF8C     NOP
18BF0  F00A     NOP
18BF2  0EFC     MOVLW 0xFC
18BF6  FF8C     NOP
18BF8  F00B     NOP
18BFA  0EFD     MOVLW 0xFD
18BFE  FF8C     NOP
18C00  F00C     NOP
18C02  0E20     MOVLW 0x20
18C04  D005     BRA 0x8C10
18C06  90D8     BCF 0xFD8, 0, ACCESS
18C08  320C     RRCF 0xC, F, ACCESS
18C0A  320B     RRCF wtemp5, F, ACCESS
18C0C  320A     RRCF ttemp3, F, ACCESS
18C0E  3209     RRCF ltemp2, F, ACCESS
18C10  2EE8     DECFSZ 0xFE8, F, ACCESS
18C12  D7F9     BRA 0x8C06
18C14  0EFF     MOVLW 0xFF
18C18  F027     NOP
18C1A  FFE3     NOP
50:            	f1_as_mant1 |= 0x800000UL;
18C1C  0EFC     MOVLW 0xFC
18C1E  8EE3     BSF 0xFE3, 7, ACCESS
51:            	f1_as_mant1 &= 0xFFFFFFUL;
18C20  50E1     MOVF 0xFE1, W, ACCESS
18C22  0FFA     ADDLW 0xFA
18C24  6ED9     MOVWF 0xFD9, ACCESS
18C26  50E2     MOVF 0xFE2, W, ACCESS
18C28  6EDA     MOVWF 0xFDA, ACCESS
18C2A  0EFF     MOVLW 0xFF
18C2C  22DA     ADDWFC 0xFDA, F, ACCESS
18C2E  0EFF     MOVLW 0xFF
18C30  16DE     ANDWF 0xFDE, F, ACCESS
18C32  0EFF     MOVLW 0xFF
18C34  16DE     ANDWF 0xFDE, F, ACCESS
18C36  0EFF     MOVLW 0xFF
18C38  16DE     ANDWF 0xFDE, F, ACCESS
18C3A  0E00     MOVLW 0x0
18C3C  16DE     ANDWF 0xFDE, F, ACCESS
52:            	exp1 -= 127+23;
18C3E  0EFE     MOVLW 0xFE
18C42  FF8C     NOP
18C44  F001     NOP
18C46  0E96     MOVLW 0x96
18C48  5E01     SUBWF ltemp0, F, ACCESS
18C4A  0EFE     MOVLW 0xFE
18C4E  F007     NOP
18C50  FFE3     NOP
53:            	if((signed char)exp1 < 0) {
18C52  0EFE     MOVLW 0xFE
18C54  AEE3     BTFSS 0xFE3, 7, ACCESS
18C56  D014     BRA 0x8C80
54:            		if((signed char)exp1 < -23)
18C58  0EFE     MOVLW 0xFE
18C5A  50E3     MOVF 0xFE3, W, ACCESS
18C5C  0A80     XORLW 0x80
18C5E  0F97     ADDLW 0x97
18C60  A0D8     BTFSS 0xFD8, 0, ACCESS
18C62  D7B9     BRA 0x8BD6
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
18C64  90D8     BCF 0xFD8, 0, ACCESS
18C66  0EFD     MOVLW 0xFD
18C68  32E3     RRCF 0xFE3, F, ACCESS
18C6A  0EFC     MOVLW 0xFC
18C6C  32E3     RRCF 0xFE3, F, ACCESS
18C6E  0EFB     MOVLW 0xFB
18C70  32E3     RRCF 0xFE3, F, ACCESS
18C72  0EFA     MOVLW 0xFA
18C74  32E3     RRCF 0xFE3, F, ACCESS
18C76  0EFE     MOVLW 0xFE
18C78  2AE3     INCF 0xFE3, F, ACCESS
18C7A  B4D8     BTFSC 0xFD8, 2, ACCESS
18C7C  D018     BRA 0x8CAE
18C7E  D7F2     BRA 0x8C64
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
18C80  0EFE     MOVLW 0xFE
18C84  FF8C     NOP
18C86  F001     NOP
18C88  0E1F     MOVLW 0x1F
18C8A  6401     CPFSGT ltemp0, ACCESS
18C8C  D00C     BRA 0x8CA6
18C8E  D7A3     BRA 0x8BD6
61:            			return 00;
62:            		while(exp1 != 0) {
18CA6  0EFE     MOVLW 0xFE
18CA8  50E3     MOVF 0xFE3, W, ACCESS
18CAA  A4D8     BTFSS 0xFD8, 2, ACCESS
18CAC  D7F1     BRA 0x8C90
63:            			f1_as_mant1 <<= 1;
18C90  90D8     BCF 0xFD8, 0, ACCESS
18C92  0EFA     MOVLW 0xFA
18C94  36E3     RLCF 0xFE3, F, ACCESS
18C96  0EFB     MOVLW 0xFB
18C98  36E3     RLCF 0xFE3, F, ACCESS
18C9A  0EFC     MOVLW 0xFC
18C9C  36E3     RLCF 0xFE3, F, ACCESS
18C9E  0EFD     MOVLW 0xFD
18CA0  36E3     RLCF 0xFE3, F, ACCESS
64:            			exp1--;
18CA2  0EFE     MOVLW 0xFE
18CA4  06E3     DECF 0xFE3, F, ACCESS
65:            		}
66:            	}
67:            	if(sign1)
18CAE  0EFF     MOVLW 0xFF
18CB0  50E3     MOVF 0xFE3, W, ACCESS
18CB2  B4D8     BTFSC 0xFD8, 2, ACCESS
18CB4  D011     BRA 0x8CD8
68:            		f1_as_mant1 = -f1_as_mant1;
18CB6  0EFA     MOVLW 0xFA
18CB8  6CE3     NEGF 0xFE3, ACCESS
18CBA  0EFB     MOVLW 0xFB
18CBC  1EE3     COMF 0xFE3, F, ACCESS
18CBE  0EFC     MOVLW 0xFC
18CC0  1EE3     COMF 0xFE3, F, ACCESS
18CC2  0EFD     MOVLW 0xFD
18CC4  1EE3     COMF 0xFE3, F, ACCESS
18CC6  E308     BNC 0x8CD8
18CC8  0EFB     MOVLW 0xFB
18CCA  2AE3     INCF 0xFE3, F, ACCESS
18CCC  E305     BNC 0x8CD8
18CCE  0EFC     MOVLW 0xFC
18CD0  2AE3     INCF 0xFE3, F, ACCESS
18CD2  E302     BNC 0x8CD8
18CD4  0EFD     MOVLW 0xFD
18CD6  2AE3     INCF 0xFE3, F, ACCESS
69:            	return f1_as_mant1;
18CD8  0EFA     MOVLW 0xFA
18CDC  FF8C     NOP
18CDE  F001     NOP
18CE0  0EFB     MOVLW 0xFB
18CE4  FF8C     NOP
18CE6  F002     NOP
18CE8  0EFC     MOVLW 0xFC
18CEC  FF8C     NOP
18CEE  F003     NOP
18CF0  0EFD     MOVLW 0xFD
18CF4  FF8C     NOP
18CF6  F004     NOP
70:            }
18CF8  0EFA     MOVLW 0xFA
18CFA  26E1     ADDWF 0xFE1, F, ACCESS
18CFC  0EFF     MOVLW 0xFF
18CFE  22E2     ADDWFC 0xFE2, F, ACCESS
18D00  0012     RETURN 0
71:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/floorf.c  ------------------------------------------
1:             #include "libm.h"
2:             
3:             float floorf(float x)
161B6  0E0A     MOVLW 0xA
161B8  26E1     ADDWF 0xFE1, F, ACCESS
161BA  0E00     MOVLW 0x0
161BC  22E2     ADDWFC 0xFE2, F, ACCESS
4:             {
5:             	union {float f; uint32_t i;} u = {x};
161C0  F1E8     NOP
161C2  F009     NOP
161C6  F1EC     NOP
161C8  F00A     NOP
161CC  F1F0     NOP
161CE  F00B     NOP
161D2  F1F4     NOP
161D4  F00C     NOP
161D6  0EF6     MOVLW 0xF6
161DA  F027     NOP
161DC  FFE3     NOP
161DE  0EF7     MOVLW 0xF7
161E2  F02B     NOP
161E4  FFE3     NOP
161E6  0EF8     MOVLW 0xF8
161EA  F02F     NOP
161EC  FFE3     NOP
161EE  0EF9     MOVLW 0xF9
161F2  F033     NOP
161F4  FFE3     NOP
161F6  0EF2     MOVLW 0xF2
161FA  FF8C     NOP
161FC  F009     NOP
161FE  0EF3     MOVLW 0xF3
16202  FF8C     NOP
16204  F00A     NOP
16206  0EF4     MOVLW 0xF4
1620A  FF8C     NOP
1620C  F00B     NOP
1620E  0EF5     MOVLW 0xF5
16212  FF8C     NOP
16214  F00C     NOP
16216  0EF6     MOVLW 0xF6
1621A  F027     NOP
1621C  FFE3     NOP
1621E  0EF7     MOVLW 0xF7
16222  F02B     NOP
16224  FFE3     NOP
16226  0EF8     MOVLW 0xF8
1622A  F02F     NOP
1622C  FFE3     NOP
1622E  0EF9     MOVLW 0xF9
16232  F033     NOP
16234  FFE3     NOP
6:             	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
16236  0E81     MOVLW 0x81
16238  6E0B     MOVWF wtemp5, ACCESS
1623A  0EFF     MOVLW 0xFF
1623C  6E0C     MOVWF 0xC, ACCESS
1623E  0EF6     MOVLW 0xF6
16242  FF8C     NOP
16244  F005     NOP
16246  0EF7     MOVLW 0xF7
1624A  FF8C     NOP
1624C  F006     NOP
1624E  0EF8     MOVLW 0xF8
16252  FF8C     NOP
16254  F007     NOP
16256  0EF9     MOVLW 0xF9
1625A  FF8C     NOP
1625C  F008     NOP
1625E  0E18     MOVLW 0x18
16260  D005     BRA 0x626C
16262  90D8     BCF 0xFD8, 0, ACCESS
16264  3208     RRCF 0x8, F, ACCESS
16266  3207     RRCF ttemp2, F, ACCESS
16268  3206     RRCF 0x6, F, ACCESS
1626A  3205     RRCF ltemp1, F, ACCESS
1626C  2EE8     DECFSZ 0xFE8, F, ACCESS
1626E  D7F9     BRA 0x6262
16272  F014     NOP
16274  F009     NOP
16278  F018     NOP
1627A  F00A     NOP
1627C  0EFF     MOVLW 0xFF
1627E  1609     ANDWF ltemp2, F, ACCESS
16280  0E00     MOVLW 0x0
16282  160A     ANDWF ttemp3, F, ACCESS
16284  500B     MOVF wtemp5, W, ACCESS
16286  2609     ADDWF ltemp2, F, ACCESS
16288  500C     MOVF 0xC, W, ACCESS
1628A  220A     ADDWFC ttemp3, F, ACCESS
1628C  0EFE     MOVLW 0xFE
16290  F027     NOP
16292  FFE3     NOP
16294  0EFF     MOVLW 0xFF
16298  F02B     NOP
1629A  FFE3     NOP
7:             	uint32_t m;
8:             
9:             	if (e >= 23)
1629C  0EFF     MOVLW 0xFF
1629E  BEE3     BTFSC 0xFE3, 7, ACCESS
162A0  D019     BRA 0x62D4
162A2  0EFF     MOVLW 0xFF
162A4  50E3     MOVF 0xFE3, W, ACCESS
162A6  E108     BNZ 0x62B8
162A8  0EFE     MOVLW 0xFE
162AC  FF8C     NOP
162AE  F001     NOP
162B0  0E17     MOVLW 0x17
162B2  5E01     SUBWF ltemp0, F, ACCESS
162B4  A0D8     BTFSS 0xFD8, 0, ACCESS
162B6  D00E     BRA 0x62D4
10:            		return x;
162B8  0EF2     MOVLW 0xF2
162BC  FF8C     NOP
162BE  F001     NOP
162C0  0EF3     MOVLW 0xF3
162C4  FF8C     NOP
162C6  F002     NOP
162C8  0EF4     MOVLW 0xF4
162CC  FF8C     NOP
162CE  F003     NOP
162D0  0EF5     MOVLW 0xF5
162D2  D11F     BRA 0x6512
11:            	if (e >= 0) {
162D4  0EFF     MOVLW 0xFF
162D6  BEE3     BTFSC 0xFE3, 7, ACCESS
162D8  D0B4     BRA 0x6442
12:            		m = 0x007fffff >> e;
162DA  0EFE     MOVLW 0xFE
162DE  FF8C     NOP
162E0  F00C     NOP
162E2  0EFF     MOVLW 0xFF
162E4  6E05     MOVWF ltemp1, ACCESS
162E6  0EFF     MOVLW 0xFF
162E8  6E06     MOVWF 0x6, ACCESS
162EA  0E7F     MOVLW 0x7F
162EC  6E07     MOVWF ttemp2, ACCESS
162EE  0E00     MOVLW 0x0
162F0  6E08     MOVWF 0x8, ACCESS
162F2  660C     TSTFSZ 0xC, ACCESS
162F4  D001     BRA 0x62F8
162F6  D007     BRA 0x6306
162F8  3408     RLCF 0x8, W, ACCESS
162FA  3208     RRCF 0x8, F, ACCESS
162FC  3207     RRCF ttemp2, F, ACCESS
162FE  3206     RRCF 0x6, F, ACCESS
16300  3205     RRCF ltemp1, F, ACCESS
16302  2E0C     DECFSZ 0xC, F, ACCESS
16304  D7F6     BRA 0x62F2
16306  0EFA     MOVLW 0xFA
1630A  F017     NOP
1630C  FFE3     NOP
1630E  0EFB     MOVLW 0xFB
16312  F01B     NOP
16314  FFE3     NOP
16316  0EFC     MOVLW 0xFC
1631A  F01F     NOP
1631C  FFE3     NOP
1631E  0EFD     MOVLW 0xFD
16322  F023     NOP
16324  FFE3     NOP
13:            		if ((u.i & m) == 0)
16326  0EF6     MOVLW 0xF6
1632A  FF8C     NOP
1632C  F009     NOP
1632E  0EF7     MOVLW 0xF7
16332  FF8C     NOP
16334  F00A     NOP
16336  0EF8     MOVLW 0xF8
1633A  FF8C     NOP
1633C  F00B     NOP
1633E  0EF9     MOVLW 0xF9
16342  FF8C     NOP
16344  F00C     NOP
16346  0EFA     MOVLW 0xFA
16348  50E3     MOVF 0xFE3, W, ACCESS
1634A  1609     ANDWF ltemp2, F, ACCESS
1634C  0EFB     MOVLW 0xFB
1634E  50E3     MOVF 0xFE3, W, ACCESS
16350  160A     ANDWF ttemp3, F, ACCESS
16352  0EFC     MOVLW 0xFC
16354  50E3     MOVF 0xFE3, W, ACCESS
16356  160B     ANDWF wtemp5, F, ACCESS
16358  0EFD     MOVLW 0xFD
1635A  50E3     MOVF 0xFE3, W, ACCESS
1635C  160C     ANDWF 0xC, F, ACCESS
1635E  5009     MOVF ltemp2, W, ACCESS
16360  100A     IORWF ttemp3, W, ACCESS
16362  100B     IORWF wtemp5, W, ACCESS
16364  100C     IORWF 0xC, W, ACCESS
16366  B4D8     BTFSC 0xFD8, 2, ACCESS
16368  D7A7     BRA 0x62B8
14:            			return x;
15:            		FORCE_EVAL(x + 0x1p120f);
16:            		if (u.i >> 31)
1636A  0EF6     MOVLW 0xF6
1636E  FF8C     NOP
16370  F009     NOP
16372  0EF7     MOVLW 0xF7
16376  FF8C     NOP
16378  F00A     NOP
1637A  0EF8     MOVLW 0xF8
1637E  FF8C     NOP
16380  F00B     NOP
16382  0EF9     MOVLW 0xF9
16386  FF8C     NOP
16388  F00C     NOP
1638A  0E20     MOVLW 0x20
1638C  D005     BRA 0x6398
1638E  90D8     BCF 0xFD8, 0, ACCESS
16390  320C     RRCF 0xC, F, ACCESS
16392  320B     RRCF wtemp5, F, ACCESS
16394  320A     RRCF ttemp3, F, ACCESS
16396  3209     RRCF ltemp2, F, ACCESS
16398  2EE8     DECFSZ 0xFE8, F, ACCESS
1639A  D7F9     BRA 0x638E
1639C  5009     MOVF ltemp2, W, ACCESS
1639E  B4D8     BTFSC 0xFD8, 2, ACCESS
163A0  D028     BRA 0x63F2
17:            			u.i += m;
163A2  0EF6     MOVLW 0xF6
163A4  50E3     MOVF 0xFE3, W, ACCESS
163A6  6E01     MOVWF ltemp0, ACCESS
163A8  0EFA     MOVLW 0xFA
163AA  50E3     MOVF 0xFE3, W, ACCESS
163AC  2601     ADDWF ltemp0, F, ACCESS
163AE  0EF6     MOVLW 0xF6
163B2  F007     NOP
163B4  FFE3     NOP
163B6  0EF7     MOVLW 0xF7
163B8  50E3     MOVF 0xFE3, W, ACCESS
163BA  6E01     MOVWF ltemp0, ACCESS
163BC  0EFB     MOVLW 0xFB
163BE  50E3     MOVF 0xFE3, W, ACCESS
163C0  2201     ADDWFC ltemp0, F, ACCESS
163C2  0EF7     MOVLW 0xF7
163C6  F007     NOP
163C8  FFE3     NOP
163CA  0EF8     MOVLW 0xF8
163CC  50E3     MOVF 0xFE3, W, ACCESS
163CE  6E01     MOVWF ltemp0, ACCESS
163D0  0EFC     MOVLW 0xFC
163D2  50E3     MOVF 0xFE3, W, ACCESS
163D4  2201     ADDWFC ltemp0, F, ACCESS
163D6  0EF8     MOVLW 0xF8
163DA  F007     NOP
163DC  FFE3     NOP
163DE  0EF9     MOVLW 0xF9
163E0  50E3     MOVF 0xFE3, W, ACCESS
163E2  6E01     MOVWF ltemp0, ACCESS
163E4  0EFD     MOVLW 0xFD
163E6  50E3     MOVF 0xFE3, W, ACCESS
163E8  2201     ADDWFC ltemp0, F, ACCESS
163EA  0EF9     MOVLW 0xF9
163EE  F007     NOP
163F0  FFE3     NOP
18:            		u.i &= ~m;
163F2  0EFA     MOVLW 0xFA
163F6  FF8C     NOP
163F8  F009     NOP
163FA  0EFB     MOVLW 0xFB
163FE  FF8C     NOP
16400  F00A     NOP
16402  0EFC     MOVLW 0xFC
16406  FF8C     NOP
16408  F00B     NOP
1640A  0EFD     MOVLW 0xFD
1640E  FF8C     NOP
16410  F00C     NOP
16412  1C09     COMF ltemp2, W, ACCESS
16414  6E05     MOVWF ltemp1, ACCESS
16416  1C0A     COMF ttemp3, W, ACCESS
16418  6E06     MOVWF 0x6, ACCESS
1641A  1C0B     COMF wtemp5, W, ACCESS
1641C  6E07     MOVWF ttemp2, ACCESS
1641E  1C0C     COMF 0xC, W, ACCESS
16420  6E08     MOVWF 0x8, ACCESS
16422  50E1     MOVF 0xFE1, W, ACCESS
16424  0FF6     ADDLW 0xF6
16426  6ED9     MOVWF 0xFD9, ACCESS
16428  50E2     MOVF 0xFE2, W, ACCESS
1642A  6EDA     MOVWF 0xFDA, ACCESS
1642C  0EFF     MOVLW 0xFF
1642E  22DA     ADDWFC 0xFDA, F, ACCESS
16430  5005     MOVF ltemp1, W, ACCESS
16432  16DE     ANDWF 0xFDE, F, ACCESS
16434  5006     MOVF 0x6, W, ACCESS
16436  16DE     ANDWF 0xFDE, F, ACCESS
16438  5007     MOVF ttemp2, W, ACCESS
1643A  16DE     ANDWF 0xFDE, F, ACCESS
1643C  5008     MOVF 0x8, W, ACCESS
1643E  16DE     ANDWF 0xFDE, F, ACCESS
19:            	} else {
16440  D05B     BRA 0x64F8
20:            		FORCE_EVAL(x + 0x1p120f);
21:            		if (u.i >> 31 == 0)
16442  0EF6     MOVLW 0xF6
16446  FF8C     NOP
16448  F009     NOP
1644A  0EF7     MOVLW 0xF7
1644E  FF8C     NOP
16450  F00A     NOP
16452  0EF8     MOVLW 0xF8
16456  FF8C     NOP
16458  F00B     NOP
1645A  0EF9     MOVLW 0xF9
1645E  FF8C     NOP
16460  F00C     NOP
16462  0E20     MOVLW 0x20
16464  D005     BRA 0x6470
16466  90D8     BCF 0xFD8, 0, ACCESS
16468  320C     RRCF 0xC, F, ACCESS
1646A  320B     RRCF wtemp5, F, ACCESS
1646C  320A     RRCF ttemp3, F, ACCESS
1646E  3209     RRCF ltemp2, F, ACCESS
16470  2EE8     DECFSZ 0xFE8, F, ACCESS
16472  D7F9     BRA 0x6466
16474  6609     TSTFSZ ltemp2, ACCESS
16476  D009     BRA 0x648A
22:            			u.i = 0;
16478  0EF6     MOVLW 0xF6
1647A  6AE3     CLRF 0xFE3, ACCESS
1647C  0EF7     MOVLW 0xF7
1647E  6AE3     CLRF 0xFE3, ACCESS
16480  0EF8     MOVLW 0xF8
16482  6AE3     CLRF 0xFE3, ACCESS
16484  0EF9     MOVLW 0xF9
16486  6AE3     CLRF 0xFE3, ACCESS
16488  D037     BRA 0x64F8
23:            		else if (u.i << 1)
1648A  0EF6     MOVLW 0xF6
1648E  FF8C     NOP
16490  F009     NOP
16492  0EF7     MOVLW 0xF7
16496  FF8C     NOP
16498  F00A     NOP
1649A  0EF8     MOVLW 0xF8
1649E  FF8C     NOP
164A0  F00B     NOP
164A2  0EF9     MOVLW 0xF9
164A6  FF8C     NOP
164A8  F00C     NOP
164AA  90D8     BCF 0xFD8, 0, ACCESS
164AC  3409     RLCF ltemp2, W, ACCESS
164AE  6E05     MOVWF ltemp1, ACCESS
164B0  340A     RLCF ttemp3, W, ACCESS
164B2  6E06     MOVWF 0x6, ACCESS
164B4  340B     RLCF wtemp5, W, ACCESS
164B6  6E07     MOVWF ttemp2, ACCESS
164B8  340C     RLCF 0xC, W, ACCESS
164BA  6E08     MOVWF 0x8, ACCESS
164BC  5005     MOVF ltemp1, W, ACCESS
164BE  1006     IORWF 0x6, W, ACCESS
164C0  1007     IORWF ttemp2, W, ACCESS
164C2  1008     IORWF 0x8, W, ACCESS
164C4  B4D8     BTFSC 0xFD8, 2, ACCESS
164C6  D018     BRA 0x64F8
24:            			u.f = -1.0;
164C8  0E00     MOVLW 0x0
164CA  6E09     MOVWF ltemp2, ACCESS
164CC  0E00     MOVLW 0x0
164CE  6E0A     MOVWF ttemp3, ACCESS
164D0  0E80     MOVLW 0x80
164D2  6E0B     MOVWF wtemp5, ACCESS
164D4  0EBF     MOVLW 0xBF
164D6  6E0C     MOVWF 0xC, ACCESS
164D8  0EF6     MOVLW 0xF6
164DC  F027     NOP
164DE  FFE3     NOP
164E0  0EF7     MOVLW 0xF7
164E4  F02B     NOP
164E6  FFE3     NOP
164E8  0EF8     MOVLW 0xF8
164EC  F02F     NOP
164EE  FFE3     NOP
164F0  0EF9     MOVLW 0xF9
164F4  F033     NOP
164F6  FFE3     NOP
25:            	}
26:            	return u.f;
164F8  0EF6     MOVLW 0xF6
164FC  FF8C     NOP
164FE  F001     NOP
16500  0EF7     MOVLW 0xF7
16504  FF8C     NOP
16506  F002     NOP
16508  0EF8     MOVLW 0xF8
1650C  FF8C     NOP
1650E  F003     NOP
16510  0EF9     MOVLW 0xF9
16514  FF8C     NOP
16516  F004     NOP
27:            }
16518  0EF2     MOVLW 0xF2
1651A  26E1     ADDWF 0xFE1, F, ACCESS
1651C  0EFF     MOVLW 0xFF
1651E  22E2     ADDWFC 0xFE2, F, ACCESS
16520  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/flneg.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned long *)&f1)
11:            
12:            // Negate a float
13:            
14:            double
15:            __flneg(double f1)
16:            {
17:            	if(mant1 != 0x0)
1B0A2  0EFC     MOVLW 0xFC
1B0A4  50E3     MOVF 0xFE3, W, ACCESS
1B0A6  E10A     BNZ 0xB0BC
1B0A8  0EFD     MOVLW 0xFD
1B0AA  50E3     MOVF 0xFE3, W, ACCESS
1B0AC  E107     BNZ 0xB0BC
1B0AE  0EFE     MOVLW 0xFE
1B0B0  50E3     MOVF 0xFE3, W, ACCESS
1B0B2  E104     BNZ 0xB0BC
1B0B4  0EFF     MOVLW 0xFF
1B0B6  50E3     MOVF 0xFE3, W, ACCESS
1B0B8  B4D8     BTFSC 0xFD8, 2, ACCESS
1B0BA  D002     BRA 0xB0C0
18:            		mant1 ^= 0x80000000UL;
1B0BC  0EFF     MOVLW 0xFF
1B0BE  7EE3     BTG 0xFE3, 7, ACCESS
19:            	return f1;
1B0C0  0EFC     MOVLW 0xFC
1B0C4  FF8C     NOP
1B0C6  F001     NOP
1B0C8  0EFD     MOVLW 0xFD
1B0CC  FF8C     NOP
1B0CE  F002     NOP
1B0D0  0EFE     MOVLW 0xFE
1B0D4  FF8C     NOP
1B0D6  F003     NOP
1B0D8  0EFF     MOVLW 0xFF
1B0DC  FF8C     NOP
1B0DE  F004     NOP
20:            }
1B0E0  52E5     MOVF 0xFE5, F, ACCESS
1B0E2  52E5     MOVF 0xFE5, F, ACCESS
1B0E4  52E5     MOVF 0xFE5, F, ACCESS
1B0E6  52E5     MOVF 0xFE5, F, ACCESS
1B0E8  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/flge.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __flge(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
18D02  50E1     MOVF 0xFE1, W, ACCESS
18D04  0FFC     ADDLW 0xFC
18D06  6ED9     MOVWF 0xFD9, ACCESS
18D08  50E2     MOVF 0xFE2, W, ACCESS
18D0A  6EDA     MOVWF 0xFDA, ACCESS
18D0C  0EFF     MOVLW 0xFF
18D0E  22DA     ADDWFC 0xFDA, F, ACCESS
18D10  0E00     MOVLW 0x0
18D12  14DE     ANDWF 0xFDE, W, ACCESS
18D14  6E09     MOVWF ltemp2, ACCESS
18D16  0E00     MOVLW 0x0
18D18  14DE     ANDWF 0xFDE, W, ACCESS
18D1A  6E0A     MOVWF ttemp3, ACCESS
18D1C  0E80     MOVLW 0x80
18D1E  14DE     ANDWF 0xFDE, W, ACCESS
18D20  6E0B     MOVWF wtemp5, ACCESS
18D22  0E7F     MOVLW 0x7F
18D24  14DE     ANDWF 0xFDE, W, ACCESS
18D26  6E0C     MOVWF 0xC, ACCESS
18D28  5009     MOVF ltemp2, W, ACCESS
18D2A  100A     IORWF ttemp3, W, ACCESS
18D2C  100B     IORWF wtemp5, W, ACCESS
18D2E  100C     IORWF 0xC, W, ACCESS
18D30  A4D8     BTFSS 0xFD8, 2, ACCESS
18D32  D008     BRA 0x8D44
8:             		f1 = 0x00000000UL;
18D34  0EFC     MOVLW 0xFC
18D36  6AE3     CLRF 0xFE3, ACCESS
18D38  0EFD     MOVLW 0xFD
18D3A  6AE3     CLRF 0xFE3, ACCESS
18D3C  0EFE     MOVLW 0xFE
18D3E  6AE3     CLRF 0xFE3, ACCESS
18D40  0EFF     MOVLW 0xFF
18D42  6AE3     CLRF 0xFE3, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
18D44  50E1     MOVF 0xFE1, W, ACCESS
18D46  0FF8     ADDLW 0xF8
18D48  6ED9     MOVWF 0xFD9, ACCESS
18D4A  50E2     MOVF 0xFE2, W, ACCESS
18D4C  6EDA     MOVWF 0xFDA, ACCESS
18D4E  0EFF     MOVLW 0xFF
18D50  22DA     ADDWFC 0xFDA, F, ACCESS
18D52  0E00     MOVLW 0x0
18D54  14DE     ANDWF 0xFDE, W, ACCESS
18D56  6E09     MOVWF ltemp2, ACCESS
18D58  0E00     MOVLW 0x0
18D5A  14DE     ANDWF 0xFDE, W, ACCESS
18D5C  6E0A     MOVWF ttemp3, ACCESS
18D5E  0E80     MOVLW 0x80
18D60  14DE     ANDWF 0xFDE, W, ACCESS
18D62  6E0B     MOVWF wtemp5, ACCESS
18D64  0E7F     MOVLW 0x7F
18D66  14DE     ANDWF 0xFDE, W, ACCESS
18D68  6E0C     MOVWF 0xC, ACCESS
18D6A  5009     MOVF ltemp2, W, ACCESS
18D6C  100A     IORWF ttemp3, W, ACCESS
18D6E  100B     IORWF wtemp5, W, ACCESS
18D70  100C     IORWF 0xC, W, ACCESS
18D72  A4D8     BTFSS 0xFD8, 2, ACCESS
18D74  D008     BRA 0x8D86
10:            	        f2 = 0x00000000UL;
18D76  0EF8     MOVLW 0xF8
18D78  6AE3     CLRF 0xFE3, ACCESS
18D7A  0EF9     MOVLW 0xF9
18D7C  6AE3     CLRF 0xFE3, ACCESS
18D7E  0EFA     MOVLW 0xFA
18D80  6AE3     CLRF 0xFE3, ACCESS
18D82  0EFB     MOVLW 0xFB
18D84  6AE3     CLRF 0xFE3, ACCESS
11:            	// compute >= a clever way
12:            	if(f1 &  0x80000000UL)
18D86  0EFF     MOVLW 0xFF
18D88  AEE3     BTFSS 0xFE3, 7, ACCESS
18D8A  D024     BRA 0x8DD4
13:            		f1 = 0x80000000UL - f1;
18D8C  0E00     MOVLW 0x0
18D8E  6E09     MOVWF ltemp2, ACCESS
18D90  0E00     MOVLW 0x0
18D92  6E0A     MOVWF ttemp3, ACCESS
18D94  0E00     MOVLW 0x0
18D96  6E0B     MOVWF wtemp5, ACCESS
18D98  0E80     MOVLW 0x80
18D9A  6E0C     MOVWF 0xC, ACCESS
18D9C  0EFC     MOVLW 0xFC
18D9E  50E3     MOVF 0xFE3, W, ACCESS
18DA0  5E09     SUBWF ltemp2, F, ACCESS
18DA2  0EFD     MOVLW 0xFD
18DA4  50E3     MOVF 0xFE3, W, ACCESS
18DA6  5A0A     SUBWFB ttemp3, F, ACCESS
18DA8  0EFE     MOVLW 0xFE
18DAA  50E3     MOVF 0xFE3, W, ACCESS
18DAC  5A0B     SUBWFB wtemp5, F, ACCESS
18DAE  0EFF     MOVLW 0xFF
18DB0  50E3     MOVF 0xFE3, W, ACCESS
18DB2  5A0C     SUBWFB 0xC, F, ACCESS
18DB4  0EFC     MOVLW 0xFC
18DB8  F027     NOP
18DBA  FFE3     NOP
18DBC  0EFD     MOVLW 0xFD
18DC0  F02B     NOP
18DC2  FFE3     NOP
18DC4  0EFE     MOVLW 0xFE
18DC8  F02F     NOP
18DCA  FFE3     NOP
18DCC  0EFF     MOVLW 0xFF
18DD0  F033     NOP
18DD2  FFE3     NOP
14:            	if(f2 &  0x80000000UL)
18DD4  0EFB     MOVLW 0xFB
18DD6  AEE3     BTFSS 0xFE3, 7, ACCESS
18DD8  D024     BRA 0x8E22
15:            		f2 = 0x80000000UL - f2;
18DDA  0E00     MOVLW 0x0
18DDC  6E09     MOVWF ltemp2, ACCESS
18DDE  0E00     MOVLW 0x0
18DE0  6E0A     MOVWF ttemp3, ACCESS
18DE2  0E00     MOVLW 0x0
18DE4  6E0B     MOVWF wtemp5, ACCESS
18DE6  0E80     MOVLW 0x80
18DE8  6E0C     MOVWF 0xC, ACCESS
18DEA  0EF8     MOVLW 0xF8
18DEC  50E3     MOVF 0xFE3, W, ACCESS
18DEE  5E09     SUBWF ltemp2, F, ACCESS
18DF0  0EF9     MOVLW 0xF9
18DF2  50E3     MOVF 0xFE3, W, ACCESS
18DF4  5A0A     SUBWFB ttemp3, F, ACCESS
18DF6  0EFA     MOVLW 0xFA
18DF8  50E3     MOVF 0xFE3, W, ACCESS
18DFA  5A0B     SUBWFB wtemp5, F, ACCESS
18DFC  0EFB     MOVLW 0xFB
18DFE  50E3     MOVF 0xFE3, W, ACCESS
18E00  5A0C     SUBWFB 0xC, F, ACCESS
18E02  0EF8     MOVLW 0xF8
18E06  F027     NOP
18E08  FFE3     NOP
18E0A  0EF9     MOVLW 0xF9
18E0E  F02B     NOP
18E10  FFE3     NOP
18E12  0EFA     MOVLW 0xFA
18E16  F02F     NOP
18E18  FFE3     NOP
18E1A  0EFB     MOVLW 0xFB
18E1E  F033     NOP
18E20  FFE3     NOP
16:            	f1 ^= 0x80000000UL;
18E22  0EFF     MOVLW 0xFF
18E24  7EE3     BTG 0xFE3, 7, ACCESS
17:            	f2 ^= 0x80000000UL;
18E26  0EFB     MOVLW 0xFB
18E28  7EE3     BTG 0xFE3, 7, ACCESS
18:            	return f1 >= f2;
18E2A  50E1     MOVF 0xFE1, W, ACCESS
18E2C  0FFC     ADDLW 0xFC
18E2E  6ED9     MOVWF 0xFD9, ACCESS
18E30  50E2     MOVF 0xFE2, W, ACCESS
18E32  6EDA     MOVWF 0xFDA, ACCESS
18E34  0EFF     MOVLW 0xFF
18E36  22DA     ADDWFC 0xFDA, F, ACCESS
18E38  0EF8     MOVLW 0xF8
18E3A  50E3     MOVF 0xFE3, W, ACCESS
18E3C  5CDE     SUBWF 0xFDE, W, ACCESS
18E3E  0EF9     MOVLW 0xF9
18E40  50E3     MOVF 0xFE3, W, ACCESS
18E42  58DE     SUBWFB 0xFDE, W, ACCESS
18E44  0EFA     MOVLW 0xFA
18E46  50E3     MOVF 0xFE3, W, ACCESS
18E48  58DE     SUBWFB 0xFDE, W, ACCESS
18E4A  0EFB     MOVLW 0xFB
18E4C  50E3     MOVF 0xFE3, W, ACCESS
18E4E  58DE     SUBWFB 0xFDE, W, ACCESS
18E50  B0D8     BTFSC 0xFD8, 0, ACCESS
18E52  D002     BRA 0x8E58
18E54  9001     BCF ltemp0, 0, ACCESS
18E56  D001     BRA 0x8E5A
18E58  8001     BSF ltemp0, 0, ACCESS
19:            }
18E5A  0EF8     MOVLW 0xF8
18E5C  26E1     ADDWF 0xFE1, F, ACCESS
18E5E  0EFF     MOVLW 0xFF
18E60  22E2     ADDWFC 0xFE2, F, ACCESS
18E62  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/fleq.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __fleq(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
1A192  50E1     MOVF 0xFE1, W, ACCESS
1A194  0FFC     ADDLW 0xFC
1A196  6ED9     MOVWF 0xFD9, ACCESS
1A198  50E2     MOVF 0xFE2, W, ACCESS
1A19A  6EDA     MOVWF 0xFDA, ACCESS
1A19C  0EFF     MOVLW 0xFF
1A19E  22DA     ADDWFC 0xFDA, F, ACCESS
1A1A0  0E00     MOVLW 0x0
1A1A2  14DE     ANDWF 0xFDE, W, ACCESS
1A1A4  6E09     MOVWF ltemp2, ACCESS
1A1A6  0E00     MOVLW 0x0
1A1A8  14DE     ANDWF 0xFDE, W, ACCESS
1A1AA  6E0A     MOVWF ttemp3, ACCESS
1A1AC  0E80     MOVLW 0x80
1A1AE  14DE     ANDWF 0xFDE, W, ACCESS
1A1B0  6E0B     MOVWF wtemp5, ACCESS
1A1B2  0E7F     MOVLW 0x7F
1A1B4  14DE     ANDWF 0xFDE, W, ACCESS
1A1B6  6E0C     MOVWF 0xC, ACCESS
1A1B8  5009     MOVF ltemp2, W, ACCESS
1A1BA  100A     IORWF ttemp3, W, ACCESS
1A1BC  100B     IORWF wtemp5, W, ACCESS
1A1BE  100C     IORWF 0xC, W, ACCESS
1A1C0  A4D8     BTFSS 0xFD8, 2, ACCESS
1A1C2  D008     BRA 0xA1D4
8:             		f1 = 0x00000000UL;
1A1C4  0EFC     MOVLW 0xFC
1A1C6  6AE3     CLRF 0xFE3, ACCESS
1A1C8  0EFD     MOVLW 0xFD
1A1CA  6AE3     CLRF 0xFE3, ACCESS
1A1CC  0EFE     MOVLW 0xFE
1A1CE  6AE3     CLRF 0xFE3, ACCESS
1A1D0  0EFF     MOVLW 0xFF
1A1D2  6AE3     CLRF 0xFE3, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
1A1D4  50E1     MOVF 0xFE1, W, ACCESS
1A1D6  0FF8     ADDLW 0xF8
1A1D8  6ED9     MOVWF 0xFD9, ACCESS
1A1DA  50E2     MOVF 0xFE2, W, ACCESS
1A1DC  6EDA     MOVWF 0xFDA, ACCESS
1A1DE  0EFF     MOVLW 0xFF
1A1E0  22DA     ADDWFC 0xFDA, F, ACCESS
1A1E2  0E00     MOVLW 0x0
1A1E4  14DE     ANDWF 0xFDE, W, ACCESS
1A1E6  6E09     MOVWF ltemp2, ACCESS
1A1E8  0E00     MOVLW 0x0
1A1EA  14DE     ANDWF 0xFDE, W, ACCESS
1A1EC  6E0A     MOVWF ttemp3, ACCESS
1A1EE  0E80     MOVLW 0x80
1A1F0  14DE     ANDWF 0xFDE, W, ACCESS
1A1F2  6E0B     MOVWF wtemp5, ACCESS
1A1F4  0E7F     MOVLW 0x7F
1A1F6  14DE     ANDWF 0xFDE, W, ACCESS
1A1F8  6E0C     MOVWF 0xC, ACCESS
1A1FA  5009     MOVF ltemp2, W, ACCESS
1A1FC  100A     IORWF ttemp3, W, ACCESS
1A1FE  100B     IORWF wtemp5, W, ACCESS
1A200  100C     IORWF 0xC, W, ACCESS
1A202  A4D8     BTFSS 0xFD8, 2, ACCESS
1A204  D008     BRA 0xA216
10:            	        f2 = 0x00000000UL;
1A206  0EF8     MOVLW 0xF8
1A208  6AE3     CLRF 0xFE3, ACCESS
1A20A  0EF9     MOVLW 0xF9
1A20C  6AE3     CLRF 0xFE3, ACCESS
1A20E  0EFA     MOVLW 0xFA
1A210  6AE3     CLRF 0xFE3, ACCESS
1A212  0EFB     MOVLW 0xFB
1A214  6AE3     CLRF 0xFE3, ACCESS
11:            	return f1 == f2;
1A216  50E1     MOVF 0xFE1, W, ACCESS
1A218  0FFC     ADDLW 0xFC
1A21A  6ED9     MOVWF 0xFD9, ACCESS
1A21C  50E2     MOVF 0xFE2, W, ACCESS
1A21E  6EDA     MOVWF 0xFDA, ACCESS
1A220  0EFF     MOVLW 0xFF
1A222  22DA     ADDWFC 0xFDA, F, ACCESS
1A224  0EF8     MOVLW 0xF8
1A226  50E3     MOVF 0xFE3, W, ACCESS
1A228  18DE     XORWF 0xFDE, W, ACCESS
1A22A  E10D     BNZ 0xA246
1A22C  0EF9     MOVLW 0xF9
1A22E  50E3     MOVF 0xFE3, W, ACCESS
1A230  18DE     XORWF 0xFDE, W, ACCESS
1A232  E109     BNZ 0xA246
1A234  0EFA     MOVLW 0xFA
1A236  50E3     MOVF 0xFE3, W, ACCESS
1A238  18DE     XORWF 0xFDE, W, ACCESS
1A23A  E105     BNZ 0xA246
1A23C  0EFB     MOVLW 0xFB
1A23E  50E3     MOVF 0xFE3, W, ACCESS
1A240  18DE     XORWF 0xFDE, W, ACCESS
1A242  B4D8     BTFSC 0xFD8, 2, ACCESS
1A244  D002     BRA 0xA24A
1A246  9001     BCF ltemp0, 0, ACCESS
1A248  D001     BRA 0xA24C
1A24A  8001     BSF ltemp0, 0, ACCESS
12:            }
1A24C  0EF8     MOVLW 0xF8
1A24E  26E1     ADDWF 0xFE1, F, ACCESS
1A250  0EFF     MOVLW 0xFF
1A252  22E2     ADDWFC 0xFE2, F, ACCESS
1A254  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/fabsf.c  -------------------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             float fabsf(float x)
1A30E  52E6     MOVF 0xFE6, F, ACCESS
1A310  52E6     MOVF 0xFE6, F, ACCESS
1A312  52E6     MOVF 0xFE6, F, ACCESS
1A314  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u = {x};
1A318  F1F8     NOP
1A31A  F009     NOP
1A31E  F1FC     NOP
1A320  F00A     NOP
1A324  F200     NOP
1A326  F00B     NOP
1A32A  F204     NOP
1A32C  F00C     NOP
1A32E  0EFC     MOVLW 0xFC
1A332  F027     NOP
1A334  FFE3     NOP
1A336  0EFD     MOVLW 0xFD
1A33A  F02B     NOP
1A33C  FFE3     NOP
1A33E  0EFE     MOVLW 0xFE
1A342  F02F     NOP
1A344  FFE3     NOP
1A346  0EFF     MOVLW 0xFF
1A34A  F033     NOP
1A34C  FFE3     NOP
1A34E  0EF8     MOVLW 0xF8
1A352  FF8C     NOP
1A354  F009     NOP
1A356  0EF9     MOVLW 0xF9
1A35A  FF8C     NOP
1A35C  F00A     NOP
1A35E  0EFA     MOVLW 0xFA
1A362  FF8C     NOP
1A364  F00B     NOP
1A366  0EFB     MOVLW 0xFB
1A36A  FF8C     NOP
1A36C  F00C     NOP
1A36E  0EFC     MOVLW 0xFC
1A372  F027     NOP
1A374  FFE3     NOP
1A376  0EFD     MOVLW 0xFD
1A37A  F02B     NOP
1A37C  FFE3     NOP
1A37E  0EFE     MOVLW 0xFE
1A382  F02F     NOP
1A384  FFE3     NOP
1A386  0EFF     MOVLW 0xFF
1A38A  F033     NOP
1A38C  FFE3     NOP
7:             	u.i &= 0x7fffffff;
1A38E  0EFF     MOVLW 0xFF
1A390  9EE3     BCF 0xFE3, 7, ACCESS
8:             	return u.f;
1A392  0EFC     MOVLW 0xFC
1A396  FF8C     NOP
1A398  F001     NOP
1A39A  0EFD     MOVLW 0xFD
1A39E  FF8C     NOP
1A3A0  F002     NOP
1A3A2  0EFE     MOVLW 0xFE
1A3A6  FF8C     NOP
1A3A8  F003     NOP
1A3AA  0EFF     MOVLW 0xFF
1A3AE  FF8C     NOP
1A3B0  F004     NOP
9:             }
1A3B2  0EF8     MOVLW 0xF8
1A3B4  26E1     ADDWF 0xFE1, F, ACCESS
1A3B6  0EFF     MOVLW 0xFF
1A3B8  22E2     ADDWFC 0xFE2, F, ACCESS
1A3BA  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
19818  52E6     MOVF 0xFE6, F, ACCESS
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
19820  A03E     BTFSS flags, 0, ACCESS
19822  D010     BRA 0x9844
78:                    fputs((const char *)buf, fp);
19824  0EFA     MOVLW 0xFA
19828  FF8F     NOP
1982A  FFE6     NOP
1982E  FF8F     NOP
19830  FFE6     NOP
19832  0EF6     MOVLW 0xF6
19836  FF8F     NOP
19838  FFE6     NOP
1983C  FF8F     NOP
1983E  FFE6     NOP
19840  EC2D     CALL 0x1A65A, 0
19842  F0D3     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
19844  0EF7     MOVLW 0xF7
19846  BEE3     BTFSC 0xFE3, 7, ACCESS
19848  D011     BRA 0x986C
1984A  0EF6     MOVLW 0xF6
1984E  FF8C     NOP
19850  F001     NOP
19852  0EFC     MOVLW 0xFC
19856  F007     NOP
19858  FFE3     NOP
1985A  0EF7     MOVLW 0xF7
1985E  FF8C     NOP
19860  F001     NOP
19862  0EFD     MOVLW 0xFD
19866  F007     NOP
19868  FFE3     NOP
1986A  D004     BRA 0x9874
1986C  0EFC     MOVLW 0xFC
1986E  6AE3     CLRF 0xFE3, ACCESS
19870  0EFD     MOVLW 0xFD
19872  6AE3     CLRF 0xFE3, ACCESS
83:                i = 0;
19874  0EFE     MOVLW 0xFE
19876  6AE3     CLRF 0xFE3, ACCESS
19878  0EFF     MOVLW 0xFF
1987A  6AE3     CLRF 0xFE3, ACCESS
84:                while (i < w) {
1987C  D01E     BRA 0x98BA
198BA  50E1     MOVF 0xFE1, W, ACCESS
198BC  0FFE     ADDLW 0xFE
198BE  6ED9     MOVWF 0xFD9, ACCESS
198C0  50E2     MOVF 0xFE2, W, ACCESS
198C2  6EDA     MOVWF 0xFDA, ACCESS
198C4  0EFF     MOVLW 0xFF
198C6  22DA     ADDWFC 0xFDA, F, ACCESS
198C8  0EFC     MOVLW 0xFC
198CA  50E3     MOVF 0xFE3, W, ACCESS
198CC  5CDE     SUBWF 0xFDE, W, ACCESS
198CE  50DE     MOVF 0xFDE, W, ACCESS
198D0  0A80     XORLW 0x80
198D2  6E01     MOVWF ltemp0, ACCESS
198D4  0EFD     MOVLW 0xFD
198D6  50E3     MOVF 0xFE3, W, ACCESS
198D8  0A80     XORLW 0x80
198DA  5801     SUBWFB ltemp0, W, ACCESS
198DC  A0D8     BTFSS 0xFD8, 0, ACCESS
198DE  D7CF     BRA 0x987E
85:                    fputc(' ', fp);
1987E  0EFA     MOVLW 0xFA
19882  FF8F     NOP
19884  FFE6     NOP
19888  FF8F     NOP
1988A  FFE6     NOP
1988C  0E20     MOVLW 0x20
1988E  6EE6     MOVWF 0xFE6, ACCESS
19890  0E00     MOVLW 0x0
19892  6EE6     MOVWF 0xFE6, ACCESS
19894  EC61     CALL 0x194C2, 0
19896  F0CA     NOP
86:                    ++i;
19898  0EFE     MOVLW 0xFE
1989A  50E3     MOVF 0xFE3, W, ACCESS
1989C  0F01     ADDLW 0x1
1989E  6E01     MOVWF ltemp0, ACCESS
198A0  0EFE     MOVLW 0xFE
198A4  F007     NOP
198A6  FFE3     NOP
198A8  6A01     CLRF ltemp0, ACCESS
198AA  0EFF     MOVLW 0xFF
198AC  50E3     MOVF 0xFE3, W, ACCESS
198AE  2001     ADDWFC ltemp0, W, ACCESS
198B0  6E01     MOVWF ltemp0, ACCESS
198B2  0EFF     MOVLW 0xFF
198B6  F007     NOP
198B8  FFE3     NOP
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
198E0  B03E     BTFSC flags, 0, ACCESS
198E2  D010     BRA 0x9904
91:                    fputs((const char *)buf, fp);
198E4  0EFA     MOVLW 0xFA
198E8  FF8F     NOP
198EA  FFE6     NOP
198EE  FF8F     NOP
198F0  FFE6     NOP
198F2  0EF6     MOVLW 0xF6
198F6  FF8F     NOP
198F8  FFE6     NOP
198FC  FF8F     NOP
198FE  FFE6     NOP
19900  EC2D     CALL 0x1A65A, 0
19902  F0D3     NOP
92:                }
93:            
94:                return strlen(buf) + w;
19904  0EF8     MOVLW 0xF8
19908  FF8F     NOP
1990A  FFE6     NOP
1990E  FF8F     NOP
19910  FFE6     NOP
19912  ECDC     CALL 0x1A5B8, 0
19914  F0D2     NOP
19916  0EFC     MOVLW 0xFC
19918  50E3     MOVF 0xFE3, W, ACCESS
1991A  2601     ADDWF ltemp0, F, ACCESS
1991C  0EFD     MOVLW 0xFD
1991E  50E3     MOVF 0xFE3, W, ACCESS
19920  2202     ADDWFC ttemp5, F, ACCESS
95:            }
19922  0EF6     MOVLW 0xF6
19924  26E1     ADDWF 0xFE1, F, ACCESS
19926  0EFF     MOVLW 0xFF
19928  22E2     ADDWFC 0xFE2, F, ACCESS
1992A  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
1A8A8  52E6     MOVF 0xFE6, F, ACCESS
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
1A8AC  503A     MOVF width, W, ACCESS
1A8AE  103B     IORWF 0x3B, W, ACCESS
1A8B0  A4D8     BTFSS 0xFD8, 2, ACCESS
1A8B2  D009     BRA 0xA8C6
1A8B4  0EFE     MOVLW 0xFE
1A8B8  F0EB     NOP
1A8BA  FFE3     NOP
1A8BC  0EFF     MOVLW 0xFF
1A8C0  F0EF     NOP
1A8C2  FFE3     NOP
1A8C4  D016     BRA 0xA8F2
1A8C6  0EFF     MOVLW 0xFF
1A8C8  6E0B     MOVWF wtemp5, ACCESS
1A8CA  0EFF     MOVLW 0xFF
1A8CC  6E0C     MOVWF 0xC, ACCESS
1A8D0  F0E8     NOP
1A8D2  F009     NOP
1A8D6  F0EC     NOP
1A8D8  F00A     NOP
1A8DA  500B     MOVF wtemp5, W, ACCESS
1A8DC  2609     ADDWF ltemp2, F, ACCESS
1A8DE  500C     MOVF 0xC, W, ACCESS
1A8E0  220A     ADDWFC ttemp3, F, ACCESS
1A8E2  0EFE     MOVLW 0xFE
1A8E6  F027     NOP
1A8E8  FFE3     NOP
1A8EA  0EFF     MOVLW 0xFF
1A8EE  F02B     NOP
1A8F0  FFE3     NOP
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
1A8F2  0EFB     MOVLW 0xFB
1A8F6  FF8C     NOP
1A8F8  F297     NOP
268:               dbuf[1] = '\0';
1A8FA  0102     MOVLB 0x2
1A8FC  6B98     CLRF 0x98, BANKED
269:               return pad(fp, &dbuf[0], w);
1A8FE  0EFE     MOVLW 0xFE
1A902  FF8F     NOP
1A904  FFE6     NOP
1A908  FF8F     NOP
1A90A  FFE6     NOP
1A90C  0E97     MOVLW 0x97
1A90E  6EE6     MOVWF 0xFE6, ACCESS
1A910  0E02     MOVLW 0x2
1A912  6EE6     MOVWF 0xFE6, ACCESS
1A914  0EF8     MOVLW 0xF8
1A918  FF8F     NOP
1A91A  FFE6     NOP
1A91E  FF8F     NOP
1A920  FFE6     NOP
1A922  EC0C     CALL 0x19818, 0
1A924  F0CC     NOP
270:           }
1A926  0EFB     MOVLW 0xFB
1A928  26E1     ADDWF 0xFE1, F, ACCESS
1A92A  0EFF     MOVLW 0xFF
1A92C  22E2     ADDWFC 0xFE2, F, ACCESS
1A92E  0012     RETURN 0
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
15530  0E12     MOVLW 0x12
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
15538  0EE4     MOVLW 0xE4
1553A  24E1     ADDWF 0xFE1, W, ACCESS
1553C  6ED9     MOVWF 0xFD9, ACCESS
1553E  0EFF     MOVLW 0xFF
15540  20E2     ADDWFC 0xFE2, W, ACCESS
15542  6EDA     MOVWF 0xFDA, ACCESS
15544  0E08     MOVLW 0x8
15546  6E01     MOVWF ltemp0, ACCESS
15548  0EF0     MOVLW 0xF0
1554C  FF7B     NOP
1554E  FFE3     NOP
15550  28E8     INCF 0xFE8, W, ACCESS
15552  2E01     DECFSZ ltemp0, F, ACCESS
15554  D7FA     BRA 0x554A
281:               s = n < 0 ? 1 : 0;
15556  0EF7     MOVLW 0xF7
15558  AEE3     BTFSS 0xFE3, 7, ACCESS
1555A  D002     BRA 0x5560
1555C  0E01     MOVLW 0x1
1555E  D001     BRA 0x5562
15560  0E00     MOVLW 0x0
15562  6E0B     MOVWF wtemp5, ACCESS
15564  6A0C     CLRF 0xC, ACCESS
15566  0EFA     MOVLW 0xFA
1556A  F02F     NOP
1556C  FFE3     NOP
1556E  0EFB     MOVLW 0xFB
15572  F033     NOP
15574  FFE3     NOP
282:               if (s) {
15576  0EFA     MOVLW 0xFA
1557A  FF8C     NOP
1557C  F001     NOP
1557E  0EFB     MOVLW 0xFB
15580  50E3     MOVF 0xFE3, W, ACCESS
15582  1001     IORWF ltemp0, W, ACCESS
15584  B4D8     BTFSC 0xFD8, 2, ACCESS
15586  D025     BRA 0x55D2
283:                   n = -n;
15588  0EF0     MOVLW 0xF0
1558A  6CE3     NEGF 0xFE3, ACCESS
1558C  0EF1     MOVLW 0xF1
1558E  1EE3     COMF 0xFE3, F, ACCESS
15590  0EF2     MOVLW 0xF2
15592  1EE3     COMF 0xFE3, F, ACCESS
15594  0EF3     MOVLW 0xF3
15596  1EE3     COMF 0xFE3, F, ACCESS
15598  0EF4     MOVLW 0xF4
1559A  1EE3     COMF 0xFE3, F, ACCESS
1559C  0EF5     MOVLW 0xF5
1559E  1EE3     COMF 0xFE3, F, ACCESS
155A0  0EF6     MOVLW 0xF6
155A2  1EE3     COMF 0xFE3, F, ACCESS
155A4  0EF7     MOVLW 0xF7
155A6  1EE3     COMF 0xFE3, F, ACCESS
155A8  E314     BNC 0x55D2
155AA  0EF1     MOVLW 0xF1
155AC  2AE3     INCF 0xFE3, F, ACCESS
155AE  E311     BNC 0x55D2
155B0  0EF2     MOVLW 0xF2
155B2  2AE3     INCF 0xFE3, F, ACCESS
155B4  E30E     BNC 0x55D2
155B6  0EF3     MOVLW 0xF3
155B8  2AE3     INCF 0xFE3, F, ACCESS
155BA  E30B     BNC 0x55D2
155BC  0EF4     MOVLW 0xF4
155BE  2AE3     INCF 0xFE3, F, ACCESS
155C0  E308     BNC 0x55D2
155C2  0EF5     MOVLW 0xF5
155C4  2AE3     INCF 0xFE3, F, ACCESS
155C6  E305     BNC 0x55D2
155C8  0EF6     MOVLW 0xF6
155CA  2AE3     INCF 0xFE3, F, ACCESS
155CC  E302     BNC 0x55D2
155CE  0EF7     MOVLW 0xF7
155D0  2AE3     INCF 0xFE3, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
155D2  AE3D     BTFSS 0x3D, 7, ACCESS
288:                   flags &= ~ZERO_FLAG;
155D4  923E     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
155D6  BE3D     BTFSC 0x3D, 7, ACCESS
155D8  D005     BRA 0x55E4
155DA  503D     MOVF 0x3D, W, ACCESS
155DC  E110     BNZ 0x55FE
155DE  043C     DECF prec, W, ACCESS
155E0  B0D8     BTFSC 0xFD8, 0, ACCESS
155E2  D00D     BRA 0x55FE
155E4  0E01     MOVLW 0x1
155E6  6E0B     MOVWF wtemp5, ACCESS
155E8  0E00     MOVLW 0x0
155EA  6E0C     MOVWF 0xC, ACCESS
155EC  0EFE     MOVLW 0xFE
155F0  F02F     NOP
155F2  FFE3     NOP
155F4  0EFF     MOVLW 0xFF
155F8  F033     NOP
155FA  FFE3     NOP
155FC  D008     BRA 0x560E
155FE  0EFE     MOVLW 0xFE
15602  F0F3     NOP
15604  FFE3     NOP
15606  0EFF     MOVLW 0xFF
1560A  F0F7     NOP
1560C  FFE3     NOP
291:               w = width;
1560E  0EFC     MOVLW 0xFC
15612  F0EB     NOP
15614  FFE3     NOP
15616  0EFD     MOVLW 0xFD
1561A  F0EF     NOP
1561C  FFE3     NOP
292:               if (s || (flags & PLUS_FLAG)) {
1561E  0EFA     MOVLW 0xFA
15622  FF8C     NOP
15624  F001     NOP
15626  0EFB     MOVLW 0xFB
15628  50E3     MOVF 0xFE3, W, ACCESS
1562A  1001     IORWF ltemp0, W, ACCESS
1562C  A4D8     BTFSS 0xFD8, 2, ACCESS
1562E  D002     BRA 0x5634
15630  A43E     BTFSS flags, 2, ACCESS
15632  D00A     BRA 0x5648
293:                   --w;
15634  50E1     MOVF 0xFE1, W, ACCESS
15636  0FFC     ADDLW 0xFC
15638  6ED9     MOVWF 0xFD9, ACCESS
1563A  50E2     MOVF 0xFE2, W, ACCESS
1563C  6EDA     MOVWF 0xFDA, ACCESS
1563E  0EFF     MOVLW 0xFF
15640  22DA     ADDWFC 0xFDA, F, ACCESS
15642  06DE     DECF 0xFDE, F, ACCESS
15644  0E00     MOVLW 0x0
15646  5ADD     SUBWFB 0xFDD, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
15648  0E4F     MOVLW 0x4F
1564A  6E0B     MOVWF wtemp5, ACCESS
1564C  0E00     MOVLW 0x0
1564E  6E0C     MOVWF 0xC, ACCESS
15650  0EF8     MOVLW 0xF8
15654  F02F     NOP
15656  FFE3     NOP
15658  0EF9     MOVLW 0xF9
1565C  F033     NOP
1565E  FFE3     NOP
298:               dbuf[i] = '\0';
15660  0102     MOVLB 0x2
15662  6BE6     CLRF 0xE6, BANKED
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
15664  D109     BRA 0x5878
15878  0EF9     MOVLW 0xF9
1587A  BEE3     BTFSC 0xFE3, 7, ACCESS
1587C  D036     BRA 0x58EA
1587E  0EF9     MOVLW 0xF9
15880  50E3     MOVF 0xFE3, W, ACCESS
15882  E104     BNZ 0x588C
15884  0EF8     MOVLW 0xF8
15886  04E3     DECF 0xFE3, W, ACCESS
15888  A0D8     BTFSS 0xFD8, 0, ACCESS
1588A  D02F     BRA 0x58EA
1588C  0EF0     MOVLW 0xF0
1588E  50E3     MOVF 0xFE3, W, ACCESS
15890  E115     BNZ 0x58BC
15892  0EF1     MOVLW 0xF1
15894  50E3     MOVF 0xFE3, W, ACCESS
15896  E112     BNZ 0x58BC
15898  0EF2     MOVLW 0xF2
1589A  50E3     MOVF 0xFE3, W, ACCESS
1589C  E10F     BNZ 0x58BC
1589E  0EF3     MOVLW 0xF3
158A0  50E3     MOVF 0xFE3, W, ACCESS
158A2  E10C     BNZ 0x58BC
158A4  0EF4     MOVLW 0xF4
158A6  50E3     MOVF 0xFE3, W, ACCESS
158A8  E109     BNZ 0x58BC
158AA  0EF5     MOVLW 0xF5
158AC  50E3     MOVF 0xFE3, W, ACCESS
158AE  E106     BNZ 0x58BC
158B0  0EF6     MOVLW 0xF6
158B2  50E3     MOVF 0xFE3, W, ACCESS
158B4  E103     BNZ 0x58BC
158B6  0EF7     MOVLW 0xF7
158B8  50E3     MOVF 0xFE3, W, ACCESS
158BA  A4D8     BTFSS 0xFD8, 2, ACCESS
158BC  D6D4     BRA 0x5666
158BE  0EFF     MOVLW 0xFF
158C0  BEE3     BTFSC 0xFE3, 7, ACCESS
158C2  D007     BRA 0x58D2
158C4  0EFF     MOVLW 0xFF
158C6  50E3     MOVF 0xFE3, W, ACCESS
158C8  E103     BNZ 0x58D0
158CA  0EFE     MOVLW 0xFE
158CC  04E3     DECF 0xFE3, W, ACCESS
158CE  B0D8     BTFSC 0xFD8, 0, ACCESS
158D0  D6CA     BRA 0x5666
158D2  0EFD     MOVLW 0xFD
158D4  BEE3     BTFSC 0xFE3, 7, ACCESS
158D6  D009     BRA 0x58EA
158D8  0EFD     MOVLW 0xFD
158DA  50E3     MOVF 0xFE3, W, ACCESS
158DC  E104     BNZ 0x58E6
158DE  0EFC     MOVLW 0xFC
158E0  04E3     DECF 0xFE3, W, ACCESS
158E2  A0D8     BTFSS 0xFD8, 0, ACCESS
158E4  D002     BRA 0x58EA
158E6  B23E     BTFSC flags, 1, ACCESS
158E8  D6BE     BRA 0x5666
300:                   --i;
15666  50E1     MOVF 0xFE1, W, ACCESS
15668  0FF8     ADDLW 0xF8
1566A  6ED9     MOVWF 0xFD9, ACCESS
1566C  50E2     MOVF 0xFE2, W, ACCESS
1566E  6EDA     MOVWF 0xFDA, ACCESS
15670  0EFF     MOVLW 0xFF
15672  22DA     ADDWFC 0xFDA, F, ACCESS
15674  06DE     DECF 0xFDE, F, ACCESS
15676  0E00     MOVLW 0x0
15678  5ADD     SUBWFB 0xFDD, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
1567A  0E0A     MOVLW 0xA
1567C  6EE6     MOVWF 0xFE6, ACCESS
1567E  0E00     MOVLW 0x0
15680  6EE6     MOVWF 0xFE6, ACCESS
15682  0E00     MOVLW 0x0
15684  6EE6     MOVWF 0xFE6, ACCESS
15686  0E00     MOVLW 0x0
15688  6EE6     MOVWF 0xFE6, ACCESS
1568A  0E00     MOVLW 0x0
1568C  6EE6     MOVWF 0xFE6, ACCESS
1568E  0E00     MOVLW 0x0
15690  6EE6     MOVWF 0xFE6, ACCESS
15692  0E00     MOVLW 0x0
15694  6EE6     MOVWF 0xFE6, ACCESS
15696  0E00     MOVLW 0x0
15698  6EE6     MOVWF 0xFE6, ACCESS
1569A  50E1     MOVF 0xFE1, W, ACCESS
1569C  0FE8     ADDLW 0xE8
1569E  6ED9     MOVWF 0xFD9, ACCESS
156A0  50E2     MOVF 0xFE2, W, ACCESS
156A2  6EDA     MOVWF 0xFDA, ACCESS
156A4  0EFF     MOVLW 0xFF
156A6  22DA     ADDWFC 0xFDA, F, ACCESS
156AA  FF7B     NOP
156AC  FFE6     NOP
156B0  FF7B     NOP
156B2  FFE6     NOP
156B6  FF7B     NOP
156B8  FFE6     NOP
156BC  FF7B     NOP
156BE  FFE6     NOP
156C2  FF7B     NOP
156C4  FFE6     NOP
156C8  FF7B     NOP
156CA  FFE6     NOP
156CE  FF7B     NOP
156D0  FFE6     NOP
156D4  FF7B     NOP
156D6  FFE6     NOP
156D8  EC7C     CALL 0x178F8, 0
156DA  F0BC     NOP
156DC  52E5     MOVF 0xFE5, F, ACCESS
156E0  FF9C     NOP
156E2  F018     NOP
156E4  52E5     MOVF 0xFE5, F, ACCESS
156E8  FF9C     NOP
156EA  F017     NOP
156EC  52E5     MOVF 0xFE5, F, ACCESS
156F0  FF9C     NOP
156F2  F016     NOP
156F4  52E5     MOVF 0xFE5, F, ACCESS
156F8  FF9C     NOP
156FA  F015     NOP
156FC  52E5     MOVF 0xFE5, F, ACCESS
15700  FF9C     NOP
15702  F014     NOP
15704  52E5     MOVF 0xFE5, F, ACCESS
15708  FF9C     NOP
1570A  F013     NOP
1570C  52E5     MOVF 0xFE5, F, ACCESS
15710  FF9C     NOP
15712  F012     NOP
15714  52E5     MOVF 0xFE5, F, ACCESS
15718  FF9C     NOP
1571A  F011     NOP
1571C  0EF8     MOVLW 0xF8
1571E  26E1     ADDWF 0xFE1, F, ACCESS
15720  0EFF     MOVLW 0xFF
15722  22E2     ADDWFC 0xFE2, F, ACCESS
15726  F044     NOP
15728  F00B     NOP
1572C  F048     NOP
1572E  F00C     NOP
15732  F02F     NOP
15734  FFE6     NOP
15738  F033     NOP
1573A  FFE6     NOP
1573C  ECE1     CALL 0x1B1C2, 0
1573E  F0D8     NOP
15740  0E30     MOVLW 0x30
15742  2601     ADDWF ltemp0, F, ACCESS
15744  0EF8     MOVLW 0xF8
15748  FF8C     NOP
1574A  F00B     NOP
1574C  0EF9     MOVLW 0xF9
15750  FF8C     NOP
15752  F00C     NOP
15754  0E97     MOVLW 0x97
15756  240B     ADDWF wtemp5, W, ACCESS
15758  6ED9     MOVWF 0xFD9, ACCESS
1575A  0E02     MOVLW 0x2
1575C  200C     ADDWFC 0xC, W, ACCESS
1575E  6EDA     MOVWF 0xFDA, ACCESS
15762  F007     NOP
15764  FFDF     NOP
302:                   --p;
15766  50E1     MOVF 0xFE1, W, ACCESS
15768  0FFE     ADDLW 0xFE
1576A  6ED9     MOVWF 0xFD9, ACCESS
1576C  50E2     MOVF 0xFE2, W, ACCESS
1576E  6EDA     MOVWF 0xFDA, ACCESS
15770  0EFF     MOVLW 0xFF
15772  22DA     ADDWFC 0xFDA, F, ACCESS
15774  06DE     DECF 0xFDE, F, ACCESS
15776  0E00     MOVLW 0x0
15778  5ADD     SUBWFB 0xFDD, F, ACCESS
303:                   --w;
1577A  50E1     MOVF 0xFE1, W, ACCESS
1577C  0FFC     ADDLW 0xFC
1577E  6ED9     MOVWF 0xFD9, ACCESS
15780  50E2     MOVF 0xFE2, W, ACCESS
15782  6EDA     MOVWF 0xFDA, ACCESS
15784  0EFF     MOVLW 0xFF
15786  22DA     ADDWFC 0xFDA, F, ACCESS
15788  06DE     DECF 0xFDE, F, ACCESS
1578A  0E00     MOVLW 0x0
1578C  5ADD     SUBWFB 0xFDD, F, ACCESS
304:                   n = n / 10;
1578E  0E0A     MOVLW 0xA
15790  6EE6     MOVWF 0xFE6, ACCESS
15792  0E00     MOVLW 0x0
15794  6EE6     MOVWF 0xFE6, ACCESS
15796  0E00     MOVLW 0x0
15798  6EE6     MOVWF 0xFE6, ACCESS
1579A  0E00     MOVLW 0x0
1579C  6EE6     MOVWF 0xFE6, ACCESS
1579E  0E00     MOVLW 0x0
157A0  6EE6     MOVWF 0xFE6, ACCESS
157A2  0E00     MOVLW 0x0
157A4  6EE6     MOVWF 0xFE6, ACCESS
157A6  0E00     MOVLW 0x0
157A8  6EE6     MOVWF 0xFE6, ACCESS
157AA  0E00     MOVLW 0x0
157AC  6EE6     MOVWF 0xFE6, ACCESS
157AE  50E1     MOVF 0xFE1, W, ACCESS
157B0  0FE8     ADDLW 0xE8
157B2  6ED9     MOVWF 0xFD9, ACCESS
157B4  50E2     MOVF 0xFE2, W, ACCESS
157B6  6EDA     MOVWF 0xFDA, ACCESS
157B8  0EFF     MOVLW 0xFF
157BA  22DA     ADDWFC 0xFDA, F, ACCESS
157BE  FF7B     NOP
157C0  FFE6     NOP
157C4  FF7B     NOP
157C6  FFE6     NOP
157CA  FF7B     NOP
157CC  FFE6     NOP
157D0  FF7B     NOP
157D2  FFE6     NOP
157D6  FF7B     NOP
157D8  FFE6     NOP
157DC  FF7B     NOP
157DE  FFE6     NOP
157E2  FF7B     NOP
157E4  FFE6     NOP
157E8  FF7B     NOP
157EA  FFE6     NOP
157EC  EC02     CALL 0x17404, 0
157EE  F0BA     NOP
157F0  52E5     MOVF 0xFE5, F, ACCESS
157F4  FF9C     NOP
157F6  F018     NOP
157F8  52E5     MOVF 0xFE5, F, ACCESS
157FC  FF9C     NOP
157FE  F017     NOP
15800  52E5     MOVF 0xFE5, F, ACCESS
15804  FF9C     NOP
15806  F016     NOP
15808  52E5     MOVF 0xFE5, F, ACCESS
1580C  FF9C     NOP
1580E  F015     NOP
15810  52E5     MOVF 0xFE5, F, ACCESS
15814  FF9C     NOP
15816  F014     NOP
15818  52E5     MOVF 0xFE5, F, ACCESS
1581C  FF9C     NOP
1581E  F013     NOP
15820  52E5     MOVF 0xFE5, F, ACCESS
15824  FF9C     NOP
15826  F012     NOP
15828  52E5     MOVF 0xFE5, F, ACCESS
1582C  FF9C     NOP
1582E  F011     NOP
15830  0EF8     MOVLW 0xF8
15832  26E1     ADDWF 0xFE1, F, ACCESS
15834  0EFF     MOVLW 0xFF
15836  22E2     ADDWFC 0xFE2, F, ACCESS
15838  0EF0     MOVLW 0xF0
1583C  F047     NOP
1583E  FFE3     NOP
15840  0EF1     MOVLW 0xF1
15844  F04B     NOP
15846  FFE3     NOP
15848  0EF2     MOVLW 0xF2
1584C  F04F     NOP
1584E  FFE3     NOP
15850  0EF3     MOVLW 0xF3
15854  F053     NOP
15856  FFE3     NOP
15858  0EF4     MOVLW 0xF4
1585C  F057     NOP
1585E  FFE3     NOP
15860  0EF5     MOVLW 0xF5
15864  F05B     NOP
15866  FFE3     NOP
15868  0EF6     MOVLW 0xF6
1586C  F05F     NOP
1586E  FFE3     NOP
15870  0EF7     MOVLW 0xF7
15874  F063     NOP
15876  FFE3     NOP
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
158EA  0EFA     MOVLW 0xFA
158EE  FF8C     NOP
158F0  F001     NOP
158F2  0EFB     MOVLW 0xFB
158F4  50E3     MOVF 0xFE3, W, ACCESS
158F6  1001     IORWF ltemp0, W, ACCESS
158F8  A4D8     BTFSS 0xFD8, 2, ACCESS
158FA  D002     BRA 0x5900
158FC  A43E     BTFSS flags, 2, ACCESS
158FE  D033     BRA 0x5966
309:                   --i;
15900  50E1     MOVF 0xFE1, W, ACCESS
15902  0FF8     ADDLW 0xF8
15904  6ED9     MOVWF 0xFD9, ACCESS
15906  50E2     MOVF 0xFE2, W, ACCESS
15908  6EDA     MOVWF 0xFDA, ACCESS
1590A  0EFF     MOVLW 0xFF
1590C  22DA     ADDWFC 0xFDA, F, ACCESS
1590E  06DE     DECF 0xFDE, F, ACCESS
15910  0E00     MOVLW 0x0
15912  5ADD     SUBWFB 0xFDD, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
15914  0EFA     MOVLW 0xFA
15918  FF8C     NOP
1591A  F001     NOP
1591C  0EFB     MOVLW 0xFB
1591E  50E3     MOVF 0xFE3, W, ACCESS
15920  1001     IORWF ltemp0, W, ACCESS
15922  A4D8     BTFSS 0xFD8, 2, ACCESS
15924  D002     BRA 0x592A
15926  0E2B     MOVLW 0x2B
15928  D001     BRA 0x592C
1592A  0E2D     MOVLW 0x2D
1592C  6E0B     MOVWF wtemp5, ACCESS
1592E  0E00     MOVLW 0x0
15930  6E0C     MOVWF 0xC, ACCESS
15932  0EEE     MOVLW 0xEE
15936  F02F     NOP
15938  FFE3     NOP
1593A  0EEF     MOVLW 0xEF
1593E  F033     NOP
15940  FFE3     NOP
15942  0EF8     MOVLW 0xF8
15946  FF8C     NOP
15948  F00B     NOP
1594A  0EF9     MOVLW 0xF9
1594E  FF8C     NOP
15950  F00C     NOP
15952  0E97     MOVLW 0x97
15954  240B     ADDWF wtemp5, W, ACCESS
15956  6ED9     MOVWF 0xFD9, ACCESS
15958  0E02     MOVLW 0x2
1595A  200C     ADDWFC 0xC, W, ACCESS
1595C  6EDA     MOVWF 0xFDA, ACCESS
1595E  0EEE     MOVLW 0xEE
15962  FF8F     NOP
15964  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
15966  0EFC     MOVLW 0xFC
1596A  FF8F     NOP
1596C  FFE6     NOP
15970  FF8F     NOP
15972  FFE6     NOP
15974  0E97     MOVLW 0x97
15976  6E0B     MOVWF wtemp5, ACCESS
15978  0E02     MOVLW 0x2
1597A  6E0C     MOVWF 0xC, ACCESS
1597C  0EF6     MOVLW 0xF6
1597E  50E3     MOVF 0xFE3, W, ACCESS
15980  260B     ADDWF wtemp5, F, ACCESS
15982  0EF7     MOVLW 0xF7
15984  50E3     MOVF 0xFE3, W, ACCESS
15986  220C     ADDWFC 0xC, F, ACCESS
1598A  F02F     NOP
1598C  FFE6     NOP
15990  F033     NOP
15992  FFE6     NOP
15994  0EE8     MOVLW 0xE8
15998  FF8F     NOP
1599A  FFE6     NOP
1599E  FF8F     NOP
159A0  FFE6     NOP
159A2  EC0C     CALL 0x19818, 0
159A4  F0CC     NOP
315:           }
159A6  0EE4     MOVLW 0xE4
159A8  26E1     ADDWF 0xFE1, F, ACCESS
159AA  0EFF     MOVLW 0xFF
159AC  22E2     ADDWFC 0xFE2, F, ACCESS
159AE  0012     RETURN 0
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
10000  0E38     MOVLW 0x38
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
10008  0EF2     MOVLW 0xF2
1000A  6AE3     CLRF 0xFE3, ACCESS
1000C  0EF3     MOVLW 0xF3
1000E  6AE3     CLRF 0xFE3, ACCESS
327:               g = f;
10010  0EC2     MOVLW 0xC2
10014  FF8C     NOP
10016  F009     NOP
10018  0EC3     MOVLW 0xC3
1001C  FF8C     NOP
1001E  F00A     NOP
10020  0EC4     MOVLW 0xC4
10024  FF8C     NOP
10026  F00B     NOP
10028  0EC5     MOVLW 0xC5
1002C  FF8C     NOP
1002E  F00C     NOP
10030  0ED8     MOVLW 0xD8
10034  F027     NOP
10036  FFE3     NOP
10038  0ED9     MOVLW 0xD9
1003C  F02B     NOP
1003E  FFE3     NOP
10040  0EDA     MOVLW 0xDA
10044  F02F     NOP
10046  FFE3     NOP
10048  0EDB     MOVLW 0xDB
1004C  F033     NOP
1004E  FFE3     NOP
328:               if (g < 0.0) {
10050  0EDB     MOVLW 0xDB
10052  AEE3     BTFSS 0xFE3, 7, ACCESS
10054  D02B     BRA ivt0x8_undefint
329:                   sign = 1;
10056  0E01     MOVLW 0x1
10058  6E0B     MOVWF wtemp5, ACCESS
1005A  0E00     MOVLW 0x0
1005C  6E0C     MOVWF 0xC, ACCESS
1005E  0EF2     MOVLW 0xF2
10062  F02F     NOP
10064  FFE3     NOP
10066  0EF3     MOVLW 0xF3
1006A  F033     NOP
1006C  FFE3     NOP
330:                   g = -g;
1006E  0ED8     MOVLW 0xD8
10072  FF8F     NOP
10074  FFE6     NOP
10078  FF8F     NOP
1007A  FFE6     NOP
1007E  FF8F     NOP
10080  FFE6     NOP
10084  FF8F     NOP
10086  FFE6     NOP
10088  EC51     CALL 0x1B0A2, 0
1008A  F0D8     NOP
1008C  0ED8     MOVLW 0xD8
10090  F007     NOP
10092  FFE3     NOP
10094  0ED9     MOVLW 0xD9
10098  F00B     NOP
1009A  FFE3     NOP
1009C  0EDA     MOVLW 0xDA
100A0  F00F     NOP
100A2  FFE3     NOP
100A4  0EDB     MOVLW 0xDB
100A8  F013     NOP
100AA  FFE3     NOP
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
100AC  0EE8     MOVLW 0xE8
100AE  6AE3     CLRF 0xFE3, ACCESS
100B0  0EE9     MOVLW 0xE9
100B2  6AE3     CLRF 0xFE3, ACCESS
335:               w = width;
100B4  0EEE     MOVLW 0xEE
100B8  F0EB     NOP
100BA  FFE3     NOP
100BC  0EEF     MOVLW 0xEF
100C0  F0EF     NOP
100C2  FFE3     NOP
336:               if (sign || (flags & PLUS_FLAG)) {
100C4  0EF2     MOVLW 0xF2
100C8  FF8C     NOP
100CA  F001     NOP
100CC  0EF3     MOVLW 0xF3
100CE  50E3     MOVF 0xFE3, W, ACCESS
100D0  1001     IORWF ltemp0, W, ACCESS
100D2  A4D8     BTFSS 0xFD8, 2, ACCESS
100D4  D002     BRA 0xDA
100D6  A43E     BTFSS flags, 2, ACCESS
100D8  D036     BRA 0x146
337:                   dbuf[n] = sign ? '-' : '+';
100DA  0EF2     MOVLW 0xF2
100DE  FF8C     NOP
100E0  F001     NOP
100E2  0EF3     MOVLW 0xF3
100E4  50E3     MOVF 0xFE3, W, ACCESS
100E6  1001     IORWF ltemp0, W, ACCESS
100E8  A4D8     BTFSS 0xFD8, 2, ACCESS
100EA  D002     BRA 0xF0
100EC  0E2B     MOVLW 0x2B
100EE  D001     BRA 0xF2
100F0  0E2D     MOVLW 0x2D
100F2  6E0B     MOVWF wtemp5, ACCESS
100F4  0E00     MOVLW 0x0
100F6  6E0C     MOVWF 0xC, ACCESS
100F8  0ED2     MOVLW 0xD2
100FC  F02F     NOP
100FE  FFE3     NOP
10100  0ED3     MOVLW 0xD3
10104  F033     NOP
10106  FFE3     NOP
10108  0ED2     MOVLW 0xD2
1010C  FF8C     NOP
1010E  F297     NOP
338:                   ++n;
10110  0EE8     MOVLW 0xE8
10112  50E3     MOVF 0xFE3, W, ACCESS
10114  0F01     ADDLW 0x1
10116  6E01     MOVWF ltemp0, ACCESS
10118  0EE8     MOVLW 0xE8
1011C  F007     NOP
1011E  FFE3     NOP
10120  6A01     CLRF ltemp0, ACCESS
10122  0EE9     MOVLW 0xE9
10124  50E3     MOVF 0xFE3, W, ACCESS
10126  2001     ADDWFC ltemp0, W, ACCESS
10128  6E01     MOVWF ltemp0, ACCESS
1012A  0EE9     MOVLW 0xE9
1012E  F007     NOP
10130  FFE3     NOP
339:                   --w;
10132  50E1     MOVF 0xFE1, W, ACCESS
10134  0FEE     ADDLW 0xEE
10136  6ED9     MOVWF 0xFD9, ACCESS
10138  50E2     MOVF 0xFE2, W, ACCESS
1013A  6EDA     MOVWF 0xFDA, ACCESS
1013C  0EFF     MOVLW 0xFF
1013E  22DA     ADDWFC 0xFDA, F, ACCESS
10140  06DE     DECF 0xFDE, F, ACCESS
10142  0E00     MOVLW 0x0
10144  5ADD     SUBWFB 0xFDD, F, ACCESS
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
10146  0ED8     MOVLW 0xD8
1014A  FF8F     NOP
1014C  FFE6     NOP
10150  FF8F     NOP
10152  FFE6     NOP
10156  FF8F     NOP
10158  FFE6     NOP
1015C  FF8F     NOP
1015E  FFE6     NOP
10160  EC7A     CALL 0x186F4, 0
10162  F0C3     NOP
10164  0401     DECF ltemp0, W, ACCESS
10166  1002     IORWF ttemp5, W, ACCESS
10168  A4D8     BTFSS 0xFD8, 2, ACCESS
1016A  D076     BRA 0x258
344:                   if (isupper((int)c)) {
1016C  0EBF     MOVLW 0xBF
1016E  6E0B     MOVWF wtemp5, ACCESS
10170  0EFF     MOVLW 0xFF
10172  6E0C     MOVWF 0xC, ACCESS
10174  0EC1     MOVLW 0xC1
10176  50E3     MOVF 0xFE3, W, ACCESS
10178  6E09     MOVWF ltemp2, ACCESS
1017A  6A0A     CLRF ttemp3, ACCESS
1017C  500B     MOVF wtemp5, W, ACCESS
1017E  2609     ADDWF ltemp2, F, ACCESS
10180  500C     MOVF 0xC, W, ACCESS
10182  220A     ADDWFC ttemp3, F, ACCESS
10184  500A     MOVF ttemp3, W, ACCESS
10186  E106     BNZ 0x194
10188  0E1A     MOVLW 0x1A
1018A  5C09     SUBWF ltemp2, W, ACCESS
1018C  B0D8     BTFSC 0xFD8, 0, ACCESS
1018E  D002     BRA 0x194
10190  0E01     MOVLW 0x1
10192  D001     BRA 0x196
10194  0E00     MOVLW 0x0
10196  6E0B     MOVWF wtemp5, ACCESS
10198  6A0C     CLRF 0xC, ACCESS
1019A  0ED0     MOVLW 0xD0
1019E  F02F     NOP
101A0  FFE3     NOP
101A2  0ED1     MOVLW 0xD1
101A6  F033     NOP
101A8  FFE3     NOP
101AA  0ED0     MOVLW 0xD0
101AE  FF8C     NOP
101B0  F001     NOP
101B2  0ED1     MOVLW 0xD1
101B4  50E3     MOVF 0xFE3, W, ACCESS
101B6  1001     IORWF ltemp0, W, ACCESS
101B8  B4D8     BTFSC 0xFD8, 2, ACCESS
101BA  D017     BRA 0x1EA
345:                       strcpy(&dbuf[n], "INF");
101BC  0ED6     MOVLW 0xD6
101BE  6EE6     MOVWF 0xFE6, ACCESS
101C0  0EFF     MOVLW 0xFF
101C2  6EE6     MOVWF 0xFE6, ACCESS
101C4  0E97     MOVLW 0x97
101C6  6E0B     MOVWF wtemp5, ACCESS
101C8  0E02     MOVLW 0x2
101CA  6E0C     MOVWF 0xC, ACCESS
101CC  0EE6     MOVLW 0xE6
101CE  50E3     MOVF 0xFE3, W, ACCESS
101D0  260B     ADDWF wtemp5, F, ACCESS
101D2  0EE7     MOVLW 0xE7
101D4  50E3     MOVF 0xFE3, W, ACCESS
101D6  220C     ADDWFC 0xC, F, ACCESS
101DA  F02F     NOP
101DC  FFE6     NOP
101E0  F033     NOP
101E2  FFE6     NOP
101E4  EC5F     CALL 0x1A0BE, 0
101E6  F0D0     NOP
346:                   } else {
101E8  D016     BRA 0x216
347:                       strcpy(&dbuf[n], "inf");
101EA  0EDE     MOVLW 0xDE
101EC  6EE6     MOVWF 0xFE6, ACCESS
101EE  0EFF     MOVLW 0xFF
101F0  6EE6     MOVWF 0xFE6, ACCESS
101F2  0E97     MOVLW 0x97
101F4  6E0B     MOVWF wtemp5, ACCESS
101F6  0E02     MOVLW 0x2
101F8  6E0C     MOVWF 0xC, ACCESS
101FA  0EE6     MOVLW 0xE6
101FC  50E3     MOVF 0xFE3, W, ACCESS
101FE  260B     ADDWF wtemp5, F, ACCESS
10200  0EE7     MOVLW 0xE7
10202  50E3     MOVF 0xFE3, W, ACCESS
10204  220C     ADDWFC 0xC, F, ACCESS
10208  F02F     NOP
1020A  FFE6     NOP
1020E  F033     NOP
10210  FFE6     NOP
10212  EC5F     CALL 0x1A0BE, 0
10214  F0D0     NOP
348:                   }
349:                   w -= CSTRLEN("inf");
10216  50E1     MOVF 0xFE1, W, ACCESS
10218  0FEE     ADDLW 0xEE
1021A  6ED9     MOVWF 0xFD9, ACCESS
1021C  50E2     MOVF 0xFE2, W, ACCESS
1021E  6EDA     MOVWF 0xFDA, ACCESS
10220  0EFF     MOVLW 0xFF
10222  22DA     ADDWFC 0xFDA, F, ACCESS
10224  0EFD     MOVLW 0xFD
10226  26DE     ADDWF 0xFDE, F, ACCESS
10228  0EFF     MOVLW 0xFF
1022A  22DD     ADDWFC 0xFDD, F, ACCESS
350:                   return pad(fp, &dbuf[0], w);
1022C  0EEE     MOVLW 0xEE
10230  FF8F     NOP
10232  FFE6     NOP
10236  FF8F     NOP
10238  FFE6     NOP
1023A  0E97     MOVLW 0x97
1023C  6EE6     MOVWF 0xFE6, ACCESS
1023E  0E02     MOVLW 0x2
10240  6EE6     MOVWF 0xFE6, ACCESS
10242  0EC2     MOVLW 0xC2
10246  FF8F     NOP
10248  FFE6     NOP
1024C  FF8F     NOP
1024E  FFE6     NOP
10250  EC0C     CALL 0x19818, 0
10252  F0CC     NOP
10254  EF1D     GOTO 0x1123A
10256  F089     NOP
351:               }
352:               if (isnan(g)) {
10258  0ED8     MOVLW 0xD8
1025C  FF8F     NOP
1025E  FFE6     NOP
10262  FF8F     NOP
10264  FFE6     NOP
10268  FF8F     NOP
1026A  FFE6     NOP
1026E  FF8F     NOP
10270  FFE6     NOP
10272  EC7A     CALL 0x186F4, 0
10274  F0C3     NOP
10276  5001     MOVF ltemp0, W, ACCESS
10278  1002     IORWF ttemp5, W, ACCESS
1027A  A4D8     BTFSS 0xFD8, 2, ACCESS
1027C  D056     BRA 0x32A
353:                   if (isupper((int)c)) {
1027E  0EBF     MOVLW 0xBF
10280  6E0B     MOVWF wtemp5, ACCESS
10282  0EFF     MOVLW 0xFF
10284  6E0C     MOVWF 0xC, ACCESS
10286  0EC1     MOVLW 0xC1
10288  50E3     MOVF 0xFE3, W, ACCESS
1028A  6E09     MOVWF ltemp2, ACCESS
1028C  6A0A     CLRF ttemp3, ACCESS
1028E  500B     MOVF wtemp5, W, ACCESS
10290  2609     ADDWF ltemp2, F, ACCESS
10292  500C     MOVF 0xC, W, ACCESS
10294  220A     ADDWFC ttemp3, F, ACCESS
10296  500A     MOVF ttemp3, W, ACCESS
10298  E106     BNZ 0x2A6
1029A  0E1A     MOVLW 0x1A
1029C  5C09     SUBWF ltemp2, W, ACCESS
1029E  B0D8     BTFSC 0xFD8, 0, ACCESS
102A0  D002     BRA 0x2A6
102A2  0E01     MOVLW 0x1
102A4  D001     BRA 0x2A8
102A6  0E00     MOVLW 0x0
102A8  6E0B     MOVWF wtemp5, ACCESS
102AA  6A0C     CLRF 0xC, ACCESS
102AC  0ECE     MOVLW 0xCE
102B0  F02F     NOP
102B2  FFE3     NOP
102B4  0ECF     MOVLW 0xCF
102B8  F033     NOP
102BA  FFE3     NOP
102BC  0ECE     MOVLW 0xCE
102C0  FF8C     NOP
102C2  F001     NOP
102C4  0ECF     MOVLW 0xCF
102C6  50E3     MOVF 0xFE3, W, ACCESS
102C8  1001     IORWF ltemp0, W, ACCESS
102CA  B4D8     BTFSC 0xFD8, 2, ACCESS
102CC  D017     BRA 0x2FC
354:                       strcpy(&dbuf[n], "NAN");
102CE  0EDA     MOVLW 0xDA
102D0  6EE6     MOVWF 0xFE6, ACCESS
102D2  0EFF     MOVLW 0xFF
102D4  6EE6     MOVWF 0xFE6, ACCESS
102D6  0E97     MOVLW 0x97
102D8  6E0B     MOVWF wtemp5, ACCESS
102DA  0E02     MOVLW 0x2
102DC  6E0C     MOVWF 0xC, ACCESS
102DE  0EE6     MOVLW 0xE6
102E0  50E3     MOVF 0xFE3, W, ACCESS
102E2  260B     ADDWF wtemp5, F, ACCESS
102E4  0EE7     MOVLW 0xE7
102E6  50E3     MOVF 0xFE3, W, ACCESS
102E8  220C     ADDWFC 0xC, F, ACCESS
102EC  F02F     NOP
102EE  FFE6     NOP
102F2  F033     NOP
102F4  FFE6     NOP
102F6  EC5F     CALL 0x1A0BE, 0
102F8  F0D0     NOP
355:                   } else {
102FA  D78D     BRA 0x216
356:                       strcpy(&dbuf[n], "nan");
102FC  0EE2     MOVLW 0xE2
102FE  6EE6     MOVWF 0xFE6, ACCESS
10300  0EFF     MOVLW 0xFF
10302  6EE6     MOVWF 0xFE6, ACCESS
10304  0E97     MOVLW 0x97
10306  6E0B     MOVWF wtemp5, ACCESS
10308  0E02     MOVLW 0x2
1030A  6E0C     MOVWF 0xC, ACCESS
1030C  0EE6     MOVLW 0xE6
1030E  50E3     MOVF 0xFE3, W, ACCESS
10310  260B     ADDWF wtemp5, F, ACCESS
10312  0EE7     MOVLW 0xE7
10314  50E3     MOVF 0xFE3, W, ACCESS
10316  220C     ADDWFC 0xC, F, ACCESS
1031A  F02F     NOP
1031C  FFE6     NOP
10320  F033     NOP
10322  FFE6     NOP
10324  EC5F     CALL 0x1A0BE, 0
10326  F0D0     NOP
10328  D776     BRA 0x216
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
1032A  0E00     MOVLW 0x0
1032C  6E09     MOVWF ltemp2, ACCESS
1032E  0E00     MOVLW 0x0
10330  6E0A     MOVWF ttemp3, ACCESS
10332  0E80     MOVLW 0x80
10334  6E0B     MOVWF wtemp5, ACCESS
10336  0E3F     MOVLW 0x3F
10338  6E0C     MOVWF 0xC, ACCESS
1033A  0ED4     MOVLW 0xD4
1033E  F027     NOP
10340  FFE3     NOP
10342  0ED5     MOVLW 0xD5
10346  F02B     NOP
10348  FFE3     NOP
1034A  0ED6     MOVLW 0xD6
1034E  F02F     NOP
10350  FFE3     NOP
10352  0ED7     MOVLW 0xD7
10356  F033     NOP
10358  FFE3     NOP
364:               e = 0;
1035A  0EEA     MOVLW 0xEA
1035C  6AE3     CLRF 0xFE3, ACCESS
1035E  0EEB     MOVLW 0xEB
10360  6AE3     CLRF 0xFE3, ACCESS
365:               if (!(g == 0.0)) {
10362  0E00     MOVLW 0x0
10364  6EE6     MOVWF 0xFE6, ACCESS
10366  0E00     MOVLW 0x0
10368  6EE6     MOVWF 0xFE6, ACCESS
1036A  0E00     MOVLW 0x0
1036C  6EE6     MOVWF 0xFE6, ACCESS
1036E  0E00     MOVLW 0x0
10370  6EE6     MOVWF 0xFE6, ACCESS
10372  0ED4     MOVLW 0xD4
10376  FF8F     NOP
10378  FFE6     NOP
1037C  FF8F     NOP
1037E  FFE6     NOP
10382  FF8F     NOP
10384  FFE6     NOP
10388  FF8F     NOP
1038A  FFE6     NOP
1038C  ECC9     CALL 0x1A192, 0
1038E  F0D0     NOP
10390  A001     BTFSS ltemp0, 0, ACCESS
10392  D039     BRA 0x406
10394  D0BC     BRA 0x50E
366:                   while (!(g < (u*10.0))) {
10406  0E00     MOVLW 0x0
10408  6EE6     MOVWF 0xFE6, ACCESS
1040A  0E00     MOVLW 0x0
1040C  6EE6     MOVWF 0xFE6, ACCESS
1040E  0E20     MOVLW 0x20
10410  6EE6     MOVWF 0xFE6, ACCESS
10412  0E41     MOVLW 0x41
10414  6EE6     MOVWF 0xFE6, ACCESS
10416  0ED0     MOVLW 0xD0
1041A  FF8F     NOP
1041C  FFE6     NOP
10420  FF8F     NOP
10422  FFE6     NOP
10426  FF8F     NOP
10428  FFE6     NOP
1042C  FF8F     NOP
1042E  FFE6     NOP
10430  ECA0     CALL 0x13340, 0
10432  F099     NOP
10436  F007     NOP
10438  FFE6     NOP
1043C  F00B     NOP
1043E  FFE6     NOP
10442  F00F     NOP
10444  FFE6     NOP
10448  F013     NOP
1044A  FFE6     NOP
1044C  0ED4     MOVLW 0xD4
10450  FF8F     NOP
10452  FFE6     NOP
10456  FF8F     NOP
10458  FFE6     NOP
1045C  FF8F     NOP
1045E  FFE6     NOP
10462  FF8F     NOP
10464  FFE6     NOP
10466  EC81     CALL 0x18D02, 0
10468  F0C6     NOP
1046A  A001     BTFSS ltemp0, 0, ACCESS
1046C  D032     BRA 0x4D2
1046E  D793     BRA 0x396
367:                       u = u*10.0;
10396  0E00     MOVLW 0x0
10398  6EE6     MOVWF 0xFE6, ACCESS
1039A  0E00     MOVLW 0x0
1039C  6EE6     MOVWF 0xFE6, ACCESS
1039E  0E20     MOVLW 0x20
103A0  6EE6     MOVWF 0xFE6, ACCESS
103A2  0E41     MOVLW 0x41
103A4  6EE6     MOVWF 0xFE6, ACCESS
103A6  0ED0     MOVLW 0xD0
103AA  FF8F     NOP
103AC  FFE6     NOP
103B0  FF8F     NOP
103B2  FFE6     NOP
103B6  FF8F     NOP
103B8  FFE6     NOP
103BC  FF8F     NOP
103BE  FFE6     NOP
103C0  ECA0     CALL 0x13340, 0
103C2  F099     NOP
103C4  0ED4     MOVLW 0xD4
103C8  F007     NOP
103CA  FFE3     NOP
103CC  0ED5     MOVLW 0xD5
103D0  F00B     NOP
103D2  FFE3     NOP
103D4  0ED6     MOVLW 0xD6
103D8  F00F     NOP
103DA  FFE3     NOP
103DC  0ED7     MOVLW 0xD7
103E0  F013     NOP
103E2  FFE3     NOP
368:                       ++e;
103E4  0EEA     MOVLW 0xEA
103E6  50E3     MOVF 0xFE3, W, ACCESS
103E8  0F01     ADDLW 0x1
103EA  6E01     MOVWF ltemp0, ACCESS
103EC  0EEA     MOVLW 0xEA
103F0  F007     NOP
103F2  FFE3     NOP
103F4  6A01     CLRF ltemp0, ACCESS
103F6  0EEB     MOVLW 0xEB
103F8  50E3     MOVF 0xFE3, W, ACCESS
103FA  2001     ADDWFC ltemp0, W, ACCESS
103FC  6E01     MOVWF ltemp0, ACCESS
103FE  0EEB     MOVLW 0xEB
10402  F007     NOP
10404  FFE3     NOP
369:                   }
370:                   while (g < u) {
104D2  0ED4     MOVLW 0xD4
104D6  FF8F     NOP
104D8  FFE6     NOP
104DC  FF8F     NOP
104DE  FFE6     NOP
104E2  FF8F     NOP
104E4  FFE6     NOP
104E8  FF8F     NOP
104EA  FFE6     NOP
104EC  0ED4     MOVLW 0xD4
104F0  FF8F     NOP
104F2  FFE6     NOP
104F6  FF8F     NOP
104F8  FFE6     NOP
104FC  FF8F     NOP
104FE  FFE6     NOP
10502  FF8F     NOP
10504  FFE6     NOP
10506  EC81     CALL 0x18D02, 0
10508  F0C6     NOP
1050A  A001     BTFSS ltemp0, 0, ACCESS
1050C  D7B1     BRA 0x470
371:                       u = u/10.0;
10470  0E00     MOVLW 0x0
10472  6EE6     MOVWF 0xFE6, ACCESS
10474  0E00     MOVLW 0x0
10476  6EE6     MOVWF 0xFE6, ACCESS
10478  0E20     MOVLW 0x20
1047A  6EE6     MOVWF 0xFE6, ACCESS
1047C  0E41     MOVLW 0x41
1047E  6EE6     MOVWF 0xFE6, ACCESS
10480  0ED0     MOVLW 0xD0
10484  FF8F     NOP
10486  FFE6     NOP
1048A  FF8F     NOP
1048C  FFE6     NOP
10490  FF8F     NOP
10492  FFE6     NOP
10496  FF8F     NOP
10498  FFE6     NOP
1049A  EC51     CALL 0x14AA2, 0
1049C  F0A5     NOP
1049E  0ED4     MOVLW 0xD4
104A2  F007     NOP
104A4  FFE3     NOP
104A6  0ED5     MOVLW 0xD5
104AA  F00B     NOP
104AC  FFE3     NOP
104AE  0ED6     MOVLW 0xD6
104B2  F00F     NOP
104B4  FFE3     NOP
104B6  0ED7     MOVLW 0xD7
104BA  F013     NOP
104BC  FFE3     NOP
372:                       --e;
104BE  50E1     MOVF 0xFE1, W, ACCESS
104C0  0FEA     ADDLW 0xEA
104C2  6ED9     MOVWF 0xFD9, ACCESS
104C4  50E2     MOVF 0xFE2, W, ACCESS
104C6  6EDA     MOVWF 0xFDA, ACCESS
104C8  0EFF     MOVLW 0xFF
104CA  22DA     ADDWFC 0xFDA, F, ACCESS
104CC  06DE     DECF 0xFDE, F, ACCESS
104CE  0E00     MOVLW 0x0
104D0  5ADD     SUBWFB 0xFDD, F, ACCESS
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
1050E  0EC1     MOVLW 0xC1
10510  50E3     MOVF 0xFE3, W, ACCESS
10512  6EE6     MOVWF 0xFE6, ACCESS
10514  0E00     MOVLW 0x0
10516  6EE6     MOVWF 0xFE6, ACCESS
10518  ECDA     CALL 0x1A9B4, 0
1051A  F0D4     NOP
1051C  0EFE     MOVLW 0xFE
10520  F007     NOP
10522  FFE3     NOP
378:               nmode = mode;
10524  0EFE     MOVLW 0xFE
10528  FF8C     NOP
1052A  F001     NOP
1052C  0EFF     MOVLW 0xFF
10530  F007     NOP
10532  FFE3     NOP
379:               if (mode == 'g') {
10534  0EFE     MOVLW 0xFE
10538  FF8C     NOP
1053A  F001     NOP
1053C  0E67     MOVLW 0x67
1053E  1801     XORWF ltemp0, W, ACCESS
10540  A4D8     BTFSS 0xFD8, 2, ACCESS
10542  D025     BRA 0x58E
380:           		if (prec == 0) {
10544  503C     MOVF prec, W, ACCESS
10546  103D     IORWF 0x3D, W, ACCESS
10548  A4D8     BTFSS 0xFD8, 2, ACCESS
1054A  D004     BRA 0x554
381:           			prec = 1;
1054C  0E00     MOVLW 0x0
1054E  6E3D     MOVWF 0x3D, ACCESS
10550  0E01     MOVLW 0x1
10552  6E3C     MOVWF prec, ACCESS
382:           		}
383:                   p = (0 < prec) ? prec : 6;
10554  BE3D     BTFSC 0x3D, 7, ACCESS
10556  D005     BRA 0x562
10558  503D     MOVF 0x3D, W, ACCESS
1055A  E110     BNZ 0x57C
1055C  043C     DECF prec, W, ACCESS
1055E  B0D8     BTFSC 0xFD8, 0, ACCESS
10560  D00D     BRA 0x57C
10562  0E06     MOVLW 0x6
10564  6E0B     MOVWF wtemp5, ACCESS
10566  0E00     MOVLW 0x0
10568  6E0C     MOVWF 0xC, ACCESS
1056A  0EF0     MOVLW 0xF0
1056E  F02F     NOP
10570  FFE3     NOP
10572  0EF1     MOVLW 0xF1
10576  F033     NOP
10578  FFE3     NOP
1057A  D00C     BRA 0x594
1057C  0EF0     MOVLW 0xF0
10580  F0F3     NOP
10582  FFE3     NOP
10584  0EF1     MOVLW 0xF1
10588  F0F7     NOP
1058A  FFE3     NOP
1058C  D003     BRA 0x594
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
1058E  AE3D     BTFSS 0x3D, 7, ACCESS
10590  D7F5     BRA 0x57C
10592  D7E7     BRA 0x562
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
10594  0EFE     MOVLW 0xFE
10598  FF8C     NOP
1059A  F001     NOP
1059C  0E67     MOVLW 0x67
1059E  1801     XORWF ltemp0, W, ACCESS
105A0  A4D8     BTFSS 0xFD8, 2, ACCESS
105A2  D02F     BRA 0x602
390:                   if (!(e < -4) && !((p - 1) < e)) {
105A4  0EEB     MOVLW 0xEB
105A6  AEE3     BTFSS 0xFE3, 7, ACCESS
105A8  D00E     BRA 0x5C6
105AA  0EEA     MOVLW 0xEA
105AE  FF8C     NOP
105B0  F001     NOP
105B2  0EFC     MOVLW 0xFC
105B4  5E01     SUBWF ltemp0, F, ACCESS
105B6  0EEB     MOVLW 0xEB
105BA  FF8C     NOP
105BC  F001     NOP
105BE  0EFF     MOVLW 0xFF
105C0  5A01     SUBWFB ltemp0, F, ACCESS
105C2  A0D8     BTFSS 0xFD8, 0, ACCESS
105C4  D018     BRA 0x5F6
105C6  0EF0     MOVLW 0xF0
105C8  50E3     MOVF 0xFE3, W, ACCESS
105CA  0FFF     ADDLW 0xFF
105CC  6E0B     MOVWF wtemp5, ACCESS
105CE  0EF1     MOVLW 0xF1
105D2  FF8C     NOP
105D4  F00C     NOP
105D6  0EFF     MOVLW 0xFF
105D8  220C     ADDWFC 0xC, F, ACCESS
105DA  0EEA     MOVLW 0xEA
105DC  50E3     MOVF 0xFE3, W, ACCESS
105DE  5C0B     SUBWF wtemp5, W, ACCESS
105E0  500C     MOVF 0xC, W, ACCESS
105E2  0A80     XORLW 0x80
105E4  6E01     MOVWF ltemp0, ACCESS
105E6  0EEB     MOVLW 0xEB
105E8  50E3     MOVF 0xFE3, W, ACCESS
105EA  0A80     XORLW 0x80
105EC  5801     SUBWFB ltemp0, W, ACCESS
105EE  A0D8     BTFSS 0xFD8, 0, ACCESS
105F0  D002     BRA 0x5F6
391:                       nmode = 'f';
105F2  0E66     MOVLW 0x66
105F4  D001     BRA 0x5F8
392:                   } else {
393:                       nmode = 'e';
105F6  0E65     MOVLW 0x65
105F8  6E0C     MOVWF 0xC, ACCESS
105FA  0EFF     MOVLW 0xFF
105FE  F033     NOP
10600  FFE3     NOP
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
10602  0EF0     MOVLW 0xF0
10606  FF8C     NOP
10608  F001     NOP
1060A  0EF8     MOVLW 0xF8
1060E  F007     NOP
10610  FFE3     NOP
10612  0EF1     MOVLW 0xF1
10616  FF8C     NOP
10618  F001     NOP
1061A  0EF9     MOVLW 0xF9
1061E  F007     NOP
10620  FFE3     NOP
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
10622  0EFE     MOVLW 0xFE
10626  FF8C     NOP
10628  F001     NOP
1062A  0E67     MOVLW 0x67
1062C  1801     XORWF ltemp0, W, ACCESS
1062E  A4D8     BTFSS 0xFD8, 2, ACCESS
10630  D00B     BRA 0x648
10632  0EFF     MOVLW 0xFF
10636  FF8C     NOP
10638  F001     NOP
1063A  0E66     MOVLW 0x66
1063C  1801     XORWF ltemp0, W, ACCESS
1063E  A4D8     BTFSS 0xFD8, 2, ACCESS
10640  D014     BRA 0x66A
10642  0EEB     MOVLW 0xEB
10644  AEE3     BTFSS 0xFE3, 7, ACCESS
10646  D011     BRA 0x66A
400:                   ++m;
10648  0EF8     MOVLW 0xF8
1064A  50E3     MOVF 0xFE3, W, ACCESS
1064C  0F01     ADDLW 0x1
1064E  6E01     MOVWF ltemp0, ACCESS
10650  0EF8     MOVLW 0xF8
10654  F007     NOP
10656  FFE3     NOP
10658  6A01     CLRF ltemp0, ACCESS
1065A  0EF9     MOVLW 0xF9
1065C  50E3     MOVF 0xFE3, W, ACCESS
1065E  2001     ADDWFC ltemp0, W, ACCESS
10660  6E01     MOVWF ltemp0, ACCESS
10662  0EF9     MOVLW 0xF9
10666  F007     NOP
10668  FFE3     NOP
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
1066A  0EFF     MOVLW 0xFF
1066E  FF8C     NOP
10670  F001     NOP
10672  0E66     MOVLW 0x66
10674  1801     XORWF ltemp0, W, ACCESS
10676  A4D8     BTFSS 0xFD8, 2, ACCESS
10678  D03B     BRA 0x6F0
405:                   if (e < 0) {
1067A  0EEB     MOVLW 0xEB
1067C  AEE3     BTFSS 0xFE3, 7, ACCESS
1067E  D01C     BRA 0x6B8
406:                       u = 1.0;
10680  0E00     MOVLW 0x0
10682  6E09     MOVWF ltemp2, ACCESS
10684  0E00     MOVLW 0x0
10686  6E0A     MOVWF ttemp3, ACCESS
10688  0E80     MOVLW 0x80
1068A  6E0B     MOVWF wtemp5, ACCESS
1068C  0E3F     MOVLW 0x3F
1068E  6E0C     MOVWF 0xC, ACCESS
10690  0ED4     MOVLW 0xD4
10694  F027     NOP
10696  FFE3     NOP
10698  0ED5     MOVLW 0xD5
1069C  F02B     NOP
1069E  FFE3     NOP
106A0  0ED6     MOVLW 0xD6
106A4  F02F     NOP
106A6  FFE3     NOP
106A8  0ED7     MOVLW 0xD7
106AC  F033     NOP
106AE  FFE3     NOP
407:                       e = 0;
106B0  0EEA     MOVLW 0xEA
106B2  6AE3     CLRF 0xFE3, ACCESS
106B4  0EEB     MOVLW 0xEB
106B6  6AE3     CLRF 0xFE3, ACCESS
408:                   }
409:                   if (!(mode == 'g')) {
106B8  0EFE     MOVLW 0xFE
106BC  FF8C     NOP
106BE  F001     NOP
106C0  0E67     MOVLW 0x67
106C2  1801     XORWF ltemp0, W, ACCESS
106C4  B4D8     BTFSC 0xFD8, 2, ACCESS
106C6  D014     BRA 0x6F0
410:                       m += e;
106C8  0EF8     MOVLW 0xF8
106CA  50E3     MOVF 0xFE3, W, ACCESS
106CC  6E01     MOVWF ltemp0, ACCESS
106CE  0EEA     MOVLW 0xEA
106D0  50E3     MOVF 0xFE3, W, ACCESS
106D2  2601     ADDWF ltemp0, F, ACCESS
106D4  0EF8     MOVLW 0xF8
106D8  F007     NOP
106DA  FFE3     NOP
106DC  0EF9     MOVLW 0xF9
106DE  50E3     MOVF 0xFE3, W, ACCESS
106E0  6E01     MOVWF ltemp0, ACCESS
106E2  0EEB     MOVLW 0xEB
106E4  50E3     MOVF 0xFE3, W, ACCESS
106E6  2201     ADDWFC ltemp0, F, ACCESS
106E8  0EF9     MOVLW 0xF9
106EC  F007     NOP
106EE  FFE3     NOP
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
106F0  0EEC     MOVLW 0xEC
106F2  6AE3     CLRF 0xFE3, ACCESS
106F4  0EED     MOVLW 0xED
106F6  6AE3     CLRF 0xFE3, ACCESS
416:               h = g;
106F8  0ED8     MOVLW 0xD8
106FC  FF8C     NOP
106FE  F009     NOP
10700  0ED9     MOVLW 0xD9
10704  FF8C     NOP
10706  F00A     NOP
10708  0EDA     MOVLW 0xDA
1070C  FF8C     NOP
1070E  F00B     NOP
10710  0EDB     MOVLW 0xDB
10714  FF8C     NOP
10716  F00C     NOP
10718  0EE0     MOVLW 0xE0
1071C  F027     NOP
1071E  FFE3     NOP
10720  0EE1     MOVLW 0xE1
10724  F02B     NOP
10726  FFE3     NOP
10728  0EE2     MOVLW 0xE2
1072C  F02F     NOP
1072E  FFE3     NOP
10730  0EE3     MOVLW 0xE3
10734  F033     NOP
10736  FFE3     NOP
417:               ou = u;
10738  0ED4     MOVLW 0xD4
1073C  FF8C     NOP
1073E  F009     NOP
10740  0ED5     MOVLW 0xD5
10744  FF8C     NOP
10746  F00A     NOP
10748  0ED6     MOVLW 0xD6
1074C  FF8C     NOP
1074E  F00B     NOP
10750  0ED7     MOVLW 0xD7
10754  FF8C     NOP
10756  F00C     NOP
10758  0EE4     MOVLW 0xE4
1075C  F027     NOP
1075E  FFE3     NOP
10760  0EE5     MOVLW 0xE5
10764  F02B     NOP
10766  FFE3     NOP
10768  0EE6     MOVLW 0xE6
1076C  F02F     NOP
1076E  FFE3     NOP
10770  0EE7     MOVLW 0xE7
10774  F033     NOP
10776  FFE3     NOP
418:               while (i < m) {
10778  D0D6     BRA 0x926
10926  50E1     MOVF 0xFE1, W, ACCESS
10928  0FEC     ADDLW 0xEC
1092A  6ED9     MOVWF 0xFD9, ACCESS
1092C  50E2     MOVF 0xFE2, W, ACCESS
1092E  6EDA     MOVWF 0xFDA, ACCESS
10930  0EFF     MOVLW 0xFF
10932  22DA     ADDWFC 0xFDA, F, ACCESS
10934  0EF8     MOVLW 0xF8
10936  50E3     MOVF 0xFE3, W, ACCESS
10938  5CDE     SUBWF 0xFDE, W, ACCESS
1093A  50DE     MOVF 0xFDE, W, ACCESS
1093C  0A80     XORLW 0x80
1093E  6E01     MOVWF ltemp0, ACCESS
10940  0EF9     MOVLW 0xF9
10942  50E3     MOVF 0xFE3, W, ACCESS
10944  0A80     XORLW 0x80
10946  5801     SUBWFB ltemp0, W, ACCESS
10948  A0D8     BTFSS 0xFD8, 0, ACCESS
1094A  D717     BRA 0x77A
419:                   l = floor(h/u);
1077A  0ED4     MOVLW 0xD4
1077E  FF8F     NOP
10780  FFE6     NOP
10784  FF8F     NOP
10786  FFE6     NOP
1078A  FF8F     NOP
1078C  FFE6     NOP
10790  FF8F     NOP
10792  FFE6     NOP
10794  0EDC     MOVLW 0xDC
10798  FF8F     NOP
1079A  FFE6     NOP
1079E  FF8F     NOP
107A0  FFE6     NOP
107A4  FF8F     NOP
107A6  FFE6     NOP
107AA  FF8F     NOP
107AC  FFE6     NOP
107AE  EC51     CALL 0x14AA2, 0
107B0  F0A5     NOP
107B4  F007     NOP
107B6  FFE6     NOP
107BA  F00B     NOP
107BC  FFE6     NOP
107C0  F00F     NOP
107C2  FFE6     NOP
107C6  F013     NOP
107C8  FFE6     NOP
107CA  ECDB     CALL 0x161B6, 0
107CC  F0B0     NOP
107CE  0EDC     MOVLW 0xDC
107D2  F007     NOP
107D4  FFE3     NOP
107D6  0EDD     MOVLW 0xDD
107DA  F00B     NOP
107DC  FFE3     NOP
107DE  0EDE     MOVLW 0xDE
107E2  F00F     NOP
107E4  FFE3     NOP
107E6  0EDF     MOVLW 0xDF
107EA  F013     NOP
107EC  FFE3     NOP
420:                   d = (int)l;
107EE  0EDC     MOVLW 0xDC
107F2  FF8F     NOP
107F4  FFE6     NOP
107F8  FF8F     NOP
107FA  FFE6     NOP
107FE  FF8F     NOP
10800  FFE6     NOP
10804  FF8F     NOP
10806  FFE6     NOP
10808  ECC8     CALL 0x18B90, 0
1080A  F0C5     NOP
1080E  F004     NOP
10810  F00B     NOP
10814  F008     NOP
10816  F00C     NOP
10818  0EF4     MOVLW 0xF4
1081C  F02F     NOP
1081E  FFE3     NOP
10820  0EF5     MOVLW 0xF5
10824  F033     NOP
10826  FFE3     NOP
421:                   h -= l*u;
10828  0ED4     MOVLW 0xD4
1082C  FF8F     NOP
1082E  FFE6     NOP
10832  FF8F     NOP
10834  FFE6     NOP
10838  FF8F     NOP
1083A  FFE6     NOP
1083E  FF8F     NOP
10840  FFE6     NOP
10842  0ED8     MOVLW 0xD8
10846  FF8F     NOP
10848  FFE6     NOP
1084C  FF8F     NOP
1084E  FFE6     NOP
10852  FF8F     NOP
10854  FFE6     NOP
10858  FF8F     NOP
1085A  FFE6     NOP
1085C  ECA0     CALL 0x13340, 0
1085E  F099     NOP
10862  F007     NOP
10864  FFE6     NOP
10868  F00B     NOP
1086A  FFE6     NOP
1086E  F00F     NOP
10870  FFE6     NOP
10874  F013     NOP
10876  FFE6     NOP
10878  0EDC     MOVLW 0xDC
1087C  FF8F     NOP
1087E  FFE6     NOP
10882  FF8F     NOP
10884  FFE6     NOP
10888  FF8F     NOP
1088A  FFE6     NOP
1088E  FF8F     NOP
10890  FFE6     NOP
10892  EC04     CALL 0x1B208, 0
10894  F0D9     NOP
10896  0EE0     MOVLW 0xE0
1089A  F007     NOP
1089C  FFE3     NOP
1089E  0EE1     MOVLW 0xE1
108A2  F00B     NOP
108A4  FFE3     NOP
108A6  0EE2     MOVLW 0xE2
108AA  F00F     NOP
108AC  FFE3     NOP
108AE  0EE3     MOVLW 0xE3
108B2  F013     NOP
108B4  FFE3     NOP
422:                   u = u/10.0;
108B6  0E00     MOVLW 0x0
108B8  6EE6     MOVWF 0xFE6, ACCESS
108BA  0E00     MOVLW 0x0
108BC  6EE6     MOVWF 0xFE6, ACCESS
108BE  0E20     MOVLW 0x20
108C0  6EE6     MOVWF 0xFE6, ACCESS
108C2  0E41     MOVLW 0x41
108C4  6EE6     MOVWF 0xFE6, ACCESS
108C6  0ED0     MOVLW 0xD0
108CA  FF8F     NOP
108CC  FFE6     NOP
108D0  FF8F     NOP
108D2  FFE6     NOP
108D6  FF8F     NOP
108D8  FFE6     NOP
108DC  FF8F     NOP
108DE  FFE6     NOP
108E0  EC51     CALL 0x14AA2, 0
108E2  F0A5     NOP
108E4  0ED4     MOVLW 0xD4
108E8  F007     NOP
108EA  FFE3     NOP
108EC  0ED5     MOVLW 0xD5
108F0  F00B     NOP
108F2  FFE3     NOP
108F4  0ED6     MOVLW 0xD6
108F8  F00F     NOP
108FA  FFE3     NOP
108FC  0ED7     MOVLW 0xD7
10900  F013     NOP
10902  FFE3     NOP
423:                   ++i;
10904  0EEC     MOVLW 0xEC
10906  50E3     MOVF 0xFE3, W, ACCESS
10908  0F01     ADDLW 0x1
1090A  6E01     MOVWF ltemp0, ACCESS
1090C  0EEC     MOVLW 0xEC
10910  F007     NOP
10912  FFE3     NOP
10914  6A01     CLRF ltemp0, ACCESS
10916  0EED     MOVLW 0xED
10918  50E3     MOVF 0xFE3, W, ACCESS
1091A  2001     ADDWFC ltemp0, W, ACCESS
1091C  6E01     MOVWF ltemp0, ACCESS
1091E  0EED     MOVLW 0xED
10922  F007     NOP
10924  FFE3     NOP
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
1094C  0E00     MOVLW 0x0
1094E  6EE6     MOVWF 0xFE6, ACCESS
10950  0E00     MOVLW 0x0
10952  6EE6     MOVWF 0xFE6, ACCESS
10954  0EA0     MOVLW 0xA0
10956  6EE6     MOVWF 0xFE6, ACCESS
10958  0E40     MOVLW 0x40
1095A  6EE6     MOVWF 0xFE6, ACCESS
1095C  0ED0     MOVLW 0xD0
10960  FF8F     NOP
10962  FFE6     NOP
10966  FF8F     NOP
10968  FFE6     NOP
1096C  FF8F     NOP
1096E  FFE6     NOP
10972  FF8F     NOP
10974  FFE6     NOP
10976  ECA0     CALL 0x13340, 0
10978  F099     NOP
1097A  0EDC     MOVLW 0xDC
1097E  F007     NOP
10980  FFE3     NOP
10982  0EDD     MOVLW 0xDD
10986  F00B     NOP
10988  FFE3     NOP
1098A  0EDE     MOVLW 0xDE
1098E  F00F     NOP
10990  FFE3     NOP
10992  0EDF     MOVLW 0xDF
10996  F013     NOP
10998  FFE3     NOP
428:               if (h < l) {
1099A  0EDC     MOVLW 0xDC
1099E  FF8F     NOP
109A0  FFE6     NOP
109A4  FF8F     NOP
109A6  FFE6     NOP
109AA  FF8F     NOP
109AC  FFE6     NOP
109B0  FF8F     NOP
109B2  FFE6     NOP
109B4  0EDC     MOVLW 0xDC
109B8  FF8F     NOP
109BA  FFE6     NOP
109BE  FF8F     NOP
109C0  FFE6     NOP
109C4  FF8F     NOP
109C6  FFE6     NOP
109CA  FF8F     NOP
109CC  FFE6     NOP
109CE  EC81     CALL 0x18D02, 0
109D0  F0C6     NOP
109D2  A001     BTFSS ltemp0, 0, ACCESS
429:                   l = 0.0;
109D4  D021     BRA 0xA18
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
109D6  0EDC     MOVLW 0xDC
109DA  FF8F     NOP
109DC  FFE6     NOP
109E0  FF8F     NOP
109E2  FFE6     NOP
109E6  FF8F     NOP
109E8  FFE6     NOP
109EC  FF8F     NOP
109EE  FFE6     NOP
109F0  0EDC     MOVLW 0xDC
109F4  FF8F     NOP
109F6  FFE6     NOP
109FA  FF8F     NOP
109FC  FFE6     NOP
10A00  FF8F     NOP
10A02  FFE6     NOP
10A06  FF8F     NOP
10A08  FFE6     NOP
10A0A  ECC9     CALL 0x1A192, 0
10A0C  F0D0     NOP
10A0E  A001     BTFSS ltemp0, 0, ACCESS
10A10  D01B     BRA 0xA48
10A12  0EF4     MOVLW 0xF4
10A14  B0E3     BTFSC 0xFE3, 0, ACCESS
10A16  D018     BRA 0xA48
433:                       l = 0.0;
10A18  0E00     MOVLW 0x0
10A1A  6E09     MOVWF ltemp2, ACCESS
10A1C  0E00     MOVLW 0x0
10A1E  6E0A     MOVWF ttemp3, ACCESS
10A20  0E00     MOVLW 0x0
10A22  6E0B     MOVWF wtemp5, ACCESS
10A24  0E00     MOVLW 0x0
10A26  6E0C     MOVWF 0xC, ACCESS
10A28  0EDC     MOVLW 0xDC
10A2C  F027     NOP
10A2E  FFE3     NOP
10A30  0EDD     MOVLW 0xDD
10A34  F02B     NOP
10A36  FFE3     NOP
10A38  0EDE     MOVLW 0xDE
10A3C  F02F     NOP
10A3E  FFE3     NOP
10A40  0EDF     MOVLW 0xDF
10A44  F033     NOP
10A46  FFE3     NOP
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
10A48  0EDC     MOVLW 0xDC
10A4C  FF8F     NOP
10A4E  FFE6     NOP
10A52  FF8F     NOP
10A54  FFE6     NOP
10A58  FF8F     NOP
10A5A  FFE6     NOP
10A5E  FF8F     NOP
10A60  FFE6     NOP
10A62  0ED4     MOVLW 0xD4
10A66  FF8F     NOP
10A68  FFE6     NOP
10A6C  FF8F     NOP
10A6E  FFE6     NOP
10A72  FF8F     NOP
10A74  FFE6     NOP
10A78  FF8F     NOP
10A7A  FFE6     NOP
10A7C  ECB5     CALL 0x13B6A, 0
10A7E  F09D     NOP
10A80  0EE0     MOVLW 0xE0
10A84  F007     NOP
10A86  FFE3     NOP
10A88  0EE1     MOVLW 0xE1
10A8C  F00B     NOP
10A8E  FFE3     NOP
10A90  0EE2     MOVLW 0xE2
10A94  F00F     NOP
10A96  FFE3     NOP
10A98  0EE3     MOVLW 0xE3
10A9C  F013     NOP
10A9E  FFE3     NOP
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
10AA0  0EE4     MOVLW 0xE4
10AA4  FF8C     NOP
10AA6  F009     NOP
10AA8  0EE5     MOVLW 0xE5
10AAC  FF8C     NOP
10AAE  F00A     NOP
10AB0  0EE6     MOVLW 0xE6
10AB4  FF8C     NOP
10AB6  F00B     NOP
10AB8  0EE7     MOVLW 0xE7
10ABC  FF8C     NOP
10ABE  F00C     NOP
10AC0  0ED4     MOVLW 0xD4
10AC4  F027     NOP
10AC6  FFE3     NOP
10AC8  0ED5     MOVLW 0xD5
10ACC  F02B     NOP
10ACE  FFE3     NOP
10AD0  0ED6     MOVLW 0xD6
10AD4  F02F     NOP
10AD6  FFE3     NOP
10AD8  0ED7     MOVLW 0xD7
10ADC  F033     NOP
10ADE  FFE3     NOP
442:               ne = (nmode == 'e') ? 0 : e;
10AE0  0EFF     MOVLW 0xFF
10AE4  FF8C     NOP
10AE6  F001     NOP
10AE8  0E65     MOVLW 0x65
10AEA  1801     XORWF ltemp0, W, ACCESS
10AEC  B4D8     BTFSC 0xFD8, 2, ACCESS
10AEE  D011     BRA 0xB12
10AF0  0EEA     MOVLW 0xEA
10AF4  FF8C     NOP
10AF6  F001     NOP
10AF8  0EF6     MOVLW 0xF6
10AFC  F007     NOP
10AFE  FFE3     NOP
10B00  0EEB     MOVLW 0xEB
10B04  FF8C     NOP
10B06  F001     NOP
10B08  0EF7     MOVLW 0xF7
10B0C  F007     NOP
10B0E  FFE3     NOP
10B10  D004     BRA 0xB1A
10B12  0EF6     MOVLW 0xF6
10B14  6AE3     CLRF 0xFE3, ACCESS
10B16  0EF7     MOVLW 0xF7
10B18  6AE3     CLRF 0xFE3, ACCESS
443:               pp = 0;
10B1A  0EFA     MOVLW 0xFA
10B1C  6AE3     CLRF 0xFE3, ACCESS
10B1E  0EFB     MOVLW 0xFB
10B20  6AE3     CLRF 0xFE3, ACCESS
444:               t = 0;
10B22  0EFC     MOVLW 0xFC
10B24  6AE3     CLRF 0xFE3, ACCESS
10B26  0EFD     MOVLW 0xFD
10B28  6AE3     CLRF 0xFE3, ACCESS
445:               i = 0;
10B2A  0EEC     MOVLW 0xEC
10B2C  6AE3     CLRF 0xFE3, ACCESS
10B2E  0EED     MOVLW 0xED
10B30  6AE3     CLRF 0xFE3, ACCESS
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
10B32  D1B7     BRA 0xEA2
10EA2  50E1     MOVF 0xFE1, W, ACCESS
10EA4  0FEC     ADDLW 0xEC
10EA6  6ED9     MOVWF 0xFD9, ACCESS
10EA8  50E2     MOVF 0xFE2, W, ACCESS
10EAA  6EDA     MOVWF 0xFDA, ACCESS
10EAC  0EFF     MOVLW 0xFF
10EAE  22DA     ADDWFC 0xFDA, F, ACCESS
10EB0  0EF8     MOVLW 0xF8
10EB2  50E3     MOVF 0xFE3, W, ACCESS
10EB4  5CDE     SUBWF 0xFDE, W, ACCESS
10EB6  50DE     MOVF 0xFDE, W, ACCESS
10EB8  0A80     XORLW 0x80
10EBA  6E01     MOVWF ltemp0, ACCESS
10EBC  0EF9     MOVLW 0xF9
10EBE  50E3     MOVF 0xFE3, W, ACCESS
10EC0  0A80     XORLW 0x80
10EC2  5801     SUBWFB ltemp0, W, ACCESS
10EC4  B0D8     BTFSC 0xFD8, 0, ACCESS
10EC6  D00E     BRA 0xEE4
10EC8  0EE9     MOVLW 0xE9
10ECA  BEE3     BTFSC 0xFE3, 7, ACCESS
10ECC  D633     BRA 0xB34
10ECE  0EE9     MOVLW 0xE9
10ED0  50E3     MOVF 0xFE3, W, ACCESS
10ED2  E108     BNZ 0xEE4
10ED4  0EE8     MOVLW 0xE8
10ED8  FF8C     NOP
10EDA  F001     NOP
10EDC  0E4B     MOVLW 0x4B
10EDE  5E01     SUBWF ltemp0, F, ACCESS
10EE0  A0D8     BTFSS 0xFD8, 0, ACCESS
10EE2  D628     BRA 0xB34
447:                   l = floor(h/u);
10B34  0ED4     MOVLW 0xD4
10B38  FF8F     NOP
10B3A  FFE6     NOP
10B3E  FF8F     NOP
10B40  FFE6     NOP
10B44  FF8F     NOP
10B46  FFE6     NOP
10B4A  FF8F     NOP
10B4C  FFE6     NOP
10B4E  0EDC     MOVLW 0xDC
10B52  FF8F     NOP
10B54  FFE6     NOP
10B58  FF8F     NOP
10B5A  FFE6     NOP
10B5E  FF8F     NOP
10B60  FFE6     NOP
10B64  FF8F     NOP
10B66  FFE6     NOP
10B68  EC51     CALL 0x14AA2, 0
10B6A  F0A5     NOP
10B6E  F007     NOP
10B70  FFE6     NOP
10B74  F00B     NOP
10B76  FFE6     NOP
10B7A  F00F     NOP
10B7C  FFE6     NOP
10B80  F013     NOP
10B82  FFE6     NOP
10B84  ECDB     CALL 0x161B6, 0
10B86  F0B0     NOP
10B88  0EDC     MOVLW 0xDC
10B8C  F007     NOP
10B8E  FFE3     NOP
10B90  0EDD     MOVLW 0xDD
10B94  F00B     NOP
10B96  FFE3     NOP
10B98  0EDE     MOVLW 0xDE
10B9C  F00F     NOP
10B9E  FFE3     NOP
10BA0  0EDF     MOVLW 0xDF
10BA4  F013     NOP
10BA6  FFE3     NOP
448:                   d = (int)l;
10BA8  0EDC     MOVLW 0xDC
10BAC  FF8F     NOP
10BAE  FFE6     NOP
10BB2  FF8F     NOP
10BB4  FFE6     NOP
10BB8  FF8F     NOP
10BBA  FFE6     NOP
10BBE  FF8F     NOP
10BC0  FFE6     NOP
10BC2  ECC8     CALL 0x18B90, 0
10BC4  F0C5     NOP
10BC8  F004     NOP
10BCA  F00B     NOP
10BCE  F008     NOP
10BD0  F00C     NOP
10BD2  0EF4     MOVLW 0xF4
10BD6  F02F     NOP
10BD8  FFE3     NOP
10BDA  0EF5     MOVLW 0xF5
10BDE  F033     NOP
10BE0  FFE3     NOP
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
10BE2  B83E     BTFSC flags, 4, ACCESS
10BE4  D026     BRA 0xC32
10BE6  0EF4     MOVLW 0xF4
10BEA  FF8C     NOP
10BEC  F001     NOP
10BEE  0EF5     MOVLW 0xF5
10BF0  50E3     MOVF 0xFE3, W, ACCESS
10BF2  1001     IORWF ltemp0, W, ACCESS
10BF4  A4D8     BTFSS 0xFD8, 2, ACCESS
10BF6  D01D     BRA 0xC32
10BF8  0EFE     MOVLW 0xFE
10BFC  FF8C     NOP
10BFE  F001     NOP
10C00  0E67     MOVLW 0x67
10C02  1801     XORWF ltemp0, W, ACCESS
10C04  A4D8     BTFSS 0xFD8, 2, ACCESS
10C06  D015     BRA 0xC32
10C08  0EF7     MOVLW 0xF7
10C0A  AEE3     BTFSS 0xFE3, 7, ACCESS
10C0C  D012     BRA 0xC32
450:                       ++t;
10C0E  0EFC     MOVLW 0xFC
10C10  50E3     MOVF 0xFE3, W, ACCESS
10C12  0F01     ADDLW 0x1
10C14  6E01     MOVWF ltemp0, ACCESS
10C16  0EFC     MOVLW 0xFC
10C1A  F007     NOP
10C1C  FFE3     NOP
10C1E  6A01     CLRF ltemp0, ACCESS
10C20  0EFD     MOVLW 0xFD
10C22  50E3     MOVF 0xFE3, W, ACCESS
10C24  2001     ADDWFC ltemp0, W, ACCESS
10C26  6E01     MOVWF ltemp0, ACCESS
10C28  0EFD     MOVLW 0xFD
10C2C  F007     NOP
10C2E  FFE3     NOP
451:                   } else {
10C30  D0AF     BRA 0xD90
452:                       if (!pp && (ne < 0)) {
10C32  0EFA     MOVLW 0xFA
10C36  FF8C     NOP
10C38  F001     NOP
10C3A  0EFB     MOVLW 0xFB
10C3C  50E3     MOVF 0xFE3, W, ACCESS
10C3E  1001     IORWF ltemp0, W, ACCESS
10C40  A4D8     BTFSS 0xFD8, 2, ACCESS
10C42  D070     BRA 0xD24
10C44  0EF7     MOVLW 0xF7
10C46  AEE3     BTFSS 0xFE3, 7, ACCESS
10C48  D06D     BRA 0xD24
453:                           dbuf[n++] = '.';
10C4A  0EE8     MOVLW 0xE8
10C4E  FF8C     NOP
10C50  F00B     NOP
10C52  0EE9     MOVLW 0xE9
10C56  FF8C     NOP
10C58  F00C     NOP
10C5A  0E97     MOVLW 0x97
10C5C  240B     ADDWF wtemp5, W, ACCESS
10C5E  6ED9     MOVWF 0xFD9, ACCESS
10C60  0E02     MOVLW 0x2
10C62  200C     ADDWFC 0xC, W, ACCESS
10C64  6EDA     MOVWF 0xFDA, ACCESS
10C66  0E2E     MOVLW 0x2E
10C68  6EDF     MOVWF 0xFDF, ACCESS
10C6A  0EE8     MOVLW 0xE8
10C6C  50E3     MOVF 0xFE3, W, ACCESS
10C6E  0F01     ADDLW 0x1
10C70  6E01     MOVWF ltemp0, ACCESS
10C72  0EE8     MOVLW 0xE8
10C76  F007     NOP
10C78  FFE3     NOP
10C7A  6A01     CLRF ltemp0, ACCESS
10C7C  0EE9     MOVLW 0xE9
10C7E  50E3     MOVF 0xFE3, W, ACCESS
10C80  2001     ADDWFC ltemp0, W, ACCESS
10C82  6E01     MOVWF ltemp0, ACCESS
10C84  0EE9     MOVLW 0xE9
10C88  F007     NOP
10C8A  FFE3     NOP
454:                           --w;
10C8C  50E1     MOVF 0xFE1, W, ACCESS
10C8E  0FEE     ADDLW 0xEE
10C90  6ED9     MOVWF 0xFD9, ACCESS
10C92  50E2     MOVF 0xFE2, W, ACCESS
10C94  6EDA     MOVWF 0xFDA, ACCESS
10C96  0EFF     MOVLW 0xFF
10C98  22DA     ADDWFC 0xFDA, F, ACCESS
10C9A  06DE     DECF 0xFDE, F, ACCESS
10C9C  0E00     MOVLW 0x0
10C9E  5ADD     SUBWFB 0xFDD, F, ACCESS
455:                           pp = 1;
10CA0  0E01     MOVLW 0x1
10CA2  6E0B     MOVWF wtemp5, ACCESS
10CA4  0E00     MOVLW 0x0
10CA6  6E0C     MOVWF 0xC, ACCESS
10CA8  0EFA     MOVLW 0xFA
10CAC  F02F     NOP
10CAE  FFE3     NOP
10CB0  0EFB     MOVLW 0xFB
10CB4  F033     NOP
10CB6  FFE3     NOP
10CB8  D035     BRA 0xD24
456:                       }
457:                       while (t) {
10D24  0EFC     MOVLW 0xFC
10D28  FF8C     NOP
10D2A  F001     NOP
10D2C  0EFD     MOVLW 0xFD
10D2E  50E3     MOVF 0xFE3, W, ACCESS
10D30  1001     IORWF ltemp0, W, ACCESS
10D32  A4D8     BTFSS 0xFD8, 2, ACCESS
10D34  D7C2     BRA 0xCBA
458:                           dbuf[n++] = '0';
10CBA  0EE8     MOVLW 0xE8
10CBE  FF8C     NOP
10CC0  F00B     NOP
10CC2  0EE9     MOVLW 0xE9
10CC6  FF8C     NOP
10CC8  F00C     NOP
10CCA  0E97     MOVLW 0x97
10CCC  240B     ADDWF wtemp5, W, ACCESS
10CCE  6ED9     MOVWF 0xFD9, ACCESS
10CD0  0E02     MOVLW 0x2
10CD2  200C     ADDWFC 0xC, W, ACCESS
10CD4  6EDA     MOVWF 0xFDA, ACCESS
10CD6  0E30     MOVLW 0x30
10CD8  6EDF     MOVWF 0xFDF, ACCESS
10CDA  0EE8     MOVLW 0xE8
10CDC  50E3     MOVF 0xFE3, W, ACCESS
10CDE  0F01     ADDLW 0x1
10CE0  6E01     MOVWF ltemp0, ACCESS
10CE2  0EE8     MOVLW 0xE8
10CE6  F007     NOP
10CE8  FFE3     NOP
10CEA  6A01     CLRF ltemp0, ACCESS
10CEC  0EE9     MOVLW 0xE9
10CEE  50E3     MOVF 0xFE3, W, ACCESS
10CF0  2001     ADDWFC ltemp0, W, ACCESS
10CF2  6E01     MOVWF ltemp0, ACCESS
10CF4  0EE9     MOVLW 0xE9
10CF8  F007     NOP
10CFA  FFE3     NOP
459:                           --w;
10CFC  50E1     MOVF 0xFE1, W, ACCESS
10CFE  0FEE     ADDLW 0xEE
10D00  6ED9     MOVWF 0xFD9, ACCESS
10D02  50E2     MOVF 0xFE2, W, ACCESS
10D04  6EDA     MOVWF 0xFDA, ACCESS
10D06  0EFF     MOVLW 0xFF
10D08  22DA     ADDWFC 0xFDA, F, ACCESS
10D0A  06DE     DECF 0xFDE, F, ACCESS
10D0C  0E00     MOVLW 0x0
10D0E  5ADD     SUBWFB 0xFDD, F, ACCESS
460:                           --t;
10D10  50E1     MOVF 0xFE1, W, ACCESS
10D12  0FFC     ADDLW 0xFC
10D14  6ED9     MOVWF 0xFD9, ACCESS
10D16  50E2     MOVF 0xFE2, W, ACCESS
10D18  6EDA     MOVWF 0xFDA, ACCESS
10D1A  0EFF     MOVLW 0xFF
10D1C  22DA     ADDWFC 0xFDA, F, ACCESS
10D1E  06DE     DECF 0xFDE, F, ACCESS
10D20  0E00     MOVLW 0x0
10D22  5ADD     SUBWFB 0xFDD, F, ACCESS
461:                       }
462:                       dbuf[n++] = '0' + d;
10D36  0EE8     MOVLW 0xE8
10D3A  FF8C     NOP
10D3C  F00B     NOP
10D3E  0EE9     MOVLW 0xE9
10D42  FF8C     NOP
10D44  F00C     NOP
10D46  0E97     MOVLW 0x97
10D48  240B     ADDWF wtemp5, W, ACCESS
10D4A  6ED9     MOVWF 0xFD9, ACCESS
10D4C  0E02     MOVLW 0x2
10D4E  200C     ADDWFC 0xC, W, ACCESS
10D50  6EDA     MOVWF 0xFDA, ACCESS
10D52  0EF4     MOVLW 0xF4
10D54  50E3     MOVF 0xFE3, W, ACCESS
10D56  0F30     ADDLW 0x30
10D58  6EDF     MOVWF 0xFDF, ACCESS
10D5A  0EE8     MOVLW 0xE8
10D5C  50E3     MOVF 0xFE3, W, ACCESS
10D5E  0F01     ADDLW 0x1
10D60  6E01     MOVWF ltemp0, ACCESS
10D62  0EE8     MOVLW 0xE8
10D66  F007     NOP
10D68  FFE3     NOP
10D6A  6A01     CLRF ltemp0, ACCESS
10D6C  0EE9     MOVLW 0xE9
10D6E  50E3     MOVF 0xFE3, W, ACCESS
10D70  2001     ADDWFC ltemp0, W, ACCESS
10D72  6E01     MOVWF ltemp0, ACCESS
10D74  0EE9     MOVLW 0xE9
10D78  F007     NOP
10D7A  FFE3     NOP
463:                       --w;
10D7C  50E1     MOVF 0xFE1, W, ACCESS
10D7E  0FEE     ADDLW 0xEE
10D80  6ED9     MOVWF 0xFD9, ACCESS
10D82  50E2     MOVF 0xFE2, W, ACCESS
10D84  6EDA     MOVWF 0xFDA, ACCESS
10D86  0EFF     MOVLW 0xFF
10D88  22DA     ADDWFC 0xFDA, F, ACCESS
10D8A  06DE     DECF 0xFDE, F, ACCESS
10D8C  0E00     MOVLW 0x0
10D8E  5ADD     SUBWFB 0xFDD, F, ACCESS
464:                   }
465:                   h -= l*u;
10D90  0ED4     MOVLW 0xD4
10D94  FF8F     NOP
10D96  FFE6     NOP
10D9A  FF8F     NOP
10D9C  FFE6     NOP
10DA0  FF8F     NOP
10DA2  FFE6     NOP
10DA6  FF8F     NOP
10DA8  FFE6     NOP
10DAA  0ED8     MOVLW 0xD8
10DAE  FF8F     NOP
10DB0  FFE6     NOP
10DB4  FF8F     NOP
10DB6  FFE6     NOP
10DBA  FF8F     NOP
10DBC  FFE6     NOP
10DC0  FF8F     NOP
10DC2  FFE6     NOP
10DC4  ECA0     CALL 0x13340, 0
10DC6  F099     NOP
10DCA  F007     NOP
10DCC  FFE6     NOP
10DD0  F00B     NOP
10DD2  FFE6     NOP
10DD6  F00F     NOP
10DD8  FFE6     NOP
10DDC  F013     NOP
10DDE  FFE6     NOP
10DE0  0EDC     MOVLW 0xDC
10DE4  FF8F     NOP
10DE6  FFE6     NOP
10DEA  FF8F     NOP
10DEC  FFE6     NOP
10DF0  FF8F     NOP
10DF2  FFE6     NOP
10DF6  FF8F     NOP
10DF8  FFE6     NOP
10DFA  EC04     CALL 0x1B208, 0
10DFC  F0D9     NOP
10DFE  0EE0     MOVLW 0xE0
10E02  F007     NOP
10E04  FFE3     NOP
10E06  0EE1     MOVLW 0xE1
10E0A  F00B     NOP
10E0C  FFE3     NOP
10E0E  0EE2     MOVLW 0xE2
10E12  F00F     NOP
10E14  FFE3     NOP
10E16  0EE3     MOVLW 0xE3
10E1A  F013     NOP
10E1C  FFE3     NOP
466:                   u = u/10.0;
10E1E  0E00     MOVLW 0x0
10E20  6EE6     MOVWF 0xFE6, ACCESS
10E22  0E00     MOVLW 0x0
10E24  6EE6     MOVWF 0xFE6, ACCESS
10E26  0E20     MOVLW 0x20
10E28  6EE6     MOVWF 0xFE6, ACCESS
10E2A  0E41     MOVLW 0x41
10E2C  6EE6     MOVWF 0xFE6, ACCESS
10E2E  0ED0     MOVLW 0xD0
10E32  FF8F     NOP
10E34  FFE6     NOP
10E38  FF8F     NOP
10E3A  FFE6     NOP
10E3E  FF8F     NOP
10E40  FFE6     NOP
10E44  FF8F     NOP
10E46  FFE6     NOP
10E48  EC51     CALL 0x14AA2, 0
10E4A  F0A5     NOP
10E4C  0ED4     MOVLW 0xD4
10E50  F007     NOP
10E52  FFE3     NOP
10E54  0ED5     MOVLW 0xD5
10E58  F00B     NOP
10E5A  FFE3     NOP
10E5C  0ED6     MOVLW 0xD6
10E60  F00F     NOP
10E62  FFE3     NOP
10E64  0ED7     MOVLW 0xD7
10E68  F013     NOP
10E6A  FFE3     NOP
467:                   --ne;
10E6C  50E1     MOVF 0xFE1, W, ACCESS
10E6E  0FF6     ADDLW 0xF6
10E70  6ED9     MOVWF 0xFD9, ACCESS
10E72  50E2     MOVF 0xFE2, W, ACCESS
10E74  6EDA     MOVWF 0xFDA, ACCESS
10E76  0EFF     MOVLW 0xFF
10E78  22DA     ADDWFC 0xFDA, F, ACCESS
10E7A  06DE     DECF 0xFDE, F, ACCESS
10E7C  0E00     MOVLW 0x0
10E7E  5ADD     SUBWFB 0xFDD, F, ACCESS
468:                   ++i;
10E80  0EEC     MOVLW 0xEC
10E82  50E3     MOVF 0xFE3, W, ACCESS
10E84  0F01     ADDLW 0x1
10E86  6E01     MOVWF ltemp0, ACCESS
10E88  0EEC     MOVLW 0xEC
10E8C  F007     NOP
10E8E  FFE3     NOP
10E90  6A01     CLRF ltemp0, ACCESS
10E92  0EED     MOVLW 0xED
10E94  50E3     MOVF 0xFE3, W, ACCESS
10E96  2001     ADDWFC ltemp0, W, ACCESS
10E98  6E01     MOVWF ltemp0, ACCESS
10E9A  0EED     MOVLW 0xED
10E9E  F007     NOP
10EA0  FFE3     NOP
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
10EE4  0EFA     MOVLW 0xFA
10EE8  FF8C     NOP
10EEA  F001     NOP
10EEC  0EFB     MOVLW 0xFB
10EEE  50E3     MOVF 0xFE3, W, ACCESS
10EF0  1001     IORWF ltemp0, W, ACCESS
10EF2  B4D8     BTFSC 0xFD8, 2, ACCESS
10EF4  A83E     BTFSS flags, 4, ACCESS
10EF6  D021     BRA 0xF3A
471:                   dbuf[n++] = '.';
10EF8  0EE8     MOVLW 0xE8
10EFC  FF8C     NOP
10EFE  F00B     NOP
10F00  0EE9     MOVLW 0xE9
10F04  FF8C     NOP
10F06  F00C     NOP
10F08  0E97     MOVLW 0x97
10F0A  240B     ADDWF wtemp5, W, ACCESS
10F0C  6ED9     MOVWF 0xFD9, ACCESS
10F0E  0E02     MOVLW 0x2
10F10  200C     ADDWFC 0xC, W, ACCESS
10F12  6EDA     MOVWF 0xFDA, ACCESS
10F14  0E2E     MOVLW 0x2E
10F16  6EDF     MOVWF 0xFDF, ACCESS
10F18  0EE8     MOVLW 0xE8
10F1A  50E3     MOVF 0xFE3, W, ACCESS
10F1C  0F01     ADDLW 0x1
10F1E  6E01     MOVWF ltemp0, ACCESS
10F20  0EE8     MOVLW 0xE8
10F24  F007     NOP
10F26  FFE3     NOP
10F28  6A01     CLRF ltemp0, ACCESS
10F2A  0EE9     MOVLW 0xE9
10F2C  50E3     MOVF 0xFE3, W, ACCESS
10F2E  2001     ADDWFC ltemp0, W, ACCESS
10F30  6E01     MOVWF ltemp0, ACCESS
10F32  0EE9     MOVLW 0xE9
10F36  F007     NOP
10F38  FFE3     NOP
472:               }
473:               dbuf[n] = '\0';
10F3A  0EE8     MOVLW 0xE8
10F3E  FF8C     NOP
10F40  F00B     NOP
10F42  0EE9     MOVLW 0xE9
10F46  FF8C     NOP
10F48  F00C     NOP
10F4A  0E97     MOVLW 0x97
10F4C  240B     ADDWF wtemp5, W, ACCESS
10F4E  6ED9     MOVWF 0xFD9, ACCESS
10F50  0E02     MOVLW 0x2
10F52  200C     ADDWFC 0xC, W, ACCESS
10F54  6EDA     MOVWF 0xFDA, ACCESS
10F56  0E00     MOVLW 0x0
10F58  6EDF     MOVWF 0xFDF, ACCESS
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
10F5A  0EFF     MOVLW 0xFF
10F5E  FF8C     NOP
10F60  F001     NOP
10F62  0E65     MOVLW 0x65
10F64  1801     XORWF ltemp0, W, ACCESS
10F66  A4D8     BTFSS 0xFD8, 2, ACCESS
10F68  EF16     GOTO 0x1022C
10F6A  F081     NOP
477:                   i = sizeof(dbuf) - 1;
10F6C  0E4F     MOVLW 0x4F
10F6E  6E0B     MOVWF wtemp5, ACCESS
10F70  0E00     MOVLW 0x0
10F72  6E0C     MOVWF 0xC, ACCESS
10F74  0EEC     MOVLW 0xEC
10F78  F02F     NOP
10F7A  FFE3     NOP
10F7C  0EED     MOVLW 0xED
10F80  F033     NOP
10F82  FFE3     NOP
478:                   dbuf[i] = '\0';
10F84  0EEC     MOVLW 0xEC
10F88  FF8C     NOP
10F8A  F00B     NOP
10F8C  0EED     MOVLW 0xED
10F90  FF8C     NOP
10F92  F00C     NOP
10F94  0E97     MOVLW 0x97
10F96  240B     ADDWF wtemp5, W, ACCESS
10F98  6ED9     MOVWF 0xFD9, ACCESS
10F9A  0E02     MOVLW 0x2
10F9C  200C     ADDWFC 0xC, W, ACCESS
10F9E  6EDA     MOVWF 0xFDA, ACCESS
10FA0  0E00     MOVLW 0x0
10FA2  6EDF     MOVWF 0xFDF, ACCESS
479:                   sign = 0;
10FA4  0EF2     MOVLW 0xF2
10FA6  6AE3     CLRF 0xFE3, ACCESS
10FA8  0EF3     MOVLW 0xF3
10FAA  6AE3     CLRF 0xFE3, ACCESS
480:                   if (e < 0) {
10FAC  0EEB     MOVLW 0xEB
10FAE  AEE3     BTFSS 0xFE3, 7, ACCESS
10FB0  D012     BRA 0xFD6
481:                       sign = 1;
10FB2  0E01     MOVLW 0x1
10FB4  6E0B     MOVWF wtemp5, ACCESS
10FB6  0E00     MOVLW 0x0
10FB8  6E0C     MOVWF 0xC, ACCESS
10FBA  0EF2     MOVLW 0xF2
10FBE  F02F     NOP
10FC0  FFE3     NOP
10FC2  0EF3     MOVLW 0xF3
10FC6  F033     NOP
10FC8  FFE3     NOP
482:                       e = -e;
10FCA  0EEA     MOVLW 0xEA
10FCC  6CE3     NEGF 0xFE3, ACCESS
10FCE  0EEB     MOVLW 0xEB
10FD0  1EE3     COMF 0xFE3, F, ACCESS
10FD2  B0D8     BTFSC 0xFD8, 0, ACCESS
10FD4  2AE3     INCF 0xFE3, F, ACCESS
483:                   }
484:                   p = 2;
10FD6  0E02     MOVLW 0x2
10FD8  6E0B     MOVWF wtemp5, ACCESS
10FDA  0E00     MOVLW 0x0
10FDC  6E0C     MOVWF 0xC, ACCESS
10FDE  0EF0     MOVLW 0xF0
10FE2  F02F     NOP
10FE4  FFE3     NOP
10FE6  0EF1     MOVLW 0xF1
10FEA  F033     NOP
10FEC  FFE3     NOP
485:                   while (e || (0 < p)) {
10FEE  D051     BRA 0x1092
11092  0EEA     MOVLW 0xEA
11096  FF8C     NOP
11098  F001     NOP
1109A  0EEB     MOVLW 0xEB
1109C  50E3     MOVF 0xFE3, W, ACCESS
1109E  1001     IORWF ltemp0, W, ACCESS
110A0  A4D8     BTFSS 0xFD8, 2, ACCESS
110A2  D7A6     BRA 0xFF0
110A4  0EF1     MOVLW 0xF1
110A6  BEE3     BTFSC 0xFE3, 7, ACCESS
110A8  D007     BRA 0x10B8
110AA  0EF1     MOVLW 0xF1
110AC  50E3     MOVF 0xFE3, W, ACCESS
110AE  E1A0     BNZ 0xFF0
110B0  0EF0     MOVLW 0xF0
110B2  04E3     DECF 0xFE3, W, ACCESS
110B4  B0D8     BTFSC 0xFD8, 0, ACCESS
110B6  D79C     BRA 0xFF0
486:                       --i;
10FF0  50E1     MOVF 0xFE1, W, ACCESS
10FF2  0FEC     ADDLW 0xEC
10FF4  6ED9     MOVWF 0xFD9, ACCESS
10FF6  50E2     MOVF 0xFE2, W, ACCESS
10FF8  6EDA     MOVWF 0xFDA, ACCESS
10FFA  0EFF     MOVLW 0xFF
10FFC  22DA     ADDWFC 0xFDA, F, ACCESS
10FFE  06DE     DECF 0xFDE, F, ACCESS
11000  0E00     MOVLW 0x0
11002  5ADD     SUBWFB 0xFDD, F, ACCESS
487:                       dbuf[i] = '0' + (e % 10);
11004  0EEC     MOVLW 0xEC
11008  FF8C     NOP
1100A  F00B     NOP
1100C  0EED     MOVLW 0xED
11010  FF8C     NOP
11012  F00C     NOP
11014  0E97     MOVLW 0x97
11016  240B     ADDWF wtemp5, W, ACCESS
11018  6ED9     MOVWF 0xFD9, ACCESS
1101A  0E02     MOVLW 0x2
1101C  200C     ADDWFC 0xC, W, ACCESS
1101E  6EDA     MOVWF 0xFDA, ACCESS
11020  0E0A     MOVLW 0xA
11022  6EE6     MOVWF 0xFE6, ACCESS
11024  0E00     MOVLW 0x0
11026  6EE6     MOVWF 0xFE6, ACCESS
11028  0EE8     MOVLW 0xE8
1102C  FF8F     NOP
1102E  FFE6     NOP
11032  FF8F     NOP
11034  FFE6     NOP
11036  EC80     CALL 0x19700, 0
11038  F0CB     NOP
1103A  5001     MOVF ltemp0, W, ACCESS
1103C  0F30     ADDLW 0x30
1103E  6EDF     MOVWF 0xFDF, ACCESS
488:                       e = e / 10;
11040  0E0A     MOVLW 0xA
11042  6EE6     MOVWF 0xFE6, ACCESS
11044  0E00     MOVLW 0x0
11046  6EE6     MOVWF 0xFE6, ACCESS
11048  0EE8     MOVLW 0xE8
1104C  FF8F     NOP
1104E  FFE6     NOP
11052  FF8F     NOP
11054  FFE6     NOP
11056  ECE3     CALL 0x18FC6, 0
11058  F0C7     NOP
1105A  0EEA     MOVLW 0xEA
1105E  F007     NOP
11060  FFE3     NOP
11062  0EEB     MOVLW 0xEB
11066  F00B     NOP
11068  FFE3     NOP
489:                       --p;
1106A  50E1     MOVF 0xFE1, W, ACCESS
1106C  0FF0     ADDLW 0xF0
1106E  6ED9     MOVWF 0xFD9, ACCESS
11070  50E2     MOVF 0xFE2, W, ACCESS
11072  6EDA     MOVWF 0xFDA, ACCESS
11074  0EFF     MOVLW 0xFF
11076  22DA     ADDWFC 0xFDA, F, ACCESS
11078  06DE     DECF 0xFDE, F, ACCESS
1107A  0E00     MOVLW 0x0
1107C  5ADD     SUBWFB 0xFDD, F, ACCESS
490:                       --w;
1107E  50E1     MOVF 0xFE1, W, ACCESS
11080  0FEE     ADDLW 0xEE
11082  6ED9     MOVWF 0xFD9, ACCESS
11084  50E2     MOVF 0xFE2, W, ACCESS
11086  6EDA     MOVWF 0xFDA, ACCESS
11088  0EFF     MOVLW 0xFF
1108A  22DA     ADDWFC 0xFDA, F, ACCESS
1108C  06DE     DECF 0xFDE, F, ACCESS
1108E  0E00     MOVLW 0x0
11090  5ADD     SUBWFB 0xFDD, F, ACCESS
491:                   }
492:                   --i;
110B8  50E1     MOVF 0xFE1, W, ACCESS
110BA  0FEC     ADDLW 0xEC
110BC  6ED9     MOVWF 0xFD9, ACCESS
110BE  50E2     MOVF 0xFE2, W, ACCESS
110C0  6EDA     MOVWF 0xFDA, ACCESS
110C2  0EFF     MOVLW 0xFF
110C4  22DA     ADDWFC 0xFDA, F, ACCESS
110C6  06DE     DECF 0xFDE, F, ACCESS
110C8  0E00     MOVLW 0x0
110CA  5ADD     SUBWFB 0xFDD, F, ACCESS
493:                   dbuf[i] = sign ? '-' : '+';
110CC  0EF2     MOVLW 0xF2
110D0  FF8C     NOP
110D2  F001     NOP
110D4  0EF3     MOVLW 0xF3
110D6  50E3     MOVF 0xFE3, W, ACCESS
110D8  1001     IORWF ltemp0, W, ACCESS
110DA  A4D8     BTFSS 0xFD8, 2, ACCESS
110DC  D002     BRA 0x10E2
110DE  0E2B     MOVLW 0x2B
110E0  D001     BRA 0x10E4
110E2  0E2D     MOVLW 0x2D
110E4  6E0B     MOVWF wtemp5, ACCESS
110E6  0E00     MOVLW 0x0
110E8  6E0C     MOVWF 0xC, ACCESS
110EA  0ECC     MOVLW 0xCC
110EE  F02F     NOP
110F0  FFE3     NOP
110F2  0ECD     MOVLW 0xCD
110F6  F033     NOP
110F8  FFE3     NOP
110FA  0EEC     MOVLW 0xEC
110FE  FF8C     NOP
11100  F00B     NOP
11102  0EED     MOVLW 0xED
11106  FF8C     NOP
11108  F00C     NOP
1110A  0E97     MOVLW 0x97
1110C  240B     ADDWF wtemp5, W, ACCESS
1110E  6ED9     MOVWF 0xFD9, ACCESS
11110  0E02     MOVLW 0x2
11112  200C     ADDWFC 0xC, W, ACCESS
11114  6EDA     MOVWF 0xFDA, ACCESS
11116  0ECC     MOVLW 0xCC
1111A  FF8F     NOP
1111C  FFDF     NOP
494:                   --w;
1111E  50E1     MOVF 0xFE1, W, ACCESS
11120  0FEE     ADDLW 0xEE
11122  6ED9     MOVWF 0xFD9, ACCESS
11124  50E2     MOVF 0xFE2, W, ACCESS
11126  6EDA     MOVWF 0xFDA, ACCESS
11128  0EFF     MOVLW 0xFF
1112A  22DA     ADDWFC 0xFDA, F, ACCESS
1112C  06DE     DECF 0xFDE, F, ACCESS
1112E  0E00     MOVLW 0x0
11130  5ADD     SUBWFB 0xFDD, F, ACCESS
495:                   --i;
11132  50E1     MOVF 0xFE1, W, ACCESS
11134  0FEC     ADDLW 0xEC
11136  6ED9     MOVWF 0xFD9, ACCESS
11138  50E2     MOVF 0xFE2, W, ACCESS
1113A  6EDA     MOVWF 0xFDA, ACCESS
1113C  0EFF     MOVLW 0xFF
1113E  22DA     ADDWFC 0xFDA, F, ACCESS
11140  06DE     DECF 0xFDE, F, ACCESS
11142  0E00     MOVLW 0x0
11144  5ADD     SUBWFB 0xFDD, F, ACCESS
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
11146  0EBF     MOVLW 0xBF
11148  6E0B     MOVWF wtemp5, ACCESS
1114A  0EFF     MOVLW 0xFF
1114C  6E0C     MOVWF 0xC, ACCESS
1114E  0EC1     MOVLW 0xC1
11150  50E3     MOVF 0xFE3, W, ACCESS
11152  6E09     MOVWF ltemp2, ACCESS
11154  6A0A     CLRF ttemp3, ACCESS
11156  500B     MOVF wtemp5, W, ACCESS
11158  2609     ADDWF ltemp2, F, ACCESS
1115A  500C     MOVF 0xC, W, ACCESS
1115C  220A     ADDWFC ttemp3, F, ACCESS
1115E  500A     MOVF ttemp3, W, ACCESS
11160  E106     BNZ 0x116E
11162  0E1A     MOVLW 0x1A
11164  5C09     SUBWF ltemp2, W, ACCESS
11166  B0D8     BTFSC 0xFD8, 0, ACCESS
11168  D002     BRA 0x116E
1116A  0E01     MOVLW 0x1
1116C  D001     BRA 0x1170
1116E  0E00     MOVLW 0x0
11170  6E0B     MOVWF wtemp5, ACCESS
11172  6A0C     CLRF 0xC, ACCESS
11174  0EC8     MOVLW 0xC8
11178  F02F     NOP
1117A  FFE3     NOP
1117C  0EC9     MOVLW 0xC9
11180  F033     NOP
11182  FFE3     NOP
11184  0EC8     MOVLW 0xC8
11188  FF8C     NOP
1118A  F001     NOP
1118C  0EC9     MOVLW 0xC9
1118E  50E3     MOVF 0xFE3, W, ACCESS
11190  1001     IORWF ltemp0, W, ACCESS
11192  A4D8     BTFSS 0xFD8, 2, ACCESS
11194  D002     BRA 0x119A
11196  0E65     MOVLW 0x65
11198  D001     BRA 0x119C
1119A  0E45     MOVLW 0x45
1119C  6E0B     MOVWF wtemp5, ACCESS
1119E  0E00     MOVLW 0x0
111A0  6E0C     MOVWF 0xC, ACCESS
111A2  0ECA     MOVLW 0xCA
111A6  F02F     NOP
111A8  FFE3     NOP
111AA  0ECB     MOVLW 0xCB
111AE  F033     NOP
111B0  FFE3     NOP
111B2  0EEC     MOVLW 0xEC
111B6  FF8C     NOP
111B8  F00B     NOP
111BA  0EED     MOVLW 0xED
111BE  FF8C     NOP
111C0  F00C     NOP
111C2  0E97     MOVLW 0x97
111C4  240B     ADDWF wtemp5, W, ACCESS
111C6  6ED9     MOVWF 0xFD9, ACCESS
111C8  0E02     MOVLW 0x2
111CA  200C     ADDWFC 0xC, W, ACCESS
111CC  6EDA     MOVWF 0xFDA, ACCESS
111CE  0ECA     MOVLW 0xCA
111D2  FF8F     NOP
111D4  FFDF     NOP
497:                   --w;
111D6  50E1     MOVF 0xFE1, W, ACCESS
111D8  0FEE     ADDLW 0xEE
111DA  6ED9     MOVWF 0xFD9, ACCESS
111DC  50E2     MOVF 0xFE2, W, ACCESS
111DE  6EDA     MOVWF 0xFDA, ACCESS
111E0  0EFF     MOVLW 0xFF
111E2  22DA     ADDWFC 0xFDA, F, ACCESS
111E4  06DE     DECF 0xFDE, F, ACCESS
111E6  0E00     MOVLW 0x0
111E8  5ADD     SUBWFB 0xFDD, F, ACCESS
498:                   strcpy(&dbuf[n], &dbuf[i]);
111EA  0EEC     MOVLW 0xEC
111EE  FF8C     NOP
111F0  F00B     NOP
111F2  0EED     MOVLW 0xED
111F6  FF8C     NOP
111F8  F00C     NOP
111FA  0E97     MOVLW 0x97
111FC  240B     ADDWF wtemp5, W, ACCESS
111FE  6E09     MOVWF ltemp2, ACCESS
11200  0E02     MOVLW 0x2
11202  200C     ADDWFC 0xC, W, ACCESS
11204  6E0A     MOVWF ttemp3, ACCESS
11208  F027     NOP
1120A  FFE6     NOP
1120E  F02B     NOP
11210  FFE6     NOP
11212  0E97     MOVLW 0x97
11214  6E0B     MOVWF wtemp5, ACCESS
11216  0E02     MOVLW 0x2
11218  6E0C     MOVWF 0xC, ACCESS
1121A  0EE6     MOVLW 0xE6
1121C  50E3     MOVF 0xFE3, W, ACCESS
1121E  260B     ADDWF wtemp5, F, ACCESS
11220  0EE7     MOVLW 0xE7
11222  50E3     MOVF 0xFE3, W, ACCESS
11224  220C     ADDWFC 0xC, F, ACCESS
11228  F02F     NOP
1122A  FFE6     NOP
1122E  F033     NOP
11230  FFE6     NOP
11232  EC5F     CALL 0x1A0BE, 0
11234  F0D0     NOP
11236  EF16     GOTO 0x1022C
11238  F081     NOP
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
1123A  0EC1     MOVLW 0xC1
1123C  26E1     ADDWF 0xFE1, F, ACCESS
1123E  0EFF     MOVLW 0xFF
11240  22E2     ADDWFC 0xFE2, F, ACCESS
11242  0012     RETURN 0
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
17146  0E11     MOVLW 0x11
547:           {
548:               char *cp, nuls[] = "(null)";
1714E  EE20     LFSR 2, 0xF0
17150  F0F0     NOP
17152  0E07     MOVLW 0x7
17154  6E01     MOVWF ltemp0, ACCESS
17156  0EEF     MOVLW 0xEF
1715A  FF7B     NOP
1715C  FFE3     NOP
1715E  28E8     INCF 0xFE8, W, ACCESS
17160  2E01     DECFSZ ltemp0, F, ACCESS
17162  D7FA     BRA 0x7158
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
17164  0EEB     MOVLW 0xEB
17168  FF8C     NOP
1716A  F00B     NOP
1716C  0EEC     MOVLW 0xEC
17170  FF8C     NOP
17172  F00C     NOP
17174  0EFB     MOVLW 0xFB
17178  F033     NOP
1717A  FFE3     NOP
1717C  0EFA     MOVLW 0xFA
17180  F02F     NOP
17182  FFE3     NOP
553:               if (!cp) {
17184  0EFA     MOVLW 0xFA
17188  FF8C     NOP
1718A  F001     NOP
1718C  0EFB     MOVLW 0xFB
1718E  50E3     MOVF 0xFE3, W, ACCESS
17190  1001     IORWF ltemp0, W, ACCESS
17192  A4D8     BTFSS 0xFD8, 2, ACCESS
17194  D00E     BRA 0x71B2
554:                   cp = nuls;
17196  0EEF     MOVLW 0xEF
17198  24E1     ADDWF 0xFE1, W, ACCESS
1719A  6E0B     MOVWF wtemp5, ACCESS
1719C  0EFF     MOVLW 0xFF
1719E  20E2     ADDWFC 0xFE2, W, ACCESS
171A0  6E0C     MOVWF 0xC, ACCESS
171A2  0EFB     MOVLW 0xFB
171A6  F033     NOP
171A8  FFE3     NOP
171AA  0EFA     MOVLW 0xFA
171AE  F02F     NOP
171B0  FFE3     NOP
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
171B2  0EFA     MOVLW 0xFA
171B6  FF8F     NOP
171B8  FFE6     NOP
171BC  FF8F     NOP
171BE  FFE6     NOP
171C0  ECDC     CALL 0x1A5B8, 0
171C2  F0D2     NOP
171C4  0EF6     MOVLW 0xF6
171C8  F007     NOP
171CA  FFE3     NOP
171CC  0EF7     MOVLW 0xF7
171D0  F00B     NOP
171D2  FFE3     NOP
559:               p = prec;
171D4  0EF8     MOVLW 0xF8
171D8  F0F3     NOP
171DA  FFE3     NOP
171DC  0EF9     MOVLW 0xF9
171E0  F0F7     NOP
171E2  FFE3     NOP
560:               l = (!(p < 0) && (p < l)) ? p : l;
171E4  0EF9     MOVLW 0xF9
171E6  BEE3     BTFSC 0xFE3, 7, ACCESS
171E8  D023     BRA 0x7230
171EA  50E1     MOVF 0xFE1, W, ACCESS
171EC  0FF8     ADDLW 0xF8
171EE  6ED9     MOVWF 0xFD9, ACCESS
171F0  50E2     MOVF 0xFE2, W, ACCESS
171F2  6EDA     MOVWF 0xFDA, ACCESS
171F4  0EFF     MOVLW 0xFF
171F6  22DA     ADDWFC 0xFDA, F, ACCESS
171F8  0EF6     MOVLW 0xF6
171FA  50E3     MOVF 0xFE3, W, ACCESS
171FC  5CDE     SUBWF 0xFDE, W, ACCESS
171FE  50DE     MOVF 0xFDE, W, ACCESS
17200  0A80     XORLW 0x80
17202  6E01     MOVWF ltemp0, ACCESS
17204  0EF7     MOVLW 0xF7
17206  50E3     MOVF 0xFE3, W, ACCESS
17208  0A80     XORLW 0x80
1720A  5801     SUBWFB ltemp0, W, ACCESS
1720C  B0D8     BTFSC 0xFD8, 0, ACCESS
1720E  D010     BRA 0x7230
17210  0EF8     MOVLW 0xF8
17214  FF8C     NOP
17216  F001     NOP
17218  0EF6     MOVLW 0xF6
1721C  F007     NOP
1721E  FFE3     NOP
17220  0EF9     MOVLW 0xF9
17224  FF8C     NOP
17226  F001     NOP
17228  0EF7     MOVLW 0xF7
1722C  F007     NOP
1722E  FFE3     NOP
561:               p = l;
17230  0EF6     MOVLW 0xF6
17234  FF8C     NOP
17236  F001     NOP
17238  0EF8     MOVLW 0xF8
1723C  F007     NOP
1723E  FFE3     NOP
17240  0EF7     MOVLW 0xF7
17244  FF8C     NOP
17246  F001     NOP
17248  0EF9     MOVLW 0xF9
1724C  F007     NOP
1724E  FFE3     NOP
562:               w = width;
17250  0EFC     MOVLW 0xFC
17254  F0EB     NOP
17256  FFE3     NOP
17258  0EFD     MOVLW 0xFD
1725C  F0EF     NOP
1725E  FFE3     NOP
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
17260  A03E     BTFSS flags, 0, ACCESS
17262  D01F     BRA 0x72A2
17264  D031     BRA 0x72C8
566:                   while (l < w) {
172A2  50E1     MOVF 0xFE1, W, ACCESS
172A4  0FF6     ADDLW 0xF6
172A6  6ED9     MOVWF 0xFD9, ACCESS
172A8  50E2     MOVF 0xFE2, W, ACCESS
172AA  6EDA     MOVWF 0xFDA, ACCESS
172AC  0EFF     MOVLW 0xFF
172AE  22DA     ADDWFC 0xFDA, F, ACCESS
172B0  0EFC     MOVLW 0xFC
172B2  50E3     MOVF 0xFE3, W, ACCESS
172B4  5CDE     SUBWF 0xFDE, W, ACCESS
172B6  50DE     MOVF 0xFDE, W, ACCESS
172B8  0A80     XORLW 0x80
172BA  6E01     MOVWF ltemp0, ACCESS
172BC  0EFD     MOVLW 0xFD
172BE  50E3     MOVF 0xFE3, W, ACCESS
172C0  0A80     XORLW 0x80
172C2  5801     SUBWFB ltemp0, W, ACCESS
172C4  A0D8     BTFSS 0xFD8, 0, ACCESS
172C6  D7CF     BRA 0x7266
567:                       fputc(' ', fp);
17266  0EED     MOVLW 0xED
1726A  FF8F     NOP
1726C  FFE6     NOP
17270  FF8F     NOP
17272  FFE6     NOP
17274  0E20     MOVLW 0x20
17276  6EE6     MOVWF 0xFE6, ACCESS
17278  0E00     MOVLW 0x0
1727A  6EE6     MOVWF 0xFE6, ACCESS
1727C  EC61     CALL 0x194C2, 0
1727E  F0CA     NOP
568:                       ++l;
17280  0EF6     MOVLW 0xF6
17282  50E3     MOVF 0xFE3, W, ACCESS
17284  0F01     ADDLW 0x1
17286  6E01     MOVWF ltemp0, ACCESS
17288  0EF6     MOVLW 0xF6
1728C  F007     NOP
1728E  FFE3     NOP
17290  6A01     CLRF ltemp0, ACCESS
17292  0EF7     MOVLW 0xF7
17294  50E3     MOVF 0xFE3, W, ACCESS
17296  2001     ADDWFC ltemp0, W, ACCESS
17298  6E01     MOVWF ltemp0, ACCESS
1729A  0EF7     MOVLW 0xF7
1729E  F007     NOP
172A0  FFE3     NOP
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
172C8  0EFE     MOVLW 0xFE
172CA  6AE3     CLRF 0xFE3, ACCESS
172CC  0EFF     MOVLW 0xFF
172CE  6AE3     CLRF 0xFE3, ACCESS
574:               while (i < p) {
172D0  D045     BRA 0x735C
1735C  50E1     MOVF 0xFE1, W, ACCESS
1735E  0FFE     ADDLW 0xFE
17360  6ED9     MOVWF 0xFD9, ACCESS
17362  50E2     MOVF 0xFE2, W, ACCESS
17364  6EDA     MOVWF 0xFDA, ACCESS
17366  0EFF     MOVLW 0xFF
17368  22DA     ADDWFC 0xFDA, F, ACCESS
1736A  0EF8     MOVLW 0xF8
1736C  50E3     MOVF 0xFE3, W, ACCESS
1736E  5CDE     SUBWF 0xFDE, W, ACCESS
17370  50DE     MOVF 0xFDE, W, ACCESS
17372  0A80     XORLW 0x80
17374  6E01     MOVWF ltemp0, ACCESS
17376  0EF9     MOVLW 0xF9
17378  50E3     MOVF 0xFE3, W, ACCESS
1737A  0A80     XORLW 0x80
1737C  5801     SUBWFB ltemp0, W, ACCESS
1737E  A0D8     BTFSS 0xFD8, 0, ACCESS
17380  D7A8     BRA 0x72D2
575:                   fputc(*cp, fp);
172D2  0EED     MOVLW 0xED
172D6  FF8F     NOP
172D8  FFE6     NOP
172DC  FF8F     NOP
172DE  FFE6     NOP
172E0  0EF8     MOVLW 0xF8
172E4  FF8F     NOP
172E6  FFF6     NOP
172E8  0EF9     MOVLW 0xF9
172EC  FF8F     NOP
172EE  FFF7     NOP
172F0  0E00     MOVLW 0x0
172F2  6EF8     MOVWF 0xFF8, ACCESS
172F4  0E1F     MOVLW 0x1F
172F6  64F7     CPFSGT 0xFF7, ACCESS
172F8  D003     BRA 0x7300
172FA  0008     TBLRD*
172FC  50F5     MOVF 0xFF5, W, ACCESS
172FE  D007     BRA 0x730E
17302  FFDB     NOP
17304  FFE9     NOP
17308  FFDF     NOP
1730A  FFEA     NOP
1730C  50EF     MOVF 0xFEF, W, ACCESS
1730E  6EE6     MOVWF 0xFE6, ACCESS
17310  0E00     MOVLW 0x0
17312  6EE6     MOVWF 0xFE6, ACCESS
17314  EC61     CALL 0x194C2, 0
17316  F0CA     NOP
576:                   ++cp;
17318  0EFA     MOVLW 0xFA
1731A  50E3     MOVF 0xFE3, W, ACCESS
1731C  0F01     ADDLW 0x1
1731E  6E01     MOVWF ltemp0, ACCESS
17320  0EFA     MOVLW 0xFA
17324  F007     NOP
17326  FFE3     NOP
17328  6A01     CLRF ltemp0, ACCESS
1732A  0EFB     MOVLW 0xFB
1732C  50E3     MOVF 0xFE3, W, ACCESS
1732E  2001     ADDWFC ltemp0, W, ACCESS
17330  6E01     MOVWF ltemp0, ACCESS
17332  0EFB     MOVLW 0xFB
17336  F007     NOP
17338  FFE3     NOP
577:                   ++i;
1733A  0EFE     MOVLW 0xFE
1733C  50E3     MOVF 0xFE3, W, ACCESS
1733E  0F01     ADDLW 0x1
17340  6E01     MOVWF ltemp0, ACCESS
17342  0EFE     MOVLW 0xFE
17346  F007     NOP
17348  FFE3     NOP
1734A  6A01     CLRF ltemp0, ACCESS
1734C  0EFF     MOVLW 0xFF
1734E  50E3     MOVF 0xFE3, W, ACCESS
17350  2001     ADDWFC ltemp0, W, ACCESS
17352  6E01     MOVWF ltemp0, ACCESS
17354  0EFF     MOVLW 0xFF
17358  F007     NOP
1735A  FFE3     NOP
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
17382  B03E     BTFSC flags, 0, ACCESS
17384  D01F     BRA 0x73C4
17386  D031     BRA 0x73EA
582:                   while (l < w) {
173C4  50E1     MOVF 0xFE1, W, ACCESS
173C6  0FF6     ADDLW 0xF6
173C8  6ED9     MOVWF 0xFD9, ACCESS
173CA  50E2     MOVF 0xFE2, W, ACCESS
173CC  6EDA     MOVWF 0xFDA, ACCESS
173CE  0EFF     MOVLW 0xFF
173D0  22DA     ADDWFC 0xFDA, F, ACCESS
173D2  0EFC     MOVLW 0xFC
173D4  50E3     MOVF 0xFE3, W, ACCESS
173D6  5CDE     SUBWF 0xFDE, W, ACCESS
173D8  50DE     MOVF 0xFDE, W, ACCESS
173DA  0A80     XORLW 0x80
173DC  6E01     MOVWF ltemp0, ACCESS
173DE  0EFD     MOVLW 0xFD
173E0  50E3     MOVF 0xFE3, W, ACCESS
173E2  0A80     XORLW 0x80
173E4  5801     SUBWFB ltemp0, W, ACCESS
173E6  A0D8     BTFSS 0xFD8, 0, ACCESS
173E8  D7CF     BRA 0x7388
583:                       fputc(' ', fp);
17388  0EED     MOVLW 0xED
1738C  FF8F     NOP
1738E  FFE6     NOP
17392  FF8F     NOP
17394  FFE6     NOP
17396  0E20     MOVLW 0x20
17398  6EE6     MOVWF 0xFE6, ACCESS
1739A  0E00     MOVLW 0x0
1739C  6EE6     MOVWF 0xFE6, ACCESS
1739E  EC61     CALL 0x194C2, 0
173A0  F0CA     NOP
584:                       ++l;
173A2  0EF6     MOVLW 0xF6
173A4  50E3     MOVF 0xFE3, W, ACCESS
173A6  0F01     ADDLW 0x1
173A8  6E01     MOVWF ltemp0, ACCESS
173AA  0EF6     MOVLW 0xF6
173AE  F007     NOP
173B0  FFE3     NOP
173B2  6A01     CLRF ltemp0, ACCESS
173B4  0EF7     MOVLW 0xF7
173B6  50E3     MOVF 0xFE3, W, ACCESS
173B8  2001     ADDWFC ltemp0, W, ACCESS
173BA  6E01     MOVWF ltemp0, ACCESS
173BC  0EF7     MOVLW 0xF7
173C0  F007     NOP
173C2  FFE3     NOP
585:                   }
586:               }
587:           
588:               return l;
173EA  0EF6     MOVLW 0xF6
173EE  FF8C     NOP
173F0  F001     NOP
173F2  0EF7     MOVLW 0xF7
173F6  FF8C     NOP
173F8  F002     NOP
589:           }
173FA  0EEB     MOVLW 0xEB
173FC  26E1     ADDWF 0xFE1, F, ACCESS
173FE  0EFF     MOVLW 0xFF
17400  22E2     ADDWFC 0xFE2, F, ACCESS
17402  0012     RETURN 0
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
16522  0E0E     MOVLW 0xE
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
1652A  AE3D     BTFSS 0x3D, 7, ACCESS
600:                   flags &= ~ZERO_FLAG;
1652C  923E     BCF flags, 1, ACCESS
601:               }
602:               p = (0 < prec) ? prec : 1;
1652E  BE3D     BTFSC 0x3D, 7, ACCESS
16530  D005     BRA 0x653C
16532  503D     MOVF 0x3D, W, ACCESS
16534  E110     BNZ 0x6556
16536  043C     DECF prec, W, ACCESS
16538  B0D8     BTFSC 0xFD8, 0, ACCESS
1653A  D00D     BRA 0x6556
1653C  0E01     MOVLW 0x1
1653E  6E0B     MOVWF wtemp5, ACCESS
16540  0E00     MOVLW 0x0
16542  6E0C     MOVWF 0xC, ACCESS
16544  0EFE     MOVLW 0xFE
16548  F02F     NOP
1654A  FFE3     NOP
1654C  0EFF     MOVLW 0xFF
16550  F033     NOP
16552  FFE3     NOP
16554  D008     BRA 0x6566
16556  0EFE     MOVLW 0xFE
1655A  F0F3     NOP
1655C  FFE3     NOP
1655E  0EFF     MOVLW 0xFF
16562  F0F7     NOP
16564  FFE3     NOP
603:               w = width;
16566  0EFC     MOVLW 0xFC
1656A  F0EB     NOP
1656C  FFE3     NOP
1656E  0EFD     MOVLW 0xFD
16572  F0EF     NOP
16574  FFE3     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
16576  0EE8     MOVLW 0xE8
16578  24E1     ADDWF 0xFE1, W, ACCESS
1657A  6ED9     MOVWF 0xFD9, ACCESS
1657C  0EFF     MOVLW 0xFF
1657E  20E2     ADDWFC 0xFE2, W, ACCESS
16580  6EDA     MOVWF 0xFDA, ACCESS
16582  0E08     MOVLW 0x8
16584  6E01     MOVWF ltemp0, ACCESS
16586  0EF2     MOVLW 0xF2
1658A  FF7B     NOP
1658C  FFE3     NOP
1658E  28E8     INCF 0xFE8, W, ACCESS
16590  2E01     DECFSZ ltemp0, F, ACCESS
16592  D7FA     BRA 0x6588
607:               i = sizeof(dbuf) - 1;
16594  0E4F     MOVLW 0x4F
16596  6E0B     MOVWF wtemp5, ACCESS
16598  0E00     MOVLW 0x0
1659A  6E0C     MOVWF 0xC, ACCESS
1659C  0EFA     MOVLW 0xFA
165A0  F02F     NOP
165A2  FFE3     NOP
165A4  0EFB     MOVLW 0xFB
165A8  F033     NOP
165AA  FFE3     NOP
608:               dbuf[i] = '\0';
165AC  0102     MOVLB 0x2
165AE  6BE6     CLRF 0xE6, BANKED
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
165B0  D0FB     BRA 0x67A8
167A8  0EFA     MOVLW 0xFA
167AC  FF8C     NOP
167AE  F001     NOP
167B0  0EFB     MOVLW 0xFB
167B2  50E3     MOVF 0xFE3, W, ACCESS
167B4  1001     IORWF ltemp0, W, ACCESS
167B6  B4D8     BTFSC 0xFD8, 2, ACCESS
167B8  D02F     BRA 0x6818
167BA  0EF2     MOVLW 0xF2
167BC  50E3     MOVF 0xFE3, W, ACCESS
167BE  E115     BNZ 0x67EA
167C0  0EF3     MOVLW 0xF3
167C2  50E3     MOVF 0xFE3, W, ACCESS
167C4  E112     BNZ 0x67EA
167C6  0EF4     MOVLW 0xF4
167C8  50E3     MOVF 0xFE3, W, ACCESS
167CA  E10F     BNZ 0x67EA
167CC  0EF5     MOVLW 0xF5
167CE  50E3     MOVF 0xFE3, W, ACCESS
167D0  E10C     BNZ 0x67EA
167D2  0EF6     MOVLW 0xF6
167D4  50E3     MOVF 0xFE3, W, ACCESS
167D6  E109     BNZ 0x67EA
167D8  0EF7     MOVLW 0xF7
167DA  50E3     MOVF 0xFE3, W, ACCESS
167DC  E106     BNZ 0x67EA
167DE  0EF8     MOVLW 0xF8
167E0  50E3     MOVF 0xFE3, W, ACCESS
167E2  E103     BNZ 0x67EA
167E4  0EF9     MOVLW 0xF9
167E6  50E3     MOVF 0xFE3, W, ACCESS
167E8  A4D8     BTFSS 0xFD8, 2, ACCESS
167EA  D6E3     BRA 0x65B2
167EC  0EFF     MOVLW 0xFF
167EE  BEE3     BTFSC 0xFE3, 7, ACCESS
167F0  D007     BRA 0x6800
167F2  0EFF     MOVLW 0xFF
167F4  50E3     MOVF 0xFE3, W, ACCESS
167F6  E103     BNZ 0x67FE
167F8  0EFE     MOVLW 0xFE
167FA  04E3     DECF 0xFE3, W, ACCESS
167FC  B0D8     BTFSC 0xFD8, 0, ACCESS
167FE  D6D9     BRA 0x65B2
16800  0EFD     MOVLW 0xFD
16802  BEE3     BTFSC 0xFE3, 7, ACCESS
16804  D009     BRA 0x6818
16806  0EFD     MOVLW 0xFD
16808  50E3     MOVF 0xFE3, W, ACCESS
1680A  E104     BNZ 0x6814
1680C  0EFC     MOVLW 0xFC
1680E  04E3     DECF 0xFE3, W, ACCESS
16810  A0D8     BTFSS 0xFD8, 0, ACCESS
16812  D002     BRA 0x6818
16814  B23E     BTFSC flags, 1, ACCESS
16816  D6CD     BRA 0x65B2
610:                   --i;
165B2  50E1     MOVF 0xFE1, W, ACCESS
165B4  0FFA     ADDLW 0xFA
165B6  6ED9     MOVWF 0xFD9, ACCESS
165B8  50E2     MOVF 0xFE2, W, ACCESS
165BA  6EDA     MOVWF 0xFDA, ACCESS
165BC  0EFF     MOVLW 0xFF
165BE  22DA     ADDWFC 0xFDA, F, ACCESS
165C0  06DE     DECF 0xFDE, F, ACCESS
165C2  0E00     MOVLW 0x0
165C4  5ADD     SUBWFB 0xFDD, F, ACCESS
611:                   dbuf[i] = '0' + (n % 10);
165C6  0E0A     MOVLW 0xA
165C8  6EE6     MOVWF 0xFE6, ACCESS
165CA  0E00     MOVLW 0x0
165CC  6EE6     MOVWF 0xFE6, ACCESS
165CE  0E00     MOVLW 0x0
165D0  6EE6     MOVWF 0xFE6, ACCESS
165D2  0E00     MOVLW 0x0
165D4  6EE6     MOVWF 0xFE6, ACCESS
165D6  0E00     MOVLW 0x0
165D8  6EE6     MOVWF 0xFE6, ACCESS
165DA  0E00     MOVLW 0x0
165DC  6EE6     MOVWF 0xFE6, ACCESS
165DE  0E00     MOVLW 0x0
165E0  6EE6     MOVWF 0xFE6, ACCESS
165E2  0E00     MOVLW 0x0
165E4  6EE6     MOVWF 0xFE6, ACCESS
165E6  50E1     MOVF 0xFE1, W, ACCESS
165E8  0FEA     ADDLW 0xEA
165EA  6ED9     MOVWF 0xFD9, ACCESS
165EC  50E2     MOVF 0xFE2, W, ACCESS
165EE  6EDA     MOVWF 0xFDA, ACCESS
165F0  0EFF     MOVLW 0xFF
165F2  22DA     ADDWFC 0xFDA, F, ACCESS
165F6  FF7B     NOP
165F8  FFE6     NOP
165FC  FF7B     NOP
165FE  FFE6     NOP
16602  FF7B     NOP
16604  FFE6     NOP
16608  FF7B     NOP
1660A  FFE6     NOP
1660E  FF7B     NOP
16610  FFE6     NOP
16614  FF7B     NOP
16616  FFE6     NOP
1661A  FF7B     NOP
1661C  FFE6     NOP
16620  FF7B     NOP
16622  FFE6     NOP
16624  EC8A     CALL 0x19114, 0
16626  F0C8     NOP
16628  52E5     MOVF 0xFE5, F, ACCESS
1662C  FF9C     NOP
1662E  F018     NOP
16630  52E5     MOVF 0xFE5, F, ACCESS
16634  FF9C     NOP
16636  F017     NOP
16638  52E5     MOVF 0xFE5, F, ACCESS
1663C  FF9C     NOP
1663E  F016     NOP
16640  52E5     MOVF 0xFE5, F, ACCESS
16644  FF9C     NOP
16646  F015     NOP
16648  52E5     MOVF 0xFE5, F, ACCESS
1664C  FF9C     NOP
1664E  F014     NOP
16650  52E5     MOVF 0xFE5, F, ACCESS
16654  FF9C     NOP
16656  F013     NOP
16658  52E5     MOVF 0xFE5, F, ACCESS
1665C  FF9C     NOP
1665E  F012     NOP
16660  52E5     MOVF 0xFE5, F, ACCESS
16664  FF9C     NOP
16666  F011     NOP
16668  0EF8     MOVLW 0xF8
1666A  26E1     ADDWF 0xFE1, F, ACCESS
1666C  0EFF     MOVLW 0xFF
1666E  22E2     ADDWFC 0xFE2, F, ACCESS
16670  0E30     MOVLW 0x30
16672  2611     ADDWF lltemp2, F, ACCESS
16674  0EFA     MOVLW 0xFA
16678  FF8C     NOP
1667A  F00B     NOP
1667C  0EFB     MOVLW 0xFB
16680  FF8C     NOP
16682  F00C     NOP
16684  0E97     MOVLW 0x97
16686  240B     ADDWF wtemp5, W, ACCESS
16688  6ED9     MOVWF 0xFD9, ACCESS
1668A  0E02     MOVLW 0x2
1668C  200C     ADDWFC 0xC, W, ACCESS
1668E  6EDA     MOVWF 0xFDA, ACCESS
16692  F047     NOP
16694  FFDF     NOP
612:                   --p;
16696  50E1     MOVF 0xFE1, W, ACCESS
16698  0FFE     ADDLW 0xFE
1669A  6ED9     MOVWF 0xFD9, ACCESS
1669C  50E2     MOVF 0xFE2, W, ACCESS
1669E  6EDA     MOVWF 0xFDA, ACCESS
166A0  0EFF     MOVLW 0xFF
166A2  22DA     ADDWFC 0xFDA, F, ACCESS
166A4  06DE     DECF 0xFDE, F, ACCESS
166A6  0E00     MOVLW 0x0
166A8  5ADD     SUBWFB 0xFDD, F, ACCESS
613:                   --w;
166AA  50E1     MOVF 0xFE1, W, ACCESS
166AC  0FFC     ADDLW 0xFC
166AE  6ED9     MOVWF 0xFD9, ACCESS
166B0  50E2     MOVF 0xFE2, W, ACCESS
166B2  6EDA     MOVWF 0xFDA, ACCESS
166B4  0EFF     MOVLW 0xFF
166B6  22DA     ADDWFC 0xFDA, F, ACCESS
166B8  06DE     DECF 0xFDE, F, ACCESS
166BA  0E00     MOVLW 0x0
166BC  5ADD     SUBWFB 0xFDD, F, ACCESS
614:                   n = n / 10;
166BE  0E0A     MOVLW 0xA
166C0  6EE6     MOVWF 0xFE6, ACCESS
166C2  0E00     MOVLW 0x0
166C4  6EE6     MOVWF 0xFE6, ACCESS
166C6  0E00     MOVLW 0x0
166C8  6EE6     MOVWF 0xFE6, ACCESS
166CA  0E00     MOVLW 0x0
166CC  6EE6     MOVWF 0xFE6, ACCESS
166CE  0E00     MOVLW 0x0
166D0  6EE6     MOVWF 0xFE6, ACCESS
166D2  0E00     MOVLW 0x0
166D4  6EE6     MOVWF 0xFE6, ACCESS
166D6  0E00     MOVLW 0x0
166D8  6EE6     MOVWF 0xFE6, ACCESS
166DA  0E00     MOVLW 0x0
166DC  6EE6     MOVWF 0xFE6, ACCESS
166DE  50E1     MOVF 0xFE1, W, ACCESS
166E0  0FEA     ADDLW 0xEA
166E2  6ED9     MOVWF 0xFD9, ACCESS
166E4  50E2     MOVF 0xFE2, W, ACCESS
166E6  6EDA     MOVWF 0xFDA, ACCESS
166E8  0EFF     MOVLW 0xFF
166EA  22DA     ADDWFC 0xFDA, F, ACCESS
166EE  FF7B     NOP
166F0  FFE6     NOP
166F4  FF7B     NOP
166F6  FFE6     NOP
166FA  FF7B     NOP
166FC  FFE6     NOP
16700  FF7B     NOP
16702  FFE6     NOP
16706  FF7B     NOP
16708  FFE6     NOP
1670C  FF7B     NOP
1670E  FFE6     NOP
16712  FF7B     NOP
16714  FFE6     NOP
16718  FF7B     NOP
1671A  FFE6     NOP
1671C  EC08     CALL 0x18A10, 0
1671E  F0C5     NOP
16720  52E5     MOVF 0xFE5, F, ACCESS
16724  FF9C     NOP
16726  F018     NOP
16728  52E5     MOVF 0xFE5, F, ACCESS
1672C  FF9C     NOP
1672E  F017     NOP
16730  52E5     MOVF 0xFE5, F, ACCESS
16734  FF9C     NOP
16736  F016     NOP
16738  52E5     MOVF 0xFE5, F, ACCESS
1673C  FF9C     NOP
1673E  F015     NOP
16740  52E5     MOVF 0xFE5, F, ACCESS
16744  FF9C     NOP
16746  F014     NOP
16748  52E5     MOVF 0xFE5, F, ACCESS
1674C  FF9C     NOP
1674E  F013     NOP
16750  52E5     MOVF 0xFE5, F, ACCESS
16754  FF9C     NOP
16756  F012     NOP
16758  52E5     MOVF 0xFE5, F, ACCESS
1675C  FF9C     NOP
1675E  F011     NOP
16760  0EF8     MOVLW 0xF8
16762  26E1     ADDWF 0xFE1, F, ACCESS
16764  0EFF     MOVLW 0xFF
16766  22E2     ADDWFC 0xFE2, F, ACCESS
16768  0EF2     MOVLW 0xF2
1676C  F047     NOP
1676E  FFE3     NOP
16770  0EF3     MOVLW 0xF3
16774  F04B     NOP
16776  FFE3     NOP
16778  0EF4     MOVLW 0xF4
1677C  F04F     NOP
1677E  FFE3     NOP
16780  0EF5     MOVLW 0xF5
16784  F053     NOP
16786  FFE3     NOP
16788  0EF6     MOVLW 0xF6
1678C  F057     NOP
1678E  FFE3     NOP
16790  0EF7     MOVLW 0xF7
16794  F05B     NOP
16796  FFE3     NOP
16798  0EF8     MOVLW 0xF8
1679C  F05F     NOP
1679E  FFE3     NOP
167A0  0EF9     MOVLW 0xF9
167A4  F063     NOP
167A6  FFE3     NOP
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
16818  0EFC     MOVLW 0xFC
1681C  FF8F     NOP
1681E  FFE6     NOP
16822  FF8F     NOP
16824  FFE6     NOP
16826  0E97     MOVLW 0x97
16828  6E0B     MOVWF wtemp5, ACCESS
1682A  0E02     MOVLW 0x2
1682C  6E0C     MOVWF 0xC, ACCESS
1682E  0EF8     MOVLW 0xF8
16830  50E3     MOVF 0xFE3, W, ACCESS
16832  260B     ADDWF wtemp5, F, ACCESS
16834  0EF9     MOVLW 0xF9
16836  50E3     MOVF 0xFE3, W, ACCESS
16838  220C     ADDWFC 0xC, F, ACCESS
1683C  F02F     NOP
1683E  FFE6     NOP
16842  F033     NOP
16844  FFE6     NOP
16846  0EEC     MOVLW 0xEC
1684A  FF8F     NOP
1684C  FFE6     NOP
16850  FF8F     NOP
16852  FFE6     NOP
16854  EC0C     CALL 0x19818, 0
16856  F0CC     NOP
619:           }
16858  0EE8     MOVLW 0xE8
1685A  26E1     ADDWF 0xFE1, F, ACCESS
1685C  0EFF     MOVLW 0xFF
1685E  22E2     ADDWFC 0xFE2, F, ACCESS
16860  0012     RETURN 0
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
15DFC  0E14     MOVLW 0x14
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
15E04  AE3D     BTFSS 0x3D, 7, ACCESS
630:                   flags &= ~ZERO_FLAG;
15E06  923E     BCF flags, 1, ACCESS
631:               }
632:               p = (0 < prec) ? prec : 1;
15E08  BE3D     BTFSC 0x3D, 7, ACCESS
15E0A  D005     BRA 0x5E16
15E0C  503D     MOVF 0x3D, W, ACCESS
15E0E  E110     BNZ 0x5E30
15E10  043C     DECF prec, W, ACCESS
15E12  B0D8     BTFSC 0xFD8, 0, ACCESS
15E14  D00D     BRA 0x5E30
15E16  0E01     MOVLW 0x1
15E18  6E0B     MOVWF wtemp5, ACCESS
15E1A  0E00     MOVLW 0x0
15E1C  6E0C     MOVWF 0xC, ACCESS
15E1E  0EFE     MOVLW 0xFE
15E22  F02F     NOP
15E24  FFE3     NOP
15E26  0EFF     MOVLW 0xFF
15E2A  F033     NOP
15E2C  FFE3     NOP
15E2E  D008     BRA 0x5E40
15E30  0EFE     MOVLW 0xFE
15E34  F0F3     NOP
15E36  FFE3     NOP
15E38  0EFF     MOVLW 0xFF
15E3C  F0F7     NOP
15E3E  FFE3     NOP
633:               w = width;
15E40  0EFC     MOVLW 0xFC
15E44  F0EB     NOP
15E46  FFE3     NOP
15E48  0EFD     MOVLW 0xFD
15E4C  F0EF     NOP
15E4E  FFE3     NOP
634:               if (flags & POUND_FLAG) {
15E50  A83E     BTFSS flags, 4, ACCESS
15E52  D00B     BRA 0x5E6A
635:                   w -= 2;
15E54  50E1     MOVF 0xFE1, W, ACCESS
15E56  0FFC     ADDLW 0xFC
15E58  6ED9     MOVWF 0xFD9, ACCESS
15E5A  50E2     MOVF 0xFE2, W, ACCESS
15E5C  6EDA     MOVWF 0xFDA, ACCESS
15E5E  0EFF     MOVLW 0xFF
15E60  22DA     ADDWFC 0xFDA, F, ACCESS
15E62  0EFE     MOVLW 0xFE
15E64  26DE     ADDWF 0xFDE, F, ACCESS
15E66  0EFF     MOVLW 0xFF
15E68  22DD     ADDWFC 0xFDD, F, ACCESS
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
15E6A  0EE2     MOVLW 0xE2
15E6C  24E1     ADDWF 0xFE1, W, ACCESS
15E6E  6ED9     MOVWF 0xFD9, ACCESS
15E70  0EFF     MOVLW 0xFF
15E72  20E2     ADDWFC 0xFE2, W, ACCESS
15E74  6EDA     MOVWF 0xFDA, ACCESS
15E76  0E08     MOVLW 0x8
15E78  6E01     MOVWF ltemp0, ACCESS
15E7A  0EF0     MOVLW 0xF0
15E7E  FF7B     NOP
15E80  FFE3     NOP
15E82  28E8     INCF 0xFE8, W, ACCESS
15E84  2E01     DECFSZ ltemp0, F, ACCESS
15E86  D7FA     BRA 0x5E7C
640:               i = sizeof(dbuf) - 1;
15E88  0E4F     MOVLW 0x4F
15E8A  6E0B     MOVWF wtemp5, ACCESS
15E8C  0E00     MOVLW 0x0
15E8E  6E0C     MOVWF 0xC, ACCESS
15E90  0EFA     MOVLW 0xFA
15E94  F02F     NOP
15E96  FFE3     NOP
15E98  0EFB     MOVLW 0xFB
15E9C  F033     NOP
15E9E  FFE3     NOP
641:               dbuf[i] = '\0';
15EA0  0102     MOVLB 0x2
15EA2  6BE6     CLRF 0xE6, BANKED
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
15EA4  D0EE     BRA 0x6082
16082  0EFB     MOVLW 0xFB
16084  BEE3     BTFSC 0xFE3, 7, ACCESS
16086  D03A     BRA 0x60FC
16088  0EFB     MOVLW 0xFB
1608A  50E3     MOVF 0xFE3, W, ACCESS
1608C  E108     BNZ 0x609E
1608E  0EFA     MOVLW 0xFA
16092  FF8C     NOP
16094  F001     NOP
16096  0E02     MOVLW 0x2
16098  5E01     SUBWF ltemp0, F, ACCESS
1609A  A0D8     BTFSS 0xFD8, 0, ACCESS
1609C  D02F     BRA 0x60FC
1609E  0EF0     MOVLW 0xF0
160A0  50E3     MOVF 0xFE3, W, ACCESS
160A2  E115     BNZ 0x60CE
160A4  0EF1     MOVLW 0xF1
160A6  50E3     MOVF 0xFE3, W, ACCESS
160A8  E112     BNZ 0x60CE
160AA  0EF2     MOVLW 0xF2
160AC  50E3     MOVF 0xFE3, W, ACCESS
160AE  E10F     BNZ 0x60CE
160B0  0EF3     MOVLW 0xF3
160B2  50E3     MOVF 0xFE3, W, ACCESS
160B4  E10C     BNZ 0x60CE
160B6  0EF4     MOVLW 0xF4
160B8  50E3     MOVF 0xFE3, W, ACCESS
160BA  E109     BNZ 0x60CE
160BC  0EF5     MOVLW 0xF5
160BE  50E3     MOVF 0xFE3, W, ACCESS
160C0  E106     BNZ 0x60CE
160C2  0EF6     MOVLW 0xF6
160C4  50E3     MOVF 0xFE3, W, ACCESS
160C6  E103     BNZ 0x60CE
160C8  0EF7     MOVLW 0xF7
160CA  50E3     MOVF 0xFE3, W, ACCESS
160CC  A4D8     BTFSS 0xFD8, 2, ACCESS
160CE  D6EB     BRA 0x5EA6
160D0  0EFF     MOVLW 0xFF
160D2  BEE3     BTFSC 0xFE3, 7, ACCESS
160D4  D007     BRA 0x60E4
160D6  0EFF     MOVLW 0xFF
160D8  50E3     MOVF 0xFE3, W, ACCESS
160DA  E103     BNZ 0x60E2
160DC  0EFE     MOVLW 0xFE
160DE  04E3     DECF 0xFE3, W, ACCESS
160E0  B0D8     BTFSC 0xFD8, 0, ACCESS
160E2  D6E1     BRA 0x5EA6
160E4  0EFD     MOVLW 0xFD
160E6  BEE3     BTFSC 0xFE3, 7, ACCESS
160E8  D009     BRA 0x60FC
160EA  0EFD     MOVLW 0xFD
160EC  50E3     MOVF 0xFE3, W, ACCESS
160EE  E104     BNZ 0x60F8
160F0  0EFC     MOVLW 0xFC
160F2  04E3     DECF 0xFE3, W, ACCESS
160F4  A0D8     BTFSS 0xFD8, 0, ACCESS
160F6  D002     BRA 0x60FC
160F8  B23E     BTFSC flags, 1, ACCESS
160FA  D6D5     BRA 0x5EA6
643:                   --i;
15EA6  50E1     MOVF 0xFE1, W, ACCESS
15EA8  0FFA     ADDLW 0xFA
15EAA  6ED9     MOVWF 0xFD9, ACCESS
15EAC  50E2     MOVF 0xFE2, W, ACCESS
15EAE  6EDA     MOVWF 0xFDA, ACCESS
15EB0  0EFF     MOVLW 0xFF
15EB2  22DA     ADDWFC 0xFDA, F, ACCESS
15EB4  06DE     DECF 0xFDE, F, ACCESS
15EB6  0E00     MOVLW 0x0
15EB8  5ADD     SUBWFB 0xFDD, F, ACCESS
644:                   c = n & 0x0f;
15EBA  0EF0     MOVLW 0xF0
15EBE  FF8C     NOP
15EC0  F00B     NOP
15EC2  0EF1     MOVLW 0xF1
15EC6  FF8C     NOP
15EC8  F00C     NOP
15ECA  0E0F     MOVLW 0xF
15ECC  160B     ANDWF wtemp5, F, ACCESS
15ECE  0E00     MOVLW 0x0
15ED0  160C     ANDWF 0xC, F, ACCESS
15ED2  0EF8     MOVLW 0xF8
15ED6  F02F     NOP
15ED8  FFE3     NOP
15EDA  0EF9     MOVLW 0xF9
15EDE  F033     NOP
15EE0  FFE3     NOP
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
15EE2  0EF9     MOVLW 0xF9
15EE4  BEE3     BTFSC 0xFE3, 7, ACCESS
15EE6  D00F     BRA 0x5F06
15EE8  0EF9     MOVLW 0xF9
15EEA  50E3     MOVF 0xFE3, W, ACCESS
15EEC  E108     BNZ 0x5EFE
15EEE  0EF8     MOVLW 0xF8
15EF2  FF8C     NOP
15EF4  F001     NOP
15EF6  0E0A     MOVLW 0xA
15EF8  5E01     SUBWF ltemp0, F, ACCESS
15EFA  A0D8     BTFSS 0xFD8, 0, ACCESS
15EFC  D004     BRA 0x5F06
15EFE  0EF8     MOVLW 0xF8
15F00  50E3     MOVF 0xFE3, W, ACCESS
15F02  0F57     ADDLW 0x57
15F04  D003     BRA 0x5F0C
15F06  0EF8     MOVLW 0xF8
15F08  50E3     MOVF 0xFE3, W, ACCESS
15F0A  0F30     ADDLW 0x30
15F0C  6E0B     MOVWF wtemp5, ACCESS
15F0E  0EF9     MOVLW 0xF9
15F12  FF8C     NOP
15F14  F00C     NOP
15F16  0E00     MOVLW 0x0
15F18  220C     ADDWFC 0xC, F, ACCESS
15F1A  0EF8     MOVLW 0xF8
15F1E  F02F     NOP
15F20  FFE3     NOP
15F22  0EF9     MOVLW 0xF9
15F26  F033     NOP
15F28  FFE3     NOP
646:                   if (isupper((int)x) && isalpha(c)) {
15F2A  0EBF     MOVLW 0xBF
15F2C  6E0B     MOVWF wtemp5, ACCESS
15F2E  0EFF     MOVLW 0xFF
15F30  6E0C     MOVWF 0xC, ACCESS
15F32  0EE1     MOVLW 0xE1
15F34  50E3     MOVF 0xFE3, W, ACCESS
15F36  6E09     MOVWF ltemp2, ACCESS
15F38  6A0A     CLRF ttemp3, ACCESS
15F3A  500B     MOVF wtemp5, W, ACCESS
15F3C  2609     ADDWF ltemp2, F, ACCESS
15F3E  500C     MOVF 0xC, W, ACCESS
15F40  220A     ADDWFC ttemp3, F, ACCESS
15F42  500A     MOVF ttemp3, W, ACCESS
15F44  E106     BNZ 0x5F52
15F46  0E1A     MOVLW 0x1A
15F48  5C09     SUBWF ltemp2, W, ACCESS
15F4A  B0D8     BTFSC 0xFD8, 0, ACCESS
15F4C  D002     BRA 0x5F52
15F4E  0E01     MOVLW 0x1
15F50  D001     BRA 0x5F54
15F52  0E00     MOVLW 0x0
15F54  6E0B     MOVWF wtemp5, ACCESS
15F56  6A0C     CLRF 0xC, ACCESS
15F58  0EEE     MOVLW 0xEE
15F5C  F02F     NOP
15F5E  FFE3     NOP
15F60  0EEF     MOVLW 0xEF
15F64  F033     NOP
15F66  FFE3     NOP
15F68  0EEE     MOVLW 0xEE
15F6C  FF8C     NOP
15F6E  F001     NOP
15F70  0EEF     MOVLW 0xEF
15F72  50E3     MOVF 0xFE3, W, ACCESS
15F74  1001     IORWF ltemp0, W, ACCESS
15F76  B4D8     BTFSC 0xFD8, 2, ACCESS
15F78  D041     BRA 0x5FFC
15F7A  0E9F     MOVLW 0x9F
15F7C  6E0B     MOVWF wtemp5, ACCESS
15F7E  0EFF     MOVLW 0xFF
15F80  6E0C     MOVWF 0xC, ACCESS
15F82  0EF8     MOVLW 0xF8
15F86  FF8C     NOP
15F88  F009     NOP
15F8A  0EF9     MOVLW 0xF9
15F8E  FF8C     NOP
15F90  F00A     NOP
15F92  0E20     MOVLW 0x20
15F94  1209     IORWF ltemp2, F, ACCESS
15F96  0E00     MOVLW 0x0
15F98  120A     IORWF ttemp3, F, ACCESS
15F9A  500B     MOVF wtemp5, W, ACCESS
15F9C  2609     ADDWF ltemp2, F, ACCESS
15F9E  500C     MOVF 0xC, W, ACCESS
15FA0  220A     ADDWFC ttemp3, F, ACCESS
15FA2  500A     MOVF ttemp3, W, ACCESS
15FA4  E106     BNZ 0x5FB2
15FA6  0E1A     MOVLW 0x1A
15FA8  5C09     SUBWF ltemp2, W, ACCESS
15FAA  B0D8     BTFSC 0xFD8, 0, ACCESS
15FAC  D002     BRA 0x5FB2
15FAE  0E01     MOVLW 0x1
15FB0  D001     BRA 0x5FB4
15FB2  0E00     MOVLW 0x0
15FB4  6E0B     MOVWF wtemp5, ACCESS
15FB6  6A0C     CLRF 0xC, ACCESS
15FB8  0EEC     MOVLW 0xEC
15FBC  F02F     NOP
15FBE  FFE3     NOP
15FC0  0EED     MOVLW 0xED
15FC4  F033     NOP
15FC6  FFE3     NOP
15FC8  0EEC     MOVLW 0xEC
15FCC  FF8C     NOP
15FCE  F001     NOP
15FD0  0EED     MOVLW 0xED
15FD2  50E3     MOVF 0xFE3, W, ACCESS
15FD4  1001     IORWF ltemp0, W, ACCESS
15FD6  B4D8     BTFSC 0xFD8, 2, ACCESS
15FD8  D011     BRA 0x5FFC
647:                       c = toupper(c);
15FDA  0EF8     MOVLW 0xF8
15FDE  FF8F     NOP
15FE0  FFE6     NOP
15FE4  FF8F     NOP
15FE6  FFE6     NOP
15FE8  EC98     CALL 0x1A930, 0
15FEA  F0D4     NOP
15FEC  0EF8     MOVLW 0xF8
15FF0  F007     NOP
15FF2  FFE3     NOP
15FF4  0EF9     MOVLW 0xF9
15FF8  F00B     NOP
15FFA  FFE3     NOP
648:                   }
649:                   dbuf[i] = (char)c;
15FFC  0EFA     MOVLW 0xFA
16000  FF8C     NOP
16002  F00B     NOP
16004  0EFB     MOVLW 0xFB
16008  FF8C     NOP
1600A  F00C     NOP
1600C  0E97     MOVLW 0x97
1600E  240B     ADDWF wtemp5, W, ACCESS
16010  6ED9     MOVWF 0xFD9, ACCESS
16012  0E02     MOVLW 0x2
16014  200C     ADDWFC 0xC, W, ACCESS
16016  6EDA     MOVWF 0xFDA, ACCESS
16018  0EF8     MOVLW 0xF8
1601C  FF8F     NOP
1601E  FFDF     NOP
650:                   --p;
16020  50E1     MOVF 0xFE1, W, ACCESS
16022  0FFE     ADDLW 0xFE
16024  6ED9     MOVWF 0xFD9, ACCESS
16026  50E2     MOVF 0xFE2, W, ACCESS
16028  6EDA     MOVWF 0xFDA, ACCESS
1602A  0EFF     MOVLW 0xFF
1602C  22DA     ADDWFC 0xFDA, F, ACCESS
1602E  06DE     DECF 0xFDE, F, ACCESS
16030  0E00     MOVLW 0x0
16032  5ADD     SUBWFB 0xFDD, F, ACCESS
651:                   --w;
16034  50E1     MOVF 0xFE1, W, ACCESS
16036  0FFC     ADDLW 0xFC
16038  6ED9     MOVWF 0xFD9, ACCESS
1603A  50E2     MOVF 0xFE2, W, ACCESS
1603C  6EDA     MOVWF 0xFDA, ACCESS
1603E  0EFF     MOVLW 0xFF
16040  22DA     ADDWFC 0xFDA, F, ACCESS
16042  06DE     DECF 0xFDE, F, ACCESS
16044  0E00     MOVLW 0x0
16046  5ADD     SUBWFB 0xFDD, F, ACCESS
652:                   n = n >> 4;
16048  0E04     MOVLW 0x4
1604A  6E0C     MOVWF 0xC, ACCESS
1604C  50E1     MOVF 0xFE1, W, ACCESS
1604E  0FF0     ADDLW 0xF0
16050  6ED9     MOVWF 0xFD9, ACCESS
16052  50E2     MOVF 0xFE2, W, ACCESS
16054  6EDA     MOVWF 0xFDA, ACCESS
16056  0EFF     MOVLW 0xFF
16058  22DA     ADDWFC 0xFDA, F, ACCESS
1605A  280C     INCF 0xC, W, ACCESS
1605C  52DE     MOVF 0xFDE, F, ACCESS
1605E  D00F     BRA 0x607E
16060  52DE     MOVF 0xFDE, F, ACCESS
16062  52DE     MOVF 0xFDE, F, ACCESS
16064  52DE     MOVF 0xFDE, F, ACCESS
16066  52DE     MOVF 0xFDE, F, ACCESS
16068  52DE     MOVF 0xFDE, F, ACCESS
1606A  52DE     MOVF 0xFDE, F, ACCESS
1606C  90D8     BCF 0xFD8, 0, ACCESS
1606E  32DD     RRCF 0xFDD, F, ACCESS
16070  32DD     RRCF 0xFDD, F, ACCESS
16072  32DD     RRCF 0xFDD, F, ACCESS
16074  32DD     RRCF 0xFDD, F, ACCESS
16076  32DD     RRCF 0xFDD, F, ACCESS
16078  32DD     RRCF 0xFDD, F, ACCESS
1607A  32DD     RRCF 0xFDD, F, ACCESS
1607C  32DE     RRCF 0xFDE, F, ACCESS
1607E  2EE8     DECFSZ 0xFE8, F, ACCESS
16080  D7EF     BRA 0x6060
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
160FC  A83E     BTFSS flags, 4, ACCESS
160FE  D036     BRA 0x616C
657:                   --i;
16100  50E1     MOVF 0xFE1, W, ACCESS
16102  0FFA     ADDLW 0xFA
16104  6ED9     MOVWF 0xFD9, ACCESS
16106  50E2     MOVF 0xFE2, W, ACCESS
16108  6EDA     MOVWF 0xFDA, ACCESS
1610A  0EFF     MOVLW 0xFF
1610C  22DA     ADDWFC 0xFDA, F, ACCESS
1610E  06DE     DECF 0xFDE, F, ACCESS
16110  0E00     MOVLW 0x0
16112  5ADD     SUBWFB 0xFDD, F, ACCESS
658:                   dbuf[i] = x;
16114  0EFA     MOVLW 0xFA
16118  FF8C     NOP
1611A  F00B     NOP
1611C  0EFB     MOVLW 0xFB
16120  FF8C     NOP
16122  F00C     NOP
16124  0E97     MOVLW 0x97
16126  240B     ADDWF wtemp5, W, ACCESS
16128  6ED9     MOVWF 0xFD9, ACCESS
1612A  0E02     MOVLW 0x2
1612C  200C     ADDWFC 0xC, W, ACCESS
1612E  6EDA     MOVWF 0xFDA, ACCESS
16130  0EE1     MOVLW 0xE1
16134  FF8F     NOP
16136  FFDF     NOP
659:                   --i;
16138  50E1     MOVF 0xFE1, W, ACCESS
1613A  0FFA     ADDLW 0xFA
1613C  6ED9     MOVWF 0xFD9, ACCESS
1613E  50E2     MOVF 0xFE2, W, ACCESS
16140  6EDA     MOVWF 0xFDA, ACCESS
16142  0EFF     MOVLW 0xFF
16144  22DA     ADDWFC 0xFDA, F, ACCESS
16146  06DE     DECF 0xFDE, F, ACCESS
16148  0E00     MOVLW 0x0
1614A  5ADD     SUBWFB 0xFDD, F, ACCESS
660:                   dbuf[i] = '0';
1614C  0EFA     MOVLW 0xFA
16150  FF8C     NOP
16152  F00B     NOP
16154  0EFB     MOVLW 0xFB
16158  FF8C     NOP
1615A  F00C     NOP
1615C  0E97     MOVLW 0x97
1615E  240B     ADDWF wtemp5, W, ACCESS
16160  6ED9     MOVWF 0xFD9, ACCESS
16162  0E02     MOVLW 0x2
16164  200C     ADDWFC 0xC, W, ACCESS
16166  6EDA     MOVWF 0xFDA, ACCESS
16168  0E30     MOVLW 0x30
1616A  6EDF     MOVWF 0xFDF, ACCESS
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
1616C  0EFC     MOVLW 0xFC
16170  FF8F     NOP
16172  FFE6     NOP
16176  FF8F     NOP
16178  FFE6     NOP
1617A  0E97     MOVLW 0x97
1617C  6E0B     MOVWF wtemp5, ACCESS
1617E  0E02     MOVLW 0x2
16180  6E0C     MOVWF 0xC, ACCESS
16182  0EF8     MOVLW 0xF8
16184  50E3     MOVF 0xFE3, W, ACCESS
16186  260B     ADDWF wtemp5, F, ACCESS
16188  0EF9     MOVLW 0xF9
1618A  50E3     MOVF 0xFE3, W, ACCESS
1618C  220C     ADDWFC 0xC, F, ACCESS
16190  F02F     NOP
16192  FFE6     NOP
16196  F033     NOP
16198  FFE6     NOP
1619A  0EE6     MOVLW 0xE6
1619E  FF8F     NOP
161A0  FFE6     NOP
161A4  FF8F     NOP
161A6  FFE6     NOP
161A8  EC0C     CALL 0x19818, 0
161AA  F0CC     NOP
665:           }
161AC  0EE1     MOVLW 0xE1
161AE  26E1     ADDWF 0xFE1, F, ACCESS
161B0  0EFF     MOVLW 0xFF
161B2  22E2     ADDWFC 0xFE2, F, ACCESS
161B4  0012     RETURN 0
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
12394  0E20     MOVLW 0x20
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
1239C  0EDC     MOVLW 0xDC
123A0  FF8F     NOP
123A2  FFD9     NOP
123A4  0EDD     MOVLW 0xDD
123A8  FF8F     NOP
123AA  FFDA     NOP
123AE  FF7B     NOP
123B0  FFF6     NOP
123B4  FF77     NOP
123B6  FFF7     NOP
123B8  0E00     MOVLW 0x0
123BA  6EF8     MOVWF 0xFF8, ACCESS
123BC  0008     TBLRD*
123BE  50F5     MOVF 0xFF5, W, ACCESS
123C0  0A25     XORLW 0x25
123C2  A4D8     BTFSS 0xFD8, 2, ACCESS
123C4  EF71     GOTO 0x132E2
123C6  F099     NOP
681:                   ++*fmt;
123C8  0EDC     MOVLW 0xDC
123CC  FF8F     NOP
123CE  FFD9     NOP
123D0  0EDD     MOVLW 0xDD
123D4  FF8F     NOP
123D6  FFDA     NOP
123D8  2ADE     INCF 0xFDE, F, ACCESS
123DA  0E00     MOVLW 0x0
123DC  22DD     ADDWFC 0xFDD, F, ACCESS
682:           
683:                   flags = width = 0;
123DE  6A3A     CLRF width, ACCESS
123E0  6A3B     CLRF 0x3B, ACCESS
123E2  6A3E     CLRF flags, ACCESS
123E4  6A3F     CLRF 0x3F, ACCESS
684:                   prec = -1;
123E6  683C     SETF prec, ACCESS
123E8  683D     SETF 0x3D, ACCESS
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
123EA  0EDC     MOVLW 0xDC
123EE  FF8F     NOP
123F0  FFD9     NOP
123F2  0EDD     MOVLW 0xDD
123F6  FF8F     NOP
123F8  FFDA     NOP
123FC  FF7B     NOP
123FE  FFF6     NOP
12402  FF77     NOP
12404  FFF7     NOP
12406  0E00     MOVLW 0x0
12408  6EF8     MOVWF 0xFF8, ACCESS
1240A  0008     TBLRD*
1240C  50F5     MOVF 0xFF5, W, ACCESS
1240E  0A2A     XORLW 0x2A
12410  A4D8     BTFSS 0xFD8, 2, ACCESS
12412  D031     BRA 0x2476
724:                       ++*fmt;
12414  0EDC     MOVLW 0xDC
12418  FF8F     NOP
1241A  FFD9     NOP
1241C  0EDD     MOVLW 0xDD
12420  FF8F     NOP
12422  FFDA     NOP
12424  2ADE     INCF 0xFDE, F, ACCESS
12426  0E00     MOVLW 0x0
12428  22DD     ADDWFC 0xFDD, F, ACCESS
725:                       width = va_arg(ap, int);
1242A  0EDA     MOVLW 0xDA
1242E  FF8F     NOP
12430  FFD9     NOP
12432  0EDB     MOVLW 0xDB
12436  FF8F     NOP
12438  FFDA     NOP
1243A  0E02     MOVLW 0x2
1243C  5EDE     SUBWF 0xFDE, F, ACCESS
1243E  0E00     MOVLW 0x0
12440  5ADD     SUBWFB 0xFDD, F, ACCESS
12444  FF78     NOP
12446  F00B     NOP
1244A  FF74     NOP
1244C  F00C     NOP
12450  F02F     NOP
12452  FFD9     NOP
12456  F033     NOP
12458  FFDA     NOP
1245C  FF78     NOP
1245E  F03A     NOP
12462  FF74     NOP
12464  F03B     NOP
726:                       if (width < 0) {
12466  AE3B     BTFSS 0x3B, 7, ACCESS
12468  D066     BRA 0x2536
727:                           flags |= MINUS_FLAG;
1246A  803E     BSF flags, 0, ACCESS
728:                           width = -width;
1246C  6C3A     NEGF width, ACCESS
1246E  1E3B     COMF 0x3B, F, ACCESS
12470  B0D8     BTFSC 0xFD8, 0, ACCESS
12472  2A3B     INCF 0x3B, F, ACCESS
12474  D060     BRA 0x2536
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
12476  0EDC     MOVLW 0xDC
1247A  FF8F     NOP
1247C  FFD9     NOP
1247E  0EDD     MOVLW 0xDD
12482  FF8F     NOP
12484  FFDA     NOP
12488  FF78     NOP
1248A  F00B     NOP
1248E  FF74     NOP
12490  F00C     NOP
12494  F02F     NOP
12496  FFE6     NOP
1249A  F033     NOP
1249C  FFE6     NOP
1249E  EC42     CALL 0x17684, 0
124A0  F0BB     NOP
124A4  F004     NOP
124A6  F03A     NOP
124AA  F008     NOP
124AC  F03B     NOP
732:                       while (isdigit((*fmt)[0])) {
124AE  D00B     BRA 0x24C6
124C6  0ED0     MOVLW 0xD0
124C8  6E0B     MOVWF wtemp5, ACCESS
124CA  0EFF     MOVLW 0xFF
124CC  6E0C     MOVWF 0xC, ACCESS
124CE  0EDC     MOVLW 0xDC
124D2  FF8F     NOP
124D4  FFD9     NOP
124D6  0EDD     MOVLW 0xDD
124DA  FF8F     NOP
124DC  FFDA     NOP
124E0  FF7B     NOP
124E2  FFF6     NOP
124E6  FF77     NOP
124E8  FFF7     NOP
124EA  0E00     MOVLW 0x0
124EC  6EF8     MOVWF 0xFF8, ACCESS
124EE  0008     TBLRD*
124F0  50F5     MOVF 0xFF5, W, ACCESS
124F2  6E09     MOVWF ltemp2, ACCESS
124F4  6A0A     CLRF ttemp3, ACCESS
124F6  500B     MOVF wtemp5, W, ACCESS
124F8  2609     ADDWF ltemp2, F, ACCESS
124FA  500C     MOVF 0xC, W, ACCESS
124FC  220A     ADDWFC ttemp3, F, ACCESS
124FE  500A     MOVF ttemp3, W, ACCESS
12500  E106     BNZ 0x250E
12502  0E0A     MOVLW 0xA
12504  5C09     SUBWF ltemp2, W, ACCESS
12506  B0D8     BTFSC 0xFD8, 0, ACCESS
12508  D002     BRA 0x250E
1250A  0E01     MOVLW 0x1
1250C  D001     BRA 0x2510
1250E  0E00     MOVLW 0x0
12510  6E0B     MOVWF wtemp5, ACCESS
12512  6A0C     CLRF 0xC, ACCESS
12514  0EE4     MOVLW 0xE4
12518  F02F     NOP
1251A  FFE3     NOP
1251C  0EE5     MOVLW 0xE5
12520  F033     NOP
12522  FFE3     NOP
12524  0EE4     MOVLW 0xE4
12528  FF8C     NOP
1252A  F001     NOP
1252C  0EE5     MOVLW 0xE5
1252E  50E3     MOVF 0xFE3, W, ACCESS
12530  1001     IORWF ltemp0, W, ACCESS
12532  A4D8     BTFSS 0xFD8, 2, ACCESS
12534  D7BD     BRA 0x24B0
733:                           ++*fmt;
124B0  0EDC     MOVLW 0xDC
124B4  FF8F     NOP
124B6  FFD9     NOP
124B8  0EDD     MOVLW 0xDD
124BC  FF8F     NOP
124BE  FFDA     NOP
124C0  2ADE     INCF 0xFDE, F, ACCESS
124C2  0E00     MOVLW 0x0
124C4  22DD     ADDWFC 0xFDD, F, ACCESS
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
12536  0EDC     MOVLW 0xDC
1253A  FF8F     NOP
1253C  FFD9     NOP
1253E  0EDD     MOVLW 0xDD
12542  FF8F     NOP
12544  FFDA     NOP
12548  FF7B     NOP
1254A  FFF6     NOP
1254E  FF77     NOP
12550  FFF7     NOP
12552  0E00     MOVLW 0x0
12554  6EF8     MOVWF 0xFF8, ACCESS
12556  0008     TBLRD*
12558  50F5     MOVF 0xFF5, W, ACCESS
1255A  0A2E     XORLW 0x2E
1255C  A4D8     BTFSS 0xFD8, 2, ACCESS
1255E  D0AC     BRA 0x26B8
741:                       prec = 0;
12560  6A3C     CLRF prec, ACCESS
12562  6A3D     CLRF 0x3D, ACCESS
742:                       ++*fmt;
12564  0EDC     MOVLW 0xDC
12568  FF8F     NOP
1256A  FFD9     NOP
1256C  0EDD     MOVLW 0xDD
12570  FF8F     NOP
12572  FFDA     NOP
12574  2ADE     INCF 0xFDE, F, ACCESS
12576  0E00     MOVLW 0x0
12578  22DD     ADDWFC 0xFDD, F, ACCESS
743:                       if ((*fmt)[0] == '*') {
1257A  0EDC     MOVLW 0xDC
1257E  FF8F     NOP
12580  FFD9     NOP
12582  0EDD     MOVLW 0xDD
12586  FF8F     NOP
12588  FFDA     NOP
1258C  FF7B     NOP
1258E  FFF6     NOP
12592  FF77     NOP
12594  FFF7     NOP
12596  0E00     MOVLW 0x0
12598  6EF8     MOVWF 0xFF8, ACCESS
1259A  0008     TBLRD*
1259C  50F5     MOVF 0xFF5, W, ACCESS
1259E  0A2A     XORLW 0x2A
125A0  A4D8     BTFSS 0xFD8, 2, ACCESS
125A2  D02A     BRA 0x25F8
744:                           ++*fmt;
125A4  0EDC     MOVLW 0xDC
125A8  FF8F     NOP
125AA  FFD9     NOP
125AC  0EDD     MOVLW 0xDD
125B0  FF8F     NOP
125B2  FFDA     NOP
125B4  2ADE     INCF 0xFDE, F, ACCESS
125B6  0E00     MOVLW 0x0
125B8  22DD     ADDWFC 0xFDD, F, ACCESS
745:                           prec = va_arg(ap, int);
125BA  0EDA     MOVLW 0xDA
125BE  FF8F     NOP
125C0  FFD9     NOP
125C2  0EDB     MOVLW 0xDB
125C6  FF8F     NOP
125C8  FFDA     NOP
125CA  0E02     MOVLW 0x2
125CC  5EDE     SUBWF 0xFDE, F, ACCESS
125CE  0E00     MOVLW 0x0
125D0  5ADD     SUBWFB 0xFDD, F, ACCESS
125D4  FF78     NOP
125D6  F00B     NOP
125DA  FF74     NOP
125DC  F00C     NOP
125E0  F02F     NOP
125E2  FFD9     NOP
125E6  F033     NOP
125E8  FFDA     NOP
125EC  FF78     NOP
125EE  F03C     NOP
125F2  FF74     NOP
125F4  F03D     NOP
746:                       } else {
125F6  D060     BRA 0x26B8
747:                           prec = atoi(*fmt);
125F8  0EDC     MOVLW 0xDC
125FC  FF8F     NOP
125FE  FFD9     NOP
12600  0EDD     MOVLW 0xDD
12604  FF8F     NOP
12606  FFDA     NOP
1260A  FF78     NOP
1260C  F00B     NOP
12610  FF74     NOP
12612  F00C     NOP
12616  F02F     NOP
12618  FFE6     NOP
1261C  F033     NOP
1261E  FFE6     NOP
12620  EC42     CALL 0x17684, 0
12622  F0BB     NOP
12626  F004     NOP
12628  F03C     NOP
1262C  F008     NOP
1262E  F03D     NOP
748:                           while (isdigit((*fmt)[0])) {
12630  D00B     BRA 0x2648
12648  0ED0     MOVLW 0xD0
1264A  6E0B     MOVWF wtemp5, ACCESS
1264C  0EFF     MOVLW 0xFF
1264E  6E0C     MOVWF 0xC, ACCESS
12650  0EDC     MOVLW 0xDC
12654  FF8F     NOP
12656  FFD9     NOP
12658  0EDD     MOVLW 0xDD
1265C  FF8F     NOP
1265E  FFDA     NOP
12662  FF7B     NOP
12664  FFF6     NOP
12668  FF77     NOP
1266A  FFF7     NOP
1266C  0E00     MOVLW 0x0
1266E  6EF8     MOVWF 0xFF8, ACCESS
12670  0008     TBLRD*
12672  50F5     MOVF 0xFF5, W, ACCESS
12674  6E09     MOVWF ltemp2, ACCESS
12676  6A0A     CLRF ttemp3, ACCESS
12678  500B     MOVF wtemp5, W, ACCESS
1267A  2609     ADDWF ltemp2, F, ACCESS
1267C  500C     MOVF 0xC, W, ACCESS
1267E  220A     ADDWFC ttemp3, F, ACCESS
12680  500A     MOVF ttemp3, W, ACCESS
12682  E106     BNZ 0x2690
12684  0E0A     MOVLW 0xA
12686  5C09     SUBWF ltemp2, W, ACCESS
12688  B0D8     BTFSC 0xFD8, 0, ACCESS
1268A  D002     BRA 0x2690
1268C  0E01     MOVLW 0x1
1268E  D001     BRA 0x2692
12690  0E00     MOVLW 0x0
12692  6E0B     MOVWF wtemp5, ACCESS
12694  6A0C     CLRF 0xC, ACCESS
12696  0EE0     MOVLW 0xE0
1269A  F02F     NOP
1269C  FFE3     NOP
1269E  0EE1     MOVLW 0xE1
126A2  F033     NOP
126A4  FFE3     NOP
126A6  0EE0     MOVLW 0xE0
126AA  FF8C     NOP
126AC  F001     NOP
126AE  0EE1     MOVLW 0xE1
126B0  50E3     MOVF 0xFE3, W, ACCESS
126B2  1001     IORWF ltemp0, W, ACCESS
126B4  A4D8     BTFSS 0xFD8, 2, ACCESS
126B6  D7BD     BRA 0x2632
749:                               ++*fmt;
12632  0EDC     MOVLW 0xDC
12636  FF8F     NOP
12638  FFD9     NOP
1263A  0EDD     MOVLW 0xDD
1263E  FF8F     NOP
12640  FFDA     NOP
12642  2ADE     INCF 0xFDE, F, ACCESS
12644  0E00     MOVLW 0x0
12646  22DD     ADDWFC 0xFDD, F, ACCESS
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
126B8  0EDC     MOVLW 0xDC
126BC  FF8F     NOP
126BE  FFD9     NOP
126C0  0EDD     MOVLW 0xDD
126C4  FF8F     NOP
126C6  FFDA     NOP
126CA  FF7B     NOP
126CC  FFF6     NOP
126D0  FF77     NOP
126D2  FFF7     NOP
126D4  0E00     MOVLW 0x0
126D6  6EF8     MOVWF 0xFF8, ACCESS
126D8  0008     TBLRD*
126DA  50F5     MOVF 0xFF5, W, ACCESS
126DC  6EE6     MOVWF 0xFE6, ACCESS
126DE  0E00     MOVLW 0x0
126E0  6EE6     MOVWF 0xFE6, ACCESS
126E2  ECDA     CALL 0x1A9B4, 0
126E4  F0D4     NOP
126E6  0EFA     MOVLW 0xFA
126EA  F007     NOP
126EC  FFE3     NOP
758:                   if (ct[0]) {
126EE  0EFA     MOVLW 0xFA
126F0  50E3     MOVF 0xFE3, W, ACCESS
126F2  B4D8     BTFSC 0xFD8, 2, ACCESS
126F4  D05B     BRA 0x27AC
759:                       ct[1] = tolower((int)(*fmt)[1]);
126F6  0EFB     MOVLW 0xFB
126F8  24E1     ADDWF 0xFE1, W, ACCESS
126FA  6ED9     MOVWF 0xFD9, ACCESS
126FC  0EFF     MOVLW 0xFF
126FE  20E2     ADDWFC 0xFE2, W, ACCESS
12700  6EDA     MOVWF 0xFDA, ACCESS
12702  0EDC     MOVLW 0xDC
12706  FF8F     NOP
12708  FFE9     NOP
1270A  0EDD     MOVLW 0xDD
1270E  FF8F     NOP
12710  FFEA     NOP
12714  FFB8     NOP
12716  F00B     NOP
1271A  FFB4     NOP
1271C  F00C     NOP
1271E  0E01     MOVLW 0x1
12720  260B     ADDWF wtemp5, F, ACCESS
12722  0E00     MOVLW 0x0
12724  220C     ADDWFC 0xC, F, ACCESS
12728  F02F     NOP
1272A  FFF6     NOP
1272E  F033     NOP
12730  FFF7     NOP
12732  0E00     MOVLW 0x0
12734  6EF8     MOVWF 0xFF8, ACCESS
12736  0008     TBLRD*
12738  50F5     MOVF 0xFF5, W, ACCESS
1273A  6EE6     MOVWF 0xFE6, ACCESS
1273C  0E00     MOVLW 0x0
1273E  6EE6     MOVWF 0xFE6, ACCESS
12740  ECDA     CALL 0x1A9B4, 0
12742  F0D4     NOP
12744  5001     MOVF ltemp0, W, ACCESS
12746  6EDF     MOVWF 0xFDF, ACCESS
760:                       if (ct[1]) {
12748  0EFB     MOVLW 0xFB
1274A  24E1     ADDWF 0xFE1, W, ACCESS
1274C  6ED9     MOVWF 0xFD9, ACCESS
1274E  0EFF     MOVLW 0xFF
12750  20E2     ADDWFC 0xFE2, W, ACCESS
12752  6EDA     MOVWF 0xFDA, ACCESS
12754  50DF     MOVF 0xFDF, W, ACCESS
12756  B4D8     BTFSC 0xFD8, 2, ACCESS
12758  D029     BRA 0x27AC
761:                           ct[2] = tolower((int)(*fmt)[2]);
1275A  0EFC     MOVLW 0xFC
1275C  24E1     ADDWF 0xFE1, W, ACCESS
1275E  6ED9     MOVWF 0xFD9, ACCESS
12760  0EFF     MOVLW 0xFF
12762  20E2     ADDWFC 0xFE2, W, ACCESS
12764  6EDA     MOVWF 0xFDA, ACCESS
12766  0EDC     MOVLW 0xDC
1276A  FF8F     NOP
1276C  FFE9     NOP
1276E  0EDD     MOVLW 0xDD
12772  FF8F     NOP
12774  FFEA     NOP
12778  FFB8     NOP
1277A  F00B     NOP
1277E  FFB4     NOP
12780  F00C     NOP
12782  0E02     MOVLW 0x2
12784  260B     ADDWF wtemp5, F, ACCESS
12786  0E00     MOVLW 0x0
12788  220C     ADDWFC 0xC, F, ACCESS
1278C  F02F     NOP
1278E  FFF6     NOP
12792  F033     NOP
12794  FFF7     NOP
12796  0E00     MOVLW 0x0
12798  6EF8     MOVWF 0xFF8, ACCESS
1279A  0008     TBLRD*
1279C  50F5     MOVF 0xFF5, W, ACCESS
1279E  6EE6     MOVWF 0xFE6, ACCESS
127A0  0E00     MOVLW 0x0
127A2  6EE6     MOVWF 0xFE6, ACCESS
127A4  ECDA     CALL 0x1A9B4, 0
127A6  F0D4     NOP
127A8  5001     MOVF ltemp0, W, ACCESS
127AA  6EDF     MOVWF 0xFDF, ACCESS
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
127AC  0EDC     MOVLW 0xDC
127B0  FF8F     NOP
127B2  FFD9     NOP
127B4  0EDD     MOVLW 0xDD
127B8  FF8F     NOP
127BA  FFDA     NOP
127BE  FF7B     NOP
127C0  FFF6     NOP
127C4  FF77     NOP
127C6  FFF7     NOP
127C8  0E00     MOVLW 0x0
127CA  6EF8     MOVWF 0xFF8, ACCESS
127CC  0008     TBLRD*
127CE  50F5     MOVF 0xFF5, W, ACCESS
127D0  0A63     XORLW 0x63
127D2  A4D8     BTFSS 0xFD8, 2, ACCESS
127D4  D037     BRA 0x2844
793:                       ++*fmt;
127D6  0EDC     MOVLW 0xDC
127DA  FF8F     NOP
127DC  FFD9     NOP
127DE  0EDD     MOVLW 0xDD
127E2  FF8F     NOP
127E4  FFDA     NOP
127E6  2ADE     INCF 0xFDE, F, ACCESS
127E8  0E00     MOVLW 0x0
127EA  22DD     ADDWFC 0xFDD, F, ACCESS
794:                       c = (unsigned char)va_arg(ap, int);
127EC  0EDA     MOVLW 0xDA
127F0  FF8F     NOP
127F2  FFD9     NOP
127F4  0EDB     MOVLW 0xDB
127F8  FF8F     NOP
127FA  FFDA     NOP
127FC  0E02     MOVLW 0x2
127FE  5EDE     SUBWF 0xFDE, F, ACCESS
12800  0E00     MOVLW 0x0
12802  5ADD     SUBWFB 0xFDD, F, ACCESS
12806  FF78     NOP
12808  F00B     NOP
1280C  FF74     NOP
1280E  F00C     NOP
12812  F02F     NOP
12814  FFD9     NOP
12818  F033     NOP
1281A  FFDA     NOP
1281C  50DF     MOVF 0xFDF, W, ACCESS
1281E  6E0C     MOVWF 0xC, ACCESS
12820  0EFF     MOVLW 0xFF
12824  F033     NOP
12826  FFE3     NOP
795:                       return ctoa(fp, c);
12828  0EFF     MOVLW 0xFF
1282A  50E3     MOVF 0xFE3, W, ACCESS
1282C  6EE6     MOVWF 0xFE6, ACCESS
1282E  0EDD     MOVLW 0xDD
12832  FF8F     NOP
12834  FFE6     NOP
12838  FF8F     NOP
1283A  FFE6     NOP
1283C  EC54     CALL 0x1A8A8, 0
1283E  F0D4     NOP
12840  EF9B     GOTO 0x13336
12842  F099     NOP
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
12844  0EDC     MOVLW 0xDC
12848  FF8F     NOP
1284A  FFD9     NOP
1284C  0EDD     MOVLW 0xDD
12850  FF8F     NOP
12852  FFDA     NOP
12856  FF7B     NOP
12858  FFF6     NOP
1285C  FF77     NOP
1285E  FFF7     NOP
12860  0E00     MOVLW 0x0
12862  6EF8     MOVWF 0xFF8, ACCESS
12864  0008     TBLRD*
12866  50F5     MOVF 0xFF5, W, ACCESS
12868  0A64     XORLW 0x64
1286A  B4D8     BTFSC 0xFD8, 2, ACCESS
1286C  D015     BRA 0x2898
1286E  0EDC     MOVLW 0xDC
12872  FF8F     NOP
12874  FFD9     NOP
12876  0EDD     MOVLW 0xDD
1287A  FF8F     NOP
1287C  FFDA     NOP
12880  FF7B     NOP
12882  FFF6     NOP
12886  FF77     NOP
12888  FFF7     NOP
1288A  0E00     MOVLW 0x0
1288C  6EF8     MOVWF 0xFF8, ACCESS
1288E  0008     TBLRD*
12890  50F5     MOVF 0xFF5, W, ACCESS
12892  0A69     XORLW 0x69
12894  A4D8     BTFSS 0xFD8, 2, ACCESS
12896  D076     BRA 0x2984
826:           
827:                       ++*fmt;
12898  0EDC     MOVLW 0xDC
1289C  FF8F     NOP
1289E  FFD9     NOP
128A0  0EDD     MOVLW 0xDD
128A4  FF8F     NOP
128A6  FFDA     NOP
128A8  2ADE     INCF 0xFDE, F, ACCESS
128AA  0E00     MOVLW 0x0
128AC  22DD     ADDWFC 0xFDD, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
128AE  0EDA     MOVLW 0xDA
128B2  FF8F     NOP
128B4  FFD9     NOP
128B6  0EDB     MOVLW 0xDB
128BA  FF8F     NOP
128BC  FFDA     NOP
128BE  0E02     MOVLW 0x2
128C0  5EDE     SUBWF 0xFDE, F, ACCESS
128C2  0E00     MOVLW 0x0
128C4  5ADD     SUBWFB 0xFDD, F, ACCESS
128C8  FF78     NOP
128CA  F00B     NOP
128CE  FF74     NOP
128D0  F00C     NOP
128D4  F02F     NOP
128D6  FFD9     NOP
128DA  F033     NOP
128DC  FFDA     NOP
128E0  FF78     NOP
128E2  F00B     NOP
128E6  FF74     NOP
128E8  F00C     NOP
128EA  0EEE     MOVLW 0xEE
128EE  F02F     NOP
128F0  FFE3     NOP
128F2  0EEF     MOVLW 0xEF
128F6  F033     NOP
128F8  FFE3     NOP
128FA  6A01     CLRF ltemp0, ACCESS
128FC  BEE3     BTFSC 0xFE3, 7, ACCESS
128FE  6801     SETF ltemp0, ACCESS
12900  0EF0     MOVLW 0xF0
12904  F007     NOP
12906  FFE3     NOP
12908  0EF1     MOVLW 0xF1
1290C  F007     NOP
1290E  FFE3     NOP
12910  0EF2     MOVLW 0xF2
12914  F007     NOP
12916  FFE3     NOP
12918  0EF3     MOVLW 0xF3
1291C  F007     NOP
1291E  FFE3     NOP
12920  0EF4     MOVLW 0xF4
12924  F007     NOP
12926  FFE3     NOP
12928  0EF5     MOVLW 0xF5
1292C  F007     NOP
1292E  FFE3     NOP
829:                                   
830:                       return dtoa(fp, ll);
12930  50E1     MOVF 0xFE1, W, ACCESS
12932  0FEE     ADDLW 0xEE
12934  6ED9     MOVWF 0xFD9, ACCESS
12936  50E2     MOVF 0xFE2, W, ACCESS
12938  6EDA     MOVWF 0xFDA, ACCESS
1293A  0EFF     MOVLW 0xFF
1293C  22DA     ADDWFC 0xFDA, F, ACCESS
12940  FF7B     NOP
12942  FFE6     NOP
12946  FF7B     NOP
12948  FFE6     NOP
1294C  FF7B     NOP
1294E  FFE6     NOP
12952  FF7B     NOP
12954  FFE6     NOP
12958  FF7B     NOP
1295A  FFE6     NOP
1295E  FF7B     NOP
12960  FFE6     NOP
12964  FF7B     NOP
12966  FFE6     NOP
1296A  FF7B     NOP
1296C  FFE6     NOP
1296E  0ED6     MOVLW 0xD6
12972  FF8F     NOP
12974  FFE6     NOP
12978  FF8F     NOP
1297A  FFE6     NOP
1297C  EC98     CALL 0x15530, 0
1297E  F0AA     NOP
12980  EF9B     GOTO 0x13336
12982  F099     NOP
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
12984  0E02     MOVLW 0x2
12986  6EE6     MOVWF 0xFE6, ACCESS
12988  0E00     MOVLW 0x0
1298A  6EE6     MOVWF 0xFE6, ACCESS
1298C  0EE9     MOVLW 0xE9
1298E  6EE6     MOVWF 0xFE6, ACCESS
12990  0EFF     MOVLW 0xFF
12992  6EE6     MOVWF 0xFE6, ACCESS
12994  0ED8     MOVLW 0xD8
12998  FF8F     NOP
1299A  FFD9     NOP
1299C  0ED9     MOVLW 0xD9
129A0  FF8F     NOP
129A2  FFDA     NOP
129A6  FF78     NOP
129A8  F00B     NOP
129AC  FF74     NOP
129AE  F00C     NOP
129B2  F02F     NOP
129B4  FFE6     NOP
129B8  F033     NOP
129BA  FFE6     NOP
129BC  ECB1     CALL 0x17D62, 0
129BE  F0BE     NOP
129C0  5001     MOVF ltemp0, W, ACCESS
129C2  1002     IORWF ttemp5, W, ACCESS
129C4  B4D8     BTFSC 0xFD8, 2, ACCESS
129C6  D022     BRA 0x2A0C
129C8  0E02     MOVLW 0x2
129CA  6EE6     MOVWF 0xFE6, ACCESS
129CC  0E00     MOVLW 0x0
129CE  6EE6     MOVWF 0xFE6, ACCESS
129D0  0EEF     MOVLW 0xEF
129D2  6EE6     MOVWF 0xFE6, ACCESS
129D4  0EFF     MOVLW 0xFF
129D6  6EE6     MOVWF 0xFE6, ACCESS
129D8  0ED8     MOVLW 0xD8
129DC  FF8F     NOP
129DE  FFD9     NOP
129E0  0ED9     MOVLW 0xD9
129E4  FF8F     NOP
129E6  FFDA     NOP
129EA  FF78     NOP
129EC  F00B     NOP
129F0  FF74     NOP
129F2  F00C     NOP
129F6  F02F     NOP
129F8  FFE6     NOP
129FC  F033     NOP
129FE  FFE6     NOP
12A00  ECB1     CALL 0x17D62, 0
12A02  F0BE     NOP
12A04  5001     MOVF ltemp0, W, ACCESS
12A06  1002     IORWF ttemp5, W, ACCESS
12A08  A4D8     BTFSS 0xFD8, 2, ACCESS
12A0A  D069     BRA 0x2ADE
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
12A0C  0EDC     MOVLW 0xDC
12A10  FF8F     NOP
12A12  FFD9     NOP
12A14  0EDD     MOVLW 0xDD
12A18  FF8F     NOP
12A1A  FFDA     NOP
12A1C  0E02     MOVLW 0x2
12A1E  26DE     ADDWF 0xFDE, F, ACCESS
12A20  0E00     MOVLW 0x0
12A22  22DD     ADDWFC 0xFDD, F, ACCESS
839:                       ll = (long long)va_arg(ap, long);
12A24  0EDA     MOVLW 0xDA
12A28  FF8F     NOP
12A2A  FFD9     NOP
12A2C  0EDB     MOVLW 0xDB
12A30  FF8F     NOP
12A32  FFDA     NOP
12A34  0E04     MOVLW 0x4
12A36  5EDE     SUBWF 0xFDE, F, ACCESS
12A38  0E00     MOVLW 0x0
12A3A  5ADD     SUBWFB 0xFDD, F, ACCESS
12A3E  FF78     NOP
12A40  F00B     NOP
12A44  FF74     NOP
12A46  F00C     NOP
12A4A  F02F     NOP
12A4C  FFD9     NOP
12A50  F033     NOP
12A52  FFDA     NOP
12A56  FF78     NOP
12A58  F009     NOP
12A5C  FF78     NOP
12A5E  F00A     NOP
12A62  FF78     NOP
12A64  F00B     NOP
12A68  FF78     NOP
12A6A  F00C     NOP
12A6E  F024     NOP
12A70  F011     NOP
12A74  F028     NOP
12A76  F012     NOP
12A7A  F02C     NOP
12A7C  F013     NOP
12A80  F030     NOP
12A82  F014     NOP
12A84  6A15     CLRF 0x15, ACCESS
12A86  BE14     BTFSC 0x14, 7, ACCESS
12A88  6815     SETF 0x15, ACCESS
12A8C  F054     NOP
12A8E  F016     NOP
12A92  F054     NOP
12A94  F017     NOP
12A98  F054     NOP
12A9A  F018     NOP
12A9C  0EEE     MOVLW 0xEE
12AA0  F047     NOP
12AA2  FFE3     NOP
12AA4  0EEF     MOVLW 0xEF
12AA8  F04B     NOP
12AAA  FFE3     NOP
12AAC  0EF0     MOVLW 0xF0
12AB0  F04F     NOP
12AB2  FFE3     NOP
12AB4  0EF1     MOVLW 0xF1
12AB8  F053     NOP
12ABA  FFE3     NOP
12ABC  0EF2     MOVLW 0xF2
12AC0  F057     NOP
12AC2  FFE3     NOP
12AC4  0EF3     MOVLW 0xF3
12AC8  F05B     NOP
12ACA  FFE3     NOP
12ACC  0EF4     MOVLW 0xF4
12AD0  F05F     NOP
12AD2  FFE3     NOP
12AD4  0EF5     MOVLW 0xF5
12AD8  F063     NOP
12ADA  FFE3     NOP
12ADC  D729     BRA 0x2930
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
12ADE  0EFA     MOVLW 0xFA
12AE2  FF8C     NOP
12AE4  F001     NOP
12AE6  0E66     MOVLW 0x66
12AE8  1801     XORWF ltemp0, W, ACCESS
12AEA  A4D8     BTFSS 0xFD8, 2, ACCESS
12AEC  D06E     BRA 0x2BCA
921:           
922:                       c = (*fmt)[0];
12AEE  0EDC     MOVLW 0xDC
12AF2  FF8F     NOP
12AF4  FFD9     NOP
12AF6  0EDD     MOVLW 0xDD
12AFA  FF8F     NOP
12AFC  FFDA     NOP
12B00  FF7B     NOP
12B02  FFF6     NOP
12B06  FF77     NOP
12B08  FFF7     NOP
12B0A  0E00     MOVLW 0x0
12B0C  6EF8     MOVWF 0xFF8, ACCESS
12B0E  0008     TBLRD*
12B10  0EFF     MOVLW 0xFF
12B14  FFD7     NOP
12B16  FFE3     NOP
923:                       ++*fmt;
12B18  0EDC     MOVLW 0xDC
12B1C  FF8F     NOP
12B1E  FFD9     NOP
12B20  0EDD     MOVLW 0xDD
12B24  FF8F     NOP
12B26  FFDA     NOP
12B28  2ADE     INCF 0xFDE, F, ACCESS
12B2A  0E00     MOVLW 0x0
12B2C  22DD     ADDWFC 0xFDD, F, ACCESS
924:                       f = (long double)va_arg(ap, double);
12B2E  0EDA     MOVLW 0xDA
12B32  FF8F     NOP
12B34  FFD9     NOP
12B36  0EDB     MOVLW 0xDB
12B3A  FF8F     NOP
12B3C  FFDA     NOP
12B3E  0E04     MOVLW 0x4
12B40  5EDE     SUBWF 0xFDE, F, ACCESS
12B42  0E00     MOVLW 0x0
12B44  5ADD     SUBWFB 0xFDD, F, ACCESS
12B48  FF78     NOP
12B4A  F00B     NOP
12B4E  FF74     NOP
12B50  F00C     NOP
12B54  F02F     NOP
12B56  FFD9     NOP
12B5A  F033     NOP
12B5C  FFDA     NOP
12B60  FF78     NOP
12B62  F009     NOP
12B66  FF78     NOP
12B68  F00A     NOP
12B6C  FF78     NOP
12B6E  F00B     NOP
12B72  FF78     NOP
12B74  F00C     NOP
12B76  0EF6     MOVLW 0xF6
12B7A  F027     NOP
12B7C  FFE3     NOP
12B7E  0EF7     MOVLW 0xF7
12B82  F02B     NOP
12B84  FFE3     NOP
12B86  0EF8     MOVLW 0xF8
12B8A  F02F     NOP
12B8C  FFE3     NOP
12B8E  0EF9     MOVLW 0xF9
12B92  F033     NOP
12B94  FFE3     NOP
925:                                   
926:                       return efgtoa(fp, f, c);
12B96  0EFF     MOVLW 0xFF
12B98  50E3     MOVF 0xFE3, W, ACCESS
12B9A  6EE6     MOVWF 0xFE6, ACCESS
12B9C  0EF5     MOVLW 0xF5
12BA0  FF8F     NOP
12BA2  FFE6     NOP
12BA6  FF8F     NOP
12BA8  FFE6     NOP
12BAC  FF8F     NOP
12BAE  FFE6     NOP
12BB2  FF8F     NOP
12BB4  FFE6     NOP
12BB6  0ED9     MOVLW 0xD9
12BBA  FF8F     NOP
12BBC  FFE6     NOP
12BC0  FF8F     NOP
12BC2  FFE6     NOP
12BC4  EC00     CALL 0x10000, 0
12BC6  F080     NOP
12BC8  D3B6     BRA 0x3336
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
12BCA  0E02     MOVLW 0x2
12BCC  6EE6     MOVWF 0xFE6, ACCESS
12BCE  0E00     MOVLW 0x0
12BD0  6EE6     MOVWF 0xFE6, ACCESS
12BD2  0EEC     MOVLW 0xEC
12BD4  6EE6     MOVWF 0xFE6, ACCESS
12BD6  0EFF     MOVLW 0xFF
12BD8  6EE6     MOVWF 0xFE6, ACCESS
12BDA  0EF6     MOVLW 0xF6
12BDC  24E1     ADDWF 0xFE1, W, ACCESS
12BDE  6E01     MOVWF ltemp0, ACCESS
12BE0  0EFF     MOVLW 0xFF
12BE2  20E2     ADDWFC 0xFE2, W, ACCESS
12BE4  6E02     MOVWF ttemp5, ACCESS
12BE8  F007     NOP
12BEA  FFE6     NOP
12BEE  F00B     NOP
12BF0  FFE6     NOP
12BF2  ECB1     CALL 0x17D62, 0
12BF4  F0BE     NOP
12BF6  5001     MOVF ltemp0, W, ACCESS
12BF8  1002     IORWF ttemp5, W, ACCESS
12BFA  A4D8     BTFSS 0xFD8, 2, ACCESS
12BFC  D096     BRA 0x2D2A
929:           
930:                       c = (*fmt)[1];
12BFE  0EDC     MOVLW 0xDC
12C02  FF8F     NOP
12C04  FFD9     NOP
12C06  0EDD     MOVLW 0xDD
12C0A  FF8F     NOP
12C0C  FFDA     NOP
12C10  FF78     NOP
12C12  F00B     NOP
12C16  FF74     NOP
12C18  F00C     NOP
12C1A  0E01     MOVLW 0x1
12C1C  260B     ADDWF wtemp5, F, ACCESS
12C1E  0E00     MOVLW 0x0
12C20  220C     ADDWFC 0xC, F, ACCESS
12C24  F02F     NOP
12C26  FFF6     NOP
12C2A  F033     NOP
12C2C  FFF7     NOP
12C2E  0E00     MOVLW 0x0
12C30  6EF8     MOVWF 0xFF8, ACCESS
12C32  0008     TBLRD*
12C34  0EFF     MOVLW 0xFF
12C38  FFD7     NOP
12C3A  FFE3     NOP
931:                       if (isupper((int)(*fmt)[0])) {
12C3C  0EBF     MOVLW 0xBF
12C3E  6E0B     MOVWF wtemp5, ACCESS
12C40  0EFF     MOVLW 0xFF
12C42  6E0C     MOVWF 0xC, ACCESS
12C44  0EDC     MOVLW 0xDC
12C48  FF8F     NOP
12C4A  FFD9     NOP
12C4C  0EDD     MOVLW 0xDD
12C50  FF8F     NOP
12C52  FFDA     NOP
12C56  FF7B     NOP
12C58  FFF6     NOP
12C5C  FF77     NOP
12C5E  FFF7     NOP
12C60  0E00     MOVLW 0x0
12C62  6EF8     MOVWF 0xFF8, ACCESS
12C64  0008     TBLRD*
12C66  50F5     MOVF 0xFF5, W, ACCESS
12C68  6E09     MOVWF ltemp2, ACCESS
12C6A  6A0A     CLRF ttemp3, ACCESS
12C6C  500B     MOVF wtemp5, W, ACCESS
12C6E  2609     ADDWF ltemp2, F, ACCESS
12C70  500C     MOVF 0xC, W, ACCESS
12C72  220A     ADDWFC ttemp3, F, ACCESS
12C74  500A     MOVF ttemp3, W, ACCESS
12C76  E106     BNZ 0x2C84
12C78  0E1A     MOVLW 0x1A
12C7A  5C09     SUBWF ltemp2, W, ACCESS
12C7C  B0D8     BTFSC 0xFD8, 0, ACCESS
12C7E  D002     BRA 0x2C84
12C80  0E01     MOVLW 0x1
12C82  D001     BRA 0x2C86
12C84  0E00     MOVLW 0x0
12C86  6E0B     MOVWF wtemp5, ACCESS
12C88  6A0C     CLRF 0xC, ACCESS
12C8A  0EE2     MOVLW 0xE2
12C8E  F02F     NOP
12C90  FFE3     NOP
12C92  0EE3     MOVLW 0xE3
12C96  F033     NOP
12C98  FFE3     NOP
12C9A  0EE2     MOVLW 0xE2
12C9E  FF8C     NOP
12CA0  F001     NOP
12CA2  0EE3     MOVLW 0xE3
12CA4  50E3     MOVF 0xFE3, W, ACCESS
12CA6  1001     IORWF ltemp0, W, ACCESS
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
12CA8  0EDA     MOVLW 0xDA
12CAC  FF8F     NOP
12CAE  FFD9     NOP
12CB0  0EDB     MOVLW 0xDB
12CB4  FF8F     NOP
12CB6  FFDA     NOP
12CB8  0E04     MOVLW 0x4
12CBA  5EDE     SUBWF 0xFDE, F, ACCESS
12CBC  0E00     MOVLW 0x0
12CBE  5ADD     SUBWFB 0xFDD, F, ACCESS
12CC2  FF78     NOP
12CC4  F00B     NOP
12CC8  FF74     NOP
12CCA  F00C     NOP
12CCE  F02F     NOP
12CD0  FFD9     NOP
12CD4  F033     NOP
12CD6  FFDA     NOP
12CDA  FF78     NOP
12CDC  F009     NOP
12CE0  FF78     NOP
12CE2  F00A     NOP
12CE6  FF78     NOP
12CE8  F00B     NOP
12CEC  FF78     NOP
12CEE  F00C     NOP
12CF0  0EF6     MOVLW 0xF6
12CF4  F027     NOP
12CF6  FFE3     NOP
12CF8  0EF7     MOVLW 0xF7
12CFC  F02B     NOP
12CFE  FFE3     NOP
12D00  0EF8     MOVLW 0xF8
12D04  F02F     NOP
12D06  FFE3     NOP
12D08  0EF9     MOVLW 0xF9
12D0C  F033     NOP
12D0E  FFE3     NOP
935:                       }
936:                       *fmt += CSTRLEN("lf");
12D10  0EDC     MOVLW 0xDC
12D14  FF8F     NOP
12D16  FFD9     NOP
12D18  0EDD     MOVLW 0xDD
12D1C  FF8F     NOP
12D1E  FFDA     NOP
12D20  0E02     MOVLW 0x2
12D22  26DE     ADDWF 0xFDE, F, ACCESS
12D24  0E00     MOVLW 0x0
12D26  22DD     ADDWFC 0xFDD, F, ACCESS
12D28  D736     BRA 0x2B96
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
12D2A  0EDC     MOVLW 0xDC
12D2E  FF8F     NOP
12D30  FFD9     NOP
12D32  0EDD     MOVLW 0xDD
12D36  FF8F     NOP
12D38  FFDA     NOP
12D3C  FF7B     NOP
12D3E  FFF6     NOP
12D42  FF77     NOP
12D44  FFF7     NOP
12D46  0E00     MOVLW 0x0
12D48  6EF8     MOVWF 0xFF8, ACCESS
12D4A  0008     TBLRD*
12D4C  50F5     MOVF 0xFF5, W, ACCESS
12D4E  0A73     XORLW 0x73
12D50  A4D8     BTFSS 0xFD8, 2, ACCESS
12D52  D042     BRA 0x2DD8
1150:          
1151:                      ++*fmt;
12D54  0EDC     MOVLW 0xDC
12D58  FF8F     NOP
12D5A  FFD9     NOP
12D5C  0EDD     MOVLW 0xDD
12D60  FF8F     NOP
12D62  FFDA     NOP
12D64  2ADE     INCF 0xFDE, F, ACCESS
12D66  0E00     MOVLW 0x0
12D68  22DD     ADDWFC 0xFDD, F, ACCESS
1152:                      cp = va_arg(ap, char *);
12D6A  0EDA     MOVLW 0xDA
12D6E  FF8F     NOP
12D70  FFD9     NOP
12D72  0EDB     MOVLW 0xDB
12D76  FF8F     NOP
12D78  FFDA     NOP
12D7A  0E02     MOVLW 0x2
12D7C  5EDE     SUBWF 0xFDE, F, ACCESS
12D7E  0E00     MOVLW 0x0
12D80  5ADD     SUBWFB 0xFDD, F, ACCESS
12D84  FF78     NOP
12D86  F00B     NOP
12D8A  FF74     NOP
12D8C  F00C     NOP
12D90  F02F     NOP
12D92  FFD9     NOP
12D96  F033     NOP
12D98  FFDA     NOP
12D9C  FF78     NOP
12D9E  F00B     NOP
12DA2  FF74     NOP
12DA4  F00C     NOP
12DA6  0EFE     MOVLW 0xFE
12DAA  F033     NOP
12DAC  FFE3     NOP
12DAE  0EFD     MOVLW 0xFD
12DB2  F02F     NOP
12DB4  FFE3     NOP
1153:          
1154:                      return stoa(fp, cp);
12DB6  0EFD     MOVLW 0xFD
12DBA  FF8F     NOP
12DBC  FFE6     NOP
12DC0  FF8F     NOP
12DC2  FFE6     NOP
12DC4  0EDC     MOVLW 0xDC
12DC8  FF8F     NOP
12DCA  FFE6     NOP
12DCE  FF8F     NOP
12DD0  FFE6     NOP
12DD2  ECA3     CALL 0x17146, 0
12DD4  F0B8     NOP
12DD6  D2AF     BRA 0x3336
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
12DD8  0EDC     MOVLW 0xDC
12DDC  FF8F     NOP
12DDE  FFD9     NOP
12DE0  0EDD     MOVLW 0xDD
12DE4  FF8F     NOP
12DE6  FFDA     NOP
12DEA  FF7B     NOP
12DEC  FFF6     NOP
12DF0  FF77     NOP
12DF2  FFF7     NOP
12DF4  0E00     MOVLW 0x0
12DF6  6EF8     MOVWF 0xFF8, ACCESS
12DF8  0008     TBLRD*
12DFA  50F5     MOVF 0xFF5, W, ACCESS
12DFC  0A75     XORLW 0x75
12DFE  A4D8     BTFSS 0xFD8, 2, ACCESS
12E00  D07C     BRA 0x2EFA
1183:          
1184:                      ++*fmt;
12E02  0EDC     MOVLW 0xDC
12E06  FF8F     NOP
12E08  FFD9     NOP
12E0A  0EDD     MOVLW 0xDD
12E0E  FF8F     NOP
12E10  FFDA     NOP
12E12  2ADE     INCF 0xFDE, F, ACCESS
12E14  0E00     MOVLW 0x0
12E16  22DD     ADDWFC 0xFDD, F, ACCESS
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
12E18  0EDA     MOVLW 0xDA
12E1C  FF8F     NOP
12E1E  FFD9     NOP
12E20  0EDB     MOVLW 0xDB
12E24  FF8F     NOP
12E26  FFDA     NOP
12E28  0E02     MOVLW 0x2
12E2A  5EDE     SUBWF 0xFDE, F, ACCESS
12E2C  0E00     MOVLW 0x0
12E2E  5ADD     SUBWFB 0xFDD, F, ACCESS
12E32  FF78     NOP
12E34  F00B     NOP
12E38  FF74     NOP
12E3A  F00C     NOP
12E3E  F02F     NOP
12E40  FFD9     NOP
12E44  F033     NOP
12E46  FFDA     NOP
12E4A  FF78     NOP
12E4C  F00B     NOP
12E50  FF74     NOP
12E52  F00C     NOP
12E54  500B     MOVF wtemp5, W, ACCESS
12E56  6E11     MOVWF lltemp2, ACCESS
12E58  500C     MOVF 0xC, W, ACCESS
12E5A  6E12     MOVWF 0x12, ACCESS
12E5C  6A13     CLRF 0x13, ACCESS
12E5E  6A14     CLRF 0x14, ACCESS
12E60  6A15     CLRF 0x15, ACCESS
12E62  6A16     CLRF 0x16, ACCESS
12E64  6A17     CLRF 0x17, ACCESS
12E66  6A18     CLRF 0x18, ACCESS
12E68  0EE6     MOVLW 0xE6
12E6C  F047     NOP
12E6E  FFE3     NOP
12E70  0EE7     MOVLW 0xE7
12E74  F04B     NOP
12E76  FFE3     NOP
12E78  0EE8     MOVLW 0xE8
12E7C  F04F     NOP
12E7E  FFE3     NOP
12E80  0EE9     MOVLW 0xE9
12E84  F053     NOP
12E86  FFE3     NOP
12E88  0EEA     MOVLW 0xEA
12E8C  F057     NOP
12E8E  FFE3     NOP
12E90  0EEB     MOVLW 0xEB
12E94  F05B     NOP
12E96  FFE3     NOP
12E98  0EEC     MOVLW 0xEC
12E9C  F05F     NOP
12E9E  FFE3     NOP
12EA0  0EED     MOVLW 0xED
12EA4  F063     NOP
12EA6  FFE3     NOP
1186:                                  
1187:                      return utoa(fp, llu);
12EA8  50E1     MOVF 0xFE1, W, ACCESS
12EAA  0FE6     ADDLW 0xE6
12EAC  6ED9     MOVWF 0xFD9, ACCESS
12EAE  50E2     MOVF 0xFE2, W, ACCESS
12EB0  6EDA     MOVWF 0xFDA, ACCESS
12EB2  0EFF     MOVLW 0xFF
12EB4  22DA     ADDWFC 0xFDA, F, ACCESS
12EB8  FF7B     NOP
12EBA  FFE6     NOP
12EBE  FF7B     NOP
12EC0  FFE6     NOP
12EC4  FF7B     NOP
12EC6  FFE6     NOP
12ECA  FF7B     NOP
12ECC  FFE6     NOP
12ED0  FF7B     NOP
12ED2  FFE6     NOP
12ED6  FF7B     NOP
12ED8  FFE6     NOP
12EDC  FF7B     NOP
12EDE  FFE6     NOP
12EE2  FF7B     NOP
12EE4  FFE6     NOP
12EE6  0ED6     MOVLW 0xD6
12EEA  FF8F     NOP
12EEC  FFE6     NOP
12EF0  FF8F     NOP
12EF2  FFE6     NOP
12EF4  EC91     CALL 0x16522, 0
12EF6  F0B2     NOP
12EF8  D21E     BRA 0x3336
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
12EFA  0E02     MOVLW 0x2
12EFC  6EE6     MOVWF 0xFE6, ACCESS
12EFE  0E00     MOVLW 0x0
12F00  6EE6     MOVWF 0xFE6, ACCESS
12F02  0EF2     MOVLW 0xF2
12F04  6EE6     MOVWF 0xFE6, ACCESS
12F06  0EFF     MOVLW 0xFF
12F08  6EE6     MOVWF 0xFE6, ACCESS
12F0A  0ED8     MOVLW 0xD8
12F0E  FF8F     NOP
12F10  FFD9     NOP
12F12  0ED9     MOVLW 0xD9
12F16  FF8F     NOP
12F18  FFDA     NOP
12F1C  FF78     NOP
12F1E  F00B     NOP
12F22  FF74     NOP
12F24  F00C     NOP
12F28  F02F     NOP
12F2A  FFE6     NOP
12F2E  F033     NOP
12F30  FFE6     NOP
12F32  ECB1     CALL 0x17D62, 0
12F34  F0BE     NOP
12F36  5001     MOVF ltemp0, W, ACCESS
12F38  1002     IORWF ttemp5, W, ACCESS
12F3A  A4D8     BTFSS 0xFD8, 2, ACCESS
12F3C  D039     BRA 0x2FB0
1193:          
1194:                      *fmt += CSTRLEN("lu");
12F3E  0EDC     MOVLW 0xDC
12F42  FF8F     NOP
12F44  FFD9     NOP
12F46  0EDD     MOVLW 0xDD
12F4A  FF8F     NOP
12F4C  FFDA     NOP
12F4E  0E02     MOVLW 0x2
12F50  26DE     ADDWF 0xFDE, F, ACCESS
12F52  0E00     MOVLW 0x0
12F54  22DD     ADDWFC 0xFDD, F, ACCESS
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
12F56  0EDA     MOVLW 0xDA
12F5A  FF8F     NOP
12F5C  FFD9     NOP
12F5E  0EDB     MOVLW 0xDB
12F62  FF8F     NOP
12F64  FFDA     NOP
12F66  0E04     MOVLW 0x4
12F68  5EDE     SUBWF 0xFDE, F, ACCESS
12F6A  0E00     MOVLW 0x0
12F6C  5ADD     SUBWFB 0xFDD, F, ACCESS
12F70  FF78     NOP
12F72  F00B     NOP
12F76  FF74     NOP
12F78  F00C     NOP
12F7C  F02F     NOP
12F7E  FFD9     NOP
12F82  F033     NOP
12F84  FFDA     NOP
12F88  FF78     NOP
12F8A  F009     NOP
12F8E  FF78     NOP
12F90  F00A     NOP
12F94  FF78     NOP
12F96  F00B     NOP
12F9A  FF78     NOP
12F9C  F00C     NOP
12F9E  5009     MOVF ltemp2, W, ACCESS
12FA0  6E11     MOVWF lltemp2, ACCESS
12FA2  500A     MOVF ttemp3, W, ACCESS
12FA4  6E12     MOVWF 0x12, ACCESS
12FA6  500B     MOVF wtemp5, W, ACCESS
12FA8  6E13     MOVWF 0x13, ACCESS
12FAA  500C     MOVF 0xC, W, ACCESS
12FAC  6E14     MOVWF 0x14, ACCESS
12FAE  D758     BRA 0x2E60
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
12FB0  0EDC     MOVLW 0xDC
12FB4  FF8F     NOP
12FB6  FFD9     NOP
12FB8  0EDD     MOVLW 0xDD
12FBC  FF8F     NOP
12FBE  FFDA     NOP
12FC2  FF7B     NOP
12FC4  FFF6     NOP
12FC8  FF77     NOP
12FCA  FFF7     NOP
12FCC  0E00     MOVLW 0x0
12FCE  6EF8     MOVWF 0xFF8, ACCESS
12FD0  0008     TBLRD*
12FD2  50F5     MOVF 0xFF5, W, ACCESS
12FD4  0A78     XORLW 0x78
12FD6  B4D8     BTFSC 0xFD8, 2, ACCESS
12FD8  D015     BRA 0x3004
12FDA  0EDC     MOVLW 0xDC
12FDE  FF8F     NOP
12FE0  FFD9     NOP
12FE2  0EDD     MOVLW 0xDD
12FE6  FF8F     NOP
12FE8  FFDA     NOP
12FEC  FF7B     NOP
12FEE  FFF6     NOP
12FF2  FF77     NOP
12FF4  FFF7     NOP
12FF6  0E00     MOVLW 0x0
12FF8  6EF8     MOVWF 0xFF8, ACCESS
12FFA  0008     TBLRD*
12FFC  50F5     MOVF 0xFF5, W, ACCESS
12FFE  0A58     XORLW 0x58
13000  A4D8     BTFSS 0xFD8, 2, ACCESS
13002  D094     BRA 0x312C
1275:          
1276:                      c = (*fmt)[0];
13004  0EDC     MOVLW 0xDC
13008  FF8F     NOP
1300A  FFD9     NOP
1300C  0EDD     MOVLW 0xDD
13010  FF8F     NOP
13012  FFDA     NOP
13016  FF7B     NOP
13018  FFF6     NOP
1301C  FF77     NOP
1301E  FFF7     NOP
13020  0E00     MOVLW 0x0
13022  6EF8     MOVWF 0xFF8, ACCESS
13024  0008     TBLRD*
13026  0EFF     MOVLW 0xFF
1302A  FFD7     NOP
1302C  FFE3     NOP
1277:                      ++*fmt;
1302E  0EDC     MOVLW 0xDC
13032  FF8F     NOP
13034  FFD9     NOP
13036  0EDD     MOVLW 0xDD
1303A  FF8F     NOP
1303C  FFDA     NOP
1303E  2ADE     INCF 0xFDE, F, ACCESS
13040  0E00     MOVLW 0x0
13042  22DD     ADDWFC 0xFDD, F, ACCESS
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
13044  0EDA     MOVLW 0xDA
13048  FF8F     NOP
1304A  FFD9     NOP
1304C  0EDB     MOVLW 0xDB
13050  FF8F     NOP
13052  FFDA     NOP
13054  0E02     MOVLW 0x2
13056  5EDE     SUBWF 0xFDE, F, ACCESS
13058  0E00     MOVLW 0x0
1305A  5ADD     SUBWFB 0xFDD, F, ACCESS
1305E  FF78     NOP
13060  F00B     NOP
13064  FF74     NOP
13066  F00C     NOP
1306A  F02F     NOP
1306C  FFD9     NOP
13070  F033     NOP
13072  FFDA     NOP
13076  FF78     NOP
13078  F00B     NOP
1307C  FF74     NOP
1307E  F00C     NOP
13080  500B     MOVF wtemp5, W, ACCESS
13082  6E11     MOVWF lltemp2, ACCESS
13084  500C     MOVF 0xC, W, ACCESS
13086  6E12     MOVWF 0x12, ACCESS
13088  6A13     CLRF 0x13, ACCESS
1308A  6A14     CLRF 0x14, ACCESS
1308C  6A15     CLRF 0x15, ACCESS
1308E  6A16     CLRF 0x16, ACCESS
13090  6A17     CLRF 0x17, ACCESS
13092  6A18     CLRF 0x18, ACCESS
13094  0EE6     MOVLW 0xE6
13098  F047     NOP
1309A  FFE3     NOP
1309C  0EE7     MOVLW 0xE7
130A0  F04B     NOP
130A2  FFE3     NOP
130A4  0EE8     MOVLW 0xE8
130A8  F04F     NOP
130AA  FFE3     NOP
130AC  0EE9     MOVLW 0xE9
130B0  F053     NOP
130B2  FFE3     NOP
130B4  0EEA     MOVLW 0xEA
130B8  F057     NOP
130BA  FFE3     NOP
130BC  0EEB     MOVLW 0xEB
130C0  F05B     NOP
130C2  FFE3     NOP
130C4  0EEC     MOVLW 0xEC
130C8  F05F     NOP
130CA  FFE3     NOP
130CC  0EED     MOVLW 0xED
130D0  F063     NOP
130D2  FFE3     NOP
1279:                                  
1280:                      return xtoa(fp, llu, c);
130D4  0EFF     MOVLW 0xFF
130D6  50E3     MOVF 0xFE3, W, ACCESS
130D8  6EE6     MOVWF 0xFE6, ACCESS
130DA  50E1     MOVF 0xFE1, W, ACCESS
130DC  0FE5     ADDLW 0xE5
130DE  6ED9     MOVWF 0xFD9, ACCESS
130E0  50E2     MOVF 0xFE2, W, ACCESS
130E2  6EDA     MOVWF 0xFDA, ACCESS
130E4  0EFF     MOVLW 0xFF
130E6  22DA     ADDWFC 0xFDA, F, ACCESS
130EA  FF7B     NOP
130EC  FFE6     NOP
130F0  FF7B     NOP
130F2  FFE6     NOP
130F6  FF7B     NOP
130F8  FFE6     NOP
130FC  FF7B     NOP
130FE  FFE6     NOP
13102  FF7B     NOP
13104  FFE6     NOP
13108  FF7B     NOP
1310A  FFE6     NOP
1310E  FF7B     NOP
13110  FFE6     NOP
13114  FF7B     NOP
13116  FFE6     NOP
13118  0ED5     MOVLW 0xD5
1311C  FF8F     NOP
1311E  FFE6     NOP
13122  FF8F     NOP
13124  FFE6     NOP
13126  ECFE     CALL 0x15DFC, 0
13128  F0AE     NOP
1312A  D105     BRA 0x3336
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1312C  0E02     MOVLW 0x2
1312E  6EE6     MOVWF 0xFE6, ACCESS
13130  0E00     MOVLW 0x0
13132  6EE6     MOVWF 0xFE6, ACCESS
13134  0EF5     MOVLW 0xF5
13136  6EE6     MOVWF 0xFE6, ACCESS
13138  0EFF     MOVLW 0xFF
1313A  6EE6     MOVWF 0xFE6, ACCESS
1313C  0ED8     MOVLW 0xD8
13140  FF8F     NOP
13142  FFD9     NOP
13144  0ED9     MOVLW 0xD9
13148  FF8F     NOP
1314A  FFDA     NOP
1314E  FF78     NOP
13150  F00B     NOP
13154  FF74     NOP
13156  F00C     NOP
1315A  F02F     NOP
1315C  FFE6     NOP
13160  F033     NOP
13162  FFE6     NOP
13164  ECB1     CALL 0x17D62, 0
13166  F0BE     NOP
13168  5001     MOVF ltemp0, W, ACCESS
1316A  1002     IORWF ttemp5, W, ACCESS
1316C  B4D8     BTFSC 0xFD8, 2, ACCESS
1316E  D022     BRA 0x31B4
13170  0E02     MOVLW 0x2
13172  6EE6     MOVWF 0xFE6, ACCESS
13174  0E00     MOVLW 0x0
13176  6EE6     MOVWF 0xFE6, ACCESS
13178  0EE6     MOVLW 0xE6
1317A  6EE6     MOVWF 0xFE6, ACCESS
1317C  0EFF     MOVLW 0xFF
1317E  6EE6     MOVWF 0xFE6, ACCESS
13180  0ED8     MOVLW 0xD8
13184  FF8F     NOP
13186  FFD9     NOP
13188  0ED9     MOVLW 0xD9
1318C  FF8F     NOP
1318E  FFDA     NOP
13192  FF78     NOP
13194  F00B     NOP
13198  FF74     NOP
1319A  F00C     NOP
1319E  F02F     NOP
131A0  FFE6     NOP
131A4  F033     NOP
131A6  FFE6     NOP
131A8  ECB1     CALL 0x17D62, 0
131AA  F0BE     NOP
131AC  5001     MOVF ltemp0, W, ACCESS
131AE  1002     IORWF ttemp5, W, ACCESS
131B0  A4D8     BTFSS 0xFD8, 2, ACCESS
131B2  D058     BRA 0x3264
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
131B4  0EDC     MOVLW 0xDC
131B8  FF8F     NOP
131BA  FFD9     NOP
131BC  0EDD     MOVLW 0xDD
131C0  FF8F     NOP
131C2  FFDA     NOP
131C6  FF78     NOP
131C8  F00B     NOP
131CC  FF74     NOP
131CE  F00C     NOP
131D0  0E01     MOVLW 0x1
131D2  260B     ADDWF wtemp5, F, ACCESS
131D4  0E00     MOVLW 0x0
131D6  220C     ADDWFC 0xC, F, ACCESS
131DA  F02F     NOP
131DC  FFF6     NOP
131E0  F033     NOP
131E2  FFF7     NOP
131E4  0E00     MOVLW 0x0
131E6  6EF8     MOVWF 0xFF8, ACCESS
131E8  0008     TBLRD*
131EA  0EFF     MOVLW 0xFF
131EE  FFD7     NOP
131F0  FFE3     NOP
1289:                      *fmt += CSTRLEN("lx");
131F2  0EDC     MOVLW 0xDC
131F6  FF8F     NOP
131F8  FFD9     NOP
131FA  0EDD     MOVLW 0xDD
131FE  FF8F     NOP
13200  FFDA     NOP
13202  0E02     MOVLW 0x2
13204  26DE     ADDWF 0xFDE, F, ACCESS
13206  0E00     MOVLW 0x0
13208  22DD     ADDWFC 0xFDD, F, ACCESS
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1320A  0EDA     MOVLW 0xDA
1320E  FF8F     NOP
13210  FFD9     NOP
13212  0EDB     MOVLW 0xDB
13216  FF8F     NOP
13218  FFDA     NOP
1321A  0E04     MOVLW 0x4
1321C  5EDE     SUBWF 0xFDE, F, ACCESS
1321E  0E00     MOVLW 0x0
13220  5ADD     SUBWFB 0xFDD, F, ACCESS
13224  FF78     NOP
13226  F00B     NOP
1322A  FF74     NOP
1322C  F00C     NOP
13230  F02F     NOP
13232  FFD9     NOP
13236  F033     NOP
13238  FFDA     NOP
1323C  FF78     NOP
1323E  F009     NOP
13242  FF78     NOP
13244  F00A     NOP
13248  FF78     NOP
1324A  F00B     NOP
1324E  FF78     NOP
13250  F00C     NOP
13252  5009     MOVF ltemp2, W, ACCESS
13254  6E11     MOVWF lltemp2, ACCESS
13256  500A     MOVF ttemp3, W, ACCESS
13258  6E12     MOVWF 0x12, ACCESS
1325A  500B     MOVF wtemp5, W, ACCESS
1325C  6E13     MOVWF 0x13, ACCESS
1325E  500C     MOVF 0xC, W, ACCESS
13260  6E14     MOVWF 0x14, ACCESS
13262  D714     BRA 0x308C
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
13264  0EDC     MOVLW 0xDC
13268  FF8F     NOP
1326A  FFD9     NOP
1326C  0EDD     MOVLW 0xDD
13270  FF8F     NOP
13272  FFDA     NOP
13276  FF7B     NOP
13278  FFF6     NOP
1327C  FF77     NOP
1327E  FFF7     NOP
13280  0E00     MOVLW 0x0
13282  6EF8     MOVWF 0xFF8, ACCESS
13284  0008     TBLRD*
13286  50F5     MOVF 0xFF5, W, ACCESS
13288  0A25     XORLW 0x25
1328A  A4D8     BTFSS 0xFD8, 2, ACCESS
1328C  D01A     BRA 0x32C2
1351:                      ++*fmt;
1328E  0EDC     MOVLW 0xDC
13292  FF8F     NOP
13294  FFD9     NOP
13296  0EDD     MOVLW 0xDD
1329A  FF8F     NOP
1329C  FFDA     NOP
1329E  2ADE     INCF 0xFDE, F, ACCESS
132A0  0E00     MOVLW 0x0
132A2  22DD     ADDWFC 0xFDD, F, ACCESS
1352:                      fputc((int)'%', fp);
132A4  0EDE     MOVLW 0xDE
132A8  FF8F     NOP
132AA  FFE6     NOP
132AE  FF8F     NOP
132B0  FFE6     NOP
132B2  0E25     MOVLW 0x25
132B4  6EE6     MOVWF 0xFE6, ACCESS
132B6  0E00     MOVLW 0x0
132B8  6EE6     MOVWF 0xFE6, ACCESS
132BA  EC61     CALL 0x194C2, 0
132BC  F0CA     NOP
1353:                      return 1;
132BE  0E01     MOVLW 0x1
132C0  D00C     BRA 0x32DA
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
132C2  0EDC     MOVLW 0xDC
132C6  FF8F     NOP
132C8  FFD9     NOP
132CA  0EDD     MOVLW 0xDD
132CE  FF8F     NOP
132D0  FFDA     NOP
132D2  2ADE     INCF 0xFDE, F, ACCESS
132D4  0E00     MOVLW 0x0
132D6  22DD     ADDWFC 0xFDD, F, ACCESS
1358:                  return 0;
132D8  0E00     MOVLW 0x0
132DA  6E01     MOVWF ltemp0, ACCESS
132DC  0E00     MOVLW 0x0
132DE  6E02     MOVWF ttemp5, ACCESS
132E0  D02A     BRA 0x3336
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
132E2  0EDE     MOVLW 0xDE
132E6  FF8F     NOP
132E8  FFE6     NOP
132EC  FF8F     NOP
132EE  FFE6     NOP
132F0  0EDA     MOVLW 0xDA
132F4  FF8F     NOP
132F6  FFD9     NOP
132F8  0EDB     MOVLW 0xDB
132FC  FF8F     NOP
132FE  FFDA     NOP
13302  FF7B     NOP
13304  FFF6     NOP
13308  FF77     NOP
1330A  FFF7     NOP
1330C  0E00     MOVLW 0x0
1330E  6EF8     MOVWF 0xFF8, ACCESS
13310  0008     TBLRD*
13312  50F5     MOVF 0xFF5, W, ACCESS
13314  6EE6     MOVWF 0xFE6, ACCESS
13316  0E00     MOVLW 0x0
13318  6EE6     MOVWF 0xFE6, ACCESS
1331A  EC61     CALL 0x194C2, 0
1331C  F0CA     NOP
1363:              ++*fmt;
1331E  0EDC     MOVLW 0xDC
13322  FF8F     NOP
13324  FFD9     NOP
13326  0EDD     MOVLW 0xDD
1332A  FF8F     NOP
1332C  FFDA     NOP
1332E  2ADE     INCF 0xFDE, F, ACCESS
13330  0E00     MOVLW 0x0
13332  22DD     ADDWFC 0xFDD, F, ACCESS
13334  D7C4     BRA 0x32BE
1364:              return 1;
1365:          }
13336  0EDA     MOVLW 0xDA
13338  26E1     ADDWF 0xFE1, F, ACCESS
1333A  0EFF     MOVLW 0xFF
1333C  22E2     ADDWFC 0xFE2, F, ACCESS
1333E  0012     RETURN 0
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1A3BC  52E6     MOVF 0xFE6, F, ACCESS
1A3BE  52E6     MOVF 0xFE6, F, ACCESS
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1A3C0  0EFA     MOVLW 0xFA
1A3C4  FF8C     NOP
1A3C6  F00B     NOP
1A3C8  0EFB     MOVLW 0xFB
1A3CC  FF8C     NOP
1A3CE  F00C     NOP
1A3D0  0EFF     MOVLW 0xFF
1A3D4  F033     NOP
1A3D6  FFE3     NOP
1A3D8  0EFE     MOVLW 0xFE
1A3DC  F02F     NOP
1A3DE  FFE3     NOP
1374:              nout = 0;
1A3E0  0100     MOVLB 0x0
1A3E2  6BC0     CLRF nout, BANKED
1A3E4  6BC1     CLRF 0xC1, BANKED
1375:              while (*cfmt) {
1A3E6  D021     BRA 0xA42A
1A42A  50E1     MOVF 0xFE1, W, ACCESS
1A42C  0FFE     ADDLW 0xFE
1A42E  6ED9     MOVWF 0xFD9, ACCESS
1A430  50E2     MOVF 0xFE2, W, ACCESS
1A432  6EDA     MOVWF 0xFDA, ACCESS
1A434  0EFF     MOVLW 0xFF
1A436  22DA     ADDWFC 0xFDA, F, ACCESS
1A43A  FF7B     NOP
1A43C  FFF6     NOP
1A440  FF77     NOP
1A442  FFF7     NOP
1A444  0E00     MOVLW 0x0
1A446  6EF8     MOVWF 0xFF8, ACCESS
1A448  0008     TBLRD*
1A44A  50F5     MOVF 0xFF5, W, ACCESS
1A44C  0900     IORLW 0x0
1A44E  A4D8     BTFSS 0xFD8, 2, ACCESS
1A450  D7CB     BRA 0xA3E8
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
1A3E8  0EF8     MOVLW 0xF8
1A3EC  FF8F     NOP
1A3EE  FFE6     NOP
1A3F2  FF8F     NOP
1A3F4  FFE6     NOP
1A3F6  0EFC     MOVLW 0xFC
1A3F8  24E1     ADDWF 0xFE1, W, ACCESS
1A3FA  6E01     MOVWF ltemp0, ACCESS
1A3FC  0EFF     MOVLW 0xFF
1A3FE  20E2     ADDWFC 0xFE2, W, ACCESS
1A400  6E02     MOVWF ttemp5, ACCESS
1A404  F007     NOP
1A406  FFE6     NOP
1A40A  F00B     NOP
1A40C  FFE6     NOP
1A40E  0EF8     MOVLW 0xF8
1A412  FF8F     NOP
1A414  FFE6     NOP
1A418  FF8F     NOP
1A41A  FFE6     NOP
1A41C  ECCA     CALL 0x12394, 0
1A41E  F091     NOP
1A420  5001     MOVF ltemp0, W, ACCESS
1A422  0100     MOVLB 0x0
1A424  27C0     ADDWF nout, F, BANKED
1A426  5002     MOVF ttemp5, W, ACCESS
1A428  23C1     ADDWFC 0xC1, F, BANKED
1377:              }
1378:              return nout;
1A454  F300     NOP
1A456  F001     NOP
1A45A  F304     NOP
1A45C  F002     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
1A45E  0EF8     MOVLW 0xF8
1A460  26E1     ADDWF 0xFE1, F, ACCESS
1A462  0EFF     MOVLW 0xFF
1A464  22E2     ADDWFC 0xFE2, F, ACCESS
1A466  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/awmod.c  -------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
19700  52E6     MOVF 0xFE6, F, ACCESS
19702  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
19704  0EFE     MOVLW 0xFE
19706  6AE3     CLRF 0xFE3, ACCESS
13:            	if(dividend < 0) {
19708  0EFD     MOVLW 0xFD
1970A  AEE3     BTFSS 0xFE3, 7, ACCESS
1970C  D009     BRA 0x9720
14:            		dividend = -dividend;
1970E  0EFC     MOVLW 0xFC
19710  6CE3     NEGF 0xFE3, ACCESS
19712  0EFD     MOVLW 0xFD
19714  1EE3     COMF 0xFE3, F, ACCESS
19716  B0D8     BTFSC 0xFD8, 0, ACCESS
19718  2AE3     INCF 0xFE3, F, ACCESS
15:            		sign = 1;
1971A  0EFE     MOVLW 0xFE
1971C  6AE3     CLRF 0xFE3, ACCESS
1971E  2AE3     INCF 0xFE3, F, ACCESS
16:            	}
17:            	if(divisor < 0)
19720  0EFB     MOVLW 0xFB
19722  AEE3     BTFSS 0xFE3, 7, ACCESS
19724  D006     BRA 0x9732
18:            		divisor = -divisor;
19726  0EFA     MOVLW 0xFA
19728  6CE3     NEGF 0xFE3, ACCESS
1972A  0EFB     MOVLW 0xFB
1972C  1EE3     COMF 0xFE3, F, ACCESS
1972E  B0D8     BTFSC 0xFD8, 0, ACCESS
19730  2AE3     INCF 0xFE3, F, ACCESS
19:            	if(divisor != 0) {
19732  0EFA     MOVLW 0xFA
19736  FF8C     NOP
19738  F001     NOP
1973A  0EFB     MOVLW 0xFB
1973C  50E3     MOVF 0xFE3, W, ACCESS
1973E  1001     IORWF ltemp0, W, ACCESS
19740  B4D8     BTFSC 0xFD8, 2, ACCESS
19742  D053     BRA 0x97EA
20:            		counter = 1;
19744  0EFF     MOVLW 0xFF
19746  6AE3     CLRF 0xFE3, ACCESS
19748  D012     BRA 0x976E
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
19770  0EFB     MOVLW 0xFB
19772  AEE3     BTFSS 0xFE3, 7, ACCESS
19774  D7EA     BRA 0x974A
22:            			divisor <<= 1;
1974A  0EFA     MOVLW 0xFA
1974C  50E3     MOVF 0xFE3, W, ACCESS
1974E  90D8     BCF 0xFD8, 0, ACCESS
19750  34E8     RLCF 0xFE8, W, ACCESS
19752  6E01     MOVWF ltemp0, ACCESS
19754  0EFA     MOVLW 0xFA
19758  F007     NOP
1975A  FFE3     NOP
1975C  0EFB     MOVLW 0xFB
1975E  50E3     MOVF 0xFE3, W, ACCESS
19760  34E8     RLCF 0xFE8, W, ACCESS
19762  6E01     MOVWF ltemp0, ACCESS
19764  0EFB     MOVLW 0xFB
19768  F007     NOP
1976A  FFE3     NOP
23:            			counter++;
1976C  0EFF     MOVLW 0xFF
1976E  2AE3     INCF 0xFE3, F, ACCESS
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
19776  0EFA     MOVLW 0xFA
1977A  FF8C     NOP
1977C  F00B     NOP
1977E  0EFB     MOVLW 0xFB
19782  FF8C     NOP
19784  F00C     NOP
19786  0EFC     MOVLW 0xFC
1978A  FF8C     NOP
1978C  F009     NOP
1978E  0EFD     MOVLW 0xFD
19792  FF8C     NOP
19794  F00A     NOP
19796  500B     MOVF wtemp5, W, ACCESS
19798  5C09     SUBWF ltemp2, W, ACCESS
1979A  500C     MOVF 0xC, W, ACCESS
1979C  580A     SUBWFB ttemp3, W, ACCESS
1979E  A0D8     BTFSS 0xFD8, 0, ACCESS
197A0  D014     BRA 0x97CA
27:            				dividend -= divisor;
197A2  0EFC     MOVLW 0xFC
197A4  50E3     MOVF 0xFE3, W, ACCESS
197A6  6E01     MOVWF ltemp0, ACCESS
197A8  0EFA     MOVLW 0xFA
197AA  50E3     MOVF 0xFE3, W, ACCESS
197AC  5E01     SUBWF ltemp0, F, ACCESS
197AE  0EFC     MOVLW 0xFC
197B2  F007     NOP
197B4  FFE3     NOP
197B6  0EFD     MOVLW 0xFD
197B8  50E3     MOVF 0xFE3, W, ACCESS
197BA  6E01     MOVWF ltemp0, ACCESS
197BC  0EFB     MOVLW 0xFB
197BE  50E3     MOVF 0xFE3, W, ACCESS
197C0  5A01     SUBWFB ltemp0, F, ACCESS
197C2  0EFD     MOVLW 0xFD
197C6  F007     NOP
197C8  FFE3     NOP
28:            			*(unsigned int *)&divisor >>= 1;
197CA  90D8     BCF 0xFD8, 0, ACCESS
197CC  0EFB     MOVLW 0xFB
197CE  32E3     RRCF 0xFE3, F, ACCESS
197D0  0EFA     MOVLW 0xFA
197D2  32E3     RRCF 0xFE3, F, ACCESS
29:            		} while(--counter != 0);
197D4  0EFF     MOVLW 0xFF
197D6  50E3     MOVF 0xFE3, W, ACCESS
197D8  6E01     MOVWF ltemp0, ACCESS
197DA  0E01     MOVLW 0x1
197DC  5E01     SUBWF ltemp0, F, ACCESS
197DE  0EFF     MOVLW 0xFF
197E2  F007     NOP
197E4  FFE3     NOP
197E6  A4D8     BTFSS 0xFD8, 2, ACCESS
197E8  D7C6     BRA 0x9776
30:            	}
31:            	if(sign)
197EA  0EFE     MOVLW 0xFE
197EC  50E3     MOVF 0xFE3, W, ACCESS
197EE  B4D8     BTFSC 0xFD8, 2, ACCESS
197F0  D006     BRA 0x97FE
32:            		dividend = -dividend;
197F2  0EFC     MOVLW 0xFC
197F4  6CE3     NEGF 0xFE3, ACCESS
197F6  0EFD     MOVLW 0xFD
197F8  1EE3     COMF 0xFE3, F, ACCESS
197FA  B0D8     BTFSC 0xFD8, 0, ACCESS
197FC  2AE3     INCF 0xFE3, F, ACCESS
33:            	return dividend;
197FE  0EFC     MOVLW 0xFC
19802  FF8C     NOP
19804  F001     NOP
19806  0EFD     MOVLW 0xFD
1980A  FF8C     NOP
1980C  F002     NOP
34:            }
1980E  0EFA     MOVLW 0xFA
19810  26E1     ADDWF 0xFE1, F, ACCESS
19812  0EFF     MOVLW 0xFF
19814  22E2     ADDWFC 0xFE2, F, ACCESS
19816  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/awdiv.c  -------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
18FC6  52E6     MOVF 0xFE6, F, ACCESS
18FC8  52E6     MOVF 0xFE6, F, ACCESS
18FCA  52E6     MOVF 0xFE6, F, ACCESS
18FCC  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
18FCE  0EFE     MOVLW 0xFE
18FD0  6AE3     CLRF 0xFE3, ACCESS
14:            	if(divisor < 0) {
18FD2  0EF9     MOVLW 0xF9
18FD4  AEE3     BTFSS 0xFE3, 7, ACCESS
18FD6  D009     BRA 0x8FEA
15:            		divisor = -divisor;
18FD8  0EF8     MOVLW 0xF8
18FDA  6CE3     NEGF 0xFE3, ACCESS
18FDC  0EF9     MOVLW 0xF9
18FDE  1EE3     COMF 0xFE3, F, ACCESS
18FE0  B0D8     BTFSC 0xFD8, 0, ACCESS
18FE2  2AE3     INCF 0xFE3, F, ACCESS
16:            		sign = 1;
18FE4  0EFE     MOVLW 0xFE
18FE6  6AE3     CLRF 0xFE3, ACCESS
18FE8  2AE3     INCF 0xFE3, F, ACCESS
17:            	}
18:            	if(dividend < 0) {
18FEA  0EFB     MOVLW 0xFB
18FEC  AEE3     BTFSS 0xFE3, 7, ACCESS
18FEE  D008     BRA 0x9000
19:            		dividend = -dividend;
18FF0  0EFA     MOVLW 0xFA
18FF2  6CE3     NEGF 0xFE3, ACCESS
18FF4  0EFB     MOVLW 0xFB
18FF6  1EE3     COMF 0xFE3, F, ACCESS
18FF8  B0D8     BTFSC 0xFD8, 0, ACCESS
18FFA  2AE3     INCF 0xFE3, F, ACCESS
20:            		sign ^= 1;
18FFC  0EFE     MOVLW 0xFE
18FFE  70E3     BTG 0xFE3, 0, ACCESS
21:            	}
22:            	quotient = 0;
19000  0EFC     MOVLW 0xFC
19002  6AE3     CLRF 0xFE3, ACCESS
19004  0EFD     MOVLW 0xFD
19006  6AE3     CLRF 0xFE3, ACCESS
23:            	if(divisor != 0) {
19008  0EF8     MOVLW 0xF8
1900C  FF8C     NOP
1900E  F001     NOP
19010  0EF9     MOVLW 0xF9
19012  50E3     MOVF 0xFE3, W, ACCESS
19014  1001     IORWF ltemp0, W, ACCESS
19016  B4D8     BTFSC 0xFD8, 2, ACCESS
19018  D066     BRA 0x90E6
24:            		counter = 1;
1901A  0EFF     MOVLW 0xFF
1901C  6AE3     CLRF 0xFE3, ACCESS
1901E  D012     BRA 0x9044
25:            		while((divisor & 0x8000U) == 0) {
19046  0EF9     MOVLW 0xF9
19048  AEE3     BTFSS 0xFE3, 7, ACCESS
1904A  D7EA     BRA 0x9020
26:            			divisor <<= 1;
19020  0EF8     MOVLW 0xF8
19022  50E3     MOVF 0xFE3, W, ACCESS
19024  90D8     BCF 0xFD8, 0, ACCESS
19026  34E8     RLCF 0xFE8, W, ACCESS
19028  6E01     MOVWF ltemp0, ACCESS
1902A  0EF8     MOVLW 0xF8
1902E  F007     NOP
19030  FFE3     NOP
19032  0EF9     MOVLW 0xF9
19034  50E3     MOVF 0xFE3, W, ACCESS
19036  34E8     RLCF 0xFE8, W, ACCESS
19038  6E01     MOVWF ltemp0, ACCESS
1903A  0EF9     MOVLW 0xF9
1903E  F007     NOP
19040  FFE3     NOP
27:            			counter++;
19042  0EFF     MOVLW 0xFF
19044  2AE3     INCF 0xFE3, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
1904C  0EFC     MOVLW 0xFC
1904E  50E3     MOVF 0xFE3, W, ACCESS
19050  90D8     BCF 0xFD8, 0, ACCESS
19052  34E8     RLCF 0xFE8, W, ACCESS
19054  6E01     MOVWF ltemp0, ACCESS
19056  0EFC     MOVLW 0xFC
1905A  F007     NOP
1905C  FFE3     NOP
1905E  0EFD     MOVLW 0xFD
19060  50E3     MOVF 0xFE3, W, ACCESS
19062  34E8     RLCF 0xFE8, W, ACCESS
19064  6E01     MOVWF ltemp0, ACCESS
19066  0EFD     MOVLW 0xFD
1906A  F007     NOP
1906C  FFE3     NOP
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
1906E  0EF8     MOVLW 0xF8
19072  FF8C     NOP
19074  F00B     NOP
19076  0EF9     MOVLW 0xF9
1907A  FF8C     NOP
1907C  F00C     NOP
1907E  0EFA     MOVLW 0xFA
19082  FF8C     NOP
19084  F009     NOP
19086  0EFB     MOVLW 0xFB
1908A  FF8C     NOP
1908C  F00A     NOP
1908E  500B     MOVF wtemp5, W, ACCESS
19090  5C09     SUBWF ltemp2, W, ACCESS
19092  500C     MOVF 0xC, W, ACCESS
19094  580A     SUBWFB ttemp3, W, ACCESS
19096  A0D8     BTFSS 0xFD8, 0, ACCESS
19098  D016     BRA 0x90C6
32:            				dividend -= divisor;
1909A  0EFA     MOVLW 0xFA
1909C  50E3     MOVF 0xFE3, W, ACCESS
1909E  6E01     MOVWF ltemp0, ACCESS
190A0  0EF8     MOVLW 0xF8
190A2  50E3     MOVF 0xFE3, W, ACCESS
190A4  5E01     SUBWF ltemp0, F, ACCESS
190A6  0EFA     MOVLW 0xFA
190AA  F007     NOP
190AC  FFE3     NOP
190AE  0EFB     MOVLW 0xFB
190B0  50E3     MOVF 0xFE3, W, ACCESS
190B2  6E01     MOVWF ltemp0, ACCESS
190B4  0EF9     MOVLW 0xF9
190B6  50E3     MOVF 0xFE3, W, ACCESS
190B8  5A01     SUBWFB ltemp0, F, ACCESS
190BA  0EFB     MOVLW 0xFB
190BE  F007     NOP
190C0  FFE3     NOP
33:            				quotient |= 1;
190C2  0EFC     MOVLW 0xFC
190C4  80E3     BSF 0xFE3, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
190C6  90D8     BCF 0xFD8, 0, ACCESS
190C8  0EF9     MOVLW 0xF9
190CA  32E3     RRCF 0xFE3, F, ACCESS
190CC  0EF8     MOVLW 0xF8
190CE  32E3     RRCF 0xFE3, F, ACCESS
36:            		} while(--counter != 0);
190D0  0EFF     MOVLW 0xFF
190D2  50E3     MOVF 0xFE3, W, ACCESS
190D4  6E01     MOVWF ltemp0, ACCESS
190D6  0E01     MOVLW 0x1
190D8  5E01     SUBWF ltemp0, F, ACCESS
190DA  0EFF     MOVLW 0xFF
190DE  F007     NOP
190E0  FFE3     NOP
190E2  A4D8     BTFSS 0xFD8, 2, ACCESS
190E4  D7B3     BRA 0x904C
37:            	}
38:            	if(sign)
190E6  0EFE     MOVLW 0xFE
190E8  50E3     MOVF 0xFE3, W, ACCESS
190EA  B4D8     BTFSC 0xFD8, 2, ACCESS
190EC  D006     BRA 0x90FA
39:            		quotient = -quotient;
190EE  0EFC     MOVLW 0xFC
190F0  6CE3     NEGF 0xFE3, ACCESS
190F2  0EFD     MOVLW 0xFD
190F4  1EE3     COMF 0xFE3, F, ACCESS
190F6  B0D8     BTFSC 0xFD8, 0, ACCESS
190F8  2AE3     INCF 0xFE3, F, ACCESS
40:            	return quotient;
190FA  0EFC     MOVLW 0xFC
190FE  FF8C     NOP
19100  F001     NOP
19102  0EFD     MOVLW 0xFD
19106  FF8C     NOP
19108  F002     NOP
41:            }
1910A  0EF8     MOVLW 0xF8
1910C  26E1     ADDWF 0xFE1, F, ACCESS
1910E  0EFF     MOVLW 0xFF
19110  22E2     ADDWFC 0xFE2, F, ACCESS
19112  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/atoi.c  --------------------------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
17684  0E09     MOVLW 0x9
17686  26E1     ADDWF 0xFE1, F, ACCESS
17688  0E00     MOVLW 0x0
1768A  22E2     ADDWFC 0xFE2, F, ACCESS
5:             {
6:             	int n=0, neg=0;
1768C  0EFC     MOVLW 0xFC
1768E  6AE3     CLRF 0xFE3, ACCESS
17690  0EFD     MOVLW 0xFD
17692  6AE3     CLRF 0xFE3, ACCESS
17694  0EFE     MOVLW 0xFE
17696  6AE3     CLRF 0xFE3, ACCESS
17698  0EFF     MOVLW 0xFF
1769A  6AE3     CLRF 0xFE3, ACCESS
7:             	while (isspace(*s)) s++;
1769C  D011     BRA 0x76C0
1769E  0EF5     MOVLW 0xF5
176A0  50E3     MOVF 0xFE3, W, ACCESS
176A2  0F01     ADDLW 0x1
176A4  6E01     MOVWF ltemp0, ACCESS
176A6  0EF5     MOVLW 0xF5
176AA  F007     NOP
176AC  FFE3     NOP
176AE  6A01     CLRF ltemp0, ACCESS
176B0  0EF6     MOVLW 0xF6
176B2  50E3     MOVF 0xFE3, W, ACCESS
176B4  2001     ADDWFC ltemp0, W, ACCESS
176B6  6E01     MOVWF ltemp0, ACCESS
176B8  0EF6     MOVLW 0xF6
176BC  F007     NOP
176BE  FFE3     NOP
176C0  0EFB     MOVLW 0xFB
176C2  6AE3     CLRF 0xFE3, ACCESS
176C4  2AE3     INCF 0xFE3, F, ACCESS
176C6  50E1     MOVF 0xFE1, W, ACCESS
176C8  0FF5     ADDLW 0xF5
176CA  6ED9     MOVWF 0xFD9, ACCESS
176CC  50E2     MOVF 0xFE2, W, ACCESS
176CE  6EDA     MOVWF 0xFDA, ACCESS
176D0  0EFF     MOVLW 0xFF
176D2  22DA     ADDWFC 0xFDA, F, ACCESS
176D6  FF7B     NOP
176D8  FFF6     NOP
176DC  FF77     NOP
176DE  FFF7     NOP
176E0  0E00     MOVLW 0x0
176E2  6EF8     MOVWF 0xFF8, ACCESS
176E4  0008     TBLRD*
176E6  50F5     MOVF 0xFF5, W, ACCESS
176E8  0A20     XORLW 0x20
176EA  B4D8     BTFSC 0xFD8, 2, ACCESS
176EC  D023     BRA 0x7734
176EE  0EF7     MOVLW 0xF7
176F0  6E0B     MOVWF wtemp5, ACCESS
176F2  0EFF     MOVLW 0xFF
176F4  6E0C     MOVWF 0xC, ACCESS
176F6  50E1     MOVF 0xFE1, W, ACCESS
176F8  0FF5     ADDLW 0xF5
176FA  6ED9     MOVWF 0xFD9, ACCESS
176FC  50E2     MOVF 0xFE2, W, ACCESS
176FE  6EDA     MOVWF 0xFDA, ACCESS
17700  0EFF     MOVLW 0xFF
17702  22DA     ADDWFC 0xFDA, F, ACCESS
17706  FF7B     NOP
17708  FFF6     NOP
1770C  FF77     NOP
1770E  FFF7     NOP
17710  0E00     MOVLW 0x0
17712  6EF8     MOVWF 0xFF8, ACCESS
17714  0008     TBLRD*
17716  50F5     MOVF 0xFF5, W, ACCESS
17718  6E09     MOVWF ltemp2, ACCESS
1771A  6A0A     CLRF ttemp3, ACCESS
1771C  500B     MOVF wtemp5, W, ACCESS
1771E  2609     ADDWF ltemp2, F, ACCESS
17720  500C     MOVF 0xC, W, ACCESS
17722  220A     ADDWFC ttemp3, F, ACCESS
17724  500A     MOVF ttemp3, W, ACCESS
17726  E104     BNZ 0x7730
17728  0E05     MOVLW 0x5
1772A  5C09     SUBWF ltemp2, W, ACCESS
1772C  A0D8     BTFSS 0xFD8, 0, ACCESS
1772E  D002     BRA 0x7734
17730  0EFB     MOVLW 0xFB
17732  6AE3     CLRF 0xFE3, ACCESS
17734  0EFB     MOVLW 0xFB
17736  50E3     MOVF 0xFE3, W, ACCESS
17738  6E0B     MOVWF wtemp5, ACCESS
1773A  6A0C     CLRF 0xC, ACCESS
1773C  0EF9     MOVLW 0xF9
17740  F02F     NOP
17742  FFE3     NOP
17744  0EFA     MOVLW 0xFA
17748  F033     NOP
1774A  FFE3     NOP
1774C  0EF9     MOVLW 0xF9
17750  FF8C     NOP
17752  F001     NOP
17754  0EFA     MOVLW 0xFA
17756  50E3     MOVF 0xFE3, W, ACCESS
17758  1001     IORWF ltemp0, W, ACCESS
1775A  B4D8     BTFSC 0xFD8, 2, ACCESS
1775C  D01F     BRA 0x779C
1775E  D79F     BRA 0x769E
8:             	switch (*s) {
9:             	case '-': neg=1;
17760  0E01     MOVLW 0x1
17762  6E0B     MOVWF wtemp5, ACCESS
17764  0E00     MOVLW 0x0
17766  6E0C     MOVWF 0xC, ACCESS
17768  0EFE     MOVLW 0xFE
1776C  F02F     NOP
1776E  FFE3     NOP
17770  0EFF     MOVLW 0xFF
17774  F033     NOP
17776  FFE3     NOP
10:            	case '+': s++;
17778  0EF5     MOVLW 0xF5
1777A  50E3     MOVF 0xFE3, W, ACCESS
1777C  0F01     ADDLW 0x1
1777E  6E01     MOVWF ltemp0, ACCESS
17780  0EF5     MOVLW 0xF5
17784  F007     NOP
17786  FFE3     NOP
17788  6A01     CLRF ltemp0, ACCESS
1778A  0EF6     MOVLW 0xF6
1778C  50E3     MOVF 0xFE3, W, ACCESS
1778E  2001     ADDWFC ltemp0, W, ACCESS
17790  6E01     MOVWF ltemp0, ACCESS
17792  0EF6     MOVLW 0xF6
17796  F007     NOP
17798  FFE3     NOP
11:            	}
1779A  D053     BRA 0x7842
1779C  50E1     MOVF 0xFE1, W, ACCESS
1779E  0FF5     ADDLW 0xF5
177A0  6ED9     MOVWF 0xFD9, ACCESS
177A2  50E2     MOVF 0xFE2, W, ACCESS
177A4  6EDA     MOVWF 0xFDA, ACCESS
177A6  0EFF     MOVLW 0xFF
177A8  22DA     ADDWFC 0xFDA, F, ACCESS
177AC  FF7B     NOP
177AE  FFF6     NOP
177B2  FF77     NOP
177B4  FFF7     NOP
177B6  0E00     MOVLW 0x0
177B8  6EF8     MOVWF 0xFF8, ACCESS
177BA  0008     TBLRD*
177BC  50F5     MOVF 0xFF5, W, ACCESS
177BE  6E0B     MOVWF wtemp5, ACCESS
177C0  6A0C     CLRF 0xC, ACCESS
177C2  500C     MOVF 0xC, W, ACCESS
177C4  0A00     XORLW 0x0
177C6  A4D8     BTFSS 0xFD8, 2, ACCESS
177C8  D03C     BRA 0x7842
177CA  500B     MOVF wtemp5, W, ACCESS
177CC  0A2B     XORLW 0x2B
177CE  B4D8     BTFSC 0xFD8, 2, ACCESS
177D0  D7D3     BRA 0x7778
177D2  0A06     XORLW 0x6
177D4  B4D8     BTFSC 0xFD8, 2, ACCESS
177D6  D7C4     BRA 0x7760
177D8  D034     BRA 0x7842
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
17842  0ED0     MOVLW 0xD0
17844  6E0B     MOVWF wtemp5, ACCESS
17846  0EFF     MOVLW 0xFF
17848  6E0C     MOVWF 0xC, ACCESS
1784A  50E1     MOVF 0xFE1, W, ACCESS
1784C  0FF5     ADDLW 0xF5
1784E  6ED9     MOVWF 0xFD9, ACCESS
17850  50E2     MOVF 0xFE2, W, ACCESS
17852  6EDA     MOVWF 0xFDA, ACCESS
17854  0EFF     MOVLW 0xFF
17856  22DA     ADDWFC 0xFDA, F, ACCESS
1785A  FF7B     NOP
1785C  FFF6     NOP
17860  FF77     NOP
17862  FFF7     NOP
17864  0E00     MOVLW 0x0
17866  6EF8     MOVWF 0xFF8, ACCESS
17868  0008     TBLRD*
1786A  50F5     MOVF 0xFF5, W, ACCESS
1786C  6E09     MOVWF ltemp2, ACCESS
1786E  6A0A     CLRF ttemp3, ACCESS
17870  500B     MOVF wtemp5, W, ACCESS
17872  2609     ADDWF ltemp2, F, ACCESS
17874  500C     MOVF 0xC, W, ACCESS
17876  220A     ADDWFC ttemp3, F, ACCESS
17878  500A     MOVF ttemp3, W, ACCESS
1787A  E106     BNZ 0x7888
1787C  0E0A     MOVLW 0xA
1787E  5C09     SUBWF ltemp2, W, ACCESS
17880  B0D8     BTFSC 0xFD8, 0, ACCESS
17882  D002     BRA 0x7888
17884  0E01     MOVLW 0x1
17886  D001     BRA 0x788A
17888  0E00     MOVLW 0x0
1788A  6E0B     MOVWF wtemp5, ACCESS
1788C  6A0C     CLRF 0xC, ACCESS
1788E  0EF7     MOVLW 0xF7
17892  F02F     NOP
17894  FFE3     NOP
17896  0EF8     MOVLW 0xF8
1789A  F033     NOP
1789C  FFE3     NOP
1789E  0EF7     MOVLW 0xF7
178A2  FF8C     NOP
178A4  F001     NOP
178A6  0EF8     MOVLW 0xF8
178A8  50E3     MOVF 0xFE3, W, ACCESS
178AA  1001     IORWF ltemp0, W, ACCESS
178AC  A4D8     BTFSS 0xFD8, 2, ACCESS
178AE  D795     BRA 0x77DA
14:            		n = 10*n - (*s++ - '0');
177DA  0EFC     MOVLW 0xFC
177DE  FF8C     NOP
177E0  F00B     NOP
177E2  0EFD     MOVLW 0xFD
177E6  FF8C     NOP
177E8  F00C     NOP
177EA  0E0A     MOVLW 0xA
177EC  020B     MULWF wtemp5, ACCESS
177F0  FFCC     NOP
177F2  F009     NOP
177F6  FFD0     NOP
177F8  F00A     NOP
177FA  020C     MULWF 0xC, ACCESS
177FC  50F3     MOVF 0xFF3, W, ACCESS
177FE  260A     ADDWF ttemp3, F, ACCESS
17800  50E1     MOVF 0xFE1, W, ACCESS
17802  0FF5     ADDLW 0xF5
17804  6ED9     MOVWF 0xFD9, ACCESS
17806  50E2     MOVF 0xFE2, W, ACCESS
17808  6EDA     MOVWF 0xFDA, ACCESS
1780A  0EFF     MOVLW 0xFF
1780C  22DA     ADDWFC 0xFDA, F, ACCESS
17810  FF7B     NOP
17812  FFF6     NOP
17816  FF77     NOP
17818  FFF7     NOP
1781A  0E00     MOVLW 0x0
1781C  6EF8     MOVWF 0xFF8, ACCESS
1781E  0008     TBLRD*
17820  50F5     MOVF 0xFF5, W, ACCESS
17822  5E09     SUBWF ltemp2, F, ACCESS
17824  0E00     MOVLW 0x0
17826  5A0A     SUBWFB ttemp3, F, ACCESS
17828  0E30     MOVLW 0x30
1782A  2609     ADDWF ltemp2, F, ACCESS
1782C  0E00     MOVLW 0x0
1782E  220A     ADDWFC ttemp3, F, ACCESS
17830  0EFC     MOVLW 0xFC
17834  F027     NOP
17836  FFE3     NOP
17838  0EFD     MOVLW 0xFD
1783C  F02B     NOP
1783E  FFE3     NOP
17840  D79B     BRA 0x7778
15:            	return neg ? n : -n;
178B0  0EFE     MOVLW 0xFE
178B4  FF8C     NOP
178B6  F001     NOP
178B8  0EFF     MOVLW 0xFF
178BA  50E3     MOVF 0xFE3, W, ACCESS
178BC  1001     IORWF ltemp0, W, ACCESS
178BE  A4D8     BTFSS 0xFD8, 2, ACCESS
178C0  D00E     BRA 0x78DE
178C2  0EFC     MOVLW 0xFC
178C6  FF8C     NOP
178C8  F001     NOP
178CA  1E01     COMF ltemp0, F, ACCESS
178CC  0EFD     MOVLW 0xFD
178D0  FF8C     NOP
178D2  F002     NOP
178D4  1E02     COMF ttemp5, F, ACCESS
178D6  2A01     INCF ltemp0, F, ACCESS
178D8  B4D8     BTFSC 0xFD8, 2, ACCESS
178DA  2A02     INCF ttemp5, F, ACCESS
178DC  D008     BRA 0x78EE
178DE  0EFC     MOVLW 0xFC
178E2  FF8C     NOP
178E4  F001     NOP
178E6  0EFD     MOVLW 0xFD
178EA  FF8C     NOP
178EC  F002     NOP
16:            }
178EE  0EF5     MOVLW 0xF5
178F0  26E1     ADDWF 0xFE1, F, ACCESS
178F2  0EFF     MOVLW 0xFF
178F4  22E2     ADDWFC 0xFE2, F, ACCESS
178F6  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/aomod.c  -------------------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
178F8  52E6     MOVF 0xFE6, F, ACCESS
178FA  52E6     MOVF 0xFE6, F, ACCESS
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
178FC  0EFE     MOVLW 0xFE
178FE  6AE3     CLRF 0xFE3, ACCESS
15:            	if(dividend < 0) {
17900  0EFD     MOVLW 0xFD
17902  AEE3     BTFSS 0xFE3, 7, ACCESS
17904  D028     BRA 0x7956
16:            		dividend = -dividend;
17906  0EF6     MOVLW 0xF6
17908  6CE3     NEGF 0xFE3, ACCESS
1790A  0EF7     MOVLW 0xF7
1790C  1EE3     COMF 0xFE3, F, ACCESS
1790E  0EF8     MOVLW 0xF8
17910  1EE3     COMF 0xFE3, F, ACCESS
17912  0EF9     MOVLW 0xF9
17914  1EE3     COMF 0xFE3, F, ACCESS
17916  0EFA     MOVLW 0xFA
17918  1EE3     COMF 0xFE3, F, ACCESS
1791A  0EFB     MOVLW 0xFB
1791C  1EE3     COMF 0xFE3, F, ACCESS
1791E  0EFC     MOVLW 0xFC
17920  1EE3     COMF 0xFE3, F, ACCESS
17922  0EFD     MOVLW 0xFD
17924  1EE3     COMF 0xFE3, F, ACCESS
17926  E314     BNC 0x7950
17928  0EF7     MOVLW 0xF7
1792A  2AE3     INCF 0xFE3, F, ACCESS
1792C  E311     BNC 0x7950
1792E  0EF8     MOVLW 0xF8
17930  2AE3     INCF 0xFE3, F, ACCESS
17932  E30E     BNC 0x7950
17934  0EF9     MOVLW 0xF9
17936  2AE3     INCF 0xFE3, F, ACCESS
17938  E30B     BNC 0x7950
1793A  0EFA     MOVLW 0xFA
1793C  2AE3     INCF 0xFE3, F, ACCESS
1793E  E308     BNC 0x7950
17940  0EFB     MOVLW 0xFB
17942  2AE3     INCF 0xFE3, F, ACCESS
17944  E305     BNC 0x7950
17946  0EFC     MOVLW 0xFC
17948  2AE3     INCF 0xFE3, F, ACCESS
1794A  E302     BNC 0x7950
1794C  0EFD     MOVLW 0xFD
1794E  2AE3     INCF 0xFE3, F, ACCESS
17:            		sign = 1;
17950  0EFE     MOVLW 0xFE
17952  6AE3     CLRF 0xFE3, ACCESS
17954  2AE3     INCF 0xFE3, F, ACCESS
18:            	}
19:            	if(divisor < 0)
17956  0EF5     MOVLW 0xF5
17958  AEE3     BTFSS 0xFE3, 7, ACCESS
1795A  D025     BRA 0x79A6
20:            		divisor = -divisor;
1795C  0EEE     MOVLW 0xEE
1795E  6CE3     NEGF 0xFE3, ACCESS
17960  0EEF     MOVLW 0xEF
17962  1EE3     COMF 0xFE3, F, ACCESS
17964  0EF0     MOVLW 0xF0
17966  1EE3     COMF 0xFE3, F, ACCESS
17968  0EF1     MOVLW 0xF1
1796A  1EE3     COMF 0xFE3, F, ACCESS
1796C  0EF2     MOVLW 0xF2
1796E  1EE3     COMF 0xFE3, F, ACCESS
17970  0EF3     MOVLW 0xF3
17972  1EE3     COMF 0xFE3, F, ACCESS
17974  0EF4     MOVLW 0xF4
17976  1EE3     COMF 0xFE3, F, ACCESS
17978  0EF5     MOVLW 0xF5
1797A  1EE3     COMF 0xFE3, F, ACCESS
1797C  E314     BNC 0x79A6
1797E  0EEF     MOVLW 0xEF
17980  2AE3     INCF 0xFE3, F, ACCESS
17982  E311     BNC 0x79A6
17984  0EF0     MOVLW 0xF0
17986  2AE3     INCF 0xFE3, F, ACCESS
17988  E30E     BNC 0x79A6
1798A  0EF1     MOVLW 0xF1
1798C  2AE3     INCF 0xFE3, F, ACCESS
1798E  E30B     BNC 0x79A6
17990  0EF2     MOVLW 0xF2
17992  2AE3     INCF 0xFE3, F, ACCESS
17994  E308     BNC 0x79A6
17996  0EF3     MOVLW 0xF3
17998  2AE3     INCF 0xFE3, F, ACCESS
1799A  E305     BNC 0x79A6
1799C  0EF4     MOVLW 0xF4
1799E  2AE3     INCF 0xFE3, F, ACCESS
179A0  E302     BNC 0x79A6
179A2  0EF5     MOVLW 0xF5
179A4  2AE3     INCF 0xFE3, F, ACCESS
21:            	if(divisor != 0) {
179A6  0EEE     MOVLW 0xEE
179A8  50E3     MOVF 0xFE3, W, ACCESS
179AA  E116     BNZ 0x79D8
179AC  0EEF     MOVLW 0xEF
179AE  50E3     MOVF 0xFE3, W, ACCESS
179B0  E113     BNZ 0x79D8
179B2  0EF0     MOVLW 0xF0
179B4  50E3     MOVF 0xFE3, W, ACCESS
179B6  E110     BNZ 0x79D8
179B8  0EF1     MOVLW 0xF1
179BA  50E3     MOVF 0xFE3, W, ACCESS
179BC  E10D     BNZ 0x79D8
179BE  0EF2     MOVLW 0xF2
179C0  50E3     MOVF 0xFE3, W, ACCESS
179C2  E10A     BNZ 0x79D8
179C4  0EF3     MOVLW 0xF3
179C6  50E3     MOVF 0xFE3, W, ACCESS
179C8  E107     BNZ 0x79D8
179CA  0EF4     MOVLW 0xF4
179CC  50E3     MOVF 0xFE3, W, ACCESS
179CE  E104     BNZ 0x79D8
179D0  0EF5     MOVLW 0xF5
179D2  50E3     MOVF 0xFE3, W, ACCESS
179D4  B4D8     BTFSC 0xFD8, 2, ACCESS
179D6  D075     BRA 0x7AC2
22:            		counter = 1;
179D8  0EFF     MOVLW 0xFF
179DA  6AE3     CLRF 0xFE3, ACCESS
179DC  D012     BRA 0x7A02
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
17A04  0EF5     MOVLW 0xF5
17A06  AEE3     BTFSS 0xFE3, 7, ACCESS
17A08  D7EA     BRA 0x79DE
24:            			divisor <<= 1;
179DE  90D8     BCF 0xFD8, 0, ACCESS
179E0  0EEE     MOVLW 0xEE
179E2  36E3     RLCF 0xFE3, F, ACCESS
179E4  0EEF     MOVLW 0xEF
179E6  36E3     RLCF 0xFE3, F, ACCESS
179E8  0EF0     MOVLW 0xF0
179EA  36E3     RLCF 0xFE3, F, ACCESS
179EC  0EF1     MOVLW 0xF1
179EE  36E3     RLCF 0xFE3, F, ACCESS
179F0  0EF2     MOVLW 0xF2
179F2  36E3     RLCF 0xFE3, F, ACCESS
179F4  0EF3     MOVLW 0xF3
179F6  36E3     RLCF 0xFE3, F, ACCESS
179F8  0EF4     MOVLW 0xF4
179FA  36E3     RLCF 0xFE3, F, ACCESS
179FC  0EF5     MOVLW 0xF5
179FE  36E3     RLCF 0xFE3, F, ACCESS
25:            			counter++;
17A00  0EFF     MOVLW 0xFF
17A02  2AE3     INCF 0xFE3, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
17A0A  50E1     MOVF 0xFE1, W, ACCESS
17A0C  0FF6     ADDLW 0xF6
17A0E  6ED9     MOVWF 0xFD9, ACCESS
17A10  50E2     MOVF 0xFE2, W, ACCESS
17A12  6EDA     MOVWF 0xFDA, ACCESS
17A14  0EFF     MOVLW 0xFF
17A16  22DA     ADDWFC 0xFDA, F, ACCESS
17A18  0EEE     MOVLW 0xEE
17A1A  50E3     MOVF 0xFE3, W, ACCESS
17A1C  5CDE     SUBWF 0xFDE, W, ACCESS
17A1E  0EEF     MOVLW 0xEF
17A20  50E3     MOVF 0xFE3, W, ACCESS
17A22  58DE     SUBWFB 0xFDE, W, ACCESS
17A24  0EF0     MOVLW 0xF0
17A26  50E3     MOVF 0xFE3, W, ACCESS
17A28  58DE     SUBWFB 0xFDE, W, ACCESS
17A2A  0EF1     MOVLW 0xF1
17A2C  50E3     MOVF 0xFE3, W, ACCESS
17A2E  58DE     SUBWFB 0xFDE, W, ACCESS
17A30  0EF2     MOVLW 0xF2
17A32  50E3     MOVF 0xFE3, W, ACCESS
17A34  58DE     SUBWFB 0xFDE, W, ACCESS
17A36  0EF3     MOVLW 0xF3
17A38  50E3     MOVF 0xFE3, W, ACCESS
17A3A  58DE     SUBWFB 0xFDE, W, ACCESS
17A3C  0EF4     MOVLW 0xF4
17A3E  50E3     MOVF 0xFE3, W, ACCESS
17A40  58DE     SUBWFB 0xFDE, W, ACCESS
17A42  0EF5     MOVLW 0xF5
17A44  50E3     MOVF 0xFE3, W, ACCESS
17A46  58DE     SUBWFB 0xFDE, W, ACCESS
17A48  A0D8     BTFSS 0xFD8, 0, ACCESS
17A4A  D01F     BRA 0x7A8A
29:            				dividend -= divisor;
17A4C  50E1     MOVF 0xFE1, W, ACCESS
17A4E  0FF6     ADDLW 0xF6
17A50  6ED9     MOVWF 0xFD9, ACCESS
17A52  50E2     MOVF 0xFE2, W, ACCESS
17A54  6EDA     MOVWF 0xFDA, ACCESS
17A56  0EFF     MOVLW 0xFF
17A58  22DA     ADDWFC 0xFDA, F, ACCESS
17A5A  0EEE     MOVLW 0xEE
17A5C  50E3     MOVF 0xFE3, W, ACCESS
17A5E  5EDE     SUBWF 0xFDE, F, ACCESS
17A60  0EEF     MOVLW 0xEF
17A62  50E3     MOVF 0xFE3, W, ACCESS
17A64  5ADE     SUBWFB 0xFDE, F, ACCESS
17A66  0EF0     MOVLW 0xF0
17A68  50E3     MOVF 0xFE3, W, ACCESS
17A6A  5ADE     SUBWFB 0xFDE, F, ACCESS
17A6C  0EF1     MOVLW 0xF1
17A6E  50E3     MOVF 0xFE3, W, ACCESS
17A70  5ADE     SUBWFB 0xFDE, F, ACCESS
17A72  0EF2     MOVLW 0xF2
17A74  50E3     MOVF 0xFE3, W, ACCESS
17A76  5ADE     SUBWFB 0xFDE, F, ACCESS
17A78  0EF3     MOVLW 0xF3
17A7A  50E3     MOVF 0xFE3, W, ACCESS
17A7C  5ADE     SUBWFB 0xFDE, F, ACCESS
17A7E  0EF4     MOVLW 0xF4
17A80  50E3     MOVF 0xFE3, W, ACCESS
17A82  5ADE     SUBWFB 0xFDE, F, ACCESS
17A84  0EF5     MOVLW 0xF5
17A86  50E3     MOVF 0xFE3, W, ACCESS
17A88  5ADE     SUBWFB 0xFDE, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
17A8A  90D8     BCF 0xFD8, 0, ACCESS
17A8C  0EF5     MOVLW 0xF5
17A8E  32E3     RRCF 0xFE3, F, ACCESS
17A90  0EF4     MOVLW 0xF4
17A92  32E3     RRCF 0xFE3, F, ACCESS
17A94  0EF3     MOVLW 0xF3
17A96  32E3     RRCF 0xFE3, F, ACCESS
17A98  0EF2     MOVLW 0xF2
17A9A  32E3     RRCF 0xFE3, F, ACCESS
17A9C  0EF1     MOVLW 0xF1
17A9E  32E3     RRCF 0xFE3, F, ACCESS
17AA0  0EF0     MOVLW 0xF0
17AA2  32E3     RRCF 0xFE3, F, ACCESS
17AA4  0EEF     MOVLW 0xEF
17AA6  32E3     RRCF 0xFE3, F, ACCESS
17AA8  0EEE     MOVLW 0xEE
17AAA  32E3     RRCF 0xFE3, F, ACCESS
31:            		} while(--counter != 0);
17AAC  0EFF     MOVLW 0xFF
17AAE  50E3     MOVF 0xFE3, W, ACCESS
17AB0  6E01     MOVWF ltemp0, ACCESS
17AB2  0E01     MOVLW 0x1
17AB4  5E01     SUBWF ltemp0, F, ACCESS
17AB6  0EFF     MOVLW 0xFF
17ABA  F007     NOP
17ABC  FFE3     NOP
17ABE  A4D8     BTFSS 0xFD8, 2, ACCESS
17AC0  D7A4     BRA 0x7A0A
32:            	}
33:            	if(sign)
17AC2  0EFE     MOVLW 0xFE
17AC4  50E3     MOVF 0xFE3, W, ACCESS
17AC6  B4D8     BTFSC 0xFD8, 2, ACCESS
17AC8  D025     BRA 0x7B14
34:            		dividend = -dividend;
17ACA  0EF6     MOVLW 0xF6
17ACC  6CE3     NEGF 0xFE3, ACCESS
17ACE  0EF7     MOVLW 0xF7
17AD0  1EE3     COMF 0xFE3, F, ACCESS
17AD2  0EF8     MOVLW 0xF8
17AD4  1EE3     COMF 0xFE3, F, ACCESS
17AD6  0EF9     MOVLW 0xF9
17AD8  1EE3     COMF 0xFE3, F, ACCESS
17ADA  0EFA     MOVLW 0xFA
17ADC  1EE3     COMF 0xFE3, F, ACCESS
17ADE  0EFB     MOVLW 0xFB
17AE0  1EE3     COMF 0xFE3, F, ACCESS
17AE2  0EFC     MOVLW 0xFC
17AE4  1EE3     COMF 0xFE3, F, ACCESS
17AE6  0EFD     MOVLW 0xFD
17AE8  1EE3     COMF 0xFE3, F, ACCESS
17AEA  E314     BNC 0x7B14
17AEC  0EF7     MOVLW 0xF7
17AEE  2AE3     INCF 0xFE3, F, ACCESS
17AF0  E311     BNC 0x7B14
17AF2  0EF8     MOVLW 0xF8
17AF4  2AE3     INCF 0xFE3, F, ACCESS
17AF6  E30E     BNC 0x7B14
17AF8  0EF9     MOVLW 0xF9
17AFA  2AE3     INCF 0xFE3, F, ACCESS
17AFC  E30B     BNC 0x7B14
17AFE  0EFA     MOVLW 0xFA
17B00  2AE3     INCF 0xFE3, F, ACCESS
17B02  E308     BNC 0x7B14
17B04  0EFB     MOVLW 0xFB
17B06  2AE3     INCF 0xFE3, F, ACCESS
17B08  E305     BNC 0x7B14
17B0A  0EFC     MOVLW 0xFC
17B0C  2AE3     INCF 0xFE3, F, ACCESS
17B0E  E302     BNC 0x7B14
17B10  0EFD     MOVLW 0xFD
17B12  2AE3     INCF 0xFE3, F, ACCESS
35:            	return dividend;
17B14  0EF6     MOVLW 0xF6
17B16  24E1     ADDWF 0xFE1, W, ACCESS
17B18  6ED9     MOVWF 0xFD9, ACCESS
17B1A  0EFF     MOVLW 0xFF
17B1C  20E2     ADDWFC 0xFE2, W, ACCESS
17B1E  6EDA     MOVWF 0xFDA, ACCESS
17B20  0E08     MOVLW 0x8
17B22  6E01     MOVWF ltemp0, ACCESS
17B24  0EF6     MOVLW 0xF6
17B28  FF7B     NOP
17B2A  FFE3     NOP
17B2C  28E8     INCF 0xFE8, W, ACCESS
17B2E  2E01     DECFSZ ltemp0, F, ACCESS
17B30  D7FA     BRA 0x7B26
36:            }
17B32  52E5     MOVF 0xFE5, F, ACCESS
17B34  52E5     MOVF 0xFE5, F, ACCESS
17B36  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/aodiv.c  -------------------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
17404  0E0A     MOVLW 0xA
17406  26E1     ADDWF 0xFE1, F, ACCESS
17408  0E00     MOVLW 0x0
1740A  22E2     ADDWFC 0xFE2, F, ACCESS
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
1740C  0EFE     MOVLW 0xFE
1740E  6AE3     CLRF 0xFE3, ACCESS
16:            	if(divisor < 0) {
17410  0EED     MOVLW 0xED
17412  AEE3     BTFSS 0xFE3, 7, ACCESS
17414  D028     BRA 0x7466
17:            		divisor = -divisor;
17416  0EE6     MOVLW 0xE6
17418  6CE3     NEGF 0xFE3, ACCESS
1741A  0EE7     MOVLW 0xE7
1741C  1EE3     COMF 0xFE3, F, ACCESS
1741E  0EE8     MOVLW 0xE8
17420  1EE3     COMF 0xFE3, F, ACCESS
17422  0EE9     MOVLW 0xE9
17424  1EE3     COMF 0xFE3, F, ACCESS
17426  0EEA     MOVLW 0xEA
17428  1EE3     COMF 0xFE3, F, ACCESS
1742A  0EEB     MOVLW 0xEB
1742C  1EE3     COMF 0xFE3, F, ACCESS
1742E  0EEC     MOVLW 0xEC
17430  1EE3     COMF 0xFE3, F, ACCESS
17432  0EED     MOVLW 0xED
17434  1EE3     COMF 0xFE3, F, ACCESS
17436  E314     BNC 0x7460
17438  0EE7     MOVLW 0xE7
1743A  2AE3     INCF 0xFE3, F, ACCESS
1743C  E311     BNC 0x7460
1743E  0EE8     MOVLW 0xE8
17440  2AE3     INCF 0xFE3, F, ACCESS
17442  E30E     BNC 0x7460
17444  0EE9     MOVLW 0xE9
17446  2AE3     INCF 0xFE3, F, ACCESS
17448  E30B     BNC 0x7460
1744A  0EEA     MOVLW 0xEA
1744C  2AE3     INCF 0xFE3, F, ACCESS
1744E  E308     BNC 0x7460
17450  0EEB     MOVLW 0xEB
17452  2AE3     INCF 0xFE3, F, ACCESS
17454  E305     BNC 0x7460
17456  0EEC     MOVLW 0xEC
17458  2AE3     INCF 0xFE3, F, ACCESS
1745A  E302     BNC 0x7460
1745C  0EED     MOVLW 0xED
1745E  2AE3     INCF 0xFE3, F, ACCESS
18:            		sign = 1;
17460  0EFE     MOVLW 0xFE
17462  6AE3     CLRF 0xFE3, ACCESS
17464  2AE3     INCF 0xFE3, F, ACCESS
19:            	}
20:            	if(dividend < 0) {
17466  0EF5     MOVLW 0xF5
17468  AEE3     BTFSS 0xFE3, 7, ACCESS
1746A  D027     BRA 0x74BA
21:            		dividend = -dividend;
1746C  0EEE     MOVLW 0xEE
1746E  6CE3     NEGF 0xFE3, ACCESS
17470  0EEF     MOVLW 0xEF
17472  1EE3     COMF 0xFE3, F, ACCESS
17474  0EF0     MOVLW 0xF0
17476  1EE3     COMF 0xFE3, F, ACCESS
17478  0EF1     MOVLW 0xF1
1747A  1EE3     COMF 0xFE3, F, ACCESS
1747C  0EF2     MOVLW 0xF2
1747E  1EE3     COMF 0xFE3, F, ACCESS
17480  0EF3     MOVLW 0xF3
17482  1EE3     COMF 0xFE3, F, ACCESS
17484  0EF4     MOVLW 0xF4
17486  1EE3     COMF 0xFE3, F, ACCESS
17488  0EF5     MOVLW 0xF5
1748A  1EE3     COMF 0xFE3, F, ACCESS
1748C  E314     BNC 0x74B6
1748E  0EEF     MOVLW 0xEF
17490  2AE3     INCF 0xFE3, F, ACCESS
17492  E311     BNC 0x74B6
17494  0EF0     MOVLW 0xF0
17496  2AE3     INCF 0xFE3, F, ACCESS
17498  E30E     BNC 0x74B6
1749A  0EF1     MOVLW 0xF1
1749C  2AE3     INCF 0xFE3, F, ACCESS
1749E  E30B     BNC 0x74B6
174A0  0EF2     MOVLW 0xF2
174A2  2AE3     INCF 0xFE3, F, ACCESS
174A4  E308     BNC 0x74B6
174A6  0EF3     MOVLW 0xF3
174A8  2AE3     INCF 0xFE3, F, ACCESS
174AA  E305     BNC 0x74B6
174AC  0EF4     MOVLW 0xF4
174AE  2AE3     INCF 0xFE3, F, ACCESS
174B0  E302     BNC 0x74B6
174B2  0EF5     MOVLW 0xF5
174B4  2AE3     INCF 0xFE3, F, ACCESS
22:            		sign ^= 1;
174B6  0EFE     MOVLW 0xFE
174B8  70E3     BTG 0xFE3, 0, ACCESS
23:            	}
24:            	quotient = 0;
174BA  0E07     MOVLW 0x7
174BC  6E01     MOVWF ltemp0, ACCESS
174BE  0EF6     MOVLW 0xF6
174C0  6AE3     CLRF 0xFE3, ACCESS
174C2  2AE8     INCF 0xFE8, F, ACCESS
174C4  0601     DECF ltemp0, F, ACCESS
174C6  E2FC     BC 0x74C0
25:            	if(divisor != 0) {
174C8  0EE6     MOVLW 0xE6
174CA  50E3     MOVF 0xFE3, W, ACCESS
174CC  E116     BNZ 0x74FA
174CE  0EE7     MOVLW 0xE7
174D0  50E3     MOVF 0xFE3, W, ACCESS
174D2  E113     BNZ 0x74FA
174D4  0EE8     MOVLW 0xE8
174D6  50E3     MOVF 0xFE3, W, ACCESS
174D8  E110     BNZ 0x74FA
174DA  0EE9     MOVLW 0xE9
174DC  50E3     MOVF 0xFE3, W, ACCESS
174DE  E10D     BNZ 0x74FA
174E0  0EEA     MOVLW 0xEA
174E2  50E3     MOVF 0xFE3, W, ACCESS
174E4  E10A     BNZ 0x74FA
174E6  0EEB     MOVLW 0xEB
174E8  50E3     MOVF 0xFE3, W, ACCESS
174EA  E107     BNZ 0x74FA
174EC  0EEC     MOVLW 0xEC
174EE  50E3     MOVF 0xFE3, W, ACCESS
174F0  E104     BNZ 0x74FA
174F2  0EED     MOVLW 0xED
174F4  50E3     MOVF 0xFE3, W, ACCESS
174F6  B4D8     BTFSC 0xFD8, 2, ACCESS
174F8  D088     BRA 0x760A
26:            		counter = 1;
174FA  0EFF     MOVLW 0xFF
174FC  6AE3     CLRF 0xFE3, ACCESS
174FE  D012     BRA 0x7524
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
17526  0EED     MOVLW 0xED
17528  AEE3     BTFSS 0xFE3, 7, ACCESS
1752A  D7EA     BRA 0x7500
28:            			divisor <<= 1;
17500  90D8     BCF 0xFD8, 0, ACCESS
17502  0EE6     MOVLW 0xE6
17504  36E3     RLCF 0xFE3, F, ACCESS
17506  0EE7     MOVLW 0xE7
17508  36E3     RLCF 0xFE3, F, ACCESS
1750A  0EE8     MOVLW 0xE8
1750C  36E3     RLCF 0xFE3, F, ACCESS
1750E  0EE9     MOVLW 0xE9
17510  36E3     RLCF 0xFE3, F, ACCESS
17512  0EEA     MOVLW 0xEA
17514  36E3     RLCF 0xFE3, F, ACCESS
17516  0EEB     MOVLW 0xEB
17518  36E3     RLCF 0xFE3, F, ACCESS
1751A  0EEC     MOVLW 0xEC
1751C  36E3     RLCF 0xFE3, F, ACCESS
1751E  0EED     MOVLW 0xED
17520  36E3     RLCF 0xFE3, F, ACCESS
29:            			counter++;
17522  0EFF     MOVLW 0xFF
17524  2AE3     INCF 0xFE3, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
1752C  90D8     BCF 0xFD8, 0, ACCESS
1752E  0EF6     MOVLW 0xF6
17530  36E3     RLCF 0xFE3, F, ACCESS
17532  0EF7     MOVLW 0xF7
17534  36E3     RLCF 0xFE3, F, ACCESS
17536  0EF8     MOVLW 0xF8
17538  36E3     RLCF 0xFE3, F, ACCESS
1753A  0EF9     MOVLW 0xF9
1753C  36E3     RLCF 0xFE3, F, ACCESS
1753E  0EFA     MOVLW 0xFA
17540  36E3     RLCF 0xFE3, F, ACCESS
17542  0EFB     MOVLW 0xFB
17544  36E3     RLCF 0xFE3, F, ACCESS
17546  0EFC     MOVLW 0xFC
17548  36E3     RLCF 0xFE3, F, ACCESS
1754A  0EFD     MOVLW 0xFD
1754C  36E3     RLCF 0xFE3, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
1754E  50E1     MOVF 0xFE1, W, ACCESS
17550  0FEE     ADDLW 0xEE
17552  6ED9     MOVWF 0xFD9, ACCESS
17554  50E2     MOVF 0xFE2, W, ACCESS
17556  6EDA     MOVWF 0xFDA, ACCESS
17558  0EFF     MOVLW 0xFF
1755A  22DA     ADDWFC 0xFDA, F, ACCESS
1755C  0EE6     MOVLW 0xE6
1755E  50E3     MOVF 0xFE3, W, ACCESS
17560  5CDE     SUBWF 0xFDE, W, ACCESS
17562  0EE7     MOVLW 0xE7
17564  50E3     MOVF 0xFE3, W, ACCESS
17566  58DE     SUBWFB 0xFDE, W, ACCESS
17568  0EE8     MOVLW 0xE8
1756A  50E3     MOVF 0xFE3, W, ACCESS
1756C  58DE     SUBWFB 0xFDE, W, ACCESS
1756E  0EE9     MOVLW 0xE9
17570  50E3     MOVF 0xFE3, W, ACCESS
17572  58DE     SUBWFB 0xFDE, W, ACCESS
17574  0EEA     MOVLW 0xEA
17576  50E3     MOVF 0xFE3, W, ACCESS
17578  58DE     SUBWFB 0xFDE, W, ACCESS
1757A  0EEB     MOVLW 0xEB
1757C  50E3     MOVF 0xFE3, W, ACCESS
1757E  58DE     SUBWFB 0xFDE, W, ACCESS
17580  0EEC     MOVLW 0xEC
17582  50E3     MOVF 0xFE3, W, ACCESS
17584  58DE     SUBWFB 0xFDE, W, ACCESS
17586  0EED     MOVLW 0xED
17588  50E3     MOVF 0xFE3, W, ACCESS
1758A  58DE     SUBWFB 0xFDE, W, ACCESS
1758C  A0D8     BTFSS 0xFD8, 0, ACCESS
1758E  D021     BRA 0x75D2
34:            				dividend -= divisor;
17590  50E1     MOVF 0xFE1, W, ACCESS
17592  0FEE     ADDLW 0xEE
17594  6ED9     MOVWF 0xFD9, ACCESS
17596  50E2     MOVF 0xFE2, W, ACCESS
17598  6EDA     MOVWF 0xFDA, ACCESS
1759A  0EFF     MOVLW 0xFF
1759C  22DA     ADDWFC 0xFDA, F, ACCESS
1759E  0EE6     MOVLW 0xE6
175A0  50E3     MOVF 0xFE3, W, ACCESS
175A2  5EDE     SUBWF 0xFDE, F, ACCESS
175A4  0EE7     MOVLW 0xE7
175A6  50E3     MOVF 0xFE3, W, ACCESS
175A8  5ADE     SUBWFB 0xFDE, F, ACCESS
175AA  0EE8     MOVLW 0xE8
175AC  50E3     MOVF 0xFE3, W, ACCESS
175AE  5ADE     SUBWFB 0xFDE, F, ACCESS
175B0  0EE9     MOVLW 0xE9
175B2  50E3     MOVF 0xFE3, W, ACCESS
175B4  5ADE     SUBWFB 0xFDE, F, ACCESS
175B6  0EEA     MOVLW 0xEA
175B8  50E3     MOVF 0xFE3, W, ACCESS
175BA  5ADE     SUBWFB 0xFDE, F, ACCESS
175BC  0EEB     MOVLW 0xEB
175BE  50E3     MOVF 0xFE3, W, ACCESS
175C0  5ADE     SUBWFB 0xFDE, F, ACCESS
175C2  0EEC     MOVLW 0xEC
175C4  50E3     MOVF 0xFE3, W, ACCESS
175C6  5ADE     SUBWFB 0xFDE, F, ACCESS
175C8  0EED     MOVLW 0xED
175CA  50E3     MOVF 0xFE3, W, ACCESS
175CC  5ADE     SUBWFB 0xFDE, F, ACCESS
35:            				quotient |= 1;
175CE  0EF6     MOVLW 0xF6
175D0  80E3     BSF 0xFE3, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
175D2  90D8     BCF 0xFD8, 0, ACCESS
175D4  0EED     MOVLW 0xED
175D6  32E3     RRCF 0xFE3, F, ACCESS
175D8  0EEC     MOVLW 0xEC
175DA  32E3     RRCF 0xFE3, F, ACCESS
175DC  0EEB     MOVLW 0xEB
175DE  32E3     RRCF 0xFE3, F, ACCESS
175E0  0EEA     MOVLW 0xEA
175E2  32E3     RRCF 0xFE3, F, ACCESS
175E4  0EE9     MOVLW 0xE9
175E6  32E3     RRCF 0xFE3, F, ACCESS
175E8  0EE8     MOVLW 0xE8
175EA  32E3     RRCF 0xFE3, F, ACCESS
175EC  0EE7     MOVLW 0xE7
175EE  32E3     RRCF 0xFE3, F, ACCESS
175F0  0EE6     MOVLW 0xE6
175F2  32E3     RRCF 0xFE3, F, ACCESS
38:            		} while(--counter != 0);
175F4  0EFF     MOVLW 0xFF
175F6  50E3     MOVF 0xFE3, W, ACCESS
175F8  6E01     MOVWF ltemp0, ACCESS
175FA  0E01     MOVLW 0x1
175FC  5E01     SUBWF ltemp0, F, ACCESS
175FE  0EFF     MOVLW 0xFF
17602  F007     NOP
17604  FFE3     NOP
17606  A4D8     BTFSS 0xFD8, 2, ACCESS
17608  D791     BRA 0x752C
39:            	}
40:            	if(sign)
1760A  0EFE     MOVLW 0xFE
1760C  50E3     MOVF 0xFE3, W, ACCESS
1760E  B4D8     BTFSC 0xFD8, 2, ACCESS
17610  D025     BRA 0x765C
41:            		quotient = -quotient;
17612  0EF6     MOVLW 0xF6
17614  6CE3     NEGF 0xFE3, ACCESS
17616  0EF7     MOVLW 0xF7
17618  1EE3     COMF 0xFE3, F, ACCESS
1761A  0EF8     MOVLW 0xF8
1761C  1EE3     COMF 0xFE3, F, ACCESS
1761E  0EF9     MOVLW 0xF9
17620  1EE3     COMF 0xFE3, F, ACCESS
17622  0EFA     MOVLW 0xFA
17624  1EE3     COMF 0xFE3, F, ACCESS
17626  0EFB     MOVLW 0xFB
17628  1EE3     COMF 0xFE3, F, ACCESS
1762A  0EFC     MOVLW 0xFC
1762C  1EE3     COMF 0xFE3, F, ACCESS
1762E  0EFD     MOVLW 0xFD
17630  1EE3     COMF 0xFE3, F, ACCESS
17632  E314     BNC 0x765C
17634  0EF7     MOVLW 0xF7
17636  2AE3     INCF 0xFE3, F, ACCESS
17638  E311     BNC 0x765C
1763A  0EF8     MOVLW 0xF8
1763C  2AE3     INCF 0xFE3, F, ACCESS
1763E  E30E     BNC 0x765C
17640  0EF9     MOVLW 0xF9
17642  2AE3     INCF 0xFE3, F, ACCESS
17644  E30B     BNC 0x765C
17646  0EFA     MOVLW 0xFA
17648  2AE3     INCF 0xFE3, F, ACCESS
1764A  E308     BNC 0x765C
1764C  0EFB     MOVLW 0xFB
1764E  2AE3     INCF 0xFE3, F, ACCESS
17650  E305     BNC 0x765C
17652  0EFC     MOVLW 0xFC
17654  2AE3     INCF 0xFE3, F, ACCESS
17656  E302     BNC 0x765C
17658  0EFD     MOVLW 0xFD
1765A  2AE3     INCF 0xFE3, F, ACCESS
42:            	return quotient;
1765C  0EF6     MOVLW 0xF6
1765E  24E1     ADDWF 0xFE1, W, ACCESS
17660  6ED9     MOVWF 0xFD9, ACCESS
17662  0EFF     MOVLW 0xFF
17664  20E2     ADDWFC 0xFE2, W, ACCESS
17666  6EDA     MOVWF 0xFDA, ACCESS
17668  0E08     MOVLW 0x8
1766A  6E01     MOVWF ltemp0, ACCESS
1766C  0EEE     MOVLW 0xEE
17670  FF7B     NOP
17672  FFE3     NOP
17674  28E8     INCF 0xFE8, W, ACCESS
17676  2E01     DECFSZ ltemp0, F, ACCESS
17678  D7FA     BRA 0x766E
43:            }
1767A  0EF6     MOVLW 0xF6
1767C  26E1     ADDWF 0xFE1, F, ACCESS
1767E  0EFF     MOVLW 0xFF
17680  22E2     ADDWFC 0xFE2, F, ACCESS
17682  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/abs.c  ---------------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
1B1C2  0EFF     MOVLW 0xFF
1B1C4  BEE3     BTFSC 0xFE3, 7, ACCESS
1B1C6  D007     BRA 0xB1D6
1B1C8  0EFF     MOVLW 0xFF
1B1CA  50E3     MOVF 0xFE3, W, ACCESS
1B1CC  E112     BNZ 0xB1F2
1B1CE  0EFE     MOVLW 0xFE
1B1D0  04E3     DECF 0xFE3, W, ACCESS
1B1D2  B0D8     BTFSC 0xFD8, 0, ACCESS
1B1D4  D00E     BRA 0xB1F2
1B1D6  0EFE     MOVLW 0xFE
1B1DA  FF8C     NOP
1B1DC  F001     NOP
1B1DE  1E01     COMF ltemp0, F, ACCESS
1B1E0  0EFF     MOVLW 0xFF
1B1E4  FF8C     NOP
1B1E6  F002     NOP
1B1E8  1E02     COMF ttemp5, F, ACCESS
1B1EA  2A01     INCF ltemp0, F, ACCESS
1B1EC  B4D8     BTFSC 0xFD8, 2, ACCESS
1B1EE  2A02     INCF ttemp5, F, ACCESS
1B1F0  D008     BRA 0xB202
1B1F2  0EFE     MOVLW 0xFE
1B1F6  FF8C     NOP
1B1F8  F001     NOP
1B1FA  0EFF     MOVLW 0xFF
1B1FE  FF8C     NOP
1B200  F002     NOP
4:             }
1B202  52E5     MOVF 0xFE5, F, ACCESS
1B204  52E5     MOVF 0xFE5, F, ACCESS
1B206  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/__fpclassifyf.c  -----------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             int __fpclassifyf(float x)
186F4  0E06     MOVLW 0x6
186F6  26E1     ADDWF 0xFE1, F, ACCESS
186F8  0E00     MOVLW 0x0
186FA  22E2     ADDWFC 0xFE2, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u = {x};
186FE  F208     NOP
18700  F009     NOP
18704  F20C     NOP
18706  F00A     NOP
1870A  F210     NOP
1870C  F00B     NOP
18710  F214     NOP
18712  F00C     NOP
18714  0EFA     MOVLW 0xFA
18718  F027     NOP
1871A  FFE3     NOP
1871C  0EFB     MOVLW 0xFB
18720  F02B     NOP
18722  FFE3     NOP
18724  0EFC     MOVLW 0xFC
18728  F02F     NOP
1872A  FFE3     NOP
1872C  0EFD     MOVLW 0xFD
18730  F033     NOP
18732  FFE3     NOP
18734  0EF6     MOVLW 0xF6
18738  FF8C     NOP
1873A  F009     NOP
1873C  0EF7     MOVLW 0xF7
18740  FF8C     NOP
18742  F00A     NOP
18744  0EF8     MOVLW 0xF8
18748  FF8C     NOP
1874A  F00B     NOP
1874C  0EF9     MOVLW 0xF9
18750  FF8C     NOP
18752  F00C     NOP
18754  0EFA     MOVLW 0xFA
18758  F027     NOP
1875A  FFE3     NOP
1875C  0EFB     MOVLW 0xFB
18760  F02B     NOP
18762  FFE3     NOP
18764  0EFC     MOVLW 0xFC
18768  F02F     NOP
1876A  FFE3     NOP
1876C  0EFD     MOVLW 0xFD
18770  F033     NOP
18772  FFE3     NOP
7:             	int e = u.i>>23 & 0xff;
18774  0EFA     MOVLW 0xFA
18778  FF8C     NOP
1877A  F009     NOP
1877C  0EFB     MOVLW 0xFB
18780  FF8C     NOP
18782  F00A     NOP
18784  0EFC     MOVLW 0xFC
18788  FF8C     NOP
1878A  F00B     NOP
1878C  0EFD     MOVLW 0xFD
18790  FF8C     NOP
18792  F00C     NOP
18794  0E18     MOVLW 0x18
18796  D005     BRA 0x87A2
18798  90D8     BCF 0xFD8, 0, ACCESS
1879A  320C     RRCF 0xC, F, ACCESS
1879C  320B     RRCF wtemp5, F, ACCESS
1879E  320A     RRCF ttemp3, F, ACCESS
187A0  3209     RRCF ltemp2, F, ACCESS
187A2  2EE8     DECFSZ 0xFE8, F, ACCESS
187A4  D7F9     BRA 0x8798
187A8  F024     NOP
187AA  F007     NOP
187AE  F028     NOP
187B0  F008     NOP
187B2  0EFF     MOVLW 0xFF
187B4  1607     ANDWF ttemp2, F, ACCESS
187B6  0E00     MOVLW 0x0
187B8  1608     ANDWF 0x8, F, ACCESS
187BA  0EFE     MOVLW 0xFE
187BE  F01F     NOP
187C0  FFE3     NOP
187C2  0EFF     MOVLW 0xFF
187C6  F023     NOP
187C8  FFE3     NOP
8:             	if (!e) return u.i<<1 ? FP_SUBNORMAL : FP_ZERO;
187CA  0EFE     MOVLW 0xFE
187CE  FF8C     NOP
187D0  F001     NOP
187D2  0EFF     MOVLW 0xFF
187D4  50E3     MOVF 0xFE3, W, ACCESS
187D6  1001     IORWF ltemp0, W, ACCESS
187D8  A4D8     BTFSS 0xFD8, 2, ACCESS
187DA  D023     BRA 0x8822
187DC  0EFA     MOVLW 0xFA
187E0  FF8C     NOP
187E2  F009     NOP
187E4  0EFB     MOVLW 0xFB
187E8  FF8C     NOP
187EA  F00A     NOP
187EC  0EFC     MOVLW 0xFC
187F0  FF8C     NOP
187F2  F00B     NOP
187F4  0EFD     MOVLW 0xFD
187F8  FF8C     NOP
187FA  F00C     NOP
187FC  90D8     BCF 0xFD8, 0, ACCESS
187FE  3409     RLCF ltemp2, W, ACCESS
18800  6E05     MOVWF ltemp1, ACCESS
18802  340A     RLCF ttemp3, W, ACCESS
18804  6E06     MOVWF 0x6, ACCESS
18806  340B     RLCF wtemp5, W, ACCESS
18808  6E07     MOVWF ttemp2, ACCESS
1880A  340C     RLCF 0xC, W, ACCESS
1880C  6E08     MOVWF 0x8, ACCESS
1880E  5005     MOVF ltemp1, W, ACCESS
18810  1006     IORWF 0x6, W, ACCESS
18812  1007     IORWF ttemp2, W, ACCESS
18814  1008     IORWF 0x8, W, ACCESS
18816  A4D8     BTFSS 0xFD8, 2, ACCESS
18818  D002     BRA 0x881E
1881A  0E02     MOVLW 0x2
1881C  D02E     BRA 0x887A
1881E  0E03     MOVLW 0x3
18820  D02C     BRA 0x887A
9:             	if (e==0xff) return u.i<<9 ? FP_NAN : FP_INFINITE;
18822  0EFE     MOVLW 0xFE
18824  28E3     INCF 0xFE3, W, ACCESS
18826  E128     BNZ 0x8878
18828  0EFF     MOVLW 0xFF
1882A  50E3     MOVF 0xFE3, W, ACCESS
1882C  A4D8     BTFSS 0xFD8, 2, ACCESS
1882E  D024     BRA 0x8878
18830  0EFA     MOVLW 0xFA
18834  FF8C     NOP
18836  F009     NOP
18838  0EFB     MOVLW 0xFB
1883C  FF8C     NOP
1883E  F00A     NOP
18840  0EFC     MOVLW 0xFC
18844  FF8C     NOP
18846  F00B     NOP
18848  0EFD     MOVLW 0xFD
1884C  FF8C     NOP
1884E  F00C     NOP
18850  0E09     MOVLW 0x9
18852  90D8     BCF 0xFD8, 0, ACCESS
18854  3609     RLCF ltemp2, F, ACCESS
18856  360A     RLCF ttemp3, F, ACCESS
18858  360B     RLCF wtemp5, F, ACCESS
1885A  360C     RLCF 0xC, F, ACCESS
1885C  2EE8     DECFSZ 0xFE8, F, ACCESS
1885E  D7F9     BRA 0x8852
18860  5009     MOVF ltemp2, W, ACCESS
18862  100A     IORWF ttemp3, W, ACCESS
18864  100B     IORWF wtemp5, W, ACCESS
18866  100C     IORWF 0xC, W, ACCESS
18868  A4D8     BTFSS 0xFD8, 2, ACCESS
1886A  D002     BRA 0x8870
1886C  0E01     MOVLW 0x1
1886E  D001     BRA 0x8872
18870  0E00     MOVLW 0x0
18872  6E01     MOVWF ltemp0, ACCESS
18874  6A02     CLRF ttemp5, ACCESS
18876  D004     BRA 0x8880
10:            	return FP_NORMAL;
18878  0E04     MOVLW 0x4
1887A  6E01     MOVWF ltemp0, ACCESS
1887C  0E00     MOVLW 0x0
1887E  6E02     MOVWF ttemp5, ACCESS
11:            }
18880  0EF6     MOVLW 0xF6
18882  26E1     ADDWF 0xFE1, F, ACCESS
18884  0EFF     MOVLW 0xFF
18886  22E2     ADDWFC 0xFE2, F, ACCESS
18888  0012     RETURN 0
