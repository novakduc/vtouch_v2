Disassembly Listing for q43_ntsc
Generated From:
/fred/pic18_k42/q43_board/q43_ntsc.X/dist/default/production/q43_ntsc.X.production.elf
Jan 19, 2021 3:36:37 PM

---  /tmp/xcXcmKFpc.s  ----------------------------------------------------------------------------------
10CC2  0E00     MOVLW 0x0
10CC4  6EF6     MOVWF 0xFF6, ACCESS
10CC6  0E00     MOVLW 0x0
10CC8  6EF7     MOVWF 0xFF7, ACCESS
10CCA  0E01     MOVLW 0x1
10CCC  6EF8     MOVWF 0xFF8, ACCESS
10CCE  EE02     LFSR 0, 0xB00
10CD2  EE11     LFSR 1, 0x400
10CD6  0009     TBLRD*+
10CD8  C4F5     MOVFF TABLAT, POSTINC0
10CDC  50E5     MOVF 0xFE5, W, ACCESS
10CDE  50E1     MOVF 0xFE1, W, ACCESS
10CE0  E1FA     BNZ 0xCD6
10CE2  50E2     MOVF 0xFE2, W, ACCESS
10CE4  E1F8     BNZ 0xCD6
10CE6  0E2A     MOVLW 0x2A
10CE8  6EF6     MOVWF 0xFF6, ACCESS
10CEA  0E1C     MOVLW 0x1C
10CEC  6EF7     MOVWF 0xFF7, ACCESS
10CEE  0E01     MOVLW 0x1
10CF0  6EF8     MOVWF 0xFF8, ACCESS
10CF2  EE01     LFSR 0, 0x5F4
10CF6  EE10     LFSR 1, 0xB
10CFA  0009     TBLRD*+
10CFC  C4F5     MOVFF TABLAT, POSTINC0
10D00  50E5     MOVF 0xFE5, W, ACCESS
10D02  50E1     MOVF 0xFE1, W, ACCESS
10D04  E1FA     BNZ 0xCFA
10D06  0E9C     MOVLW 0x9C
10D08  6EF6     MOVWF 0xFF6, ACCESS
10D0A  0E1C     MOVLW 0x1C
10D0C  6EF7     MOVWF 0xFF7, ACCESS
10D0E  0E01     MOVLW 0x1
10D10  6EF8     MOVWF 0xFF8, ACCESS
10D12  0009     TBLRD*+
10D1A  0009     TBLRD*+
10D22  0009     TBLRD*+
10D2A  EE02     LFSR 0, 0xA00
10D2E  EE10     LFSR 1, 0x100
10D32  6AEE     CLRF 0xFEE, ACCESS
10D34  50E5     MOVF 0xFE5, W, ACCESS
10D36  50E1     MOVF 0xFE1, W, ACCESS
10D38  E1FC     BNZ 0xD32
10D3A  50E2     MOVF 0xFE2, W, ACCESS
10D3C  E1FA     BNZ 0xD32
10D3E  EE02     LFSR 0, 0x900
10D42  EE10     LFSR 1, 0x100
10D46  6AEE     CLRF 0xFEE, ACCESS
10D48  50E5     MOVF 0xFE5, W, ACCESS
10D4A  50E1     MOVF 0xFE1, W, ACCESS
10D4C  E1FC     BNZ 0xD46
10D4E  50E2     MOVF 0xFE2, W, ACCESS
10D50  E1FA     BNZ 0xD46
10D52  EE02     LFSR 0, 0x800
10D56  EE10     LFSR 1, 0x100
10D5A  6AEE     CLRF 0xFEE, ACCESS
10D5C  50E5     MOVF 0xFE5, W, ACCESS
10D5E  50E1     MOVF 0xFE1, W, ACCESS
10D60  E1FC     BNZ 0xD5A
10D62  50E2     MOVF 0xFE2, W, ACCESS
10D64  E1FA     BNZ 0xD5A
10D66  EE01     LFSR 0, 0x700
10D6A  EE10     LFSR 1, 0x100
10D6E  6AEE     CLRF 0xFEE, ACCESS
10D70  50E5     MOVF 0xFE5, W, ACCESS
10D72  50E1     MOVF 0xFE1, W, ACCESS
10D74  E1FC     BNZ 0xD6E
10D76  50E2     MOVF 0xFE2, W, ACCESS
10D78  E1FA     BNZ 0xD6E
10D7A  EE01     LFSR 0, 0x600
10D7E  0EE3     MOVLW 0xE3
10D80  6AEE     CLRF 0xFEE, ACCESS
10D82  06E8     DECF 0xFE8, F, ACCESS
10D84  E1FD     BNZ 0xD80
10D86  EE01     LFSR 0, 0x560
10D8A  0E94     MOVLW 0x94
10D8C  6AEE     CLRF 0xFEE, ACCESS
10D8E  06E8     DECF 0xFE8, F, ACCESS
10D90  E1FD     BNZ 0xD8C
10D92  EE01     LFSR 0, 0x540
10D96  0E0D     MOVLW 0xD
10D98  6AEE     CLRF 0xFEE, ACCESS
10D9A  06E8     DECF 0xFE8, F, ACCESS
10D9C  E1FD     BNZ 0xD98
10D9E  0104     MOVLB 0x4
10DA0  0E08     MOVLW 0x8
10DA2  6F5D     MOVWF 0x5D, BANKED
10DA4  0E00     MOVLW 0x0
10DA6  6F5E     MOVWF 0x5E, BANKED
10DA8  0E00     MOVLW 0x0
10DAA  6F5F     MOVWF 0x5F, BANKED
10DAC  0100     MOVLB 0x0
10DAE  EFD9     GOTO 0x10DB2
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
11658  C50E     MOVFF InterruptHandler, blockSize
1165A  F510     NOP
1165C  C50F     MOVFF 0x50F, chr
1165E  F511     NOP
8:             	while(*s) {
11660  D002     BRA 0x1666
11668  F438     NOP
1166A  F4F6     NOP
1166E  F43C     NOP
11670  F4F7     NOP
11672  0E00     MOVLW 0x0
11674  6EF8     MOVWF 0xFF8, ACCESS
11676  0E25     MOVLW 0x25
11678  64F7     CPFSGT 0xFF7, ACCESS
1167A  D003     BRA 0x1682
1167C  0008     TBLRD*
1167E  50F5     MOVF 0xFF5, W, ACCESS
11680  D005     BRA 0x168C
11682  C4F6     MOVFF TBLPTR, FSR0
11684  F4E9     NOP
11686  C4F7     MOVFF TBLPTRH, FSR0H
11688  F4EA     NOP
1168A  50EF     MOVF 0xFEF, W, ACCESS
1168C  0900     IORLW 0x0
1168E  A4D8     BTFSS 0xFD8, 2, ACCESS
11690  D7E8     BRA 0x1662
9:             		s++;
11662  4A0E     INFSNZ 0xE, F, ACCESS
11664  2A0F     INCF 0xF, F, ACCESS
10:            	}
11:            	return (size_t)(s-a);
11692  5010     MOVF 0x10, W, ACCESS
11694  5C0E     SUBWF 0xE, W, ACCESS
11696  6E0E     MOVWF 0xE, ACCESS
11698  5011     MOVF 0x11, W, ACCESS
1169A  580F     SUBWFB 0xF, W, ACCESS
1169C  6E0F     MOVWF 0xF, ACCESS
12:            }
1169E  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/putch.c  -------------------------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
11CA0  0012     RETURN 0
10:            
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_sprintf.c  --------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
114DA  0EE7     MOVLW 0xE7
114DC  6FEB     MOVWF DMAnDCNTH, BANKED
114DE  0E06     MOVLW 0x6
114E0  6FEC     MOVWF DMAnDPTR, BANKED
16:            	f.buffer = s;
114E2  C6E3     MOVFF __pcstackBANK6, f
114E4  F6ED     NOP
114E6  C6E4     MOVFF 0x6E4, 0x6EE
114E8  F6EE     NOP
17:            	f.count = 0;
114EA  0E00     MOVLW 0x0
114EC  6FF0     MOVWF DMAnDSA, BANKED
114EE  0E00     MOVLW 0x0
114F0  6FEF     MOVWF DMAnDSZH, BANKED
18:            	f.limit = 0;
114F2  0E00     MOVLW 0x0
114F4  6FF2     MOVWF DMAnSCNT, BANKED
114F6  0E00     MOVLW 0x0
114F8  6FF1     MOVWF DMAnDSAH, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
114FA  0EED     MOVLW 0xED
114FC  6E37     MOVWF 0x37, ACCESS
114FE  0E06     MOVLW 0x6
11500  6E38     MOVWF 0x38, ACCESS
11502  C6E5     MOVFF fmt, fmt
11504  F539     NOP
11506  C6E6     MOVFF 0x6E6, 0x53A
11508  F53A     NOP
1150A  0EEB     MOVLW 0xEB
1150C  6E3B     MOVWF 0x3B, ACCESS
1150E  0E06     MOVLW 0x6
11510  6E3C     MOVWF 0x3C, ACCESS
11512  ECBD     CALL 0x1137A, 0
11514  F089     NOP
20:            	s[f.count] = '\0';
11516  0106     MOVLB 0x6
11518  51EF     MOVF DMAnDSZH, W, BANKED
1151A  25E3     ADDWF 0xE3, W, BANKED
1151C  6ED9     MOVWF 0xFD9, ACCESS
1151E  51F0     MOVF DMAnDSA, W, BANKED
11520  21E4     ADDWFC 0xE4, W, BANKED
11522  6EDA     MOVWF 0xFDA, ACCESS
11524  0E00     MOVLW 0x0
11526  6EDF     MOVWF 0xFDF, ACCESS
21:            	va_end(ap);
22:            	return ret;
23:            }
11528  0012     RETURN 0
24:            
25:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
110CE  5010     MOVF 0x10, W, ACCESS
110D0  1011     IORWF 0x11, W, ACCESS
110D2  B4D8     BTFSC 0xFD8, 2, ACCESS
110D4  D004     BRA 0x10DE
110D6  5010     MOVF 0x10, W, ACCESS
110D8  1011     IORWF 0x11, W, ACCESS
110DA  A4D8     BTFSS 0xFD8, 2, ACCESS
110DC  D004     BRA 0x10E6
13:                    putch((char)c);
110DE  500E     MOVF 0xE, W, ACCESS
110E0  EC50     CALL 0x11CA0, 0
110E2  F08E     NOP
14:                } else {
110E4  0012     RETURN 0
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
110E6  EE20     LFSR 2, 0x4
110E8  F004     NOP
110EA  5010     MOVF 0x10, W, ACCESS
110EC  26D9     ADDWF 0xFD9, F, ACCESS
110EE  5011     MOVF 0x11, W, ACCESS
110F0  22DA     ADDWFC 0xFDA, F, ACCESS
110F2  50DE     MOVF 0xFDE, W, ACCESS
110F4  10DE     IORWF 0xFDE, W, ACCESS
110F6  B4D8     BTFSC 0xFD8, 2, ACCESS
110F8  D016     BRA 0x1126
110FA  EE20     LFSR 2, 0x4
110FC  F004     NOP
110FE  5010     MOVF 0x10, W, ACCESS
11100  26D9     ADDWF 0xFD9, F, ACCESS
11102  5011     MOVF 0x11, W, ACCESS
11104  22DA     ADDWFC 0xFDA, F, ACCESS
11106  EE10     LFSR 1, 0x2
11108  F002     NOP
1110A  5010     MOVF 0x10, W, ACCESS
1110C  26E1     ADDWF 0xFE1, F, ACCESS
1110E  5011     MOVF 0x11, W, ACCESS
11110  22E2     ADDWFC 0xFE2, F, ACCESS
11112  50DE     MOVF 0xFDE, W, ACCESS
11114  5CE6     SUBWF 0xFE6, W, ACCESS
11116  50E6     MOVF 0xFE6, W, ACCESS
11118  0A80     XORLW 0x80
1111A  6E16     MOVWF 0x16, ACCESS
1111C  50DE     MOVF 0xFDE, W, ACCESS
1111E  0A80     XORLW 0x80
11120  5816     SUBWFB 0x16, W, ACCESS
11122  B0D8     BTFSC 0xFD8, 0, ACCESS
11124  0012     RETURN 0
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
11126  EE20     LFSR 2, 0x2
11128  F002     NOP
1112A  5010     MOVF 0x10, W, ACCESS
1112C  26D9     ADDWF 0xFD9, F, ACCESS
1112E  5011     MOVF 0x11, W, ACCESS
11130  22DA     ADDWFC 0xFDA, F, ACCESS
11134  F378     NOP
11136  F512     NOP
1113A  F374     NOP
1113C  F513     NOP
11140  F440     NOP
11142  F4D9     NOP
11146  F444     NOP
11148  F4DA     NOP
1114C  F378     NOP
1114E  F514     NOP
11152  F374     NOP
11154  F515     NOP
11156  5012     MOVF 0x12, W, ACCESS
11158  2414     ADDWF 0x14, W, ACCESS
1115A  6ED9     MOVWF 0xFD9, ACCESS
1115C  5013     MOVF 0x13, W, ACCESS
1115E  2015     ADDWFC 0x15, W, ACCESS
11160  6EDA     MOVWF 0xFDA, ACCESS
11164  F438     NOP
11166  F4DF     NOP
19:            #pragma warning pop
20:            			++fp->count;
11168  EE20     LFSR 2, 0x2
1116A  F002     NOP
1116C  5010     MOVF 0x10, W, ACCESS
1116E  26D9     ADDWF 0xFD9, F, ACCESS
11170  5011     MOVF 0x11, W, ACCESS
11172  22DA     ADDWFC 0xFDA, F, ACCESS
11174  2ADE     INCF 0xFDE, F, ACCESS
11176  0E00     MOVLW 0x0
11178  22DD     ADDWFC 0xFDD, F, ACCESS
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
1117A  0012     RETURN 0
25:            
26:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/memset.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
10A2E  C50E     MOVFF InterruptHandler, tmp
10A30  F518     NOP
10A32  C50F     MOVFF 0x50F, _this
10A34  F519     NOP
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
10A36  5012     MOVF 0x12, W, ACCESS
10A38  1013     IORWF 0x13, W, ACCESS
10A3A  B4D8     BTFSC 0xFD8, 2, ACCESS
10A3C  0012     RETURN 0
14:            	s[0] = (unsigned char)c;
10A40  F460     NOP
10A42  F4D9     NOP
10A46  F464     NOP
10A48  F4DA     NOP
10A4C  F440     NOP
10A4E  F4DF     NOP
15:            	s[n-1] = (unsigned char)c;
10A50  5012     MOVF 0x12, W, ACCESS
10A52  2418     ADDWF 0x18, W, ACCESS
10A54  6E14     MOVWF 0x14, ACCESS
10A56  5013     MOVF 0x13, W, ACCESS
10A58  2019     ADDWFC 0x19, W, ACCESS
10A5A  6E15     MOVWF 0x15, ACCESS
10A5C  0EFF     MOVLW 0xFF
10A5E  2414     ADDWF 0x14, W, ACCESS
10A60  6ED9     MOVWF 0xFD9, ACCESS
10A62  0EFF     MOVLW 0xFF
10A64  2015     ADDWFC 0x15, W, ACCESS
10A66  6EDA     MOVWF 0xFDA, ACCESS
10A6A  F440     NOP
10A6C  F4DF     NOP
16:            	if (n <= 2) return dest;
10A6E  5013     MOVF 0x13, W, ACCESS
10A70  E104     BNZ 0xA7A
10A72  0E03     MOVLW 0x3
10A74  5C12     SUBWF 0x12, W, ACCESS
10A76  A0D8     BTFSS 0xFD8, 0, ACCESS
10A78  0012     RETURN 0
17:            	s[1] = (unsigned char)c;
10A7A  EE20     LFSR 2, 0x1
10A7C  F001     NOP
10A7E  5018     MOVF 0x18, W, ACCESS
10A80  26D9     ADDWF 0xFD9, F, ACCESS
10A82  5019     MOVF 0x19, W, ACCESS
10A84  22DA     ADDWFC 0xFDA, F, ACCESS
10A88  F440     NOP
10A8A  F4DF     NOP
18:            	s[2] = (unsigned char)c;
10A8C  EE20     LFSR 2, 0x2
10A8E  F002     NOP
10A90  5018     MOVF 0x18, W, ACCESS
10A92  26D9     ADDWF 0xFD9, F, ACCESS
10A94  5019     MOVF 0x19, W, ACCESS
10A96  22DA     ADDWFC 0xFDA, F, ACCESS
10A9A  F440     NOP
10A9C  F4DF     NOP
19:            	s[n-2] = (unsigned char)c;
10A9E  5012     MOVF 0x12, W, ACCESS
10AA0  2418     ADDWF 0x18, W, ACCESS
10AA2  6E14     MOVWF 0x14, ACCESS
10AA4  5013     MOVF 0x13, W, ACCESS
10AA6  2019     ADDWFC 0x19, W, ACCESS
10AA8  6E15     MOVWF 0x15, ACCESS
10AAA  0EFE     MOVLW 0xFE
10AAC  2414     ADDWF 0x14, W, ACCESS
10AAE  6ED9     MOVWF 0xFD9, ACCESS
10AB0  0EFF     MOVLW 0xFF
10AB2  2015     ADDWFC 0x15, W, ACCESS
10AB4  6EDA     MOVWF 0xFDA, ACCESS
10AB8  F440     NOP
10ABA  F4DF     NOP
20:            	s[n-3] = (unsigned char)c;
10ABC  5012     MOVF 0x12, W, ACCESS
10ABE  2418     ADDWF 0x18, W, ACCESS
10AC0  6E14     MOVWF 0x14, ACCESS
10AC2  5013     MOVF 0x13, W, ACCESS
10AC4  2019     ADDWFC 0x19, W, ACCESS
10AC6  6E15     MOVWF 0x15, ACCESS
10AC8  0EFD     MOVLW 0xFD
10ACA  2414     ADDWF 0x14, W, ACCESS
10ACC  6ED9     MOVWF 0xFD9, ACCESS
10ACE  0EFF     MOVLW 0xFF
10AD0  2015     ADDWFC 0x15, W, ACCESS
10AD2  6EDA     MOVWF 0xFDA, ACCESS
10AD6  F440     NOP
10AD8  F4DF     NOP
21:            	if (n <= 6) return dest;
10ADA  5013     MOVF 0x13, W, ACCESS
10ADC  E104     BNZ 0xAE6
10ADE  0E07     MOVLW 0x7
10AE0  5C12     SUBWF 0x12, W, ACCESS
10AE2  A0D8     BTFSS 0xFD8, 0, ACCESS
10AE4  0012     RETURN 0
22:            	s[3] = (unsigned char)c;
10AE6  EE20     LFSR 2, 0x3
10AE8  F003     NOP
10AEA  5018     MOVF 0x18, W, ACCESS
10AEC  26D9     ADDWF 0xFD9, F, ACCESS
10AEE  5019     MOVF 0x19, W, ACCESS
10AF0  22DA     ADDWFC 0xFDA, F, ACCESS
10AF4  F440     NOP
10AF6  F4DF     NOP
23:            	s[n-4] = (unsigned char)c;
10AF8  5012     MOVF 0x12, W, ACCESS
10AFA  2418     ADDWF 0x18, W, ACCESS
10AFC  6E14     MOVWF 0x14, ACCESS
10AFE  5013     MOVF 0x13, W, ACCESS
10B00  2019     ADDWFC 0x19, W, ACCESS
10B02  6E15     MOVWF 0x15, ACCESS
10B04  0EFC     MOVLW 0xFC
10B06  2414     ADDWF 0x14, W, ACCESS
10B08  6ED9     MOVWF 0xFD9, ACCESS
10B0A  0EFF     MOVLW 0xFF
10B0C  2015     ADDWFC 0x15, W, ACCESS
10B0E  6EDA     MOVWF 0xFDA, ACCESS
10B12  F440     NOP
10B14  F4DF     NOP
24:            	if (n <= 8) return dest;
10B16  5013     MOVF 0x13, W, ACCESS
10B18  E104     BNZ 0xB22
10B1A  0E09     MOVLW 0x9
10B1C  5C12     SUBWF 0x12, W, ACCESS
10B1E  A0D8     BTFSS 0xFD8, 0, ACCESS
10B20  0012     RETURN 0
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
10B22  C518     MOVFF tmp, d
10B24  F514     NOP
10B26  C519     MOVFF _this, 0x515
10B28  F515     NOP
10B2A  1E14     COMF 0x14, F, ACCESS
10B2C  1E15     COMF 0x15, F, ACCESS
10B2E  4A14     INFSNZ 0x14, F, ACCESS
10B30  2A15     INCF 0x15, F, ACCESS
10B32  0E03     MOVLW 0x3
10B34  1414     ANDWF 0x14, W, ACCESS
10B36  6E16     MOVWF 0x16, ACCESS
10B38  6A17     CLRF 0x17, ACCESS
32:            	s += k;
10B3A  5016     MOVF 0x16, W, ACCESS
10B3C  2618     ADDWF 0x18, F, ACCESS
10B3E  5017     MOVF 0x17, W, ACCESS
10B40  2219     ADDWFC 0x19, F, ACCESS
33:            	n -= k;
10B42  5016     MOVF 0x16, W, ACCESS
10B44  5E12     SUBWF 0x12, F, ACCESS
10B46  5017     MOVF 0x17, W, ACCESS
10B48  5A13     SUBWFB 0x13, F, ACCESS
34:            	n &= (size_t)-4;
10B4A  0EFC     MOVLW 0xFC
10B4C  1612     ANDWF 0x12, F, ACCESS
10B4E  0EFF     MOVLW 0xFF
10B50  1613     ANDWF 0x13, F, ACCESS
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
10B52  D00E     BRA 0xB70
10B56  F460     NOP
10B58  F4D9     NOP
10B5C  F464     NOP
10B5E  F4DA     NOP
10B62  F440     NOP
10B64  F4DF     NOP
10B66  0612     DECF 0x12, F, ACCESS
10B68  A0D8     BTFSS 0xFD8, 0, ACCESS
10B6A  0613     DECF 0x13, F, ACCESS
10B6C  4A18     INFSNZ 0x18, F, ACCESS
10B6E  2A19     INCF 0x19, F, ACCESS
10B70  5012     MOVF 0x12, W, ACCESS
10B72  1013     IORWF 0x13, W, ACCESS
10B74  B4D8     BTFSC 0xFD8, 2, ACCESS
10B76  0012     RETURN 0
10B78  D7ED     BRA 0xB54
87:            #endif
88:            
89:            	return dest;
90:            }
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/memcpy.c  ------------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
1152A  C510     MOVFF blockSize, s
1152C  F516     NOP
1152E  C511     MOVFF chr, fp
11530  F517     NOP
12:            	d = d1;
11532  C50E     MOVFF InterruptHandler, d
11534  F514     NOP
11536  C50F     MOVFF 0x50F, 0x515
11538  F515     NOP
13:            	while(n--) {
1153A  D015     BRA 0x1566
11566  0612     DECF 0x12, F, ACCESS
14:            		tmp = *s++;
1153E  F458     NOP
11540  F4D9     NOP
11544  F45C     NOP
11546  F4DA     NOP
11548  50DF     MOVF 0xFDF, W, ACCESS
1154A  6E18     MOVWF 0x18, ACCESS
1154C  4A16     INFSNZ 0x16, F, ACCESS
1154E  2A17     INCF 0x17, F, ACCESS
15:            		*d++ = tmp;
11552  F450     NOP
11554  F4D9     NOP
11558  F454     NOP
1155A  F4DA     NOP
1155E  F460     NOP
11560  F4DF     NOP
11562  4A14     INFSNZ 0x14, F, ACCESS
11564  2A15     INCF 0x15, F, ACCESS
11566  0612     DECF 0x12, F, ACCESS
11568  A0D8     BTFSS 0xFD8, 0, ACCESS
1156A  0613     DECF 0x13, F, ACCESS
1156C  2812     INCF 0x12, W, ACCESS
1156E  E1E6     BNZ 0x153C
11570  2813     INCF 0x13, W, ACCESS
11572  B4D8     BTFSC 0xFD8, 2, ACCESS
11574  0012     RETURN 0
11576  D7E2     BRA 0x153C
16:            	}
17:            	return d1;
18:            }
19:            
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
78:                    fputs((const char *)buf, fp);
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
83:                i = 0;
84:                while (i < w) {
85:                    fputc(' ', fp);
86:                    ++i;
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
91:                    fputs((const char *)buf, fp);
92:                }
93:            
94:                return (int)(strlen(buf) + (size_t)w);
95:            }
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = (char)d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Left justify ? Put out character */
267:               if (flags & MINUS_FLAG) {
268:                   fputc(c, fp);
269:               }
270:               /* Put out padding */
271:               w = (w < 0) ? 0 : w;
272:               l = 0;
273:               while (l < w) {
274:                   fputc(' ', fp);
275:                   ++l;
276:               }
277:               /* Right justify ? Put out string */
278:               if (!(flags & MINUS_FLAG)) {
279:                   fputc(c, fp);
280:               }
281:           
282:               return l+1;
283:           }
284:           #endif
285:           
286:           #ifdef _VFPF_D
287:           static _INLINE int dtoa(FILE *fp, long long d)
288:           {
289:               int i, p, s, w;
290:               long long n;
291:           
292:               /* Record sign, get absolute value */
293:               n = d;
294:               s = n < 0 ? 1 : 0;
295:               if (s) {
296:                   n = -n;
297:               }
298:           
299:               /* Adjust flags, precision, width */
300:               if (!(prec < 0)) {
301:                   flags &= ~ZERO_FLAG;
302:               }
303:               p = (0 < prec) ? prec : 1;
304:               w = width;
305:               if (s || (flags & PLUS_FLAG)) {
306:                   --w;
307:               }
308:           
309:               /* Convert to decimal, possibly filling on the left with zeroes */
310:               i = sizeof(dbuf) - 1;
311:               dbuf[i] = '\0';
312:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
313:                   --i;
314:                   dbuf[i] = (char)((int)'0' + abs(n % 10));
315:                   --p;
316:                   --w;
317:                   n = n / 10;
318:               }
319:           
320:               /* Display sign if required */
321:               if (s || (flags & PLUS_FLAG)) {
322:                   --i;
323:                   dbuf[i] = s ? '-' : '+';
324:               }
325:           
326:               /* Put out padded string */
327:               return pad(fp, &dbuf[i], w);
328:           }
329:           #endif
330:           
331:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
332:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
333:           {
334:               char mode, nmode;
335:               int d, e, i, m, n, ne, p, pp, sign, t, w;
336:               long double g, h, l, ou, u;
337:           
338:               /* Record sign, get absolute value */
339:               sign = 0;
340:               g = f;
341:               if (g < 0.0) {
342:                   sign = 1;
343:                   g = -g;
344:               }
345:           
346:               /* Print sign */
347:               n = 0;
348:               w = width;
349:               if (sign || (flags & PLUS_FLAG)) {
350:                   dbuf[n] = sign ? '-' : '+';
351:                   ++n;
352:                   --w;
353:               }
354:           
355:               /* Catch infinities, NaNs here */
356:               if (isinf(g)) {
357:                   if (isupper((int)c)) {
358:                       strcpy(&dbuf[n], "INF");
359:                   } else {
360:                       strcpy(&dbuf[n], "inf");
361:                   }
362:                   w -= CSTRLEN("inf");
363:                   return pad(fp, &dbuf[0], w);
364:               }
365:               if (isnan(g)) {
366:                   if (isupper((int)c)) {
367:                       strcpy(&dbuf[n], "NAN");
368:                   } else {
369:                       strcpy(&dbuf[n], "nan");
370:                   }
371:                   w -= CSTRLEN("inf");
372:                   return pad(fp, &dbuf[0], w);
373:               }
374:           
375:               /* First find the largest power of 10 not larger than number to print */
376:               u = 1.0;
377:               e = 0;
378:               if (!(g == 0.0)) {
379:                   while (!(g < (u*10.0))) {
380:                       u = u*10.0;
381:                       ++e;
382:                   }
383:                   while (g < u) {
384:                       u = u/10.0;
385:                       --e;
386:                   }
387:               }
388:           
389:               /* Get mode, precision */
390:               mode = (char)tolower((int)c);
391:               nmode = mode;
392:               if (mode == 'g') {
393:           		if (prec == 0) {
394:           			prec = 1;
395:           		}
396:                   p = (0 < prec) ? prec : 6;
397:               } else {
398:                   p = (prec < 0) ? 6 : prec;
399:               }
400:           
401:               /* Choose e or f mode from g mode */
402:               if (mode == 'g') {
403:                   if (!(e < -4) && !((p - 1) < e)) {
404:                       nmode = 'f';
405:                   } else {
406:                       nmode = 'e';
407:                   }
408:               }
409:           
410:               /* Decimal places or significant digits */
411:               m = p;
412:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
413:                   ++m;
414:               }
415:           
416:               /* Adjust starting exponent, string length for 'f' conversions */
417:               if (nmode == 'f') {
418:                   if (e < 0) {
419:                       u = 1.0;
420:                       e = 0;
421:                   }
422:                   if (!(mode == 'g')) {
423:                       m += e;
424:                   }
425:               }
426:           
427:               /* Go through the conversion once to get to the rounding step */
428:               i = 0;
429:               h = g;
430:               ou = u;
431:               while (i < m) {
432:                   l = floor(h/u);
433:                   d = (int)l;
434:                   h -= l*u;
435:                   u = u/10.0;
436:                   ++i;
437:               }
438:               
439:               /* Remainder >= halfway ? */
440:               l = u*5.0;
441:               if (h < l) {
442:                   l = 0.0;
443:               } else {
444:                   /* On tie choose even number */
445:                   if ((h == l) && !(d % 2)) {
446:                       l = 0.0;
447:                   }
448:               }
449:           
450:               /* Round */
451:               h = g + l;
452:               /* Has rounding increased the power above 10^0? */
453:           	if (h >= (ou*10.0)) {
454:           		e++;
455:           		ou *= 10.0;
456:           		if (nmode == 'f') {
457:           			// the increase in power will only affect the number of digits in 'f' mode
458:           			m++;
459:           		}
460:           	}
461:               
462:               /* Convert again, after rounding */
463:               u = ou;
464:               ne = (nmode == 'e') ? 0 : e;
465:               pp = 0;
466:               t = 0;
467:               i = 0;
468:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
469:                   l = floor(h/u);
470:                   d = (int)l;
471:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
472:                       ++t;
473:                   } else {
474:                       if (!pp && (ne < 0)) {
475:                           dbuf[n++] = '.';
476:                           --w;
477:                           pp = 1;
478:                       }
479:                       while (t) {
480:                           dbuf[n++] = '0';
481:                           --w;
482:                           --t;
483:                       }
484:                       dbuf[n++] = (char)((int)'0' + d);
485:                       --w;
486:                   }
487:                   h -= l*u;
488:                   u = u/10.0;
489:                   --ne;
490:                   ++i;
491:               }
492:               if (!pp && (flags & POUND_FLAG)) {
493:                   dbuf[n++] = '.';
494:               }
495:               dbuf[n] = '\0';
496:           
497:               /* Convert exponent */
498:               if (nmode == 'e') {
499:                   i = sizeof(dbuf) - 1;
500:                   dbuf[i] = '\0';
501:                   sign = 0;
502:                   if (e < 0) {
503:                       sign = 1;
504:                       e = -e;
505:                   }
506:                   p = 2;
507:                   while (e || (0 < p)) {
508:                       --i;
509:                       dbuf[i] = '0' + (e % 10);
510:                       e = e / 10;
511:                       --p;
512:                       --w;
513:                   }
514:                   --i;
515:                   dbuf[i] = sign ? '-' : '+';
516:                   --w;
517:                   --i;
518:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
519:                   --w;
520:                   strcpy(&dbuf[n], &dbuf[i]);
521:               }
522:           
523:               /* Put out padded string */
524:               return pad(fp, &dbuf[0], w);
525:           }
526:           #endif
527:           
528:           #ifdef _VFPF_O
529:           static _INLINE int otoa(FILE *fp, unsigned long long d)
530:           {
531:               int i, p, t, w;
532:               unsigned long long n;
533:           
534:               /* Adjust flags, precision, width */
535:               if (!(prec < 0)) {
536:                   flags &= ~ZERO_FLAG;
537:               }
538:               p = (0 < prec) ? prec : 1;
539:               w = width;
540:           
541:               /* Convert to octal, possibly filling on the left with zeroes */
542:               n = d;
543:               i = sizeof(dbuf) - 1;
544:               dbuf[i] = '\0';
545:               t = 0;
546:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
547:                   --i;
548:                   t = n & 07;
549:                   dbuf[i] = (char)((int)'0' + t);
550:                   --p;
551:                   --w;
552:                   n = n >> 3;
553:               }
554:           
555:               /* Display prefix if required */
556:               if ((flags & POUND_FLAG) && t) {
557:                   --i;
558:                   dbuf[i] = '0';
559:                   --w;
560:               }
561:           
562:               /* Put out padded string */
563:               return pad(fp, &dbuf[i], w);
564:           }
565:           #endif
566:           
567:           #ifdef _VFPF_S
568:           static _INLINE int stoa(FILE *fp, char *s)
569:           {
570:               char *cp, nuls[] = "(null)";
10B7A  EE21     LFSR 2, 0x5F4
10B7C  F1F4     NOP
10B7E  EE11     LFSR 1, 0x51C
10B80  F11C     NOP
10B82  0E06     MOVLW 0x6
10B84  C4DB     MOVFF PLUSW2, PLUSW1
10B86  F4E3     NOP
10B88  06E8     DECF 0xFE8, F, ACCESS
10B8A  E2FC     BC 0xB84
571:               int i, l, p, w;
572:           
573:               /* Check for null string */
574:               cp = s;
10B8C  C519     MOVFF _this, r
10B8E  F527     NOP
10B90  C51A     MOVFF _this, row
10B92  F528     NOP
575:               if (!cp) {
10B94  5027     MOVF 0x27, W, ACCESS
10B96  1028     IORWF 0x28, W, ACCESS
10B98  A4D8     BTFSS 0xFD8, 2, ACCESS
10B9A  D004     BRA 0xBA4
576:                   cp = nuls;
10B9C  0E1C     MOVLW 0x1C
10B9E  6E27     MOVWF 0x27, ACCESS
10BA0  0E05     MOVLW 0x5
10BA2  6E28     MOVWF 0x28, ACCESS
577:               }
578:           
579:               /* Get length, precision, width */
580:               l = (int)strlen(cp);
10BA4  C527     MOVFF r, InterruptHandler
10BA6  F50E     NOP
10BA8  C528     MOVFF row, 0x50F
10BAA  F50F     NOP
10BAC  EC2C     CALL 0x11658, 0
10BAE  F08B     NOP
10BB0  C50E     MOVFF InterruptHandler, l
10BB2  F52B     NOP
10BB4  C50F     MOVFF 0x50F, 0x52C
10BB6  F52C     NOP
581:               p = prec;
10BB8  C5E1     MOVFF prec, p
10BBA  F529     NOP
10BBC  C5E2     MOVFF 0x5E2, 0x52A
10BBE  F52A     NOP
582:               l = (!(p < 0) && (p < l)) ? p : l;
10BC0  BE2A     BTFSC 0x2A, 7, ACCESS
10BC2  D00E     BRA 0xBE0
10BC4  502B     MOVF 0x2B, W, ACCESS
10BC6  5C29     SUBWF 0x29, W, ACCESS
10BC8  502A     MOVF 0x2A, W, ACCESS
10BCA  0A80     XORLW 0x80
10BCC  6E1B     MOVWF 0x1B, ACCESS
10BCE  502C     MOVF 0x2C, W, ACCESS
10BD0  0A80     XORLW 0x80
10BD2  581B     SUBWFB 0x1B, W, ACCESS
10BD4  B0D8     BTFSC 0xFD8, 0, ACCESS
10BD6  D004     BRA 0xBE0
10BD8  C529     MOVFF p, l
10BDA  F52B     NOP
10BDC  C52A     MOVFF 0x52A, 0x52C
10BDE  F52C     NOP
583:               p = l;
10BE0  C52B     MOVFF l, p
10BE2  F529     NOP
10BE4  C52C     MOVFF 0x52C, 0x52A
10BE6  F52A     NOP
584:               w = width;
10BE8  C5DF     MOVFF width, w
10BEA  F525     NOP
10BEC  C5E0     MOVFF 0x5E0, 0x526
10BEE  F526     NOP
585:           
586:               /* Right justify, pad on left ? */
587:               if (!(flags & MINUS_FLAG)) {
10BF0  0105     MOVLB 0x5
10BF2  A1E3     BTFSS 0xE3, 0, BANKED
10BF4  D00D     BRA 0xC10
10BF6  D016     BRA 0xC24
588:                   while (l < w) {
10C10  5025     MOVF 0x25, W, ACCESS
10C12  5C2B     SUBWF 0x2B, W, ACCESS
10C14  502C     MOVF 0x2C, W, ACCESS
10C16  0A80     XORLW 0x80
10C18  6E1B     MOVWF 0x1B, ACCESS
10C1A  5026     MOVF 0x26, W, ACCESS
10C1C  0A80     XORLW 0x80
10C1E  581B     SUBWFB 0x1B, W, ACCESS
10C20  A0D8     BTFSS 0xFD8, 0, ACCESS
10C22  D7EA     BRA 0xBF8
589:                       fputc(' ', fp);
10BF8  0E00     MOVLW 0x0
10BFA  6E0F     MOVWF 0xF, ACCESS
10BFC  0E20     MOVLW 0x20
10BFE  6E0E     MOVWF 0xE, ACCESS
10C00  C517     MOVFF fp, blockSize
10C02  F510     NOP
10C04  C518     MOVFF tmp, chr
10C06  F511     NOP
10C08  EC67     CALL 0x110CE, 0
10C0A  F088     NOP
590:                       ++l;
10C0C  4A2B     INFSNZ 0x2B, F, ACCESS
10C0E  2A2C     INCF 0x2C, F, ACCESS
591:                   }
592:               }
593:           
594:               /* Put out string */
595:               i = 0;
10C24  0E00     MOVLW 0x0
10C26  6E24     MOVWF 0x24, ACCESS
10C28  0E00     MOVLW 0x0
10C2A  6E23     MOVWF 0x23, ACCESS
596:               while (i < p) {
10C2C  D021     BRA 0xC70
10C70  5029     MOVF 0x29, W, ACCESS
10C72  5C23     SUBWF 0x23, W, ACCESS
10C74  5024     MOVF 0x24, W, ACCESS
10C76  0A80     XORLW 0x80
10C78  6E1B     MOVWF 0x1B, ACCESS
10C7A  502A     MOVF 0x2A, W, ACCESS
10C7C  0A80     XORLW 0x80
10C7E  581B     SUBWFB 0x1B, W, ACCESS
10C80  A0D8     BTFSS 0xFD8, 0, ACCESS
10C82  D7D5     BRA 0xC2E
597:                   fputc(*cp, fp);
10C30  F49C     NOP
10C32  F4F6     NOP
10C36  F4A0     NOP
10C38  F4F7     NOP
10C3A  0E00     MOVLW 0x0
10C3C  6EF8     MOVWF 0xFF8, ACCESS
10C3E  0E25     MOVLW 0x25
10C40  64F7     CPFSGT 0xFF7, ACCESS
10C42  D003     BRA 0xC4A
10C44  0008     TBLRD*
10C46  50F5     MOVF 0xFF5, W, ACCESS
10C48  D005     BRA 0xC54
10C4A  C4F6     MOVFF TBLPTR, FSR0
10C4C  F4E9     NOP
10C4E  C4F7     MOVFF TBLPTRH, FSR0H
10C50  F4EA     NOP
10C52  50EF     MOVF 0xFEF, W, ACCESS
10C54  6E1B     MOVWF 0x1B, ACCESS
10C56  501B     MOVF 0x1B, W, ACCESS
10C58  6E0E     MOVWF 0xE, ACCESS
10C5A  6A0F     CLRF 0xF, ACCESS
10C5C  C517     MOVFF fp, blockSize
10C5E  F510     NOP
10C60  C518     MOVFF tmp, chr
10C62  F511     NOP
10C64  EC67     CALL 0x110CE, 0
10C66  F088     NOP
598:                   ++cp;
10C68  4A27     INFSNZ 0x27, F, ACCESS
10C6A  2A28     INCF 0x28, F, ACCESS
599:                   ++i;
10C6C  4A23     INFSNZ 0x23, F, ACCESS
10C6E  2A24     INCF 0x24, F, ACCESS
600:               }
601:           
602:               /* Left justify, pad on right ? */
603:               if (flags & MINUS_FLAG) {
10C84  0105     MOVLB 0x5
10C86  B1E3     BTFSC 0xE3, 0, BANKED
10C88  D00D     BRA 0xCA4
10C8A  D016     BRA 0xCB8
604:                   while (l < w) {
10CA4  5025     MOVF 0x25, W, ACCESS
10CA6  5C2B     SUBWF 0x2B, W, ACCESS
10CA8  502C     MOVF 0x2C, W, ACCESS
10CAA  0A80     XORLW 0x80
10CAC  6E1B     MOVWF 0x1B, ACCESS
10CAE  5026     MOVF 0x26, W, ACCESS
10CB0  0A80     XORLW 0x80
10CB2  581B     SUBWFB 0x1B, W, ACCESS
10CB4  A0D8     BTFSS 0xFD8, 0, ACCESS
10CB6  D7EA     BRA 0xC8C
605:                       fputc(' ', fp);
10C8C  0E00     MOVLW 0x0
10C8E  6E0F     MOVWF 0xF, ACCESS
10C90  0E20     MOVLW 0x20
10C92  6E0E     MOVWF 0xE, ACCESS
10C94  C517     MOVFF fp, blockSize
10C96  F510     NOP
10C98  C518     MOVFF tmp, chr
10C9A  F511     NOP
10C9C  EC67     CALL 0x110CE, 0
10C9E  F088     NOP
606:                       ++l;
10CA0  4A2B     INFSNZ 0x2B, F, ACCESS
10CA2  2A2C     INCF 0x2C, F, ACCESS
607:                   }
608:               }
609:           
610:               return l;
10CB8  C52B     MOVFF l, fp
10CBA  F517     NOP
10CBC  C52C     MOVFF 0x52C, tmp
10CBE  F518     NOP
611:           }
10CC0  0012     RETURN 0
612:           #endif
613:           
614:           #ifdef _VFPF_U
615:           static _INLINE int utoa(FILE *fp, unsigned long long d)
616:           {
617:               int i, p, w;
618:               unsigned long long n;
619:           
620:               /* Adjust flags, precision, width */
621:               if (!(prec < 0)) {
622:                   flags &= ~ZERO_FLAG;
623:               }
624:               p = (0 < prec) ? prec : 1;
625:               w = width;
626:           
627:               /* Convert to decimal, possibly filling on the left with zeroes */
628:               n = d;
629:               i = sizeof(dbuf) - 1;
630:               dbuf[i] = '\0';
631:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
632:                   --i;
633:                   dbuf[i] = '0' + (n % 10);
634:                   --p;
635:                   --w;
636:                   n = n / 10;
637:               }
638:           
639:               /* Put out padded string */
640:               return pad(fp, &dbuf[i], w);
641:           }
642:           #endif
643:           
644:           #if defined(_VFPF_X) || defined(_VFPF_P)
645:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
646:           {
647:               int c, i, p, w;
648:               unsigned long long n;
649:           
650:               /* Adjust, flags, precision, width */
651:               if (!(prec < 0)) {
652:                   flags &= ~ZERO_FLAG;
653:               }
654:               p = (0 < prec) ? prec : 1;
655:               w = width;
656:               if (flags & POUND_FLAG) {
657:                   w -= 2;
658:               }
659:           
660:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
661:               n = d;
662:               i = sizeof(dbuf) - 1;
663:               dbuf[i] = '\0';
664:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
665:                   --i;
666:                   c = n & 0x0f;
667:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
668:                   if (isupper((int)x) && isalpha(c)) {
669:                       c = toupper(c);
670:                   }
671:                   dbuf[i] = (char)c;
672:                   --p;
673:                   --w;
674:                   n = n >> 4;
675:               }
676:           
677:               /* Display prefix if required */
678:               if (flags & POUND_FLAG) {
679:                   --i;
680:                   dbuf[i] = x;
681:                   --i;
682:                   dbuf[i] = '0';
683:               }
684:           
685:               /* Put out padded string */
686:               return pad(fp, &dbuf[i], w);
687:           }
688:           #endif
689:           
690:           /* Consume and convert the next part of the format string */
691:           #ifdef _VFPF_CONVERT
692:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
693:           {
694:               char c, *cp, ct[3];
695:               int done, i;
696:               long long ll;
697:               unsigned long long llu;
698:               long double f;
699:               void *vp;
700:           
701:               /* Conversion ? */
702:               if ((*fmt)[0] == '%') {
108AE  F4BC     NOP
108B0  F4D9     NOP
108B4  F4C0     NOP
108B6  F4DA     NOP
108B8  C4DE     MOVFF POSTINC2, TBLPTR
108BA  F4F6     NOP
108BC  C4DD     MOVFF POSTDEC2, TBLPTRH
108BE  F4F7     NOP
108C0  0E00     MOVLW 0x0
108C2  6EF8     MOVWF 0xFF8, ACCESS
108C4  0008     TBLRD*
108C6  50F5     MOVF 0xFF5, W, ACCESS
108C8  0A25     XORLW 0x25
108CA  A4D8     BTFSS 0xFD8, 2, ACCESS
108CC  D090     BRA 0x9EE
703:                   ++*fmt;
108D0  F4BC     NOP
108D2  F4D9     NOP
108D6  F4C0     NOP
108D8  F4DA     NOP
108DA  2ADE     INCF 0xFDE, F, ACCESS
108DC  0E00     MOVLW 0x0
108DE  22DD     ADDWFC 0xFDD, F, ACCESS
704:           
705:                   flags = width = 0;
108E0  0E00     MOVLW 0x0
108E2  0105     MOVLB 0x5
108E4  6FE0     MOVWF 0xE0, BANKED
108E6  0E00     MOVLW 0x0
108E8  6FDF     MOVWF CLCnGLS3, BANKED
108EA  C5DF     MOVFF width, flags
108EC  F5E3     NOP
108EE  C5E0     MOVFF 0x5E0, 0x5E4
108F0  F5E4     NOP
706:                   prec = -1;
108F2  69E1     SETF 0xE1, BANKED
108F4  69E2     SETF 0xE2, BANKED
707:           
708:           #ifdef _VFPF_FLAGS
709:                   /* Get flags */
710:                   done = 0;
711:                   while (!done) {
712:                       switch ((*fmt)[0]) {
713:                           case '-' :
714:                               flags |= MINUS_FLAG;
715:                               ++*fmt;
716:                               break;
717:                           case '0' :
718:                               flags |= ZERO_FLAG;
719:                               ++*fmt;
720:                               break;
721:                           case '+' :
722:                               flags |= PLUS_FLAG;
723:                               ++*fmt;
724:                               break;
725:                           case ' ' :
726:                               flags |= SPACE_FLAG;
727:                               ++*fmt;
728:                               break;
729:                           case '#' :
730:                               flags |= POUND_FLAG;
731:                               ++*fmt;
732:                               break;
733:                           default:
734:                               done = 1;
735:                               break;
736:                       }
737:                   }
738:                   if (flags & MINUS_FLAG) {
739:                       flags &= ~ZERO_FLAG;
740:                   }
741:           #endif
742:           
743:           #ifdef _VFPF_WIDTH
744:                   /* Get field width */
745:                   if ((*fmt)[0] == '*') {
746:                       ++*fmt;
747:                       width = va_arg(ap, int);
748:                       if (width < 0) {
749:                           flags |= MINUS_FLAG;
750:                           width = -width;
751:                       }
752:                   } else {
753:                       width = atoi(*fmt);
754:                       while (isdigit((*fmt)[0])) {
755:                           ++*fmt;
756:                       }
757:                   }
758:           #endif
759:           
760:           #ifdef _VFPF_PRECISION
761:                   /* Get precision */
762:                   if ((*fmt)[0] == '.') {
763:                       prec = 0;
764:                       ++*fmt;
765:                       if ((*fmt)[0] == '*') {
766:                           ++*fmt;
767:                           prec = va_arg(ap, int);
768:                       } else {
769:                           prec = atoi(*fmt);
770:                           while (isdigit((*fmt)[0])) {
771:                               ++*fmt;
772:                           }
773:                       }
774:                   }
775:           #endif
776:           
777:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
778:                   /* Case-folded conversion types */
779:                   ct[0] = (char)tolower((int)(*fmt)[0]);
780:                   if (ct[0]) {
781:                       ct[1] = (char)tolower((int)(*fmt)[1]);
782:                       if (ct[1]) {
783:                           ct[2] = (char)tolower((int)(*fmt)[2]);
784:                       }
785:                   }
786:           #endif
787:           
788:           #ifdef _VFPF_A
789:                   /* 'a' style (hex) floating point */
790:                   if (ct[0] == 'a') {
791:           
792:                       c = (*fmt)[0];
793:                       ++*fmt;
794:                       f = (long double)va_arg(ap, double);
795:                                   
796:                       return atoa(fp, f, c);
797:                   }
798:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
799:           
800:                       c = (*fmt)[1];
801:                       if (isupper((int)(*fmt)[0])) {
802:                           f = va_arg(ap, long double);
803:                       } else {
804:                           f = (long double)va_arg(ap, double);
805:                       }
806:                       *fmt += CSTRLEN("la");
807:                                   
808:                       return atoa(fp, f, c);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_C
813:                   /* Character */
814:                   if (*fmt[0] == 'c') {
815:                       ++*fmt;
816:                       c = (unsigned char)va_arg(ap, int);
817:                       return ctoa(fp, c);
818:                   }
819:           #endif
820:           
821:           #ifdef _VFPF_D
822:           #ifdef _VFPF_HH
823:                   /* Character decimal integer */
824:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
825:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
826:           
827:                       *fmt += CSTRLEN("hhd");
828:                       ll = (long long)(signed char)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           #endif
833:           
834:           #ifdef _VFPF_H
835:                   /* Short decimal integer */
836:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
837:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
838:           
839:                       *fmt += CSTRLEN("hd");
840:                       ll = (long long)(short)va_arg(ap, int);
841:                                   
842:                       return dtoa(fp, ll);
843:                   }
844:           #endif
845:           
846:                   /* Decimal integer */
847:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
848:           
849:                       ++*fmt;
850:                       ll = (long long)va_arg(ap, int);
851:                                   
852:                       return dtoa(fp, ll);
853:                   }
854:           
855:           #ifdef _VFPF_L
856:                   /* Long decimal integer */
857:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
858:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
859:           
860:                       *fmt += CSTRLEN("ld");
861:                       ll = (long long)va_arg(ap, long);
862:                                   
863:                       return dtoa(fp, ll);
864:                   }
865:           #endif
866:           
867:           #ifdef _VFPF_LL
868:                   /* Long long decimal integer */
869:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
870:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
871:           
872:                       *fmt += CSTRLEN("lld");
873:                       ll = va_arg(ap, long long);
874:                                   
875:                       return dtoa(fp, ll);
876:                   }
877:           #endif
878:           
879:           #ifdef _VFPF_J
880:                   /* intmax_t decimal integer */
881:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
882:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
883:           
884:                       *fmt += CSTRLEN("jd");
885:                       ll = (long long)va_arg(ap, intmax_t);
886:                                   
887:                       return dtoa(fp, ll);
888:                   }
889:           #endif
890:           
891:           #ifdef _VFPF_T
892:                   /* ptrdiff_t decimal integer */
893:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
894:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
895:           
896:                       *fmt += CSTRLEN("td");
897:                       ll = (long long)va_arg(ap, ptrdiff_t);
898:                                   
899:                       return dtoa(fp, ll);
900:                   }
901:           #endif
902:           
903:           #ifdef _VFPF_Z
904:                   /* size_t decimal integer */
905:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
906:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
907:           
908:                       *fmt += CSTRLEN("zd");
909:                       ll = (long long)va_arg(ap, size_t);
910:                                   
911:                       return dtoa(fp, ll);
912:                   }
913:           #endif
914:           #endif
915:           
916:           #ifdef _VFPF_E
917:                   /* 'e' style floating point */
918:                   if (ct[0] == 'e') {
919:           
920:                       c = (*fmt)[0];
921:                       ++*fmt;
922:                       f = (long double)va_arg(ap, double);
923:                                   
924:                       return efgtoa(fp, f, c);
925:                   }
926:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
927:           
928:                       c = (*fmt)[1];
929:                       if (isupper((int)(*fmt)[0])) {
930:                           f = va_arg(ap, long double);
931:                       } else {
932:                           f = (long double)va_arg(ap, double);
933:                       }
934:                       *fmt += CSTRLEN("lf");
935:                                   
936:                       return efgtoa(fp, f, c);
937:                   }
938:           #endif
939:           
940:           #ifdef _VFPF_F
941:                   /* 'f' style floating point */
942:                   if (ct[0] == 'f') {
943:           
944:                       c = (*fmt)[0];
945:                       ++*fmt;
946:                       f = (long double)va_arg(ap, double);
947:                                   
948:                       return efgtoa(fp, f, c);
949:                   }
950:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
951:           
952:                       c = (*fmt)[1];
953:                       if (isupper((int)(*fmt)[0])) {
954:                           f = va_arg(ap, long double);
955:                       } else {
956:                           f = (long double)va_arg(ap, double);
957:                       }
958:                       *fmt += CSTRLEN("lf");
959:                                   
960:                       return efgtoa(fp, f, c);
961:                   }
962:           #endif
963:           
964:           #ifdef _VFPF_G
965:                   /* 'g' style floating point */
966:                   if (ct[0] == 'g') {
967:           
968:                       c = (*fmt)[0];
969:                       ++*fmt;
970:                       f = (long double)va_arg(ap, double);
971:                                   
972:                       return efgtoa(fp, f, c);
973:                   }
974:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
975:           
976:                       c = (*fmt)[1];
977:                       if (isupper((int)(*fmt)[0])) {
978:                           f = va_arg(ap, long double);
979:                       } else {
980:                           f = (long double)va_arg(ap, double);
981:                       }
982:                       *fmt += CSTRLEN("lg");
983:                                   
984:                       return efgtoa(fp, f, c);
985:                   }
986:           #endif
987:           
988:           #ifdef _VFPF_O
989:           #ifdef _VFPF_HH
990:                   /* Character octal integer */
991:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
992:           
993:                       *fmt += CSTRLEN("hho");
994:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
995:                                   
996:                       return otoa(fp, llu);
997:                   }
998:           #endif
999:           
1000:          #ifdef _VFPF_H
1001:                  /* Short octal integer */
1002:                  if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
1003:          
1004:                      *fmt += CSTRLEN("ho");
1005:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1006:                                  
1007:                      return otoa(fp, llu);
1008:                  }
1009:          #endif
1010:          
1011:                  /* Octal integer */
1012:                  if (*fmt[0] == 'o') {
1013:          
1014:                      ++*fmt;
1015:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1016:                                  
1017:                      return otoa(fp, llu);
1018:                  }
1019:          
1020:          #ifdef _VFPF_L
1021:                  /* Long octal integer */
1022:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1023:          
1024:                      *fmt += CSTRLEN("lo");
1025:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_LL
1032:                  /* Long long octal integer */
1033:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1034:          
1035:                      *fmt += CSTRLEN("llo");
1036:                      llu = va_arg(ap, unsigned long long);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_J
1043:                  /* uintmax_t octal integer */
1044:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1045:          
1046:                      *fmt += CSTRLEN("jo");
1047:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          
1053:          #ifdef _VFPF_T
1054:                  /* ptrdiff_t octal integer */
1055:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1056:          
1057:                      *fmt += CSTRLEN("to");
1058:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1059:                                  
1060:                      return otoa(fp, llu);
1061:                  }
1062:          #endif
1063:          
1064:          #ifdef _VFPF_Z
1065:                  /* size_t octal integer */
1066:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1067:          
1068:                      *fmt += CSTRLEN("zo");
1069:                      llu = (unsigned long long)va_arg(ap, size_t);
1070:                                  
1071:                      return otoa(fp, llu);
1072:                  }
1073:          #endif
1074:          #endif
1075:          
1076:                  /* Character count */
1077:          #ifdef _VFPF_N
1078:          
1079:          #ifdef _VFPF_HH
1080:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1081:          
1082:                      *fmt += CSTRLEN("hhn");
1083:                      vp = (void *)va_arg(ap, char *);
1084:                      *(char *)vp = (char)nout;
1085:                      return 0;
1086:                  }
1087:          #endif
1088:          
1089:          #ifdef _VFPF_H
1090:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1091:          
1092:                      *fmt += CSTRLEN("hn");
1093:                      vp = (void *)va_arg(ap, short *);
1094:                      *(short *)vp = (short)nout;
1095:                      return 0;
1096:                  }
1097:          #endif
1098:          
1099:                  if (*fmt[0] == 'n') {
1100:                      ++*fmt;
1101:                      vp = (void *)va_arg(ap, int *);
1102:                      *(int *)vp = nout;
1103:                      return 0;
1104:                  }
1105:          
1106:          #ifdef _VFPF_L
1107:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1108:          
1109:                      *fmt += CSTRLEN("ln");
1110:                      vp = (void *)va_arg(ap, long *);
1111:                      *(long *)vp = (long)nout;
1112:                      return 0;
1113:                  }
1114:          #endif
1115:          
1116:          #ifdef _VFPF_LL
1117:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1118:          
1119:                      *fmt += CSTRLEN("lln");
1120:                      vp = (void *)va_arg(ap, long long *);
1121:                      *(long long *)vp = (long long)nout;
1122:                      return 0;
1123:                  }
1124:          #endif
1125:          
1126:          #ifdef _VFPF_J
1127:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1128:          
1129:                      *fmt += CSTRLEN("jn");
1130:                      vp = (void *)va_arg(ap, uintmax_t *);
1131:                      *(uintmax_t *)vp = (uintmax_t)nout;
1132:                      return 0;
1133:                  }
1134:          #endif
1135:          
1136:          #ifdef _VFPF_T
1137:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1138:          
1139:                      *fmt += CSTRLEN("tn");
1140:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1141:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1142:                      return 0;
1143:                  }
1144:          #endif
1145:          
1146:          #ifdef _VFPF_Z
1147:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1148:          
1149:                      *fmt += CSTRLEN("zn");
1150:                      vp = (void *)va_arg(ap, size_t *);
1151:                      *(size_t *)vp = (size_t)nout;
1152:                      return 0;
1153:                  }
1154:          #endif
1155:          
1156:          #endif
1157:          
1158:          #ifdef _VFPF_P
1159:                  /* Pointer */
1160:                  if (*fmt[0] == 'p') {
1161:          
1162:                      ++*fmt;
1163:                      llu = (unsigned long long)(uintptr_t)va_arg(ap, void *);
1164:                                  
1165:                      return xtoa(fp, llu, 'x');
1166:                  }
1167:          #endif
1168:          
1169:          #ifdef _VFPF_S
1170:                  /* String */
1171:                  if (*fmt[0] == 's') {
108F8  F4BC     NOP
108FA  F4D9     NOP
108FE  F4C0     NOP
10900  F4DA     NOP
10902  C4DE     MOVFF POSTINC2, TBLPTR
10904  F4F6     NOP
10906  C4DD     MOVFF POSTDEC2, TBLPTRH
10908  F4F7     NOP
1090A  0E00     MOVLW 0x0
1090C  6EF8     MOVWF 0xFF8, ACCESS
1090E  0008     TBLRD*
10910  50F5     MOVF 0xFF5, W, ACCESS
10912  0A73     XORLW 0x73
10914  A4D8     BTFSS 0xFD8, 2, ACCESS
10916  D034     BRA 0x980
1172:          
1173:                      ++*fmt;
1091A  F4BC     NOP
1091C  F4D9     NOP
10920  F4C0     NOP
10922  F4DA     NOP
10924  2ADE     INCF 0xFDE, F, ACCESS
10926  0E00     MOVLW 0x0
10928  22DD     ADDWFC 0xFDD, F, ACCESS
1174:                      cp = va_arg(ap, char *);
1092C  F4C4     NOP
1092E  F4D9     NOP
10932  F4C8     NOP
10934  F4DA     NOP
10938  F37C     NOP
1093A  F533     NOP
1093C  0E02     MOVLW 0x2
1093E  26DE     ADDWF 0xFDE, F, ACCESS
10942  F37C     NOP
10944  F534     NOP
10946  0E00     MOVLW 0x0
10948  22DD     ADDWFC 0xFDD, F, ACCESS
1094C  F4CC     NOP
1094E  F4D9     NOP
10952  F4D0     NOP
10954  F4DA     NOP
10958  F378     NOP
1095A  F535     NOP
1095E  F374     NOP
10960  F536     NOP
1175:          
1176:                      return stoa(fp, cp);
10962  C52D     MOVFF fp, fp
10964  F517     NOP
10966  C52E     MOVFF 0x52E, tmp
10968  F518     NOP
1096A  C535     MOVFF cp, _this
1096C  F519     NOP
1096E  C536     MOVFF 0x536, _this
10970  F51A     NOP
10972  ECBD     CALL 0x10B7A, 0
10974  F085     NOP
10976  C517     MOVFF fp, fp
10978  F52D     NOP
1097A  C518     MOVFF tmp, 0x52E
1097C  F52E     NOP
1097E  0012     RETURN 0
1177:                  }
1178:          #endif
1179:          
1180:          #ifdef _VFPF_U
1181:          #ifdef _VFPF_HH
1182:                  /* Unsigned character decimal integer */
1183:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1184:          
1185:                      *fmt += CSTRLEN("hhu");
1186:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1187:                                  
1188:                      return utoa(fp, llu);
1189:                  }
1190:          #endif
1191:          
1192:          #ifdef _VFPF_H
1193:                  /* Unsigned short decimal integer */
1194:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1195:          
1196:                      *fmt += CSTRLEN("hu");
1197:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1198:                                  
1199:                      return utoa(fp, llu);
1200:                  }
1201:          #endif
1202:          
1203:                  /* Unsigned decimal integer */
1204:                  if (*fmt[0] == 'u') {
1205:          
1206:                      ++*fmt;
1207:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1208:                                  
1209:                      return utoa(fp, llu);
1210:                  }
1211:          
1212:          #ifdef _VFPF_L
1213:                  /* Unsigned long decimal integer */
1214:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1215:          
1216:                      *fmt += CSTRLEN("lu");
1217:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_LL
1224:                  /* Unsigned long long decimal integer */
1225:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1226:          
1227:                      *fmt += CSTRLEN("llu");
1228:                      llu = va_arg(ap, unsigned long long);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_J
1235:                  /* uintmax_t decimal integer */
1236:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1237:          
1238:                      *fmt += CSTRLEN("ju");
1239:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          
1245:          #ifdef _VFPF_T
1246:                  /* ptrdiff_t decimal integer */
1247:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1248:          
1249:                      *fmt += CSTRLEN("tu");
1250:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1251:                                  
1252:                      return utoa(fp, llu);
1253:                  }
1254:          #endif
1255:          
1256:          #ifdef _VFPF_Z
1257:                  /* size_t decimal integer */
1258:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1259:          
1260:                      *fmt += CSTRLEN("zu");
1261:                      llu = (unsigned long long)va_arg(ap, size_t);
1262:                                  
1263:                      return utoa(fp, llu);
1264:                  }
1265:          #endif
1266:          #endif
1267:          
1268:          #ifdef _VFPF_X
1269:          #ifdef _VFPF_HH
1270:                  /* Character hexadecimal integer */
1271:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1272:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1273:          
1274:                      c = (*fmt)[2];
1275:                      *fmt += CSTRLEN("hhx");
1276:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1277:                                  
1278:                      return xtoa(fp, llu, c);
1279:                  }
1280:          #endif
1281:          
1282:          #ifdef _VFPF_H
1283:                  /* Short hexadecimal integer */
1284:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1285:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1286:          
1287:                      c = (*fmt)[1];
1288:                      *fmt += CSTRLEN("hx");
1289:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1290:                                  
1291:                      return xtoa(fp, llu, c);
1292:                  }
1293:          #endif
1294:          
1295:                  /* Hexadecimal integer */
1296:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1297:          
1298:                      c = (*fmt)[0];
1299:                      ++*fmt;
1300:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1301:                                  
1302:                      return xtoa(fp, llu, c);
1303:                  }
1304:          
1305:          #ifdef _VFPF_L
1306:                  /* Long hexadecimal integer */
1307:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1308:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1309:          
1310:                      c = (*fmt)[1];
1311:                      *fmt += CSTRLEN("lx");
1312:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1313:                                  
1314:                      return xtoa(fp, llu, c);
1315:                  }
1316:          #endif
1317:          
1318:          #ifdef _VFPF_LL
1319:                  /* Long long hexadecimal integer */
1320:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1321:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1322:          
1323:                      c = (*fmt)[2];
1324:                      *fmt += CSTRLEN("llx");
1325:                      llu = va_arg(ap, unsigned long long);
1326:                                  
1327:                      return xtoa(fp, llu, c);
1328:                  }
1329:          #endif
1330:          
1331:          #ifdef _VFPF_J
1332:                  /* uintmax_t hexadecimal integer */
1333:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1334:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1335:          
1336:                      c = (*fmt)[1];
1337:                      *fmt += CSTRLEN("jx");
1338:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1339:                                  
1340:                      return xtoa(fp, llu, c);
1341:                  }
1342:          #endif
1343:          
1344:          #ifdef _VFPF_T
1345:                  /* ptrdiff_t hexadecimal integer */
1346:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1347:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1348:          
1349:                      c = (*fmt)[1];
1350:                      *fmt += CSTRLEN("tx");
1351:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1352:                                  
1353:                      return xtoa(fp, llu, c);
1354:                  }
1355:          #endif
1356:          
1357:          #ifdef _VFPF_Z
1358:                  /* size_t hexadecimal integer */
1359:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1360:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1361:          
1362:                      c = (*fmt)[1];
1363:                      *fmt += CSTRLEN("zx");
1364:                      llu = (unsigned long long)va_arg(ap, size_t);
1365:                                  
1366:                      return xtoa(fp, llu, c);
1367:                  }
1368:          #endif
1369:          #endif
1370:          
1371:                  /* 'Escaped' '%' character */
1372:                  if ((*fmt)[0] == '%') {
10982  F4BC     NOP
10984  F4D9     NOP
10988  F4C0     NOP
1098A  F4DA     NOP
1098C  C4DE     MOVFF POSTINC2, TBLPTR
1098E  F4F6     NOP
10990  C4DD     MOVFF POSTDEC2, TBLPTRH
10992  F4F7     NOP
10994  0E00     MOVLW 0x0
10996  6EF8     MOVWF 0xFF8, ACCESS
10998  0008     TBLRD*
1099A  50F5     MOVF 0xFF5, W, ACCESS
1099C  0A25     XORLW 0x25
1099E  A4D8     BTFSS 0xFD8, 2, ACCESS
109A0  D018     BRA 0x9D2
1373:                      ++*fmt;
109A4  F4BC     NOP
109A6  F4D9     NOP
109AA  F4C0     NOP
109AC  F4DA     NOP
109AE  2ADE     INCF 0xFDE, F, ACCESS
109B0  0E00     MOVLW 0x0
109B2  22DD     ADDWFC 0xFDD, F, ACCESS
1374:                      fputc((int)'%', fp);
109B4  0E00     MOVLW 0x0
109B6  6E0F     MOVWF 0xF, ACCESS
109B8  0E25     MOVLW 0x25
109BA  6E0E     MOVWF 0xE, ACCESS
109BC  C52D     MOVFF fp, blockSize
109BE  F510     NOP
109C0  C52E     MOVFF 0x52E, chr
109C2  F511     NOP
109C4  EC67     CALL 0x110CE, 0
109C6  F088     NOP
1375:                      return 1;
109C8  0E00     MOVLW 0x0
109CA  6E2E     MOVWF 0x2E, ACCESS
109CC  0E01     MOVLW 0x1
109CE  6E2D     MOVWF 0x2D, ACCESS
109D0  0012     RETURN 0
1376:                  }
1377:          
1378:                  /* Unrecognized conversion */
1379:                  ++*fmt;
109D4  F4BC     NOP
109D6  F4D9     NOP
109DA  F4C0     NOP
109DC  F4DA     NOP
109DE  2ADE     INCF 0xFDE, F, ACCESS
109E0  0E00     MOVLW 0x0
109E2  22DD     ADDWFC 0xFDD, F, ACCESS
1380:                  return 0;
109E4  0E00     MOVLW 0x0
109E6  6E2E     MOVWF 0x2E, ACCESS
109E8  0E00     MOVLW 0x0
109EA  6E2D     MOVWF 0x2D, ACCESS
109EC  0012     RETURN 0
1381:              }
1382:          
1383:              /* No conversion, just intervening text */
1384:              fputc((int)(*fmt)[0], fp);
109F0  F4BC     NOP
109F2  F4D9     NOP
109F6  F4C0     NOP
109F8  F4DA     NOP
109FA  C4DE     MOVFF POSTINC2, TBLPTR
109FC  F4F6     NOP
109FE  C4DD     MOVFF POSTDEC2, TBLPTRH
10A00  F4F7     NOP
10A02  0E00     MOVLW 0x0
10A04  6EF8     MOVWF 0xFF8, ACCESS
10A06  0008     TBLRD*
10A08  50F5     MOVF 0xFF5, W, ACCESS
10A0A  6E0E     MOVWF 0xE, ACCESS
10A0C  6A0F     CLRF 0xF, ACCESS
10A0E  C52D     MOVFF fp, blockSize
10A10  F510     NOP
10A12  C52E     MOVFF 0x52E, chr
10A14  F511     NOP
10A16  EC67     CALL 0x110CE, 0
10A18  F088     NOP
1385:              ++*fmt;
10A1C  F4BC     NOP
10A1E  F4D9     NOP
10A22  F4C0     NOP
10A24  F4DA     NOP
10A26  2ADE     INCF 0xFDE, F, ACCESS
10A28  0E00     MOVLW 0x0
10A2A  22DD     ADDWFC 0xFDD, F, ACCESS
10A2C  D7CD     BRA 0x9C8
1386:              return 1;
1387:          }
1388:          #endif
1389:          
1390:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1391:          {
1392:          #ifdef _VFPF_CONVERT
1393:              char *cfmt;
1394:          
1395:              cfmt = (char *)fmt;
1137A  C539     MOVFF fmt, cfmt
1137C  F53D     NOP
1137E  C53A     MOVFF 0x53A, 0x53E
11380  F53E     NOP
1396:              nout = 0;
11382  0E00     MOVLW 0x0
11384  0105     MOVLB 0x5
11386  6FDE     MOVWF CLCnGLS2, BANKED
11388  0E00     MOVLW 0x0
1138A  6FDD     MOVWF CLCnGLS1, BANKED
1397:              while (*cfmt) {
1138C  D013     BRA 0x13B4
113B6  F4F4     NOP
113B8  F4F6     NOP
113BC  F4F8     NOP
113BE  F4F7     NOP
113C0  0E00     MOVLW 0x0
113C2  6EF8     MOVWF 0xFF8, ACCESS
113C4  0008     TBLRD*
113C6  50F5     MOVF 0xFF5, W, ACCESS
113C8  0900     IORLW 0x0
113CA  A4D8     BTFSS 0xFD8, 2, ACCESS
113CC  D7E0     BRA 0x138E
1398:                  nout += vfpfcnvrt(fp, &cfmt, ap);
1138E  C537     MOVFF fp, fp
11390  F52D     NOP
11392  C538     MOVFF 0x538, 0x52E
11394  F52E     NOP
11396  0E3D     MOVLW 0x3D
11398  6E2F     MOVWF 0x2F, ACCESS
1139A  0E05     MOVLW 0x5
1139C  6E30     MOVWF 0x30, ACCESS
1139E  C53B     MOVFF ap, ap
113A0  F531     NOP
113A2  C53C     MOVFF 0x53C, 0x532
113A4  F532     NOP
113A6  EC56     CALL 0x108AC, 0
113A8  F084     NOP
113AA  502D     MOVF 0x2D, W, ACCESS
113AC  0105     MOVLB 0x5
113AE  27DD     ADDWF CLCnGLS1, F, BANKED
113B0  502E     MOVF 0x2E, W, ACCESS
113B2  23DE     ADDWFC CLCnGLS2, F, BANKED
1399:              }
1400:              return nout;
113CE  C5DD     MOVFF nout, fp
113D0  F537     NOP
113D2  C5DE     MOVFF 0x5DE, 0x538
113D4  F538     NOP
1401:          #else
1402:              return fputs(fmt, fp);
1403:          #endif
1404:          }
113D6  0012     RETURN 0
---  /fred/pic18_k42/q43_board/q43_ntsc.X/timers.c  -----------------------------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "timers.h"
5:             
6:             extern volatile uint16_t tickCount[TMR_COUNT];
7:             
8:             //**********************************************************************************************************************
9:             // Start one of the software timers
10:            
11:            void StartTimer(const uint8_t timer, const uint16_t count)
119CA  6E12     MOVWF 0x12, ACCESS
12:            {
13:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
119CC  C50E     MOVFF InterruptHandler, blockSize
119CE  F510     NOP
119D0  C50F     MOVFF 0x50F, chr
119D2  F511     NOP
119D4  90D8     BCF 0xFD8, 0, ACCESS
119D6  3610     RLCF 0x10, F, ACCESS
119D8  3611     RLCF 0x11, F, ACCESS
119DA  5012     MOVF 0x12, W, ACCESS
119DC  0D02     MULLW 0x2
119DE  0EA0     MOVLW 0xA0
119E0  24F3     ADDWF 0xFF3, W, ACCESS
119E2  6ED9     MOVWF 0xFD9, ACCESS
119E4  0E05     MOVLW 0x5
119E6  20F4     ADDWFC 0xFF4, W, ACCESS
119E8  6EDA     MOVWF 0xFDA, ACCESS
119EC  F440     NOP
119EE  F4DE     NOP
119F2  F444     NOP
119F4  F4DD     NOP
14:            }
119F6  0012     RETURN 0
15:            
16:            //**********************************************************************************************************************
17:            // Check if one of the software software timers has timed out
18:            
19:            bool TimerDone(const uint8_t timer)
20:            {
21:            	bool td = false;
22:            
23:            	ClrWdt(); // reset the WDT timer
24:            	if (tickCount[timer] == (uint16_t) 0) { //Check if counted down to zero
25:            		td = true; //then return true
26:            	}
27:            	return td;
28:            }
29:            
30:            //**********************************************************************************************************************
31:            // Simple delay for n milliseconds (blocking)
32:            
33:            void WaitMs(const uint16_t numMilliseconds)
34:            {
35:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
36:            	while (!TimerDone(TMR_INTERNAL)) {
37:            		Nop();
38:            		Nop();
39:            		Nop();
40:            		Nop();
41:            		ClrWdt(); // reset the WDT timer
42:            		//		Idle();
43:            	} //Enter idle mode to reduce power while waiting
44:            } //(timer interrupt will wake part from idle)
45:            
46:            
---  /fred/pic18_k42/q43_board/q43_ntsc.X/ringbufs.c  ---------------------------------------------------
1:             #include  <string.h>
2:             #include  "ringbufs.h"
3:             
4:             /*
5:              * general ring buffer fuctions from the internet
6:              */
7:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
8:             {
9:             	uint8_t my_value = value + 1;
10:            	if (my_value >= modulus) {
11:            		my_value = 0;
12:            	}
13:            	return my_value;
14:            }
15:            
16:            uint8_t modulo_dec(const uint8_t value, const uint8_t modulus)
17:            {
18:            	uint8_t my_value = (0 == value) ? (modulus - 1) : (value - 1);
19:            	return my_value;
20:            }
21:            
22:            void ringBufS_init(volatile ringBufS_t *_this)
23:            {
24:            	/*****
25:            	  The following clears:
26:            	    -> buf
27:            	    -> head
28:            	    -> tail
29:            	    -> count
30:            	  and sets head = tail
31:            	 ***/
32:            	memset((void*) _this, 0, sizeof(*_this));
11B18  C51A     MOVFF _this, InterruptHandler
11B1A  F50E     NOP
11B1C  C51B     MOVFF ptr, 0x50F
11B1E  F50F     NOP
11B20  0E00     MOVLW 0x0
11B22  6E11     MOVWF 0x11, ACCESS
11B24  0E00     MOVLW 0x0
11B26  6E10     MOVWF 0x10, ACCESS
11B28  0E00     MOVLW 0x0
11B2A  6E13     MOVWF 0x13, ACCESS
11B2C  0E43     MOVLW 0x43
11B2E  6E12     MOVWF 0x12, ACCESS
11B30  EC17     CALL 0x10A2E, 0
11B32  F085     NOP
33:            }
11B34  0012     RETURN 0
34:            
35:            int8_t ringBufS_empty(ringBufS_t *_this)
36:            {
37:            	return(0 == _this->count);
38:            }
39:            
40:            int8_t ringBufS_full(ringBufS_t *_this)
41:            {
42:            	return(_this->count >= RBUF_SIZE);
43:            }
44:            
45:            uint8_t ringBufS_get(ringBufS_t *_this)
46:            {
47:            	uint8_t c;
48:            	if (_this->count > 0) {
49:            		c = _this->buf[_this->tail];
50:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
51:            		--_this->count;
52:            	} else {
53:            		c = 0; // return null with empty buffer
54:            	}
55:            	return(c);
56:            }
57:            
58:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
59:            {
60:            	if (_this->count < RBUF_SIZE) {
61:            		_this->buf[_this->head] = c;
62:            		_this->head = modulo_inc(_this->head, RBUF_SIZE);
63:            		++_this->count;
64:            	}
65:            }
66:            
67:            void ringBufS_put_dma(ringBufS_t *_this, const uint8_t c)
68:            {
69:            	if (_this->count < RBUF_SIZE) {
70:            		_this->buf[_this->head] = c;
71:            		++_this->head;
72:            		++_this->count;
73:            	}
74:            }
75:            
76:            void ringBufS_put_dma_cpy(ringBufS_t *_this, const char *ptr, const uint8_t len)
77:            {
78:            	if (_this->count < RBUF_SIZE) {
11488  EE20     LFSR 2, 0x42
1148A  F042     NOP
1148C  5019     MOVF 0x19, W, ACCESS
1148E  26D9     ADDWF 0xFD9, F, ACCESS
11490  501A     MOVF 0x1A, W, ACCESS
11492  22DA     ADDWFC 0xFDA, F, ACCESS
11494  0E40     MOVLW 0x40
11496  60DF     CPFSLT 0xFDF, ACCESS
11498  0012     RETURN 0
79:            		memcpy(_this->buf, ptr, len);
1149A  C519     MOVFF _this, InterruptHandler
1149C  F50E     NOP
1149E  C51A     MOVFF _this, 0x50F
114A0  F50F     NOP
114A2  C51B     MOVFF ptr, blockSize
114A4  F510     NOP
114A6  C51C     MOVFF clearBuffer, chr
114A8  F511     NOP
114AA  C51D     MOVFF len, data
114AC  F512     NOP
114AE  6A13     CLRF 0x13, ACCESS
114B0  EC95     CALL 0x1152A, 0
114B2  F08A     NOP
80:            		_this->head = len;
114B4  EE20     LFSR 2, 0x40
114B6  F040     NOP
114B8  5019     MOVF 0x19, W, ACCESS
114BA  26D9     ADDWF 0xFD9, F, ACCESS
114BC  501A     MOVF 0x1A, W, ACCESS
114BE  22DA     ADDWFC 0xFDA, F, ACCESS
114C2  F474     NOP
114C4  F4DF     NOP
81:            		_this->count = len;
114C6  EE20     LFSR 2, 0x42
114C8  F042     NOP
114CA  5019     MOVF 0x19, W, ACCESS
114CC  26D9     ADDWF 0xFD9, F, ACCESS
114CE  501A     MOVF 0x1A, W, ACCESS
114D0  22DA     ADDWFC 0xFDA, F, ACCESS
114D4  F474     NOP
114D6  F4DF     NOP
82:            	}
83:            }
114D8  0012     RETURN 0
84:            
85:            void ringBufS_flush(ringBufS_t *_this, const bool clearBuffer)
86:            {
87:            	_this->count = 0;
11434  EE20     LFSR 2, 0x42
11436  F042     NOP
11438  501A     MOVF 0x1A, W, ACCESS
1143A  26D9     ADDWF 0xFD9, F, ACCESS
1143C  501B     MOVF 0x1B, W, ACCESS
1143E  22DA     ADDWFC 0xFDA, F, ACCESS
11440  0E00     MOVLW 0x0
11442  6EDF     MOVWF 0xFDF, ACCESS
88:            	_this->head = 0;
11444  EE20     LFSR 2, 0x40
11446  F040     NOP
11448  501A     MOVF 0x1A, W, ACCESS
1144A  26D9     ADDWF 0xFD9, F, ACCESS
1144C  501B     MOVF 0x1B, W, ACCESS
1144E  22DA     ADDWFC 0xFDA, F, ACCESS
11450  0E00     MOVLW 0x0
11452  6EDF     MOVWF 0xFDF, ACCESS
89:            	_this->tail = 0;
11454  EE20     LFSR 2, 0x41
11456  F041     NOP
11458  501A     MOVF 0x1A, W, ACCESS
1145A  26D9     ADDWF 0xFD9, F, ACCESS
1145C  501B     MOVF 0x1B, W, ACCESS
1145E  22DA     ADDWFC 0xFDA, F, ACCESS
11460  0E00     MOVLW 0x0
11462  6EDF     MOVWF 0xFDF, ACCESS
90:            	if (clearBuffer) {
11464  501C     MOVF 0x1C, W, ACCESS
11466  B4D8     BTFSC 0xFD8, 2, ACCESS
11468  0012     RETURN 0
91:            		memset(_this->buf, 0, sizeof(_this->buf));
1146A  C51A     MOVFF _this, InterruptHandler
1146C  F50E     NOP
1146E  C51B     MOVFF ptr, 0x50F
11470  F50F     NOP
11472  0E00     MOVLW 0x0
11474  6E11     MOVWF 0x11, ACCESS
11476  0E00     MOVLW 0x0
11478  6E10     MOVWF 0x10, ACCESS
1147A  0E00     MOVLW 0x0
1147C  6E13     MOVWF 0x13, ACCESS
1147E  0E40     MOVLW 0x40
11480  6E12     MOVWF 0x12, ACCESS
11482  EC17     CALL 0x10A2E, 0
11484  F085     NOP
92:            	}
93:            }
11486  0012     RETURN 0
94:            
---  /fred/pic18_k42/q43_board/q43_ntsc.X/ntsc.c  -------------------------------------------------------
1:             #include "ntsc.h"
2:             
3:             volatile uint32_t vcounts = 0;
4:             volatile uint8_t vfcounts = 0, scan_line = 0, vml = SL_V1;
5:             volatile bool ntsc_vid = true, task_hold = true;
6:             
7:             volatile enum s_mode_t s_mode;
8:             volatile uint8_t vsyncu[V_BUF_SIZ] = {0}, *vbuf_ptr;
9:             
10:            /*
11:             * function variable that should not be optimized
12:             */
13:            volatile uint8_t x;
14:            
15:            void vcntd(void);
16:            void vcnts(void);
17:            uint8_t reverse_bit8(uint8_t);
18:            
19:            /*
20:             * lsb to msb to display chars correctly
21:             */
22:            uint8_t reverse_bit8(uint8_t x)
11730  6E10     MOVWF 0x10, ACCESS
23:            {
24:            	x = ((uint8_t) ((x & (uint8_t) 0x55) << 1)) | ((uint8_t) ((x & (uint8_t) 0xAA) >> 1));
11732  C510     MOVFF blockSize, InterruptHandler
11734  F50E     NOP
11736  90D8     BCF 0xFD8, 0, ACCESS
11738  320E     RRCF 0xE, F, ACCESS
1173A  0E55     MOVLW 0x55
1173C  160E     ANDWF 0xE, F, ACCESS
1173E  C510     MOVFF blockSize, 0x50F
11740  F50F     NOP
11742  0E55     MOVLW 0x55
11744  160F     ANDWF 0xF, F, ACCESS
11746  90D8     BCF 0xFD8, 0, ACCESS
11748  340F     RLCF 0xF, W, ACCESS
1174A  100E     IORWF 0xE, W, ACCESS
1174C  6E10     MOVWF 0x10, ACCESS
25:            	x = ((uint8_t) ((x & (uint8_t) 0x33) << 2)) | ((uint8_t) ((x & (uint8_t) 0xCC) >> 2));
1174E  C510     MOVFF blockSize, InterruptHandler
11750  F50E     NOP
11752  90D8     BCF 0xFD8, 0, ACCESS
11754  320E     RRCF 0xE, F, ACCESS
11756  90D8     BCF 0xFD8, 0, ACCESS
11758  320E     RRCF 0xE, F, ACCESS
1175A  0E33     MOVLW 0x33
1175C  160E     ANDWF 0xE, F, ACCESS
1175E  C510     MOVFF blockSize, 0x50F
11760  F50F     NOP
11762  0E33     MOVLW 0x33
11764  160F     ANDWF 0xF, F, ACCESS
11766  90D8     BCF 0xFD8, 0, ACCESS
11768  360F     RLCF 0xF, F, ACCESS
1176A  90D8     BCF 0xFD8, 0, ACCESS
1176C  340F     RLCF 0xF, W, ACCESS
1176E  100E     IORWF 0xE, W, ACCESS
11770  6E10     MOVWF 0x10, ACCESS
26:            	return(uint8_t) (x << 4) | (uint8_t) (x >> 4);
11772  3810     SWAPF 0x10, W, ACCESS
27:            }
11774  0012     RETURN 0
28:            
29:            /*
30:             * setup the data formats and hardware for the DMA engine
31:             */
32:            void ntsc_init(void)
33:            {
34:            	uint16_t count = 0;
35:            	uint8_t char_c = 0, char_n = 0;
10670  0E00     MOVLW 0x0
10672  6E1C     MOVWF 0x1C, ACCESS
10674  0E00     MOVLW 0x0
10676  6E1B     MOVWF 0x1B, ACCESS
36:            
37:            	/*
38:            	 * Interrupt driven task manager
39:            	 * after the H sync pulse there are V syncs with no video
40:            	 * main-line code runs for the duration of one timer 4 interrupt period
41:            	 * ~200us for testing, then goes back to idle
42:            	 * until re-triggered the next H sync cycle
43:            	 */
44:            	TMR4_Stop();
10678  EC33     CALL 0x11C66, 0
1067A  F08E     NOP
45:            	TMR4_SetInterruptHandler(vcntd);
1067C  0EE8     MOVLW 0xE8
1067E  6E0E     MOVWF 0xE, ACCESS
10680  0E16     MOVLW 0x16
10682  6E0F     MOVWF 0xF, ACCESS
10684  0E01     MOVLW 0x1
10686  6E10     MOVWF 0x10, ACCESS
10688  EC01     CALL 0x11C02, 0
1068A  F08E     NOP
46:            
47:            	/*
48:            	 * setup system arbiter to share memory with DMA process
49:            	 */
50:            	// This function is dependant on the PR1WAY CONFIG bit
51:            	PRLOCK = 0x55;
1068C  0E55     MOVLW 0x55
1068E  0100     MOVLB 0x0
10690  6FB4     MOVWF PRLOCK, BANKED
52:            	PRLOCK = 0xAA;
10692  0EAA     MOVLW 0xAA
10694  6FB4     MOVWF PRLOCK, BANKED
53:            	PRLOCKbits.PRLOCKED = 0;
10696  91B4     BCF PRLOCK, 0, BANKED
54:            	ISRPR = 1;
10698  0E01     MOVLW 0x1
1069A  6FBF     MOVWF ISRPR, BANKED
55:            	DMA5PR = 2;
1069C  0E02     MOVLW 0x2
1069E  6FBA     MOVWF DMA5PR, BANKED
56:            	MAINPR = 3;
106A0  0E03     MOVLW 0x3
106A2  6FBE     MOVWF MAINPR, BANKED
57:            	PRLOCK = 0x55;
106A4  0E55     MOVLW 0x55
106A6  6FB4     MOVWF PRLOCK, BANKED
58:            	PRLOCK = 0xAA;
106A8  0EAA     MOVLW 0xAA
106AA  6FB4     MOVWF PRLOCK, BANKED
59:            	PRLOCKbits.PRLOCKED = 1;
106AC  81B4     BSF PRLOCK, 0, BANKED
60:            
61:            	/*
62:            	 * DMA hardware registers data setup
63:            	 */
64:            	DMA5_StopTransfer();
106AE  EC1B     CALL 0x11C36, 0
106B0  F08E     NOP
65:            	vbuf_ptr = vsync;
106B2  0E00     MOVLW 0x0
106B4  6E40     MOVWF NVMCON0, ACCESS
106B6  0E08     MOVLW 0x8
106B8  6E41     MOVWF NVMCON1, ACCESS
66:            	SLRCONB = 0xff; // reduce PORTB slewrate
106BA  0104     MOVLB 0x4
106BC  690B     SETF 0xB, BANKED
67:            	DMA5_SetDCNTIInterruptHandler(vcnts);
106BE  0E00     MOVLW 0x0
106C0  6E0E     MOVWF 0xE, ACCESS
106C2  0E04     MOVLW 0x4
106C4  6E0F     MOVWF 0xF, ACCESS
106C6  0E01     MOVLW 0x1
106C8  6E10     MOVWF 0x10, ACCESS
106CA  EC08     CALL 0x11C10, 0
106CC  F08E     NOP
68:            	DMASELECT = DMA_M;
106CE  0E04     MOVLW 0x4
106D0  0100     MOVLB 0x0
106D2  6FE8     MOVWF DMASELECT, BANKED
69:            	DMAnCON0bits.EN = 0;
106D4  9FFC     BCF DMAnCON0, 7, BANKED
70:            	DMAnSSA = (volatile uint24_t) vbuf_ptr;
106D8  F500     NOP
106DA  F0F9     NOP
106DE  F504     NOP
106E0  F0FA     NOP
106E2  6BFB     CLRF DMAnSSAU, BANKED
71:            	DMAnSSZ = DMA_B;
106E4  0E00     MOVLW 0x0
106E6  6FF8     MOVWF DMAnSSZH, BANKED
106E8  0EF0     MOVLW 0xF0
106EA  6FF7     MOVWF DMAnSSZ, BANKED
72:            	DMAnDSZ = DMAnSSZ;
106EC  C0F7     MOVFF DMAnSSZ, DMAnDSZ
106EE  F0EE     NOP
106F0  C0F8     MOVFF DMAnSSZH, DMAnDSZH
106F2  F0EF     NOP
73:            	DMAnCON0bits.EN = 1;
106F4  8FFC     BSF DMAnCON0, 7, BANKED
74:            	TRISB = vml; // video bit , on
106F8  F53C     NOP
106FA  F4C7     NOP
75:            
76:            	/*
77:            	 * setup the static V, H and video patterns for DMA transfer engine to LATB
78:            	 */
79:            	for (count = 0; count < B_START; count++) {
106FC  0E00     MOVLW 0x0
106FE  6E1E     MOVWF 0x1E, ACCESS
10700  0E00     MOVLW 0x0
10702  6E1D     MOVWF 0x1D, ACCESS
80:            		vsync[count] = SYNC_LEVEL;
10704  0E00     MOVLW 0x0
10706  241D     ADDWF 0x1D, W, ACCESS
10708  6ED9     MOVWF 0xFD9, ACCESS
1070A  0E08     MOVLW 0x8
1070C  201E     ADDWFC 0x1E, W, ACCESS
1070E  6EDA     MOVWF 0xFDA, ACCESS
10710  0E00     MOVLW 0x0
10712  6EDF     MOVWF 0xFDF, ACCESS
81:            		vsyncu[count] = SYNC_LEVEL;
10714  0E00     MOVLW 0x0
10716  241D     ADDWF 0x1D, W, ACCESS
10718  6ED9     MOVWF 0xFD9, ACCESS
1071A  0E07     MOVLW 0x7
1071C  201E     ADDWFC 0x1E, W, ACCESS
1071E  6EDA     MOVWF 0xFDA, ACCESS
10720  0E00     MOVLW 0x0
10722  6EDF     MOVWF 0xFDF, ACCESS
82:            		hsync[count] = SYNC_LEVEL;
10724  0E00     MOVLW 0x0
10726  241D     ADDWF 0x1D, W, ACCESS
10728  6ED9     MOVWF 0xFD9, ACCESS
1072A  0E09     MOVLW 0x9
1072C  201E     ADDWFC 0x1E, W, ACCESS
1072E  6EDA     MOVWF 0xFDA, ACCESS
10730  0E00     MOVLW 0x0
10732  6EDF     MOVWF 0xFDF, ACCESS
83:            	}
10734  4A1D     INFSNZ 0x1D, F, ACCESS
10736  2A1E     INCF 0x1E, F, ACCESS
10738  501E     MOVF 0x1E, W, ACCESS
1073A  E104     BNZ 0x744
1073C  0E18     MOVLW 0x18
1073E  5C1D     SUBWF 0x1D, W, ACCESS
10740  A0D8     BTFSS 0xFD8, 0, ACCESS
10742  D7E0     BRA 0x704
84:            
85:            	for (count = S_END; count < B_START; count++) {
10744  0E00     MOVLW 0x0
10746  6E1E     MOVWF 0x1E, ACCESS
10748  0E11     MOVLW 0x11
1074A  6E1D     MOVWF 0x1D, ACCESS
86:            		vsync[count] = BLANK_LEVEL;
1074C  0E00     MOVLW 0x0
1074E  241D     ADDWF 0x1D, W, ACCESS
10750  6ED9     MOVWF 0xFD9, ACCESS
10752  0E08     MOVLW 0x8
10754  201E     ADDWFC 0x1E, W, ACCESS
10756  6EDA     MOVWF 0xFDA, ACCESS
10758  0E01     MOVLW 0x1
1075A  6EDF     MOVWF 0xFDF, ACCESS
87:            		vsyncu[count] = BLANK_LEVEL;
1075C  0E00     MOVLW 0x0
1075E  241D     ADDWF 0x1D, W, ACCESS
10760  6ED9     MOVWF 0xFD9, ACCESS
10762  0E07     MOVLW 0x7
10764  201E     ADDWFC 0x1E, W, ACCESS
10766  6EDA     MOVWF 0xFDA, ACCESS
10768  0E01     MOVLW 0x1
1076A  6EDF     MOVWF 0xFDF, ACCESS
88:            		hsync[count] = SYNC_LEVEL;
1076C  0E00     MOVLW 0x0
1076E  241D     ADDWF 0x1D, W, ACCESS
10770  6ED9     MOVWF 0xFD9, ACCESS
10772  0E09     MOVLW 0x9
10774  201E     ADDWFC 0x1E, W, ACCESS
10776  6EDA     MOVWF 0xFDA, ACCESS
10778  0E00     MOVLW 0x0
1077A  6EDF     MOVWF 0xFDF, ACCESS
89:            	}
1077C  4A1D     INFSNZ 0x1D, F, ACCESS
1077E  2A1E     INCF 0x1E, F, ACCESS
10780  501E     MOVF 0x1E, W, ACCESS
10782  E104     BNZ 0x78C
10784  0E18     MOVLW 0x18
10786  5C1D     SUBWF 0x1D, W, ACCESS
10788  A0D8     BTFSS 0xFD8, 0, ACCESS
1078A  D7E0     BRA 0x74C
90:            
91:            	char_c = 7;
1078C  0E07     MOVLW 0x7
1078E  6E1C     MOVWF 0x1C, ACCESS
92:            	for (count = V_START; count < V_END; count++) {
10790  0E00     MOVLW 0x0
10792  6E1E     MOVWF 0x1E, ACCESS
10794  0E18     MOVLW 0x18
10796  6E1D     MOVWF 0x1D, ACCESS
93:            		vsync[count] |= BLANK_LEVEL;
10798  0E00     MOVLW 0x0
1079A  241D     ADDWF 0x1D, W, ACCESS
1079C  6ED9     MOVWF 0xFD9, ACCESS
1079E  0E08     MOVLW 0x8
107A0  201E     ADDWFC 0x1E, W, ACCESS
107A2  6EDA     MOVWF 0xFDA, ACCESS
107A4  0E00     MOVLW 0x0
107A6  80DB     BSF 0xFDB, 0, ACCESS
94:            		vsyncu[count] |= BLANK_LEVEL;
107A8  0E00     MOVLW 0x0
107AA  241D     ADDWF 0x1D, W, ACCESS
107AC  6ED9     MOVWF 0xFD9, ACCESS
107AE  0E07     MOVLW 0x7
107B0  201E     ADDWFC 0x1E, W, ACCESS
107B2  6EDA     MOVWF 0xFDA, ACCESS
107B4  0E00     MOVLW 0x0
107B6  80DB     BSF 0xFDB, 0, ACCESS
95:            		hsync[count] = SYNC_LEVEL;
107B8  0E00     MOVLW 0x0
107BA  241D     ADDWF 0x1D, W, ACCESS
107BC  6ED9     MOVWF 0xFD9, ACCESS
107BE  0E09     MOVLW 0x9
107C0  201E     ADDWFC 0x1E, W, ACCESS
107C2  6EDA     MOVWF 0xFDA, ACCESS
107C4  0E00     MOVLW 0x0
107C6  6EDF     MOVWF 0xFDF, ACCESS
96:            
97:            		if (count > SL_DOTS) {
107C8  501E     MOVF 0x1E, W, ACCESS
107CA  E104     BNZ 0x7D4
107CC  0E51     MOVLW 0x51
107CE  5C1D     SUBWF 0x1D, W, ACCESS
107D0  A0D8     BTFSS 0xFD8, 0, ACCESS
107D2  D013     BRA 0x7FA
98:            			if (++char_c > 6) {
107D4  2A1C     INCF 0x1C, F, ACCESS
107D6  0E06     MOVLW 0x6
107D8  641C     CPFSGT 0x1C, ACCESS
107DA  D00F     BRA 0x7FA
99:            				ntsc_font(20 + char_n++, count);
107DC  0E14     MOVLW 0x14
107DE  241B     ADDWF 0x1B, W, ACCESS
107E0  6E11     MOVWF 0x11, ACCESS
107E2  6A12     CLRF 0x12, ACCESS
107E4  0E00     MOVLW 0x0
107E6  2212     ADDWFC 0x12, F, ACCESS
107E8  C51D     MOVFF len, count
107EA  F513     NOP
107EC  C51E     MOVFF 0x51E, d
107EE  F514     NOP
107F0  EC51     CALL 0x10EA2, 0
107F2  F087     NOP
107F4  2A1B     INCF 0x1B, F, ACCESS
100:           				char_c = 0;
107F6  0E00     MOVLW 0x0
107F8  6E1C     MOVWF 0x1C, ACCESS
101:           			}
102:           		}
103:           	}
107FA  4A1D     INFSNZ 0x1D, F, ACCESS
107FC  2A1E     INCF 0x1E, F, ACCESS
107FE  501E     MOVF 0x1E, W, ACCESS
10800  E104     BNZ 0x80A
10802  0EC8     MOVLW 0xC8
10804  5C1D     SUBWF 0x1D, W, ACCESS
10806  A0D8     BTFSS 0xFD8, 0, ACCESS
10808  D7C7     BRA 0x798
104:           	for (count = V_END; count < (V_BUF_SIZ - 1); count++) {
1080A  0E00     MOVLW 0x0
1080C  6E1E     MOVWF 0x1E, ACCESS
1080E  0EC8     MOVLW 0xC8
10810  6E1D     MOVWF 0x1D, ACCESS
105:           		vsync[count] = BLANK_LEVEL;
10812  0E00     MOVLW 0x0
10814  241D     ADDWF 0x1D, W, ACCESS
10816  6ED9     MOVWF 0xFD9, ACCESS
10818  0E08     MOVLW 0x8
1081A  201E     ADDWFC 0x1E, W, ACCESS
1081C  6EDA     MOVWF 0xFDA, ACCESS
1081E  0E01     MOVLW 0x1
10820  6EDF     MOVWF 0xFDF, ACCESS
106:           		vsyncu[count] = BLANK_LEVEL;
10822  0E00     MOVLW 0x0
10824  241D     ADDWF 0x1D, W, ACCESS
10826  6ED9     MOVWF 0xFD9, ACCESS
10828  0E07     MOVLW 0x7
1082A  201E     ADDWFC 0x1E, W, ACCESS
1082C  6EDA     MOVWF 0xFDA, ACCESS
1082E  0E01     MOVLW 0x1
10830  6EDF     MOVWF 0xFDF, ACCESS
107:           		hsync[count] = SYNC_LEVEL;
10832  0E00     MOVLW 0x0
10834  241D     ADDWF 0x1D, W, ACCESS
10836  6ED9     MOVWF 0xFD9, ACCESS
10838  0E09     MOVLW 0x9
1083A  201E     ADDWFC 0x1E, W, ACCESS
1083C  6EDA     MOVWF 0xFDA, ACCESS
1083E  0E00     MOVLW 0x0
10840  6EDF     MOVWF 0xFDF, ACCESS
108:           	}
10842  4A1D     INFSNZ 0x1D, F, ACCESS
10844  2A1E     INCF 0x1E, F, ACCESS
10846  501E     MOVF 0x1E, W, ACCESS
10848  E103     BNZ 0x850
1084A  281D     INCF 0x1D, W, ACCESS
1084C  A0D8     BTFSS 0xFD8, 0, ACCESS
1084E  D7E1     BRA 0x812
109:           
110:           	for (count = (DMA_B - 5); count < (V_BUF_SIZ - 1); count++) {
10850  0E00     MOVLW 0x0
10852  6E1E     MOVWF 0x1E, ACCESS
10854  0EEB     MOVLW 0xEB
10856  6E1D     MOVWF 0x1D, ACCESS
111:           		hsync[count] = BLANK_LEVEL;
10858  0E00     MOVLW 0x0
1085A  241D     ADDWF 0x1D, W, ACCESS
1085C  6ED9     MOVWF 0xFD9, ACCESS
1085E  0E09     MOVLW 0x9
10860  201E     ADDWFC 0x1E, W, ACCESS
10862  6EDA     MOVWF 0xFDA, ACCESS
10864  0E01     MOVLW 0x1
10866  6EDF     MOVWF 0xFDF, ACCESS
112:           	}
10868  4A1D     INFSNZ 0x1D, F, ACCESS
1086A  2A1E     INCF 0x1E, F, ACCESS
1086C  501E     MOVF 0x1E, W, ACCESS
1086E  E103     BNZ 0x876
10870  281D     INCF 0x1D, W, ACCESS
10872  A0D8     BTFSS 0xFD8, 0, ACCESS
10874  D7F1     BRA 0x858
113:           
114:           	for (count = V_H; count < (V_H + 10); count++) {
10876  0E00     MOVLW 0x0
10878  6E1E     MOVWF 0x1E, ACCESS
1087A  0E78     MOVLW 0x78
1087C  6E1D     MOVWF 0x1D, ACCESS
115:           		hsync[count] = BLANK_LEVEL; // double speed H pulses
1087E  0E00     MOVLW 0x0
10880  241D     ADDWF 0x1D, W, ACCESS
10882  6ED9     MOVWF 0xFD9, ACCESS
10884  0E09     MOVLW 0x9
10886  201E     ADDWFC 0x1E, W, ACCESS
10888  6EDA     MOVWF 0xFDA, ACCESS
1088A  0E01     MOVLW 0x1
1088C  6EDF     MOVWF 0xFDF, ACCESS
116:           	}
1088E  4A1D     INFSNZ 0x1D, F, ACCESS
10890  2A1E     INCF 0x1E, F, ACCESS
10892  501E     MOVF 0x1E, W, ACCESS
10894  E104     BNZ 0x89E
10896  0E82     MOVLW 0x82
10898  5C1D     SUBWF 0x1D, W, ACCESS
1089A  A0D8     BTFSS 0xFD8, 0, ACCESS
1089C  D7F0     BRA 0x87E
117:           
118:           	// default scan mode to all lines
119:           	s_mode = sync1;
1089E  0E01     MOVLW 0x1
108A0  6E43     MOVWF NVMADR, ACCESS
120:           
121:           	/*
122:           	 * kickstart the DMA engine
123:           	 */
124:           	DMA5_StartTransfer();
108A2  EC20     CALL 0x11C40, 0
108A4  F08E     NOP
125:           	TMR4_StartTimer();
108A6  EC36     CALL 0x11C6C, 0
108A8  F08E     NOP
126:           }
108AA  0012     RETURN 0
127:           
128:           /*
129:            * Encode the font 'rom' into display memory format
130:            * two 256 byte banks for each display line, split into 4 bits per bank
131:            * It's possible to optimize 7 bits for one bank per display line but
132:            * I'm using port B so need to share the pic programmer lines on 6 and 7
133:            */
134:           void ntsc_font(uint16_t chr, uint16_t count)
135:           {
136:           	uint8_t cbits, i;
137:           
138:           	for (i = 0; i < 8; i++) {
10EA2  0E00     MOVLW 0x0
10EA4  6E1A     MOVWF 0x1A, ACCESS
139:           		cbits = reverse_bit8(fontv[(chr * 8) + (i)]); // flip bits for proper display
10EA6  C511     MOVFF chr, 0x515
10EA8  F515     NOP
10EAA  C512     MOVFF data, s
10EAC  F516     NOP
10EAE  90D8     BCF 0xFD8, 0, ACCESS
10EB0  3615     RLCF 0x15, F, ACCESS
10EB2  3616     RLCF 0x16, F, ACCESS
10EB4  90D8     BCF 0xFD8, 0, ACCESS
10EB6  3615     RLCF 0x15, F, ACCESS
10EB8  3616     RLCF 0x16, F, ACCESS
10EBA  90D8     BCF 0xFD8, 0, ACCESS
10EBC  3615     RLCF 0x15, F, ACCESS
10EBE  3616     RLCF 0x16, F, ACCESS
10EC0  0ECF     MOVLW 0xCF
10EC2  6E17     MOVWF 0x17, ACCESS
10EC4  0EFC     MOVLW 0xFC
10EC6  6E18     MOVWF 0x18, ACCESS
10EC8  5015     MOVF 0x15, W, ACCESS
10ECA  2617     ADDWF 0x17, F, ACCESS
10ECC  5016     MOVF 0x16, W, ACCESS
10ECE  2218     ADDWFC 0x18, F, ACCESS
10ED0  501A     MOVF 0x1A, W, ACCESS
10ED2  2617     ADDWF 0x17, F, ACCESS
10ED4  0E00     MOVLW 0x0
10ED6  2218     ADDWFC 0x18, F, ACCESS
10EDA  F45C     NOP
10EDC  F4F6     NOP
10EE0  F460     NOP
10EE2  F4F7     NOP
10EE4  0E00     MOVLW 0x0
10EE6  6EF8     MOVWF 0xFF8, ACCESS
10EE8  0008     TBLRD*
10EEA  50F5     MOVF 0xFF5, W, ACCESS
10EEC  EC98     CALL 0x11730, 0
10EEE  F08B     NOP
10EF0  6E19     MOVWF 0x19, ACCESS
140:           		vsync[count + i] |= ((cbits & 0xf0) >> 3) | BLANK_LEVEL; // mask and shift to upper/lower banks
10EF2  C519     MOVFF _this, 0x515
10EF4  F515     NOP
10EF6  90D8     BCF 0xFD8, 0, ACCESS
10EF8  3215     RRCF 0x15, F, ACCESS
10EFA  90D8     BCF 0xFD8, 0, ACCESS
10EFC  3215     RRCF 0x15, F, ACCESS
10EFE  90D8     BCF 0xFD8, 0, ACCESS
10F00  3215     RRCF 0x15, F, ACCESS
10F02  0E1E     MOVLW 0x1E
10F04  1615     ANDWF 0x15, F, ACCESS
10F06  0E01     MOVLW 0x1
10F08  1215     IORWF 0x15, F, ACCESS
10F0A  0E00     MOVLW 0x0
10F0C  6E16     MOVWF 0x16, ACCESS
10F0E  0E08     MOVLW 0x8
10F10  6E17     MOVWF 0x17, ACCESS
10F12  501A     MOVF 0x1A, W, ACCESS
10F14  2616     ADDWF 0x16, F, ACCESS
10F16  0E00     MOVLW 0x0
10F18  2217     ADDWFC 0x17, F, ACCESS
10F1A  5013     MOVF 0x13, W, ACCESS
10F1C  2416     ADDWF 0x16, W, ACCESS
10F1E  6ED9     MOVWF 0xFD9, ACCESS
10F20  5014     MOVF 0x14, W, ACCESS
10F22  2017     ADDWFC 0x17, W, ACCESS
10F24  6EDA     MOVWF 0xFDA, ACCESS
10F26  5015     MOVF 0x15, W, ACCESS
10F28  12DF     IORWF 0xFDF, F, ACCESS
141:           		vsyncu[count + i] |= ((cbits & 0x0f) << 1) | BLANK_LEVEL;
10F2A  C519     MOVFF _this, 0x515
10F2C  F515     NOP
10F2E  0E0F     MOVLW 0xF
10F30  1615     ANDWF 0x15, F, ACCESS
10F32  90D8     BCF 0xFD8, 0, ACCESS
10F34  3415     RLCF 0x15, W, ACCESS
10F36  6E16     MOVWF 0x16, ACCESS
10F38  0E01     MOVLW 0x1
10F3A  1216     IORWF 0x16, F, ACCESS
10F3C  0E00     MOVLW 0x0
10F3E  6E17     MOVWF 0x17, ACCESS
10F40  0E07     MOVLW 0x7
10F42  6E18     MOVWF 0x18, ACCESS
10F44  501A     MOVF 0x1A, W, ACCESS
10F46  2617     ADDWF 0x17, F, ACCESS
10F48  0E00     MOVLW 0x0
10F4A  2218     ADDWFC 0x18, F, ACCESS
10F4C  5013     MOVF 0x13, W, ACCESS
10F4E  2417     ADDWF 0x17, W, ACCESS
10F50  6ED9     MOVWF 0xFD9, ACCESS
10F52  5014     MOVF 0x14, W, ACCESS
10F54  2018     ADDWFC 0x18, W, ACCESS
10F56  6EDA     MOVWF 0xFDA, ACCESS
10F58  5016     MOVF 0x16, W, ACCESS
10F5A  12DF     IORWF 0xFDF, F, ACCESS
142:           	}
10F5C  2A1A     INCF 0x1A, F, ACCESS
10F5E  0E07     MOVLW 0x7
10F60  641A     CPFSGT 0x1A, ACCESS
10F62  D7A1     BRA 0xEA6
10F64  0012     RETURN 0
143:           }
144:           
145:           /*
146:            * low priority idle task for timer 4 ISR
147:            * waits checking task_hold until its false (set to false in DMA state machine)
148:            * this task is interruptible from all high pri interrupts and control returns after high pri processing
149:            * when it exits the hold loop, program flow returns to main for application processing
150:            * until another timer 4 interrupt returns program flow to here.
151:            */
152:           void vcntd(void) // each timer 4 interrupt
153:           {
154:           	S_SET_Toggle();
116E8  AABE     BTFSS 0xFBE, 5, ACCESS
116EA  D002     BRA 0x16F0
116EC  0E01     MOVLW 0x1
116EE  D001     BRA 0x16F2
116F0  0E00     MOVLW 0x0
116F2  0AFF     XORLW 0xFF
116F4  6E0C     MOVWF 0xC, ACCESS
116F6  3A0C     SWAPF 0xC, F, ACCESS
116F8  460C     RLNCF 0xC, F, ACCESS
116FA  50BE     MOVF 0xFBE, W, ACCESS
116FC  180C     XORWF 0xC, W, ACCESS
116FE  0BDF     ANDLW 0xDF
11700  180C     XORWF 0xC, W, ACCESS
11702  6EBE     MOVWF 0xFBE, ACCESS
155:           	TMR4_Stop();
11704  EC45     CALL 0x11C8A, 0
11706  F08E     NOP
156:           	task_hold = true;
11708  0E01     MOVLW 0x1
1170A  6E4D     MOVWF 0x4D, ACCESS
157:           	while (task_hold) {
1170C  504D     MOVF 0x4D, W, ACCESS
1170E  A4D8     BTFSS 0xFD8, 2, ACCESS
11710  D7FD     BRA 0x170C
158:           	};
159:           	S_SET_Toggle();
11712  AABE     BTFSS 0xFBE, 5, ACCESS
11714  D002     BRA 0x171A
11716  0E01     MOVLW 0x1
11718  D001     BRA 0x171C
1171A  0E00     MOVLW 0x0
1171C  0AFF     XORLW 0xFF
1171E  6E0C     MOVWF 0xC, ACCESS
11720  3A0C     SWAPF 0xC, F, ACCESS
11722  460C     RLNCF 0xC, F, ACCESS
11724  50BE     MOVF 0xFBE, W, ACCESS
11726  180C     XORWF 0xC, W, ACCESS
11728  0BDF     ANDLW 0xDF
1172A  180C     XORWF 0xC, W, ACCESS
1172C  6EBE     MOVWF 0xFBE, ACCESS
160:           }
1172E  0012     RETURN 0
161:           
162:           /*
163:            * NTSC DMA state machine
164:            * ISR triggered by the completed DMA transfer of the data buffer to PORTB
165:            * Generates the required HV sync for fake-progressive NTSC scanning on most modern TV sets
166:            * http://people.ece.cornell.edu/land/courses/ece5760/video/gvworks/GV%27s%20works%20%20NTSC%20demystified%20-%20B&W%20Video%20and%20Sync%20-%20Part%201.htm
167:            * 
168:            * some code is duplicated for scanline timing adjustments to match for different code paths.
169:            */
170:           void vcnts(void) // each scan line interrupt, 262 total for scan lines and V sync
171:           {
172:           	
173:           	x = vfcounts & 0x7; // mask bits for port B bit line and bank selection
10400  5044     MOVF NVMADRH, W, ACCESS
10402  0B07     ANDLW 0x7
10404  6E42     MOVWF NVMLOCK, ACCESS
174:           	if (x > 3) {
10406  0E03     MOVLW 0x3
10408  6442     CPFSGT NVMLOCK, ACCESS
1040A  D026     BRA 0x458
175:           		DMASELECT = DMA_M;
1040C  0E04     MOVLW 0x4
1040E  0100     MOVLB 0x0
10410  6FE8     MOVWF DMASELECT, BANKED
176:           		switch (x) {
10412  D00D     BRA 0x42E
177:           		case 4:
178:           			vml = SL_V4;
10414  0EEE     MOVLW 0xEE
10416  D031     BRA 0x47A
179:           			DMAnSSA = (volatile uint24_t) vsyncu; // upper bitmap
180:           			break;
181:           		case 5:
182:           			vml = SL_V3;
10418  0EF6     MOVLW 0xF6
1041A  D02F     BRA 0x47A
183:           			DMAnSSA = (volatile uint24_t) vsyncu; // upper bitmap
184:           			break;
185:           		case 6:
186:           			vml = SL_V2;
1041C  0EFA     MOVLW 0xFA
1041E  D02D     BRA 0x47A
187:           			DMAnSSA = (volatile uint24_t) vsyncu; // upper bitmap
188:           			break;
189:           		case 7:
190:           			vml = SL_V1;
10420  0EFC     MOVLW 0xFC
10422  D023     BRA 0x46A
191:           			DMAnSSA = (volatile uint24_t) vsync; // lower bitmap
10424  6FFB     MOVWF DMAnSSAU, BANKED
192:           			break;
10426  D045     BRA 0x4B2
193:           		default:
194:           			vml = SL_V_OFF;
10428  0EFE     MOVLW 0xFE
1042A  6E4F     MOVWF 0x4F, ACCESS
195:           			break;
1042C  D042     BRA 0x4B2
196:           		}
1042E  5042     MOVF NVMLOCK, W, ACCESS
10430  6E02     MOVWF 0x2, ACCESS
10432  6A03     CLRF 0x3, ACCESS
10434  5003     MOVF 0x3, W, ACCESS
10436  0A00     XORLW 0x0
10438  A4D8     BTFSS 0xFD8, 2, ACCESS
1043A  D7F6     BRA 0x428
1043C  5002     MOVF 0x2, W, ACCESS
1043E  0A04     XORLW 0x4
10440  B4D8     BTFSC 0xFD8, 2, ACCESS
10442  D7E8     BRA 0x414
10444  0A01     XORLW 0x1
10446  B4D8     BTFSC 0xFD8, 2, ACCESS
10448  D7E7     BRA 0x418
1044A  0A03     XORLW 0x3
1044C  B4D8     BTFSC 0xFD8, 2, ACCESS
1044E  D7E6     BRA 0x41C
10450  0A01     XORLW 0x1
10452  B4D8     BTFSC 0xFD8, 2, ACCESS
10454  D7E5     BRA 0x420
10456  D7E8     BRA 0x428
197:           	} else {
198:           		DMASELECT = DMA_M;
10458  0E04     MOVLW 0x4
1045A  0100     MOVLB 0x0
1045C  6FE8     MOVWF DMASELECT, BANKED
199:           		switch (x) {
1045E  D014     BRA 0x488
200:           		case 0:
201:           			vml = SL_V4;
10460  0EEE     MOVLW 0xEE
10462  D003     BRA 0x46A
202:           			DMAnSSA = (volatile uint24_t) vsync; // lower bitmap
203:           			break;
204:           		case 1:
205:           			vml = SL_V3;
10464  0EF6     MOVLW 0xF6
10466  D001     BRA 0x46A
206:           			DMAnSSA = (volatile uint24_t) vsync; // lower bitmap
207:           			break;
208:           		case 2:
209:           			vml = SL_V2;
10468  0EFA     MOVLW 0xFA
1046A  6E4F     MOVWF 0x4F, ACCESS
210:           			DMAnSSA = (volatile uint24_t) vsync; // lower bitmap
1046C  0E00     MOVLW 0x0
1046E  6FF9     MOVWF DMAnSSA, BANKED
10470  0E08     MOVLW 0x8
10472  6FFA     MOVWF DMAnSSAH, BANKED
10474  0E00     MOVLW 0x0
10476  D7D6     BRA 0x424
211:           			break;
212:           		case 3:
213:           			vml = SL_V1;
10478  0EFC     MOVLW 0xFC
1047A  6E4F     MOVWF 0x4F, ACCESS
214:           			DMAnSSA = (volatile uint24_t) vsyncu; // upper bitmap
1047C  0E00     MOVLW 0x0
1047E  6FF9     MOVWF DMAnSSA, BANKED
10480  0E07     MOVLW 0x7
10482  6FFA     MOVWF DMAnSSAH, BANKED
10484  0E00     MOVLW 0x0
10486  D7CE     BRA 0x424
215:           			break;
216:           		default:
217:           			vml = SL_V_OFF;
218:           			break;
219:           		}
10488  5042     MOVF NVMLOCK, W, ACCESS
1048A  6E02     MOVWF 0x2, ACCESS
1048C  6A03     CLRF 0x3, ACCESS
1048E  5003     MOVF 0x3, W, ACCESS
10490  0A00     XORLW 0x0
10492  A4D8     BTFSS 0xFD8, 2, ACCESS
10494  D7C9     BRA 0x428
10496  5002     MOVF 0x2, W, ACCESS
10498  0A00     XORLW 0x0
1049A  B4D8     BTFSC 0xFD8, 2, ACCESS
1049C  D7E1     BRA 0x460
1049E  0A01     XORLW 0x1
104A0  B4D8     BTFSC 0xFD8, 2, ACCESS
104A2  D7E0     BRA 0x464
104A4  0A03     XORLW 0x3
104A6  B4D8     BTFSC 0xFD8, 2, ACCESS
104A8  D7DF     BRA 0x468
104AA  0A01     XORLW 0x1
104AC  B4D8     BTFSC 0xFD8, 2, ACCESS
104AE  D7E4     BRA 0x478
104B0  D7BB     BRA 0x428
220:           	}
221:           	vfcounts++;
104B2  2A44     INCF NVMADRH, F, ACCESS
222:           
223:           
224:           	switch (s_mode) {
104B4  D0C2     BRA 0x63A
225:           	case sync0: // H sync and video, one line
226:           		if (vfcounts >= B_COUNT) {
104B6  0ED8     MOVLW 0xD8
104B8  6444     CPFSGT NVMADRH, ACCESS
104BA  D01F     BRA 0x4FA
227:           			s_mode = syncB;
104BC  0E02     MOVLW 0x2
104BE  6E43     MOVWF NVMADR, ACCESS
228:           			DMASELECT = DMA_M;
104C0  0E04     MOVLW 0x4
104C2  6FE8     MOVWF DMASELECT, BANKED
229:           			DMAnCON0bits.EN = 0;
104C4  9FFC     BCF DMAnCON0, 7, BANKED
230:           			DMAnSSA = (volatile uint24_t) vbuf_ptr;
104C8  F500     NOP
104CA  F0F9     NOP
104CE  F504     NOP
104D0  F0FA     NOP
104D2  6BFB     CLRF DMAnSSAU, BANKED
231:           			DMAnSSZ = DMA_B;
104D4  0E00     MOVLW 0x0
104D6  6FF8     MOVWF DMAnSSZH, BANKED
104D8  0EF0     MOVLW 0xF0
104DA  6FF7     MOVWF DMAnSSZ, BANKED
232:           			DMAnDSZ = DMAnSSZ;
104DC  C0F7     MOVFF DMAnSSZ, DMAnDSZ
104DE  F0EE     NOP
104E0  C0F8     MOVFF DMAnSSZH, DMAnDSZH
104E2  F0EF     NOP
233:           			DMAnCON0bits.EN = 1;
104E4  8FFC     BSF DMAnCON0, 7, BANKED
234:           			TRISB = SL_V_OFF;
104E6  0EFE     MOVLW 0xFE
104E8  6EC7     MOVWF 0xFC7, ACCESS
235:           			/*
236:           			 * trigger main task processing using the task manager
237:           			 */
238:           			task_hold = false; // clear idle routine run flag
104EA  0E00     MOVLW 0x0
104EC  6E4D     MOVWF 0x4D, ACCESS
239:           			TMR4_Period8BitSet(TASK_S1);
104EE  0E55     MOVLW 0x55
104F0  EC2A     CALL 0x11C54, 0
104F2  F08E     NOP
240:           			TMR4_StartTimer(); // run in main for timer 4 interrupt period then back to idle
104F4  EC48     CALL 0x11C90, 0
104F6  F08E     NOP
241:           		} else {
104F8  D0B8     BRA 0x66A
242:           			if (vfcounts == scan_line) {
104FA  5045     MOVF NVMADRU, W, ACCESS
104FC  1844     XORWF NVMADRH, W, ACCESS
104FE  A4D8     BTFSS 0xFD8, 2, ACCESS
10500  D004     BRA 0x50A
243:           				TRISB = vml; // video memory line , on
10504  F53C     NOP
10506  F4C7     NOP
244:           			} else {
10508  D0B0     BRA 0x66A
245:           				TRISB = SL_V_OFF; // turn-off all video bits
1050A  0EFE     MOVLW 0xFE
1050C  6EC7     MOVWF 0xFC7, ACCESS
1050E  D0AD     BRA 0x66A
246:           			}
247:           		}
248:           		break;
249:           	case sync1: // H sync and video, all lines
250:           		if (vfcounts >= B_COUNT) {
10510  0ED8     MOVLW 0xD8
10512  6444     CPFSGT NVMADRH, ACCESS
10514  D01D     BRA 0x550
251:           			s_mode = syncB;
10516  0E02     MOVLW 0x2
10518  6E43     MOVWF NVMADR, ACCESS
252:           			DMASELECT = DMA_M;
1051A  0E04     MOVLW 0x4
1051C  6FE8     MOVWF DMASELECT, BANKED
253:           			DMAnCON0bits.EN = 0;
1051E  9FFC     BCF DMAnCON0, 7, BANKED
254:           			DMAnSSA = (volatile uint24_t) vbuf_ptr;
10522  F500     NOP
10524  F0F9     NOP
10528  F504     NOP
1052A  F0FA     NOP
1052C  6BFB     CLRF DMAnSSAU, BANKED
255:           			DMAnSSZ = DMA_B;
1052E  0E00     MOVLW 0x0
10530  6FF8     MOVWF DMAnSSZH, BANKED
10532  0EF0     MOVLW 0xF0
10534  6FF7     MOVWF DMAnSSZ, BANKED
256:           			DMAnDSZ = DMAnSSZ;
10536  C0F7     MOVFF DMAnSSZ, DMAnDSZ
10538  F0EE     NOP
1053A  C0F8     MOVFF DMAnSSZH, DMAnDSZH
1053C  F0EF     NOP
257:           			DMAnCON0bits.EN = 1;
1053E  8FFC     BSF DMAnCON0, 7, BANKED
258:           			TRISB = SL_V_OFF; // turn-off all video bits
10540  0EFE     MOVLW 0xFE
10542  6EC7     MOVWF 0xFC7, ACCESS
259:           			/*
260:           			 * trigger main task processing using the task manager
261:           			 */
262:           			task_hold = false; // clear idle routine run flag
10544  0E00     MOVLW 0x0
10546  6E4D     MOVWF 0x4D, ACCESS
263:           			TMR4_Period8BitSet(TASK_S1);
10548  0E55     MOVLW 0x55
1054A  EC2A     CALL 0x11C54, 0
1054C  F08E     NOP
1054E  D7D2     BRA 0x4F4
264:           			TMR4_StartTimer(); // run in main for timer 4 interrupt period then back to idle
265:           		} else {
266:           			if (ntsc_vid) {
10550  504E     MOVF 0x4E, W, ACCESS
10552  A4D8     BTFSS 0xFD8, 2, ACCESS
10554  D7D6     BRA 0x502
10556  D7D9     BRA 0x50A
267:           				TRISB = vml; // video bit , on
268:           			} else {
269:           				TRISB = SL_V_OFF; // turn-off all video bits
270:           			}
271:           		}
272:           		break;
273:           	case syncB: // H sync and no video, bottom blank
274:           		if (vfcounts >= S_COUNT) {
10558  0EF6     MOVLW 0xF6
1055A  6444     CPFSGT NVMADRH, ACCESS
1055C  D086     BRA 0x66A
275:           			vfcounts = 0;
1055E  0E00     MOVLW 0x0
10560  6E44     MOVWF NVMADRH, ACCESS
276:           			s_mode = sync2;
10562  0E03     MOVLW 0x3
10564  6E43     MOVWF NVMADR, ACCESS
277:           			DMASELECT = DMA_M;
10566  0E04     MOVLW 0x4
10568  6FE8     MOVWF DMASELECT, BANKED
278:           			DMAnCON0bits.EN = 0;
1056A  9FFC     BCF DMAnCON0, 7, BANKED
279:           			DMAnSSA = (volatile uint24_t) & hsync;
1056C  0E00     MOVLW 0x0
1056E  6FF9     MOVWF DMAnSSA, BANKED
10570  0E09     MOVLW 0x9
10572  6FFA     MOVWF DMAnSSAH, BANKED
10574  0E00     MOVLW 0x0
10576  6FFB     MOVWF DMAnSSAU, BANKED
10578  D03D     BRA 0x5F4
280:           			DMAnSSZ = DMA_B;
281:           			DMAnDSZ = DMAnSSZ;
1057A  C0F7     MOVFF DMAnSSZ, DMAnDSZ
1057C  F0EE     NOP
1057E  C0F8     MOVFF DMAnSSZH, DMAnDSZH
10580  F0EF     NOP
282:           			DMAnCON0bits.EN = 1;
10582  D03D     BRA 0x5FE
283:           		}
284:           		break;
285:           	case sync2: // V sync and no video
286:           		if (vfcounts >= H_SYNC) {
10584  0E02     MOVLW 0x2
10586  6444     CPFSGT NVMADRH, ACCESS
10588  D070     BRA 0x66A
287:           			vfcounts = 0;
1058A  0E00     MOVLW 0x0
1058C  6E44     MOVWF NVMADRH, ACCESS
288:           			s_mode = sync3;
1058E  0E04     MOVLW 0x4
10590  6E43     MOVWF NVMADR, ACCESS
289:           			DMASELECT = DMA_M;
10592  0E04     MOVLW 0x4
10594  6FE8     MOVWF DMASELECT, BANKED
290:           			DMAnCON0bits.EN = 0;
10596  9FFC     BCF DMAnCON0, 7, BANKED
291:           			DMAnSSA = (volatile uint24_t) vbuf_ptr;
1059A  F500     NOP
1059C  F0F9     NOP
105A0  F504     NOP
105A2  F0FA     NOP
105A4  6BFB     CLRF DMAnSSAU, BANKED
292:           			DMAnSSZ = DMA_B;
105A6  0E00     MOVLW 0x0
105A8  6FF8     MOVWF DMAnSSZH, BANKED
105AA  0EF0     MOVLW 0xF0
105AC  6FF7     MOVWF DMAnSSZ, BANKED
293:           			DMAnDSZ = DMAnSSZ;
105AE  C0F7     MOVFF DMAnSSZ, DMAnDSZ
105B0  F0EE     NOP
105B2  C0F8     MOVFF DMAnSSZH, DMAnDSZH
105B4  F0EF     NOP
294:           			DMAnCON0bits.EN = 1;
105B6  8FFC     BSF DMAnCON0, 7, BANKED
295:           			TRISB = SL_V_OFF; // turn-off all video bits
105B8  0EFE     MOVLW 0xFE
105BA  6EC7     MOVWF 0xFC7, ACCESS
296:           			/*
297:           			 * trigger main task processing using the task manager
298:           			 */
299:           			task_hold = false; // clear idle routine run flag
105BC  0E00     MOVLW 0x0
105BE  6E4D     MOVWF 0x4D, ACCESS
300:           			TMR4_Period8BitSet(TASK_S2);
105C0  0E1E     MOVLW 0x1E
105C2  EC2A     CALL 0x11C54, 0
105C4  F08E     NOP
105C6  D796     BRA 0x4F4
301:           			TMR4_StartTimer(); // run in main for timer 4 interrupt period then back to idle
302:           		}
303:           		break;
304:           	case sync3: // H sync and no video
305:           		if (vfcounts >= H_COUNT) {
105C8  0E0B     MOVLW 0xB
105CA  6444     CPFSGT NVMADRH, ACCESS
105CC  D04E     BRA 0x66A
306:           			vfcounts = 0;
105CE  0E00     MOVLW 0x0
105D0  6E44     MOVWF NVMADRH, ACCESS
307:           			if ((bool) scan_line) {
105D2  5045     MOVF NVMADRU, W, ACCESS
105D4  B4D8     BTFSC 0xFD8, 2, ACCESS
105D6  D002     BRA 0x5DC
308:           				s_mode = sync0;
105D8  0E00     MOVLW 0x0
105DA  D001     BRA 0x5DE
309:           			} else {
310:           				s_mode = sync1;
105DC  0E01     MOVLW 0x1
105DE  6E43     MOVWF NVMADR, ACCESS
311:           			}
312:           			DMASELECT = DMA_M;
105E0  0E04     MOVLW 0x4
105E2  6FE8     MOVWF DMASELECT, BANKED
313:           			DMAnCON0bits.EN = 0;
105E4  9FFC     BCF DMAnCON0, 7, BANKED
314:           			DMAnSSA = (volatile uint24_t) vbuf_ptr;
105E8  F500     NOP
105EA  F0F9     NOP
105EE  F504     NOP
105F0  F0FA     NOP
105F2  6BFB     CLRF DMAnSSAU, BANKED
315:           			DMAnSSZ = DMA_B;
105F4  0E00     MOVLW 0x0
105F6  6FF8     MOVWF DMAnSSZH, BANKED
105F8  0EF0     MOVLW 0xF0
105FA  6FF7     MOVWF DMAnSSZ, BANKED
316:           			DMAnDSZ = DMAnSSZ;
105FC  D7BE     BRA 0x57A
317:           			DMAnCON0bits.EN = 1;
105FE  8FFC     BSF DMAnCON0, 7, BANKED
10600  D034     BRA 0x66A
318:           		}
319:           		break;
320:           	default:
321:           		vfcounts = 0;
10602  0E00     MOVLW 0x0
10604  6E44     MOVWF NVMADRH, ACCESS
322:           		s_mode = sync1;
10606  0E01     MOVLW 0x1
10608  6E43     MOVWF NVMADR, ACCESS
323:           		DMASELECT = DMA_M;
1060A  0E04     MOVLW 0x4
1060C  6FE8     MOVWF DMASELECT, BANKED
324:           		DMAnCON0bits.EN = 0;
1060E  9FFC     BCF DMAnCON0, 7, BANKED
325:           		vbuf_ptr = vsync;
10610  0E00     MOVLW 0x0
10612  6E40     MOVWF NVMCON0, ACCESS
10614  0E08     MOVLW 0x8
10616  6E41     MOVWF NVMCON1, ACCESS
326:           		DMAnSSA = (volatile uint24_t) vbuf_ptr;
1061A  F500     NOP
1061C  F0F9     NOP
10620  F504     NOP
10622  F0FA     NOP
10624  6BFB     CLRF DMAnSSAU, BANKED
327:           		DMAnSSZ = DMA_B;
10626  0E00     MOVLW 0x0
10628  6FF8     MOVWF DMAnSSZH, BANKED
1062A  0EF0     MOVLW 0xF0
1062C  6FF7     MOVWF DMAnSSZ, BANKED
328:           		DMAnDSZ = DMAnSSZ;
1062E  C0F7     MOVFF DMAnSSZ, DMAnDSZ
10630  F0EE     NOP
10632  C0F8     MOVFF DMAnSSZH, DMAnDSZH
10634  F0EF     NOP
329:           		DMAnCON0bits.EN = 1;
10636  8FFC     BSF DMAnCON0, 7, BANKED
10638  D764     BRA 0x502
330:           		TRISB = vml; // video bit , on
331:           		break;
332:           	}
1063A  5043     MOVF NVMADR, W, ACCESS
1063C  6E02     MOVWF 0x2, ACCESS
1063E  6A03     CLRF 0x3, ACCESS
10640  5003     MOVF 0x3, W, ACCESS
10642  0A00     XORLW 0x0
10644  A4D8     BTFSS 0xFD8, 2, ACCESS
10646  D7DD     BRA 0x602
10648  5002     MOVF 0x2, W, ACCESS
1064A  0A00     XORLW 0x0
1064C  B4D8     BTFSC 0xFD8, 2, ACCESS
1064E  D733     BRA 0x4B6
10650  0A01     XORLW 0x1
10652  B4D8     BTFSC 0xFD8, 2, ACCESS
10654  D75D     BRA 0x510
10656  0A03     XORLW 0x3
10658  B4D8     BTFSC 0xFD8, 2, ACCESS
1065A  D77E     BRA 0x558
1065C  0A01     XORLW 0x1
1065E  B4D8     BTFSC 0xFD8, 2, ACCESS
10660  D791     BRA 0x584
10662  0A07     XORLW 0x7
10664  B4D8     BTFSC 0xFD8, 2, ACCESS
10666  D7B0     BRA 0x5C8
10668  D7CC     BRA 0x602
333:           
334:           	/*
335:           	 * re-trigger the state machine for a new scanline
336:           	 */
337:           	DMA5_StartTransfer();
1066A  EC25     CALL 0x11C4A, 0
1066C  F08E     NOP
338:           }
1066E  0012     RETURN 0
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/uart1.c  ----------------------------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.4.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            #include "interrupt_manager.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            #define UART1_TX_BUFFER_SIZE 64
58:            #define UART1_RX_BUFFER_SIZE 64
59:            
60:            /**
61:              Section: Global Variables
62:            */
63:            
64:            static volatile uint8_t uart1TxHead = 0;
65:            static volatile uint8_t uart1TxTail = 0;
66:            static volatile uint8_t uart1TxBuffer[UART1_TX_BUFFER_SIZE];
67:            volatile uint8_t uart1TxBufferRemaining;
68:            
69:            static volatile uint8_t uart1RxHead = 0;
70:            static volatile uint8_t uart1RxTail = 0;
71:            static volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
72:            static volatile uart1_status_t uart1RxStatusBuffer[UART1_RX_BUFFER_SIZE];
73:            volatile uint8_t uart1RxCount;
74:            static volatile uart1_status_t uart1RxLastError;
75:            
76:            /**
77:              Section: UART1 APIs
78:            */
79:            void (*UART1_FramingErrorHandler)(void);
80:            void (*UART1_OverrunErrorHandler)(void);
81:            void (*UART1_ErrorHandler)(void);
82:            
83:            void UART1_DefaultFramingErrorHandler(void);
84:            void UART1_DefaultOverrunErrorHandler(void);
85:            void UART1_DefaultErrorHandler(void);
86:            
87:            void UART1_Initialize(void)
88:            {
89:                // Disable interrupts before changing states
90:                PIE4bits.U1RXIE = 0;
10F66  90A2     BCF 0xFA2, 0, ACCESS
91:                UART1_SetRxInterruptHandler(UART1_Receive_ISR);
10F68  0E7C     MOVLW 0x7C
10F6A  6E0E     MOVWF 0xE, ACCESS
10F6C  0E11     MOVLW 0x11
10F6E  6E0F     MOVWF 0xF, ACCESS
10F70  0E01     MOVLW 0x1
10F72  6E10     MOVWF 0x10, ACCESS
10F74  ECD7     CALL 0x11BAE, 0
10F76  F08D     NOP
92:                PIE4bits.U1TXIE = 0;
10F78  92A2     BCF 0xFA2, 1, ACCESS
93:                UART1_SetTxInterruptHandler(UART1_Transmit_ISR);
10F7A  0EF8     MOVLW 0xF8
10F7C  6E0E     MOVWF 0xE, ACCESS
10F7E  0E19     MOVLW 0x19
10F80  6E0F     MOVWF 0xF, ACCESS
10F82  0E01     MOVLW 0x1
10F84  6E10     MOVWF 0x10, ACCESS
10F86  ECD0     CALL 0x11BA0, 0
10F88  F08D     NOP
94:            
95:                // Set the UART1 module to the options selected in the user interface.
96:            
97:                // P1L 0; 
98:                U1P1L = 0x00;
10F8A  0E00     MOVLW 0x0
10F8C  0102     MOVLB 0x2
10F8E  6FA5     MOVWF 0xA5, BANKED
99:            
100:               // P1H 0; 
101:               U1P1H = 0x00;
10F90  0E00     MOVLW 0x0
10F92  6FA6     MOVWF 0xA6, BANKED
102:           
103:               // P2L 0; 
104:               U1P2L = 0x00;
10F94  0E00     MOVLW 0x0
10F96  6FA7     MOVWF 0xA7, BANKED
105:           
106:               // P2H 0; 
107:               U1P2H = 0x00;
10F98  0E00     MOVLW 0x0
10F9A  6FA8     MOVWF 0xA8, BANKED
108:           
109:               // P3L 0; 
110:               U1P3L = 0x00;
10F9C  0E00     MOVLW 0x0
10F9E  6FA9     MOVWF 0xA9, BANKED
111:           
112:               // P3H 0; 
113:               U1P3H = 0x00;
10FA0  0E00     MOVLW 0x0
10FA2  6FAA     MOVWF 0xAA, BANKED
114:           
115:               // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
116:               U1CON0 = 0xB0;
10FA4  0EB0     MOVLW 0xB0
10FA6  6FAB     MOVWF 0xAB, BANKED
117:           
118:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
119:               U1CON1 = 0x80;
10FA8  0E80     MOVLW 0x80
10FAA  6FAC     MOVWF ACTCON, BANKED
120:           
121:               // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
122:               U1CON2 = 0x00;
10FAC  0E00     MOVLW 0x0
10FAE  6FAD     MOVWF OSCCON1, BANKED
123:           
124:               // BRGL 130; 
125:               U1BRGL = 0x82;
10FB0  0E82     MOVLW 0x82
10FB2  6FAE     MOVWF OSCCON2, BANKED
126:           
127:               // BRGH 6; 
128:               U1BRGH = 0x06;
10FB4  0E06     MOVLW 0x6
10FB6  6FAF     MOVWF OSCCON3, BANKED
129:           
130:               // STPMD in middle of first Stop bit; TXWRE No error; 
131:               U1FIFO = 0x00;
10FB8  0E00     MOVLW 0x0
10FBA  6FB0     MOVWF OSCTUNE, BANKED
132:           
133:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
134:               U1UIR = 0x00;
10FBC  0E00     MOVLW 0x0
10FBE  6FB1     MOVWF OSCFRQ, BANKED
135:           
136:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
137:               U1ERRIR = 0x00;
10FC0  0E00     MOVLW 0x0
10FC2  6FB2     MOVWF OSCSTAT, BANKED
138:           
139:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
140:               U1ERRIE = 0x00;
10FC4  0E00     MOVLW 0x0
10FC6  6FB3     MOVWF OSCEN, BANKED
141:           
142:           
143:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
10FC8  0EA8     MOVLW 0xA8
10FCA  6E0E     MOVWF 0xE, ACCESS
10FCC  0E1C     MOVLW 0x1C
10FCE  6E0F     MOVWF 0xF, ACCESS
10FD0  0E01     MOVLW 0x1
10FD2  6E10     MOVWF 0x10, ACCESS
10FD4  ECE5     CALL 0x11BCA, 0
10FD6  F08D     NOP
144:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
10FD8  0EA6     MOVLW 0xA6
10FDA  6E0E     MOVWF 0xE, ACCESS
10FDC  0E1C     MOVLW 0x1C
10FDE  6E0F     MOVWF 0xF, ACCESS
10FE0  0E01     MOVLW 0x1
10FE2  6E10     MOVWF 0x10, ACCESS
10FE4  ECDE     CALL 0x11BBC, 0
10FE6  F08D     NOP
145:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
10FE8  0E84     MOVLW 0x84
10FEA  6E0E     MOVWF 0xE, ACCESS
10FEC  0E1C     MOVLW 0x1C
10FEE  6E0F     MOVWF 0xF, ACCESS
10FF0  0E01     MOVLW 0x1
10FF2  6E10     MOVWF 0x10, ACCESS
10FF4  ECEC     CALL 0x11BD8, 0
10FF6  F08D     NOP
146:           
147:               uart1RxLastError.status = 0;
10FF8  0E00     MOVLW 0x0
10FFA  0105     MOVLB 0x5
10FFC  6FE9     MOVWF DMAnBUF, BANKED
148:           
149:               // initializing the driver state
150:               uart1TxHead = 0;
10FFE  0E00     MOVLW 0x0
11000  6E4B     MOVWF HLVDCON1, ACCESS
151:               uart1TxTail = 0;
11002  0E00     MOVLW 0x0
11004  6E4A     MOVWF HLVDCON0, ACCESS
152:               uart1TxBufferRemaining = sizeof(uart1TxBuffer);
11006  0E40     MOVLW 0x40
11008  6E49     MOVWF BORCON, ACCESS
153:               uart1RxHead = 0;
1100A  0E00     MOVLW 0x0
1100C  6E48     MOVWF VREGCON, ACCESS
154:               uart1RxTail = 0;
1100E  0E00     MOVLW 0x0
11010  6E47     MOVWF NVMDATH, ACCESS
155:               uart1RxCount = 0;
11012  0E00     MOVLW 0x0
11014  6E46     MOVWF NVMDAT, ACCESS
156:           
157:               // enable receive interrupt
158:               PIE4bits.U1RXIE = 1;
11016  80A2     BSF 0xFA2, 0, ACCESS
159:           }
11018  0012     RETURN 0
160:           
161:           bool UART1_is_rx_ready(void)
162:           {
163:               return (uart1RxCount ? true : false);
164:           }
165:           
166:           bool UART1_is_tx_ready(void)
167:           {
168:               return (uart1TxBufferRemaining ? true : false);
169:           }
170:           
171:           bool UART1_is_tx_done(void)
172:           {
173:               return U1ERRIRbits.TXMTIF;
174:           }
175:           
176:           uart1_status_t UART1_get_last_status(void){
177:               return uart1RxLastError;
178:           }
179:           
180:           uint8_t UART1_Read(void)
181:           {
182:               uint8_t readValue  = 0;
183:               
184:               while(0 == uart1RxCount)
185:               {
186:               }
187:           
188:               uart1RxLastError = uart1RxStatusBuffer[uart1RxTail];
189:           
190:               readValue = uart1RxBuffer[uart1RxTail++];
191:              	if(sizeof(uart1RxBuffer) <= uart1RxTail)
192:               {
193:                   uart1RxTail = 0;
194:               }
195:               PIE4bits.U1RXIE = 0;
196:               uart1RxCount--;
197:               PIE4bits.U1RXIE = 1;
198:           
199:               return readValue;
200:           }
201:           
202:           void UART1_Write(uint8_t txData)
203:           {
204:               while(0 == uart1TxBufferRemaining)
205:               {
206:               }
207:           
208:               if(0 == PIE4bits.U1TXIE)
209:               {
210:                   U1TXB = txData;
211:               }
212:               else
213:               {
214:                   PIE4bits.U1TXIE = 0;
215:                   uart1TxBuffer[uart1TxHead++] = txData;
216:                   if(sizeof(uart1TxBuffer) <= uart1TxHead)
217:                   {
218:                       uart1TxHead = 0;
219:                   }
220:                   uart1TxBufferRemaining--;
221:               }
222:               PIE4bits.U1TXIE = 1;
223:           }
224:           
225:           void __interrupt(irq(U1TX),base(8),low_priority) UART1_tx_vect_isr()
11906  F360     NOP
11908  F50A     NOP
226:           {   
227:               if(UART1_TxInterruptHandler)
1190A  0105     MOVLB 0x5
1190C  51D7     MOVF CLCnPOL, W, BANKED
1190E  11D8     IORWF CLCnSEL0, W, BANKED
11910  11D9     IORWF CLCnSEL1, W, BANKED
11912  B4D8     BTFSC 0xFD8, 2, ACCESS
11914  D00C     BRA 0x192E
228:               {
229:                   UART1_TxInterruptHandler();
11916  D801     RCALL 0x191A
11918  D00A     BRA 0x192E
1191A  0005     PUSH
1191C  6EFA     MOVWF 0xFFA, ACCESS
1191E  51D7     MOVF CLCnPOL, W, BANKED
11920  6EFD     MOVWF 0xFFD, ACCESS
11922  51D8     MOVF CLCnSEL0, W, BANKED
11924  6EFE     MOVWF 0xFFE, ACCESS
11926  51D9     MOVF CLCnSEL1, W, BANKED
11928  6EFF     MOVWF 0xFFF, ACCESS
1192A  50FA     MOVF 0xFFA, W, ACCESS
1192C  0012     RETURN 0
230:               }
231:           }
11930  F428     NOP
11932  F4D8     NOP
11934  0011     RETFIE 1
232:           
233:           void __interrupt(irq(U1RX),base(8),low_priority) UART1_rx_vect_isr()
234:           {
235:               if(UART1_RxInterruptHandler)
1193E  0105     MOVLB 0x5
11940  51DA     MOVF CLCnSEL2, W, BANKED
11942  11DB     IORWF CLCnSEL3, W, BANKED
11944  11DC     IORWF CLCnGLS0, W, BANKED
11946  B4D8     BTFSC 0xFD8, 2, ACCESS
11948  D00C     BRA 0x1962
236:               {
237:                   UART1_RxInterruptHandler();
1194A  D801     RCALL 0x194E
1194C  D00A     BRA 0x1962
1194E  0005     PUSH
11950  6EFA     MOVWF 0xFFA, ACCESS
11952  51DA     MOVF CLCnSEL2, W, BANKED
11954  6EFD     MOVWF 0xFFD, ACCESS
11956  51DB     MOVF CLCnSEL3, W, BANKED
11958  6EFE     MOVWF 0xFFE, ACCESS
1195A  51DC     MOVF CLCnGLS0, W, BANKED
1195C  6EFF     MOVWF 0xFFF, ACCESS
1195E  50FA     MOVF 0xFFA, W, ACCESS
11960  0012     RETURN 0
238:               }
239:           }
240:           
241:           
242:           
243:           void UART1_Transmit_ISR(void)
244:           {
245:               // use this default transmit interrupt handler code
246:               if(sizeof(uart1TxBuffer) > uart1TxBufferRemaining)
119F8  0E40     MOVLW 0x40
119FA  6049     CPFSLT BORCON, ACCESS
119FC  D011     BRA 0x1A20
247:               {
248:                   U1TXB = uart1TxBuffer[uart1TxTail++];
119FE  0E40     MOVLW 0x40
11A00  244A     ADDWF HLVDCON0, W, ACCESS
11A02  6ED9     MOVWF 0xFD9, ACCESS
11A04  6ADA     CLRF 0xFDA, ACCESS
11A06  0E06     MOVLW 0x6
11A08  22DA     ADDWFC 0xFDA, F, ACCESS
11A0A  50DF     MOVF 0xFDF, W, ACCESS
11A0C  0102     MOVLB 0x2
11A0E  6FA3     MOVWF 0xA3, BANKED
11A10  2A4A     INCF HLVDCON0, F, ACCESS
249:                  if(sizeof(uart1TxBuffer) <= uart1TxTail)
11A12  0E3F     MOVLW 0x3F
11A14  644A     CPFSGT HLVDCON0, ACCESS
11A16  D002     BRA 0x1A1C
250:                   {
251:                       uart1TxTail = 0;
11A18  0E00     MOVLW 0x0
11A1A  6E4A     MOVWF HLVDCON0, ACCESS
252:                   }
253:                   uart1TxBufferRemaining++;
11A1C  2A49     INCF BORCON, F, ACCESS
254:               }
11A1E  0012     RETURN 0
255:               else
256:               {
257:                   PIE4bits.U1TXIE = 0;
11A20  92A2     BCF 0xFA2, 1, ACCESS
258:               }
259:               
260:               // or set custom function using UART1_SetTxInterruptHandler()
261:           }
1193A  F360     NOP
1193C  F50B     NOP
11A22  0012     RETURN 0
262:           
263:           void UART1_Receive_ISR(void)
264:           {
265:               // use this default receive interrupt handler code
266:               uart1RxStatusBuffer[uart1RxHead].status = 0;
1117C  0E60     MOVLW 0x60
1117E  2448     ADDWF VREGCON, W, ACCESS
11180  6ED9     MOVWF 0xFD9, ACCESS
11182  6ADA     CLRF 0xFDA, ACCESS
11184  0E05     MOVLW 0x5
11186  22DA     ADDWFC 0xFDA, F, ACCESS
11188  0E00     MOVLW 0x0
1118A  6EDF     MOVWF 0xFDF, ACCESS
267:           
268:               if(U1ERRIRbits.FERIF){
1118C  0102     MOVLB 0x2
1118E  A7B2     BTFSS OSCSTAT, 3, BANKED
11190  D014     BRA 0x11BA
269:                   uart1RxStatusBuffer[uart1RxHead].ferr = 1;
11192  0E60     MOVLW 0x60
11194  2448     ADDWF VREGCON, W, ACCESS
11196  6ED9     MOVWF 0xFD9, ACCESS
11198  6ADA     CLRF 0xFDA, ACCESS
1119A  0E05     MOVLW 0x5
1119C  22DA     ADDWFC 0xFDA, F, ACCESS
1119E  0105     MOVLB 0x5
111A0  82DF     BSF 0xFDF, 1, ACCESS
270:                   UART1_FramingErrorHandler();
111A2  D801     RCALL 0x11A6
111A4  D00A     BRA 0x11BA
111A6  0005     PUSH
111A8  6EFA     MOVWF 0xFFA, ACCESS
111AA  51CE     MOVF 0xCE, W, BANKED
111AC  6EFD     MOVWF 0xFFD, ACCESS
111AE  51CF     MOVF 0xCF, W, BANKED
111B0  6EFE     MOVWF 0xFFE, ACCESS
111B2  51D0     MOVF 0xD0, W, BANKED
111B4  6EFF     MOVWF 0xFFF, ACCESS
111B6  50FA     MOVF 0xFFA, W, ACCESS
111B8  0012     RETURN 0
271:               }
272:               
273:               if(U1ERRIRbits.RXFOIF){
111BA  0102     MOVLB 0x2
111BC  A3B2     BTFSS OSCSTAT, 1, BANKED
111BE  D014     BRA 0x11E8
274:                   uart1RxStatusBuffer[uart1RxHead].oerr = 1;
111C0  0E60     MOVLW 0x60
111C2  2448     ADDWF VREGCON, W, ACCESS
111C4  6ED9     MOVWF 0xFD9, ACCESS
111C6  6ADA     CLRF 0xFDA, ACCESS
111C8  0E05     MOVLW 0x5
111CA  22DA     ADDWFC 0xFDA, F, ACCESS
111CC  0105     MOVLB 0x5
111CE  84DF     BSF 0xFDF, 2, ACCESS
275:                   UART1_OverrunErrorHandler();
111D0  D801     RCALL 0x11D4
111D2  D00A     BRA 0x11E8
111D4  0005     PUSH
111D6  6EFA     MOVWF 0xFFA, ACCESS
111D8  51CB     MOVF 0xCB, W, BANKED
111DA  6EFD     MOVWF 0xFFD, ACCESS
111DC  51CC     MOVF 0xCC, W, BANKED
111DE  6EFE     MOVWF 0xFFE, ACCESS
111E0  51CD     MOVF 0xCD, W, BANKED
111E2  6EFF     MOVWF 0xFFF, ACCESS
111E4  50FA     MOVF 0xFFA, W, ACCESS
111E6  0012     RETURN 0
276:               }
277:               
278:               if(uart1RxStatusBuffer[uart1RxHead].status){
111E8  0E60     MOVLW 0x60
111EA  2448     ADDWF VREGCON, W, ACCESS
111EC  6ED9     MOVWF 0xFD9, ACCESS
111EE  6ADA     CLRF 0xFDA, ACCESS
111F0  0E05     MOVLW 0x5
111F2  22DA     ADDWFC 0xFDA, F, ACCESS
111F4  50DF     MOVF 0xFDF, W, ACCESS
111F6  B4D8     BTFSC 0xFD8, 2, ACCESS
111F8  D00D     BRA 0x1214
279:                   UART1_ErrorHandler();
111FA  D801     RCALL 0x11FE
111FC  0012     RETURN 0
111FE  0005     PUSH
11200  6EFA     MOVWF 0xFFA, ACCESS
11202  0105     MOVLB 0x5
11204  51C8     MOVF 0xC8, W, BANKED
11206  6EFD     MOVWF 0xFFD, ACCESS
11208  51C9     MOVF 0xC9, W, BANKED
1120A  6EFE     MOVWF 0xFFE, ACCESS
1120C  51CA     MOVF 0xCA, W, BANKED
1120E  6EFF     MOVWF 0xFFF, ACCESS
11210  50FA     MOVF 0xFFA, W, ACCESS
11212  0012     RETURN 0
280:               } else {
281:                   UART1_RxDataHandler();
11214  EC7C     CALL 0x11AF8, 0
11216  F08D     NOP
282:               }
283:           
284:               // or set custom function using UART1_SetRxInterruptHandler()
285:           }
11218  0012     RETURN 0
286:           
287:           void UART1_RxDataHandler(void){
288:               // use this default receive interrupt handler code
289:               uart1RxBuffer[uart1RxHead++] = U1RXB;
11AF8  0E00     MOVLW 0x0
11AFA  2448     ADDWF VREGCON, W, ACCESS
11AFC  6ED9     MOVWF 0xFD9, ACCESS
11AFE  6ADA     CLRF 0xFDA, ACCESS
11B00  0E06     MOVLW 0x6
11B02  22DA     ADDWFC 0xFDA, F, ACCESS
11B04  C2A1     MOVFF U1RXB, INDF2
11B06  F4DF     NOP
11B08  2A48     INCF VREGCON, F, ACCESS
290:               if(sizeof(uart1RxBuffer) <= uart1RxHead)
11B0A  0E3F     MOVLW 0x3F
11B0C  6448     CPFSGT VREGCON, ACCESS
11B0E  D002     BRA 0x1B14
291:               {
292:                   uart1RxHead = 0;
11B10  0E00     MOVLW 0x0
11B12  6E48     MOVWF VREGCON, ACCESS
293:               }
294:               uart1RxCount++;
11B14  2A46     INCF NVMDAT, F, ACCESS
295:           }
11B16  0012     RETURN 0
296:           
297:           void UART1_DefaultFramingErrorHandler(void){}
11CA8  0012     RETURN 0
298:           
299:           void UART1_DefaultOverrunErrorHandler(void){}
11CA6  0012     RETURN 0
300:           
301:           void UART1_DefaultErrorHandler(void){
302:               UART1_RxDataHandler();
11C84  EC7C     CALL 0x11AF8, 0
11C86  F08D     NOP
303:           }
11C88  0012     RETURN 0
304:           
305:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
306:               UART1_FramingErrorHandler = interruptHandler;
11BCA  C50E     MOVFF InterruptHandler, UART1_FramingErrorHandler
11BCC  F5CE     NOP
11BCE  C50F     MOVFF 0x50F, 0x5CF
11BD0  F5CF     NOP
11BD2  C510     MOVFF blockSize, 0x5D0
11BD4  F5D0     NOP
307:           }
11BD6  0012     RETURN 0
308:           
309:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
310:               UART1_OverrunErrorHandler = interruptHandler;
11BBC  C50E     MOVFF InterruptHandler, UART1_OverrunErrorHandler
11BBE  F5CB     NOP
11BC0  C50F     MOVFF 0x50F, 0x5CC
11BC2  F5CC     NOP
11BC4  C510     MOVFF blockSize, 0x5CD
11BC6  F5CD     NOP
311:           }
11BC8  0012     RETURN 0
312:           
313:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
314:               UART1_ErrorHandler = interruptHandler;
11BD8  C50E     MOVFF InterruptHandler, UART1_ErrorHandler
11BDA  F5C8     NOP
11BDC  C50F     MOVFF 0x50F, 0x5C9
11BDE  F5C9     NOP
11BE0  C510     MOVFF blockSize, 0x5CA
11BE2  F5CA     NOP
315:           }
11BE4  0012     RETURN 0
316:           
317:           
318:           
319:           void UART1_SetRxInterruptHandler(void (* InterruptHandler)(void)){
320:               UART1_RxInterruptHandler = InterruptHandler;
11BAE  C50E     MOVFF InterruptHandler, UART1_RxInterruptHandler
11BB0  F5DA     NOP
11BB2  C50F     MOVFF 0x50F, 0x5DB
11BB4  F5DB     NOP
11BB6  C510     MOVFF blockSize, 0x5DC
11BB8  F5DC     NOP
321:           }
11BBA  0012     RETURN 0
322:           
323:           void UART1_SetTxInterruptHandler(void (* InterruptHandler)(void)){
324:               UART1_TxInterruptHandler = InterruptHandler;
11BA0  C50E     MOVFF InterruptHandler, UART1_TxInterruptHandler
11BA2  F5D7     NOP
11BA4  C50F     MOVFF 0x50F, 0x5D8
11BA6  F5D8     NOP
11BA8  C510     MOVFF blockSize, 0x5D9
11BAA  F5D9     NOP
325:           }
11BAC  0012     RETURN 0
326:           
327:           
328:           /**
329:             End of File
330:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/tmr6.c  -----------------------------------
1:             /**
2:               TMR6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR6.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:            	Device            :  PIC18F47Q43
18:            	Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 2.30 and above 
21:            	MPLAB 	          :  MPLAB X 5.40
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "tmr6.h"
53:            #include "interrupt_manager.h"
54:            #include "../timers.h"
55:            
56:            /**
57:              Section: Global Variables Definitions
58:             */
59:            extern volatile uint16_t tickCount[TMR_COUNT];
60:            
61:            void (*TMR6_InterruptHandler)(void);
62:            
63:            /**
64:              Section: TMR6 APIs
65:             */
66:            
67:            void TMR6_Initialize(void)
68:            {
69:            	// Set TMR6 to the options selected in the User Interface
70:            
71:            	// T6CS FOSC/4; 
72:            	T6CLKCON = 0x01;
1196A  0E01     MOVLW 0x1
1196C  0103     MOVLB 0x3
1196E  6F3E     MOVWF 0x3E, BANKED
73:            
74:            	// T6PSYNC Not Synchronized; T6MODE Software control; T6CKPOL Rising Edge; T6CKSYNC Synchronized; 
75:            	T6HLT = 0x20;
11970  0E20     MOVLW 0x20
11972  6F3D     MOVWF 0x3D, BANKED
76:            
77:            	// T6RSEL T6CKIPPS pin; 
78:            	T6RST = 0x00;
11974  0E00     MOVLW 0x0
11976  6F3F     MOVWF 0x3F, BANKED
79:            
80:            	// PR6 249; 
81:            	T6PR = 0xF9;
11978  0EF9     MOVLW 0xF9
1197A  6F3B     MOVWF 0x3B, BANKED
82:            
83:            	// TMR6 0; 
84:            	T6TMR = 0x00;
1197C  0E00     MOVLW 0x0
1197E  6F3A     MOVWF CLKRCLK, BANKED
85:            
86:            	// Clearing IF flag before enabling the interrupt.
87:            	PIR15bits.TMR6IF = 0;
11980  96BD     BCF 0xFBD, 3, ACCESS
88:            
89:            	// Enabling TMR6 interrupt.
90:            	PIE15bits.TMR6IE = 1;
11982  86AD     BSF 0xFAD, 3, ACCESS
91:            
92:            	// Set Default Interrupt Handler
93:            	TMR6_SetInterruptHandler(TMR6_DefaultInterruptHandler);
11984  0E76     MOVLW 0x76
11986  6E0E     MOVWF 0xE, ACCESS
11988  0E17     MOVLW 0x17
1198A  6E0F     MOVWF 0xF, ACCESS
1198C  0E01     MOVLW 0x1
1198E  6E10     MOVWF 0x10, ACCESS
11990  ECF3     CALL 0x11BE6, 0
11992  F08D     NOP
94:            
95:            	// T6CKPS 1:8; T6OUTPS 1:4; TMR6ON on; 
96:            	T6CON = 0xB3;
11994  0EB3     MOVLW 0xB3
11996  6F3C     MOVWF 0x3C, BANKED
97:            }
11998  0012     RETURN 0
98:            
99:            void TMR6_ModeSet(TMR6_HLT_MODE mode)
100:           {
101:           	// Configure different types HLT mode
102:           	T6HLTbits.MODE = mode;
103:           }
104:           
105:           void TMR6_ExtResetSourceSet(TMR6_HLT_EXT_RESET_SOURCE reset)
106:           {
107:           	//Configure different types of HLT external reset source
108:           	T6RSTbits.RSEL = reset;
109:           }
110:           
111:           void TMR6_Start(void)
112:           {
113:           	// Start the Timer by writing to TMRxON bit
114:           	T6CONbits.TMR6ON = 1;
115:           }
116:           
117:           void TMR6_StartTimer(void)
118:           {
119:           	TMR6_Start();
120:           }
121:           
122:           void TMR6_Stop(void)
123:           {
124:           	// Stop the Timer by writing to TMRxON bit
125:           	T6CONbits.TMR6ON = 0;
11C7E  0103     MOVLB 0x3
11C80  9F3C     BCF 0x3C, 7, BANKED
126:           }
11C82  0012     RETURN 0
127:           
128:           void TMR6_StopTimer(void)
129:           {
130:           	TMR6_Stop();
131:           }
132:           
133:           uint8_t TMR6_Counter8BitGet(void)
134:           {
135:           	uint8_t readVal;
136:           
137:           	readVal = TMR6;
138:           
139:           	return readVal;
140:           }
141:           
142:           uint8_t TMR6_ReadTimer(void)
143:           {
144:           	return TMR6_Counter8BitGet();
145:           }
146:           
147:           void TMR6_Counter8BitSet(uint8_t timerVal)
148:           {
149:           	// Write to the Timer6 register
150:           	TMR6 = timerVal;
151:           }
152:           
153:           void TMR6_WriteTimer(uint8_t timerVal)
154:           {
155:           	TMR6_Counter8BitSet(timerVal);
156:           }
157:           
158:           void TMR6_Period8BitSet(uint8_t periodVal)
159:           {
160:           	PR6 = periodVal;
161:           }
162:           
163:           void TMR6_LoadPeriodRegister(uint8_t periodVal)
164:           {
165:           	TMR6_Period8BitSet(periodVal);
166:           }
167:           
168:           void __interrupt(irq(TMR6), base(8), low_priority) TMR6_ISR()
169:           {
170:           
171:           	// clear the TMR6 interrupt flag
172:           	PIR15bits.TMR6IF = 0;
118A2  96BD     BCF 0xFBD, 3, ACCESS
173:           
174:           	if (TMR6_InterruptHandler) {
118A4  0105     MOVLB 0x5
118A6  51D1     MOVF 0xD1, W, BANKED
118A8  11D2     IORWF 0xD2, W, BANKED
118AA  11D3     IORWF 0xD3, W, BANKED
118AC  B4D8     BTFSC 0xFD8, 2, ACCESS
118AE  D00C     BRA 0x18C8
175:           		TMR6_InterruptHandler();
118B0  D801     RCALL 0x18B4
118B2  D00A     BRA 0x18C8
118B4  0005     PUSH
118B6  6EFA     MOVWF 0xFFA, ACCESS
118B8  51D1     MOVF 0xD1, W, BANKED
118BA  6EFD     MOVWF 0xFFD, ACCESS
118BC  51D2     MOVF 0xD2, W, BANKED
118BE  6EFE     MOVWF 0xFFE, ACCESS
118C0  51D3     MOVF 0xD3, W, BANKED
118C2  6EFF     MOVWF 0xFFF, ACCESS
118C4  50FA     MOVF 0xFFA, W, ACCESS
118C6  0012     RETURN 0
176:           	}
177:           }
118CA  F424     NOP
118CC  F4D8     NOP
118CE  0011     RETFIE 1
178:           
179:           void TMR6_SetInterruptHandler(void (* InterruptHandler)(void))
180:           {
181:           	TMR6_InterruptHandler = InterruptHandler;
11BE6  C50E     MOVFF InterruptHandler, TMR6_InterruptHandler
11BE8  F5D1     NOP
11BEA  C50F     MOVFF 0x50F, 0x5D2
11BEC  F5D2     NOP
11BEE  C510     MOVFF blockSize, 0x5D3
11BF0  F5D3     NOP
182:           }
11BF2  0012     RETURN 0
183:           
184:           void TMR6_DefaultInterruptHandler(void)
185:           {
186:           	static uint8_t i = 0;
187:           	// add your TMR6 interrupt custom code
188:           	// or set custom function using TMR6_SetInterruptHandler()
189:           	//Decrement each software timer
190:           	for (i = 0; i < TMR_COUNT; i++) {
11776  0E00     MOVLW 0x0
11778  6E4C     MOVWF ZCDCON, ACCESS
1177A  0E06     MOVLW 0x6
1177C  644C     CPFSGT ZCDCON, ACCESS
1177E  D001     BRA 0x1782
11780  0012     RETURN 0
191:           		if (tickCount[i] != 0) {
11782  504C     MOVF ZCDCON, W, ACCESS
11784  0D02     MULLW 0x2
11786  0EA0     MOVLW 0xA0
11788  24F3     ADDWF 0xFF3, W, ACCESS
1178A  6ED9     MOVWF 0xFD9, ACCESS
1178C  0E05     MOVLW 0x5
1178E  20F4     ADDWFC 0xFF4, W, ACCESS
11790  6EDA     MOVWF 0xFDA, ACCESS
11792  50DE     MOVF 0xFDE, W, ACCESS
11794  10DE     IORWF 0xFDE, W, ACCESS
11796  B4D8     BTFSC 0xFD8, 2, ACCESS
11798  D00B     BRA 0x17B0
192:           			tickCount[i]--;
1179A  504C     MOVF ZCDCON, W, ACCESS
1179C  0D02     MULLW 0x2
1179E  0EA0     MOVLW 0xA0
117A0  24F3     ADDWF 0xFF3, W, ACCESS
117A2  6ED9     MOVWF 0xFD9, ACCESS
117A4  0E05     MOVLW 0x5
117A6  20F4     ADDWFC 0xFF4, W, ACCESS
117A8  6EDA     MOVWF 0xFDA, ACCESS
117AA  06DE     DECF 0xFDE, F, ACCESS
117AC  0E00     MOVLW 0x0
117AE  5ADD     SUBWFB 0xFDD, F, ACCESS
193:           		}
194:           	}
117B0  2A4C     INCF ZCDCON, F, ACCESS
117B2  D7E3     BRA 0x177A
195:           }
196:           
197:           /**
198:             End of File
199:            */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/tmr5.c  -----------------------------------
1:             /**
2:               TMR5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR5.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr5.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer5ReloadVal;
59:            void (*TMR5_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR5 APIs
63:            */
64:            
65:            void TMR5_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T5GE disabled; T5GTM disabled; T5GPOL low; T5GGO done; T5GSPM disabled; 
70:                T5GCON = 0x00;
1160E  0E00     MOVLW 0x0
11610  6F37     MOVWF 0x37, BANKED
71:            
72:                //GSS T5G_pin; 
73:                T5GATE = 0x00;
11612  0E00     MOVLW 0x0
11614  6F38     MOVWF 0x38, BANKED
74:            
75:                //CS FOSC/4; 
76:                T5CLK = 0x01;
11616  0E01     MOVLW 0x1
11618  6F39     MOVWF CLKRCON, BANKED
77:            
78:                //TMR5H 177; 
79:                TMR5H = 0xB1;
1161A  0EB1     MOVLW 0xB1
1161C  6F35     MOVWF 0x35, BANKED
80:            
81:                //TMR5L 224; 
82:                TMR5L = 0xE0;
1161E  0EE0     MOVLW 0xE0
11620  6F34     MOVWF 0x34, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR8bits.TMR5IF = 0;
11622  98B6     BCF 0xFB6, 4, ACCESS
86:            
87:                // Load the TMR value to reload variable
88:                timer5ReloadVal=(uint16_t)((TMR5H << 8) | TMR5L);
11624  5134     MOVF 0x34, W, BANKED
11628  FCD4     NOP
1162A  F511     NOP
1162C  6A12     CLRF 0x12, ACCESS
1162E  C511     MOVFF chr, data
11630  F512     NOP
11632  6A11     CLRF 0x11, ACCESS
11634  1011     IORWF 0x11, W, ACCESS
11636  0105     MOVLB 0x5
11638  6FE7     MOVWF 0xE7, BANKED
1163A  5012     MOVF 0x12, W, ACCESS
1163C  6FE8     MOVWF DMASELECT, BANKED
89:            
90:                // Enabling TMR5 interrupt.
91:                PIE8bits.TMR5IE = 1;
1163E  88A6     BSF 0xFA6, 4, ACCESS
92:            
93:                // Set Default Interrupt Handler
94:                TMR5_SetInterruptHandler(TMR5_DefaultInterruptHandler);
11640  0EA4     MOVLW 0xA4
11642  6E0E     MOVWF 0xE, ACCESS
11644  0E1C     MOVLW 0x1C
11646  6E0F     MOVWF 0xF, ACCESS
11648  0E01     MOVLW 0x1
1164A  6E10     MOVWF 0x10, ACCESS
1164C  ECFA     CALL 0x11BF4, 0
1164E  F08D     NOP
95:            
96:                // CKPS 1:8; NOT_SYNC synchronize; TMR5ON enabled; T5RD16 disabled; 
97:                T5CON = 0x31;
11650  0E31     MOVLW 0x31
11652  0103     MOVLB 0x3
11654  6F36     MOVWF 0x36, BANKED
98:            }
11656  0012     RETURN 0
99:            
100:           void TMR5_StartTimer(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T5CONbits.TMR5ON = 1;
104:           }
105:           
106:           void TMR5_StopTimer(void)
107:           {
108:               // Stop the Timer by writing to TMRxON bit
109:               T5CONbits.TMR5ON = 0;
110:           }
111:           
112:           uint16_t TMR5_ReadTimer(void)
113:           {
114:               uint16_t readVal;
115:               uint8_t readValHigh;
116:               uint8_t readValLow;
117:               
118:               T5CONbits.T5RD16 = 1;
119:           	
120:               readValLow = TMR5L;
121:               readValHigh = TMR5H;
122:               
123:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
124:           
125:               return readVal;
126:           }
127:           
128:           void TMR5_WriteTimer(uint16_t timerVal)
129:           {
130:               if (T5CONbits.NOT_SYNC == 1)
11A24  0103     MOVLB 0x3
11A26  A536     BTFSS 0x36, 2, BANKED
11A28  D009     BRA 0x1A3C
131:               {
132:                   // Stop the Timer by writing to TMRxON bit
133:                   T5CONbits.TMR5ON = 0;
11A2A  9136     BCF 0x36, 0, BANKED
134:           
135:                   // Write to the Timer5 register
136:                   TMR5H = (timerVal >> 8);
11A2E  F414     NOP
11A30  F335     NOP
137:                   TMR5L = timerVal;
11A34  F410     NOP
11A36  F334     NOP
138:           
139:                   // Start the Timer after writing to the register
140:                   T5CONbits.TMR5ON =1;
11A38  8136     BSF 0x36, 0, BANKED
141:               }
11A3A  0012     RETURN 0
142:               else
143:               {
144:                   // Write to the Timer5 register
145:                   TMR5H = (timerVal >> 8);
11A3E  F414     NOP
11A40  F335     NOP
146:                   TMR5L = timerVal;
11A44  F410     NOP
11A46  F334     NOP
147:               }
148:           }
11A48  0012     RETURN 0
149:           
150:           void TMR5_Reload(void)
151:           {
152:               TMR5_WriteTimer(timer5ReloadVal);
153:           }
154:           
155:           void TMR5_StartSinglePulseAcquisition(void)
156:           {
157:               T5GCONbits.T5GGO = 1;
158:           }
159:           
160:           uint8_t TMR5_CheckGateValueStatus(void)
161:           {
162:               return (T5GCONbits.T5GVAL);
163:           }
164:           
165:           void __interrupt(irq(TMR5),base(8),low_priority) TMR5_ISR()
166:           {
167:               static volatile unsigned int CountCallBack = 0;
168:           
169:               // Clear the TMR5 interrupt flag
170:               PIR8bits.TMR5IF = 0;
117F6  98B6     BCF 0xFB6, 4, ACCESS
171:               TMR5_WriteTimer(timer5ReloadVal);
117F8  C5E7     MOVFF timer5ReloadVal, timerVal
117FA  F504     NOP
117FC  C5E8     MOVFF 0x5E8, 0x505
117FE  F505     NOP
11800  EC12     CALL 0x11A24, 0
11802  F08D     NOP
172:           
173:               // callback function - called every 100th pass
174:               if (++CountCallBack >= TMR5_INTERRUPT_TICKER_FACTOR)
11804  0105     MOVLB 0x5
11806  4BE5     INFSNZ 0xE5, F, BANKED
11808  2BE6     INCF 0xE6, F, BANKED
1180A  51E6     MOVF 0xE6, W, BANKED
1180C  E104     BNZ 0x1816
1180E  0E64     MOVLW 0x64
11810  5DE5     SUBWF 0xE5, W, BANKED
11812  A0D8     BTFSS 0xFD8, 0, ACCESS
11814  D007     BRA 0x1824
175:               {
176:                   // ticker function call
177:                   TMR5_CallBack();
11816  EC4B     CALL 0x11A96, 0
11818  F08D     NOP
178:           
179:                   // reset ticker counter
180:                   CountCallBack = 0;
1181A  0E00     MOVLW 0x0
1181C  0105     MOVLB 0x5
1181E  6FE6     MOVWF 0xE6, BANKED
11820  0E00     MOVLW 0x0
11822  6FE5     MOVWF 0xE5, BANKED
181:               }
182:           }
11826  F418     NOP
11828  F4D8     NOP
1182A  0011     RETFIE 1
183:           
184:           void TMR5_CallBack(void)
185:           {
186:               // Add your custom callback code here
187:               if(TMR5_InterruptHandler)
11A96  51D4     MOVF CLCDATA, W, BANKED
11A98  11D5     IORWF CLCSELECT, W, BANKED
11A9A  11D6     IORWF CLCnCON, W, BANKED
11A9C  B4D8     BTFSC 0xFD8, 2, ACCESS
11A9E  0012     RETURN 0
188:               {
189:                   TMR5_InterruptHandler();
11AA0  D801     RCALL 0x1AA4
11AA2  0012     RETURN 0
11AA4  0005     PUSH
11AA6  6EFA     MOVWF 0xFFA, ACCESS
11AA8  51D4     MOVF CLCDATA, W, BANKED
11AAA  6EFD     MOVWF 0xFFD, ACCESS
11AAC  51D5     MOVF CLCSELECT, W, BANKED
11AAE  6EFE     MOVWF 0xFFE, ACCESS
11AB0  51D6     MOVF CLCnCON, W, BANKED
11AB2  6EFF     MOVWF 0xFFF, ACCESS
11AB4  50FA     MOVF 0xFFA, W, ACCESS
11AB6  0012     RETURN 0
190:               }
191:           }
192:           
193:           void TMR5_SetInterruptHandler(void (* InterruptHandler)(void)){
194:               TMR5_InterruptHandler = InterruptHandler;
11BF4  C50E     MOVFF InterruptHandler, TMR5_InterruptHandler
11BF6  F5D4     NOP
11BF8  C50F     MOVFF 0x50F, 0x5D5
11BFA  F5D5     NOP
11BFC  C510     MOVFF blockSize, 0x5D6
11BFE  F5D6     NOP
195:           }
11C00  0012     RETURN 0
196:           
197:           void TMR5_DefaultInterruptHandler(void){
198:               // add your TMR5 interrupt custom code
199:               // or set custom function using TMR5_SetInterruptHandler()
200:           }
11CA4  0012     RETURN 0
201:           
202:           /**
203:             End of File
204:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/tmr4.c  -----------------------------------
1:             /**
2:               TMR4 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr4.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR4 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR4.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above 
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr4.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            
59:            void (*TMR4_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR4 APIs
63:            */
64:            
65:            void TMR4_Initialize(void)
66:            {
67:                // Set TMR4 to the options selected in the User Interface
68:            
69:                // T4CS FOSC/4; 
70:                T4CLKCON = 0x01;
1199A  0E01     MOVLW 0x1
1199C  0103     MOVLB 0x3
1199E  6F32     MOVWF 0x32, BANKED
71:            
72:                // T4PSYNC Not Synchronized; T4MODE Software control; T4CKPOL Rising Edge; T4CKSYNC Synchronized; 
73:                T4HLT = 0x20;
119A0  0E20     MOVLW 0x20
119A2  6F31     MOVWF 0x31, BANKED
74:            
75:                // T4RSEL T4CKIPPS pin; 
76:                T4RST = 0x00;
119A4  0E00     MOVLW 0x0
119A6  6F33     MOVWF 0x33, BANKED
77:            
78:                // PR4 24; 
79:                T4PR = 0x18;
119A8  0E18     MOVLW 0x18
119AA  6F2F     MOVWF 0x2F, BANKED
80:            
81:                // TMR4 0; 
82:                T4TMR = 0x00;
119AC  0E00     MOVLW 0x0
119AE  6F2E     MOVWF 0x2E, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR11bits.TMR4IF = 0;
119B0  96B9     BCF 0xFB9, 3, ACCESS
86:            
87:                // Enabling TMR4 interrupt.
88:                PIE11bits.TMR4IE = 1;
119B2  86A9     BSF 0xFA9, 3, ACCESS
89:            
90:                // Set Default Interrupt Handler
91:                TMR4_SetInterruptHandler(TMR4_DefaultInterruptHandler);
119B4  0EAA     MOVLW 0xAA
119B6  6E0E     MOVWF 0xE, ACCESS
119B8  0E1C     MOVLW 0x1C
119BA  6E0F     MOVWF 0xF, ACCESS
119BC  0E01     MOVLW 0x1
119BE  6E10     MOVWF 0x10, ACCESS
119C0  EC01     CALL 0x11C02, 0
119C2  F08E     NOP
92:            
93:                // T4CKPS 1:8; T4OUTPS 1:16; TMR4ON on; 
94:                T4CON = 0xBF;
119C4  0EBF     MOVLW 0xBF
119C6  6F30     MOVWF 0x30, BANKED
95:            }
119C8  0012     RETURN 0
96:            
97:            void TMR4_ModeSet(TMR4_HLT_MODE mode)
98:            {
99:               // Configure different types HLT mode
100:               T4HLTbits.MODE = mode;
101:           }
102:           
103:           void TMR4_ExtResetSourceSet(TMR4_HLT_EXT_RESET_SOURCE reset)
104:           {
105:               //Configure different types of HLT external reset source
106:               T4RSTbits.RSEL = reset;
107:           }
108:           
109:           void TMR4_Start(void)
110:           {
111:               // Start the Timer by writing to TMRxON bit
112:               T4CONbits.TMR4ON = 1;
11C72  0103     MOVLB 0x3
11C74  8F30     BSF 0x30, 7, BANKED
11C96  0103     MOVLB 0x3
113:           }
11C76  0012     RETURN 0
11C9A  0012     RETURN 0
114:           
115:           void TMR4_StartTimer(void)
116:           {
117:               TMR4_Start();
11C6C  EC39     CALL 0x11C72, 0
11C6E  F08E     NOP
11C90  EC4B     CALL 0x11C96, 0
118:           }
11C70  0012     RETURN 0
11C94  0012     RETURN 0
119:           
120:           void TMR4_Stop(void)
121:           {
122:               // Stop the Timer by writing to TMRxON bit
123:               T4CONbits.TMR4ON = 0;
11C66  0103     MOVLB 0x3
11C68  9F30     BCF 0x30, 7, BANKED
11C8A  0103     MOVLB 0x3
124:           }
11C6A  0012     RETURN 0
11C8E  0012     RETURN 0
11CAC  0011     RETFIE 1
125:           
126:           void TMR4_StopTimer(void)
127:           {
128:               TMR4_Stop();
129:           }
130:           
131:           uint8_t TMR4_Counter8BitGet(void)
132:           {
133:               uint8_t readVal;
134:           
135:               readVal = TMR4;
136:           
137:               return readVal;
138:           }
139:           
140:           uint8_t TMR4_ReadTimer(void)
141:           {
142:               return TMR4_Counter8BitGet();
143:           }
144:           
145:           void TMR4_Counter8BitSet(uint8_t timerVal)
146:           {
147:               // Write to the Timer4 register
148:               TMR4 = timerVal;
149:           }
150:           
151:           void TMR4_WriteTimer(uint8_t timerVal)
152:           {
153:               TMR4_Counter8BitSet(timerVal);
154:           }
155:           
156:           void TMR4_Period8BitSet(uint8_t periodVal)
11C54  6E01     MOVWF 0x1, ACCESS
157:           {
158:              PR4 = periodVal;
11C58  F404     NOP
11C5A  F32F     NOP
159:           }
11C5C  0012     RETURN 0
160:           
161:           void TMR4_LoadPeriodRegister(uint8_t periodVal)
162:           {
163:              TMR4_Period8BitSet(periodVal);
164:           }
165:           
166:           void __interrupt(irq(TMR4),base(8),low_priority) TMR4_ISR()
118D2  F360     NOP
118D4  F50D     NOP
167:           {
168:           
169:               // clear the TMR4 interrupt flag
170:               PIR11bits.TMR4IF = 0;
118D6  96B9     BCF 0xFB9, 3, ACCESS
171:           
172:               if(TMR4_InterruptHandler)
118D8  0105     MOVLB 0x5
118DA  51C2     MOVF 0xC2, W, BANKED
118DC  11C3     IORWF 0xC3, W, BANKED
118DE  11C4     IORWF 0xC4, W, BANKED
118E0  B4D8     BTFSC 0xFD8, 2, ACCESS
118E2  D00C     BRA 0x18FC
173:               {
174:                   TMR4_InterruptHandler();
118E4  D801     RCALL 0x18E8
118E6  D00A     BRA 0x18FC
118E8  0005     PUSH
118EA  6EFA     MOVWF 0xFFA, ACCESS
118EC  51C2     MOVF 0xC2, W, BANKED
118EE  6EFD     MOVWF 0xFFD, ACCESS
118F0  51C3     MOVF 0xC3, W, BANKED
118F2  6EFE     MOVWF 0xFFE, ACCESS
118F4  51C4     MOVF 0xC4, W, BANKED
118F6  6EFF     MOVWF 0xFFF, ACCESS
118F8  50FA     MOVF 0xFFA, W, ACCESS
118FA  0012     RETURN 0
175:               }
176:           }
118FE  F434     NOP
11900  F4D8     NOP
11902  0011     RETFIE 1
177:           
178:           
179:           void TMR4_SetInterruptHandler(void (* InterruptHandler)(void)){
180:               TMR4_InterruptHandler = InterruptHandler;
11C02  C50E     MOVFF InterruptHandler, TMR4_InterruptHandler
11C04  F5C2     NOP
11C06  C50F     MOVFF 0x50F, 0x5C3
11C08  F5C3     NOP
11C0A  C510     MOVFF blockSize, 0x5C4
11C0C  F5C4     NOP
181:           }
11C0E  0012     RETURN 0
182:           
183:           void TMR4_DefaultInterruptHandler(void){
184:               // add your TMR4 interrupt custom code
185:               // or set custom function using TMR4_SetInterruptHandler()
186:           }
11CAA  0012     RETURN 0
187:           
188:           /**
189:             End of File
190:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/tmr2.c  -----------------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above 
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
11B36  0E01     MOVLW 0x1
11B38  6F26     MOVWF 0x26, BANKED
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
11B3A  0E00     MOVLW 0x0
11B3C  6F25     MOVWF 0x25, BANKED
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
11B3E  0E00     MOVLW 0x0
11B40  6F27     MOVWF 0x27, BANKED
74:            
75:                // PR2 15; 
76:                T2PR = 0x0F;
11B42  0E0F     MOVLW 0xF
11B44  6F23     MOVWF 0x23, BANKED
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
11B46  0E00     MOVLW 0x0
11B48  6F22     MOVWF 0x22, BANKED
80:            
81:                // Clearing IF flag.
82:                PIR3bits.TMR2IF = 0;
11B4A  96B1     BCF 0xFB1, 3, ACCESS
83:            
84:                // T2CKPS 1:1; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0x80;
11B4C  0E80     MOVLW 0x80
11B4E  6F24     MOVWF 0x24, BANKED
86:            }
11B50  0012     RETURN 0
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR3bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR3bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/spi1.c  -----------------------------------
1:             /**
2:               SPI1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the SPI1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for SPI1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above or later
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "spi1.h"
48:            #include <xc.h>
49:            
50:            typedef struct { 
51:                uint8_t con0; 
52:                uint8_t con1; 
53:                uint8_t con2; 
54:                uint8_t baud; 
55:                uint8_t operation;
56:            } spi1_configuration_t;
57:            
58:            
59:            //con0 == SPIxCON0, con1 == SPIxCON1, con2 == SPIxCON2, baud == SPIxBAUD, operation == Master/Slave
60:            static const spi1_configuration_t spi1_configuration[] = {   
61:                { 0x3, 0x24, 0x3, 0x4, 0 }
62:            };
63:            
64:            void SPI1_Initialize(void)
65:            {
66:                //EN disabled; LSBF MSb first; MST bus master; BMODE every byte; 
67:                SPI1CON0 = 0x03;
11B6E  0E03     MOVLW 0x3
11B70  0100     MOVLB 0x0
11B72  6F84     MOVWF SPI1CON0, BANKED
68:                //SMP Middle; CKE Idle to active; CKP Idle:High, Active:Low; FST disabled; SSP active low; SDIP active high; SDOP active high; 
69:                SPI1CON1 = 0x24;
11B74  0E24     MOVLW 0x24
11B76  6F85     MOVWF SPI1CON1, BANKED
70:                //SSET disabled; TXR required for a transfer; RXR suspended if the RxFIFO is full; 
71:                SPI1CON2 = 0x03;
11B78  0E03     MOVLW 0x3
11B7A  6F86     MOVWF SPI1CON2, BANKED
72:                //CLKSEL MFINTOSC; 
73:                SPI1CLK = 0x02;
11B7C  0E02     MOVLW 0x2
11B7E  6F8C     MOVWF SPI1CLK, BANKED
74:                //BAUD 4; 
75:                SPI1BAUD = 0x04;
11B80  0E04     MOVLW 0x4
11B82  6F89     MOVWF SPI1BAUD, BANKED
76:                TRISCbits.TRISC3 = 0;
11B84  96C8     BCF 0xFC8, 3, ACCESS
77:            }
11B86  0012     RETURN 0
78:            
79:            bool SPI1_Open(spi1_modes_t spi1UniqueConfiguration)
80:            {
81:                if(!SPI1CON0bits.EN)
82:                {
83:                    SPI1CON0 = spi1_configuration[spi1UniqueConfiguration].con0;
84:                    SPI1CON1 = spi1_configuration[spi1UniqueConfiguration].con1;
85:                    SPI1CON2 = spi1_configuration[spi1UniqueConfiguration].con2 | (_SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK);
86:                    SPI1CLK  = 0x00;
87:                    SPI1BAUD = spi1_configuration[spi1UniqueConfiguration].baud;        
88:                    TRISCbits.TRISC3 = spi1_configuration[spi1UniqueConfiguration].operation;
89:                    SPI1CON0bits.EN = 1;
90:                    return true;
91:                }
92:                return false;
93:            }
94:            
95:            void SPI1_Close(void)
96:            {
97:                SPI1CON0bits.EN = 0;
98:            }
99:            
100:           uint8_t SPI1_ExchangeByte(uint8_t data)
11B88  6E0E     MOVWF 0xE, ACCESS
101:           {
102:               SPI1TCNTL = 1;
11B8A  0E01     MOVLW 0x1
11B8C  0100     MOVLB 0x0
11B8E  6F82     MOVWF SPI1TCNT, BANKED
103:               SPI1TXB = data;
11B92  F438     NOP
11B94  F081     NOP
104:               while(!PIR3bits.SPI1RXIF);
11B96  A0B1     BTFSS 0xFB1, 0, ACCESS
11B98  D7FE     BRA 0x1B96
105:               return SPI1RXB;
11B9A  0100     MOVLB 0x0
11B9C  5180     MOVF SPI1RXB, W, BANKED
106:           }
11B9E  0012     RETURN 0
107:           
108:           void SPI1_ExchangeBlock(void *block, size_t blockSize)
109:           {
110:               uint8_t *data = block;
115C4  C50E     MOVFF InterruptHandler, data
115C6  F512     NOP
115C8  C50F     MOVFF 0x50F, count
115CA  F513     NOP
111:               while(blockSize--)
115CC  D017     BRA 0x15FC
115FC  0610     DECF 0x10, F, ACCESS
112:               {
113:                   SPI1TCNTL = 1;
115CE  0E01     MOVLW 0x1
115D0  0100     MOVLB 0x0
115D2  6F82     MOVWF SPI1TCNT, BANKED
114:                   SPI1TXB = *data;
115D6  F448     NOP
115D8  F4D9     NOP
115DC  F44C     NOP
115DE  F4DA     NOP
115E0  50DF     MOVF 0xFDF, W, ACCESS
115E2  6F81     MOVWF SPI1TXB, BANKED
115:                   while(!PIR3bits.SPI1RXIF);
115E4  A0B1     BTFSS 0xFB1, 0, ACCESS
115E6  D7FE     BRA 0x15E4
116:                   *data++ = SPI1RXB;
115EA  F448     NOP
115EC  F4D9     NOP
115F0  F44C     NOP
115F2  F4DA     NOP
115F4  C080     MOVFF SPI1RXB, INDF2
115F6  F4DF     NOP
115F8  4A12     INFSNZ 0x12, F, ACCESS
115FA  2A13     INCF 0x13, F, ACCESS
115FC  0610     DECF 0x10, F, ACCESS
115FE  A0D8     BTFSS 0xFD8, 0, ACCESS
11600  0611     DECF 0x11, F, ACCESS
11602  2810     INCF 0x10, W, ACCESS
11604  E1E4     BNZ 0x15CE
11606  2811     INCF 0x11, W, ACCESS
11608  B4D8     BTFSC 0xFD8, 2, ACCESS
1160A  0012     RETURN 0
1160C  D7E0     BRA 0x15CE
117:               }
118:           }
119:           
120:           // Half Duplex SPI Functions
121:           void SPI1_WriteBlock(void *block, size_t blockSize)
122:           {
123:               uint8_t *data = block;
124:               while(blockSize--)
125:               {
126:                   SPI1_ExchangeByte(*data++);
127:               }
128:           }
129:           
130:           void SPI1_ReadBlock(void *block, size_t blockSize)
131:           {
132:               uint8_t *data = block;
133:               while(blockSize--)
134:               {
135:                   *data++ = SPI1_ExchangeByte(0);
136:               }
137:           }
138:           
139:           void SPI1_WriteByte(uint8_t byte)
140:           {
141:               SPI1TXB = byte;
142:           }
143:           
144:           uint8_t SPI1_ReadByte(void)
145:           {
146:               return SPI1RXB;
147:           }
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/pin_manager.c  ----------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB             :  MPLAB X 5.40
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x07;
1101A  0E07     MOVLW 0x7
1101C  6EC2     MOVWF 0xFC2, ACCESS
61:                LATD = 0x00;
1101E  0E00     MOVLW 0x0
11020  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
11022  0E00     MOVLW 0x0
11024  6EBE     MOVWF 0xFBE, ACCESS
63:                LATB = 0x00;
11026  0E00     MOVLW 0x0
11028  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x2E;
1102A  0E2E     MOVLW 0x2E
1102C  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x00;
1102E  0E00     MOVLW 0x0
11030  6ECA     MOVWF 0xFCA, ACCESS
70:                TRISA = 0xD5;
11032  0ED5     MOVLW 0xD5
11034  6EC6     MOVWF 0xFC6, ACCESS
71:                TRISB = 0x80;
11036  0E80     MOVLW 0x80
11038  6EC7     MOVWF 0xFC7, ACCESS
72:                TRISC = 0x91;
1103A  0E91     MOVLW 0x91
1103C  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0x3C;
1103E  0E3C     MOVLW 0x3C
11040  6EC9     MOVWF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0x3C;
11042  0E3C     MOVLW 0x3C
11044  0104     MOVLB 0x4
11046  6F18     MOVWF 0x18, BANKED
79:                ANSELC = 0x01;
11048  0E01     MOVLW 0x1
1104A  6F10     MOVWF 0x10, BANKED
80:                ANSELB = 0x80;
1104C  0E80     MOVLW 0x80
1104E  6F08     MOVWF 0x8, BANKED
81:                ANSELE = 0x00;
11050  0E00     MOVLW 0x0
11052  6F20     MOVWF 0x20, BANKED
82:                ANSELA = 0xC0;
11054  0EC0     MOVLW 0xC0
11056  6F00     MOVWF data, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
11058  0E00     MOVLW 0x0
1105A  6F19     MOVWF 0x19, BANKED
88:                WPUE = 0x06;
1105C  0E06     MOVLW 0x6
1105E  6F21     MOVWF 0x21, BANKED
89:                WPUB = 0x00;
11060  0E00     MOVLW 0x0
11062  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x15;
11064  0E15     MOVLW 0x15
11066  6F01     MOVWF 0x1, BANKED
91:                WPUC = 0x06;
11068  0E06     MOVLW 0x6
1106A  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                RxyI2C registers
95:                */
96:                RB1I2C = 0x00;
1106C  0E00     MOVLW 0x0
1106E  0102     MOVLB 0x2
11070  6F89     MOVWF SPI1BAUD, BANKED
97:                RB2I2C = 0x00;
11072  0E00     MOVLW 0x0
11074  6F88     MOVWF SPI1TWIDTH, BANKED
98:                RC3I2C = 0x00;
11076  0E00     MOVLW 0x0
11078  6F87     MOVWF SPI1STATUS, BANKED
99:                RC4I2C = 0x00;
1107A  0E00     MOVLW 0x0
1107C  6F86     MOVWF SPI1CON2, BANKED
100:           
101:               /**
102:               ODx registers
103:               */
104:               ODCONE = 0x00;
1107E  0E00     MOVLW 0x0
11080  0104     MOVLB 0x4
11082  6F22     MOVWF 0x22, BANKED
105:               ODCONA = 0x00;
11084  0E00     MOVLW 0x0
11086  6F02     MOVWF 0x2, BANKED
106:               ODCONB = 0x00;
11088  0E00     MOVLW 0x0
1108A  6F0A     MOVWF 0xA, BANKED
107:               ODCONC = 0x00;
1108C  0E00     MOVLW 0x0
1108E  6F12     MOVWF 0x12, BANKED
108:               ODCOND = 0x00;
11090  0E00     MOVLW 0x0
11092  6F1A     MOVWF 0x1A, BANKED
109:           
110:               /**
111:               SLRCONx registers
112:               */
113:               SLRCONA = 0x00;
11094  0E00     MOVLW 0x0
11096  6F03     MOVWF 0x3, BANKED
114:               SLRCONB = 0x00;
11098  0E00     MOVLW 0x0
1109A  6F0B     MOVWF 0xB, BANKED
115:               SLRCONC = 0xFF;
1109C  6913     SETF 0x13, BANKED
116:               SLRCOND = 0x00;
1109E  0E00     MOVLW 0x0
110A0  6F1B     MOVWF 0x1B, BANKED
117:               SLRCONE = 0x00;
110A2  0E00     MOVLW 0x0
110A4  6F23     MOVWF 0x23, BANKED
118:           
119:               /**
120:               INLVLx registers
121:               */
122:               INLVLA = 0xFF;
110A6  6904     SETF 0x4, BANKED
123:               INLVLB = 0xFF;
110A8  690C     SETF 0xC, BANKED
124:               INLVLC = 0xFF;
110AA  6914     SETF 0x14, BANKED
125:               INLVLD = 0xFF;
110AC  691C     SETF 0x1C, BANKED
126:               INLVLE = 0x0F;
110AE  0E0F     MOVLW 0xF
110B0  6F24     MOVWF 0x24, BANKED
127:           
128:           
129:           
130:           
131:           
132:              
133:               
134:           	
135:               SPI1SCKPPS = 0x13;   //RC3->SPI1:SCK1;    
110B2  0E13     MOVLW 0x13
110B4  0102     MOVLB 0x2
110B6  6F6A     MOVWF MD1CON0, BANKED
136:               RC3PPS = 0x31;   //RC3->SPI1:SCK1;    
110B8  0E31     MOVLW 0x31
110BA  6F14     MOVWF 0x14, BANKED
137:               RC5PPS = 0x32;   //RC5->SPI1:SDO1;    
110BC  0E32     MOVLW 0x32
110BE  6F16     MOVWF 0x16, BANKED
138:               RC6PPS = 0x20;   //RC6->UART1:TX1;    
110C0  0E20     MOVLW 0x20
110C2  6F17     MOVWF 0x17, BANKED
139:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
110C4  0E17     MOVLW 0x17
110C6  6F72     MOVWF CM1NCH, BANKED
140:               SPI1SDIPPS = 0x14;   //RC4->SPI1:SDI1;    
110C8  0E14     MOVLW 0x14
110CA  6F6B     MOVWF MD1CON1, BANKED
141:           }
110CC  0012     RETURN 0
142:             
143:           void PIN_MANAGER_IOC(void)
144:           {   
145:           }
146:           
147:           /**
148:            End of File
149:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/mcc.c  ------------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above or later
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
11866  EC50     CALL 0x116A0, 0
11868  F08B     NOP
53:                PMD_Initialize();
1186A  EC39     CALL 0x11A72, 0
1186C  F08D     NOP
54:                PIN_MANAGER_Initialize();
1186E  EC0D     CALL 0x1101A, 0
11870  F088     NOP
55:                OSCILLATOR_Initialize();
11872  EC6C     CALL 0x11AD8, 0
11874  F08D     NOP
56:                TMR6_Initialize();
11876  ECB5     CALL 0x1196A, 0
11878  F08C     NOP
57:                DMA6_Initialize();
1187A  ECBC     CALL 0x11578, 0
1187C  F08A     NOP
58:                DMA5_Initialize();
1187E  ECEC     CALL 0x113D8, 0
11880  F089     NOP
59:                TMR4_Initialize();
11882  ECCD     CALL 0x1199A, 0
11884  F08C     NOP
60:                TMR2_Initialize();
11886  EC9B     CALL 0x11B36, 0
11888  F08D     NOP
61:                TMR5_Initialize();
1188A  EC07     CALL 0x1160E, 0
1188C  F08B     NOP
62:                UART1_Initialize();
1188E  ECB3     CALL 0x10F66, 0
11890  F087     NOP
63:                SPI1_Initialize();
11892  ECB7     CALL 0x11B6E, 0
11894  F08D     NOP
64:                SystemArbiter_Initialize();
11896  EC0F     CALL 0x11C1E, 0
11898  F08E     NOP
65:            }
1189A  0012     RETURN 0
66:            
67:            void OSCILLATOR_Initialize(void)
68:            {
69:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
70:                OSCCON1 = 0x20;
11AD8  0E20     MOVLW 0x20
11ADA  0100     MOVLB 0x0
11ADC  6FAD     MOVWF OSCCON1, BANKED
71:                // CSWHOLD may proceed; SOSCPWR Low power; 
72:                OSCCON3 = 0x00;
11ADE  0E00     MOVLW 0x0
11AE0  6FAF     MOVWF OSCCON3, BANKED
73:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
74:                OSCEN = 0x00;
11AE2  0E00     MOVLW 0x0
11AE4  6FB3     MOVWF OSCEN, BANKED
75:                // HFFRQ 4_MHz; 
76:                OSCFRQ = 0x02;
11AE6  0E02     MOVLW 0x2
11AE8  6FB1     MOVWF OSCFRQ, BANKED
77:                // TUN 0; 
78:                OSCTUNE = 0x00;
11AEA  0E00     MOVLW 0x0
11AEC  6FB0     MOVWF OSCTUNE, BANKED
79:                // ACTUD enabled; ACTEN disabled; 
80:                ACTCON = 0x00;
11AEE  0E00     MOVLW 0x0
11AF0  6FAC     MOVWF ACTCON, BANKED
81:                // Wait for PLL to stabilize
82:                while(PLLR == 0)
83:                {
84:                }
11AF2  B1B2     BTFSC OSCSTAT, 0, BANKED
11AF4  0012     RETURN 0
11AF6  D7FD     BRA 0x1AF2
85:            }
86:            
87:            void PMD_Initialize(void)
88:            {
89:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; 
90:                PMD0 = 0x00;
11A72  0E00     MOVLW 0x0
11A74  0100     MOVLB 0x0
11A76  6F60     MOVWF PMD0, BANKED
91:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
92:                PMD1 = 0x00;
11A78  0E00     MOVLW 0x0
11A7A  6F61     MOVWF PMD1, BANKED
93:                // ZCDMD ZCD enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; DAC1MD DAC1 enabled; 
94:                PMD3 = 0x00;
11A7C  0E00     MOVLW 0x0
11A7E  6F63     MOVWF PMD3, BANKED
95:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
96:                PMD4 = 0x00;
11A80  0E00     MOVLW 0x0
11A82  6F64     MOVWF PMD4, BANKED
97:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM3MD PWM3 enabled; 
98:                PMD5 = 0x00;
11A84  0E00     MOVLW 0x0
11A86  6F65     MOVWF PMD5, BANKED
99:                // U5MD UART5 enabled; U4MD UART4 enabled; U3MD UART3 enabled; U2MD UART2 enabled; U1MD UART1 enabled; SPI2MD SPI2 enabled; SPI1MD SPI1 enabled; I2C1MD I2C1 enabled; 
100:               PMD6 = 0x00;
11A88  0E00     MOVLW 0x0
11A8A  6F66     MOVWF PMD6, BANKED
101:               // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
102:               PMD7 = 0x00;
11A8C  0E00     MOVLW 0x0
11A8E  6F67     MOVWF PMD7, BANKED
103:               // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
104:               PMD8 = 0x00;
11A90  0E00     MOVLW 0x0
11A92  6F68     MOVWF PMD8, BANKED
105:           }
11A94  0012     RETURN 0
106:           
107:           
108:           void SystemArbiter_Initialize(void)
109:           {
110:               // This function is dependant on the PR1WAY CONFIG bit
111:               PRLOCK = 0x55;
11C1E  0E55     MOVLW 0x55
11C20  6FB4     MOVWF PRLOCK, BANKED
112:               PRLOCK = 0xAA;
11C22  0EAA     MOVLW 0xAA
11C24  6FB4     MOVWF PRLOCK, BANKED
113:               PRLOCKbits.PRLOCKED = 1;
11C26  81B4     BSF PRLOCK, 0, BANKED
114:           }
11C28  0012     RETURN 0
115:           /**
116:            End of File
117:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/interrupt_manager.c  ----------------------
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
19:                    Device            :  PIC18F47Q43
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.30 and above or later
23:                    MPLAB 	          :  MPLAB X 5.40
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                INTCON0bits.IPEN = 1;
116A0  8AD6     BSF 0xFD6, 5, ACCESS
55:            
56:                bool state = (unsigned char)GIE;
116A2  0E00     MOVLW 0x0
116A4  BED6     BTFSC 0xFD6, 7, ACCESS
116A6  0E01     MOVLW 0x1
116A8  6E0E     MOVWF 0xE, ACCESS
57:                GIE = 0;
116AA  9ED6     BCF 0xFD6, 7, ACCESS
58:                IVTLOCK = 0x55;
116AC  0E55     MOVLW 0x55
116AE  0104     MOVLB 0x4
116B0  6F59     MOVWF 0x59, BANKED
59:                IVTLOCK = 0xAA;
116B2  0EAA     MOVLW 0xAA
116B4  6F59     MOVWF 0x59, BANKED
60:                IVTLOCKbits.IVTLOCKED = 0x00; // unlock IVT
116B6  9159     BCF 0x59, 0, BANKED
61:            
62:                IVTBASEU = 0;
116B8  0E00     MOVLW 0x0
116BA  6F5F     MOVWF 0x5F, BANKED
63:                IVTBASEH = 0;
116BC  0E00     MOVLW 0x0
116BE  6F5E     MOVWF 0x5E, BANKED
64:                IVTBASEL = 8;
116C0  0E08     MOVLW 0x8
116C2  6F5D     MOVWF 0x5D, BANKED
65:            
66:                IVTLOCK = 0x55;
116C4  0E55     MOVLW 0x55
116C6  6F59     MOVWF 0x59, BANKED
67:                IVTLOCK = 0xAA;
116C8  0EAA     MOVLW 0xAA
116CA  6F59     MOVWF 0x59, BANKED
68:                IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
116CC  8159     BSF 0x59, 0, BANKED
69:            
70:                GIE = state;
116CE  B00E     BTFSC 0xE, 0, ACCESS
116D0  D002     BRA 0x16D6
116D2  9ED6     BCF 0xFD6, 7, ACCESS
116D4  D001     BRA 0x16D8
116D6  8ED6     BSF 0xFD6, 7, ACCESS
71:                // Assign peripheral interrupt priority vectors
72:                IPR12bits.DMA5DCNTIP = 1;
116D8  0103     MOVLB 0x3
116DA  8B6E     BSF MD1CARH, 5, BANKED
73:                IPR4bits.U1TXIP = 0;
116DC  9366     BCF PMD6, 1, BANKED
74:                IPR4bits.U1RXIP = 0;
116DE  9166     BCF PMD6, 0, BANKED
75:                IPR15bits.TMR6IP = 0;
116E0  9771     BCF CM1CON1, 3, BANKED
76:                IPR8bits.TMR5IP = 0;
116E2  996A     BCF MD1CON0, 4, BANKED
77:                IPR11bits.TMR4IP = 0;
116E4  976D     BCF MD1CARL, 3, BANKED
78:            }
116E6  0012     RETURN 0
79:            
80:            void __interrupt(irq(default),base(8)) Default_ISR()
11CAC  0011     RETFIE 1
81:            {
82:            }
11A4C  9ABA     BCF 0xFBA, 5, ACCESS
83:            
84:            /**
85:             End of File
86:            */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/dma6.c  -----------------------------------
1:             /**
2:               DMA6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA6.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma6.h"
53:            
54:            
55:            /**
56:              Section: DMA6 APIs
57:            */
58:            
59:            void DMA6_Initialize(void)
60:            {
61:                //DMA Instance Selection : 0x05
62:                DMASELECT = 0x05;
11578  0E05     MOVLW 0x5
1157A  0100     MOVLB 0x0
1157C  6FE8     MOVWF DMASELECT, BANKED
63:                //Source Address : hsync
64:                DMAnSSA = &hsync;
1157E  0E00     MOVLW 0x0
11580  6FF9     MOVWF DMAnSSA, BANKED
11582  0E09     MOVLW 0x9
11584  6FFA     MOVWF DMAnSSAH, BANKED
11586  0E00     MOVLW 0x0
11588  6FFB     MOVWF DMAnSSAU, BANKED
65:                //Destination Address : &DstVarName5
66:                DMAnDSA= &DstVarName5;
1158A  0E05     MOVLW 0x5
1158C  6FF1     MOVWF DMAnDSAH, BANKED
1158E  0EEA     MOVLW 0xEA
11590  6FF0     MOVWF DMAnDSA, BANKED
67:                //DMODE unchanged; DSTP not cleared; SMR GPR; SMODE incremented; SSTP not cleared; 
68:                DMAnCON1 = 0x02;
11592  0E02     MOVLW 0x2
11594  6FFD     MOVWF DMAnCON1, BANKED
69:                //Source Message Size : 1
70:                DMAnSSZ = 1;
11596  0E00     MOVLW 0x0
11598  6FF8     MOVWF DMAnSSZH, BANKED
1159A  0E01     MOVLW 0x1
1159C  6FF7     MOVWF DMAnSSZ, BANKED
71:                //Destination Message Size : 1
72:                DMAnDSZ = 1;
1159E  0E00     MOVLW 0x0
115A0  6FEF     MOVWF DMAnDSZH, BANKED
115A2  0E01     MOVLW 0x1
115A4  6FEE     MOVWF DMAnDSZ, BANKED
73:                //Start Trigger : SIRQ None; 
74:                DMAnSIRQ = 0x00;
115A6  0E00     MOVLW 0x0
115A8  6FFF     MOVWF DMAnSIRQ, BANKED
75:                //Abort Trigger : AIRQ None; 
76:                DMAnAIRQ = 0x00;
115AA  0E00     MOVLW 0x0
115AC  6FFE     MOVWF DMAnAIRQ, BANKED
77:            	
78:                // Clear Destination Count Interrupt Flag bit
79:                PIR13bits.DMA6DCNTIF = 0; 
115AE  9ABB     BCF 0xFBB, 5, ACCESS
80:                // Clear Source Count Interrupt Flag bit
81:                PIR13bits.DMA6SCNTIF = 0; 
115B0  98BB     BCF 0xFBB, 4, ACCESS
82:                // Clear Abort Interrupt Flag bit
83:                PIR13bits.DMA6AIF = 0; 
115B2  9EBB     BCF 0xFBB, 7, ACCESS
84:                // Clear Overrun Interrupt Flag bit
85:                PIR13bits.DMA6ORIF =0; 
115B4  9CBB     BCF 0xFBB, 6, ACCESS
86:                
87:                PIE13bits.DMA6DCNTIE = 0;
115B6  9AAB     BCF 0xFAB, 5, ACCESS
88:                PIE13bits.DMA6SCNTIE = 0;
115B8  98AB     BCF 0xFAB, 4, ACCESS
89:                PIE13bits.DMA6AIE = 0;
115BA  9EAB     BCF 0xFAB, 7, ACCESS
90:                PIE13bits.DMA6ORIE = 0;
115BC  9CAB     BCF 0xFAB, 6, ACCESS
91:            	
92:                //EN enabled; SIRQEN disabled; DGO not in progress; AIRQEN disabled; 
93:                DMAnCON0 = 0x80;
115BE  0E80     MOVLW 0x80
115C0  6FFC     MOVWF DMAnCON0, BANKED
94:            	
95:            }
115C2  0012     RETURN 0
96:            
97:            void DMA6_SelectSourceRegion(uint8_t region)
98:            {
99:                DMASELECT = 0x05;
100:           	DMAnCON1bits.SMR  = region;
101:           }
102:           
103:           void DMA6_SetSourceAddress(uint24_t address)
104:           {
105:               DMASELECT = 0x05;
106:           	DMAnSSA = address;
107:           }
108:           
109:           void DMA6_SetDestinationAddress(uint16_t address)
110:           {
111:               DMASELECT = 0x05;
112:           	DMAnDSA = address;
113:           }
114:           
115:           void DMA6_SetSourceSize(uint16_t size)
116:           {
117:               DMASELECT = 0x05;
118:           	DMAnSSZ= size;
119:           }
120:           
121:           void DMA6_SetDestinationSize(uint16_t size)
122:           {                     
123:               DMASELECT = 0x05;
124:           	DMAnDSZ= size;
125:           }
126:           
127:           uint24_t DMA6_GetSourcePointer(void)
128:           {
129:               DMASELECT = 0x05;
130:           	return DMAnSPTR;
131:           }
132:           
133:           uint16_t DMA6_GetDestinationPointer(void)
134:           {
135:               DMASELECT = 0x05;
136:           	return DMAnDPTR;
137:           }
138:           
139:           void DMA6_SetStartTrigger(uint8_t sirq)
140:           {
141:               DMASELECT = 0x05;
142:           	DMAnSIRQ = sirq;
143:           }
144:           
145:           void DMA6_SetAbortTrigger(uint8_t airq)
146:           {
147:               DMASELECT = 0x05;
148:           	DMAnAIRQ = airq;
149:           }
150:           
151:           void DMA6_StartTransfer(void)
152:           {
153:               DMASELECT = 0x05;
154:           	DMAnCON0bits.DGO = 1;
155:           }
156:           
157:           void DMA6_StartTransferWithTrigger(void)
158:           {
159:               DMASELECT = 0x05;
160:           	DMAnCON0bits.SIRQEN = 1;
161:           }
162:           
163:           void DMA6_StopTransfer(void)
164:           {
165:               DMASELECT = 0x05;
166:           	DMAnCON0bits.SIRQEN = 0; 
167:           	DMAnCON0bits.DGO = 0;
168:           }
169:           
170:           void DMA6_SetDMAPriority(uint8_t priority)
171:           {
172:               // This function is dependant on the PR1WAY CONFIG bit
173:           	PRLOCK = 0x55;
174:           	PRLOCK = 0xAA;
175:           	PRLOCKbits.PRLOCKED = 0;
176:           	DMA6PR = priority;
177:           	PRLOCK = 0x55;
178:           	PRLOCK = 0xAA;
179:           	PRLOCKbits.PRLOCKED = 1;
180:           }
181:           
182:           /**
183:            End of File
184:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/mcc_generated_files/dma5.c  -----------------------------------
1:             /**
2:               DMA5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA5.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma5.h"
53:            
54:            void (*DMA5_DCNTI_InterruptHandler)(void);
55:            
56:            /**
57:              Section: DMA5 APIs
58:            */
59:            
60:            void DMA5_Initialize(void)
61:            {
62:                //DMA Instance Selection : 0x04
63:                DMASELECT = 0x04;
113D8  0E04     MOVLW 0x4
113DA  6FE8     MOVWF DMASELECT, BANKED
64:                //Source Address : vsync
65:                DMAnSSA = &vsync;
113DC  0E00     MOVLW 0x0
113DE  6FF9     MOVWF DMAnSSA, BANKED
113E0  0E08     MOVLW 0x8
113E2  6FFA     MOVWF DMAnSSAH, BANKED
113E4  0E00     MOVLW 0x0
113E6  6FFB     MOVWF DMAnSSAU, BANKED
66:                //Destination Address : &LATB
67:                DMAnDSA= &LATB;
113E8  0E04     MOVLW 0x4
113EA  6FF1     MOVWF DMAnDSAH, BANKED
113EC  0EBF     MOVLW 0xBF
113EE  6FF0     MOVWF DMAnDSA, BANKED
68:                //DMODE unchanged; DSTP not cleared; SMR GPR; SMODE incremented; SSTP not cleared; 
69:                DMAnCON1 = 0x02;
113F0  0E02     MOVLW 0x2
113F2  6FFD     MOVWF DMAnCON1, BANKED
70:                //Source Message Size : 31
71:                DMAnSSZ = 243;
113F4  0E00     MOVLW 0x0
113F6  6FF8     MOVWF DMAnSSZH, BANKED
113F8  0EF3     MOVLW 0xF3
113FA  6FF7     MOVWF DMAnSSZ, BANKED
72:                //Destination Message Size : 13
73:                DMAnDSZ = 243;
113FC  0E00     MOVLW 0x0
113FE  6FEF     MOVWF DMAnDSZH, BANKED
11400  0EF3     MOVLW 0xF3
11402  6FEE     MOVWF DMAnDSZ, BANKED
74:                //Start Trigger : SIRQ None; 
75:                DMAnSIRQ = 0x00;
11404  0E00     MOVLW 0x0
11406  6FFF     MOVWF DMAnSIRQ, BANKED
76:                //Abort Trigger : AIRQ None; 
77:                DMAnAIRQ = 0x00;
11408  0E00     MOVLW 0x0
1140A  6FFE     MOVWF DMAnAIRQ, BANKED
78:            	
79:                // Clear Destination Count Interrupt Flag bit
80:                PIR12bits.DMA5DCNTIF = 0; 
1140C  9ABA     BCF 0xFBA, 5, ACCESS
81:                // Clear Source Count Interrupt Flag bit
82:                PIR12bits.DMA5SCNTIF = 0; 
1140E  98BA     BCF 0xFBA, 4, ACCESS
83:                // Clear Abort Interrupt Flag bit
84:                PIR12bits.DMA5AIF = 0; 
11410  9EBA     BCF 0xFBA, 7, ACCESS
85:                // Clear Overrun Interrupt Flag bit
86:                PIR12bits.DMA5ORIF =0; 
11412  9CBA     BCF 0xFBA, 6, ACCESS
87:                
88:                PIE12bits.DMA5DCNTIE = 1;
11414  8AAA     BSF 0xFAA, 5, ACCESS
89:            	DMA5_SetDCNTIInterruptHandler(DMA5_DefaultInterruptHandler);
11416  0EAE     MOVLW 0xAE
11418  6E0E     MOVWF 0xE, ACCESS
1141A  0E1C     MOVLW 0x1C
1141C  6E0F     MOVWF 0xF, ACCESS
1141E  0E01     MOVLW 0x1
11420  6E10     MOVWF 0x10, ACCESS
11422  EC08     CALL 0x11C10, 0
11424  F08E     NOP
90:                PIE12bits.DMA5SCNTIE = 0;
11426  98AA     BCF 0xFAA, 4, ACCESS
91:                PIE12bits.DMA5AIE = 0;
11428  9EAA     BCF 0xFAA, 7, ACCESS
92:                PIE12bits.DMA5ORIE = 0;
1142A  9CAA     BCF 0xFAA, 6, ACCESS
93:            	
94:                //EN enabled; SIRQEN disabled; DGO not in progress; AIRQEN disabled; 
95:                DMAnCON0 = 0x80;
1142C  0E80     MOVLW 0x80
1142E  0100     MOVLB 0x0
11430  6FFC     MOVWF DMAnCON0, BANKED
96:            	
97:            }
11432  0012     RETURN 0
98:            
99:            void DMA5_SelectSourceRegion(uint8_t region)
100:           {
101:               DMASELECT = 0x04;
102:           	DMAnCON1bits.SMR  = region;
103:           }
104:           
105:           void DMA5_SetSourceAddress(uint24_t address)
106:           {
107:               DMASELECT = 0x04;
108:           	DMAnSSA = address;
109:           }
110:           
111:           void DMA5_SetDestinationAddress(uint16_t address)
112:           {
113:               DMASELECT = 0x04;
114:           	DMAnDSA = address;
115:           }
116:           
117:           void DMA5_SetSourceSize(uint16_t size)
118:           {
119:               DMASELECT = 0x04;
120:           	DMAnSSZ= size;
121:           }
122:           
123:           void DMA5_SetDestinationSize(uint16_t size)
124:           {                     
125:               DMASELECT = 0x04;
126:           	DMAnDSZ= size;
127:           }
128:           
129:           uint24_t DMA5_GetSourcePointer(void)
130:           {
131:               DMASELECT = 0x04;
132:           	return DMAnSPTR;
133:           }
134:           
135:           uint16_t DMA5_GetDestinationPointer(void)
136:           {
137:               DMASELECT = 0x04;
138:           	return DMAnDPTR;
139:           }
140:           
141:           void DMA5_SetStartTrigger(uint8_t sirq)
142:           {
143:               DMASELECT = 0x04;
144:           	DMAnSIRQ = sirq;
145:           }
146:           
147:           void DMA5_SetAbortTrigger(uint8_t airq)
148:           {
149:               DMASELECT = 0x04;
150:           	DMAnAIRQ = airq;
151:           }
152:           
153:           void DMA5_StartTransfer(void)
154:           {
155:               DMASELECT = 0x04;
11C40  0E04     MOVLW 0x4
11C42  0100     MOVLB 0x0
11C44  6FE8     MOVWF DMASELECT, BANKED
11C4A  0E04     MOVLW 0x4
156:           	DMAnCON0bits.DGO = 1;
11C46  8BFC     BSF DMAnCON0, 5, BANKED
11C50  8BFC     BSF DMAnCON0, 5, BANKED
157:           }
11C48  0012     RETURN 0
11C52  0012     RETURN 0
158:           
159:           void DMA5_StartTransferWithTrigger(void)
160:           {
161:               DMASELECT = 0x04;
162:           	DMAnCON0bits.SIRQEN = 1;
163:           }
164:           
165:           void DMA5_StopTransfer(void)
166:           {
167:               DMASELECT = 0x04;
11C36  0E04     MOVLW 0x4
11C38  6FE8     MOVWF DMASELECT, BANKED
168:           	DMAnCON0bits.SIRQEN = 0; 
11C3A  9DFC     BCF DMAnCON0, 6, BANKED
169:           	DMAnCON0bits.DGO = 0;
11C3C  9BFC     BCF DMAnCON0, 5, BANKED
170:           }
11C3E  0012     RETURN 0
171:           
172:           void DMA5_SetDMAPriority(uint8_t priority)
173:           {
174:               // This function is dependant on the PR1WAY CONFIG bit
175:           	PRLOCK = 0x55;
176:           	PRLOCK = 0xAA;
177:           	PRLOCKbits.PRLOCKED = 0;
178:           	DMA5PR = priority;
179:           	PRLOCK = 0x55;
180:           	PRLOCK = 0xAA;
181:           	PRLOCKbits.PRLOCKED = 1;
182:           }
183:           
184:           void __interrupt(irq(IRQ_DMA5DCNT),base(8)) DMA5_DMADCNTI_ISR()
185:           {
186:               // Clear the source count interrupt flag
187:               PIR12bits.DMA5DCNTIF = 0;
11A4C  9ABA     BCF 0xFBA, 5, ACCESS
188:           
189:               if (DMA5_DCNTI_InterruptHandler)
11A4E  0105     MOVLB 0x5
11A50  51C5     MOVF 0xC5, W, BANKED
11A52  11C6     IORWF 0xC6, W, BANKED
11A54  11C7     IORWF 0xC7, W, BANKED
11A56  B4D8     BTFSC 0xFD8, 2, ACCESS
11A58  0011     RETFIE 1
190:                       DMA5_DCNTI_InterruptHandler();
11A5A  D801     RCALL 0x1A5E
11A5C  0011     RETFIE 1
11A5E  0005     PUSH
11A60  6EFA     MOVWF 0xFFA, ACCESS
11A62  51C5     MOVF 0xC5, W, BANKED
11A64  6EFD     MOVWF 0xFFD, ACCESS
11A66  51C6     MOVF 0xC6, W, BANKED
11A68  6EFE     MOVWF 0xFFE, ACCESS
11A6A  51C7     MOVF 0xC7, W, BANKED
11A6C  6EFF     MOVWF 0xFFF, ACCESS
11A6E  50FA     MOVF 0xFFA, W, ACCESS
11A70  0012     RETURN 0
191:           }
192:           
193:           void DMA5_SetDCNTIInterruptHandler(void (* InterruptHandler)(void))
194:           {
195:           	 DMA5_DCNTI_InterruptHandler = InterruptHandler;
11C10  C50E     MOVFF InterruptHandler, DMA5_DCNTI_InterruptHandler
11C12  F5C5     NOP
11C14  C50F     MOVFF 0x50F, 0x5C6
11C16  F5C6     NOP
11C18  C510     MOVFF blockSize, 0x5C7
11C1A  F5C7     NOP
196:           }
117F2  F360     NOP
117F4  F506     NOP
11C1C  0012     RETURN 0
197:           
198:           void DMA5_DefaultInterruptHandler(void){
199:               // add your DMA5 interrupt custom code
200:               // or set custom function using DMA5_SetSCNTIInterruptHandler() /DMA5_SetDCNTIInterruptHandler() /DMA5_SetAIInterruptHandler() /DMA5_SetORIInterruptHandler()
201:           }
11CAE  0012     RETURN 0
202:           /**
203:            End of File
204:           */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/main.c  -------------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:            	Device            :  PIC18F47Q43
18:            	Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:             */
43:            #pragma warning disable 520
44:            #pragma warning disable 1498
45:            
46:            #include <stdlib.h>
47:            #include <stdbool.h>
48:            #include "mcc_generated_files/mcc.h"
49:            #include "mcc_generated_files/tmr5.h"
50:            #include "mcc_generated_files/tmr4.h"
51:            #include "qconfig.h"
52:            #include "vtouch.h"
53:            #include "vtouch_build.h"
54:            #include "timers.h"
55:            #include "eadog.h"
56:            #include "ntsc.h"
57:            
58:            volatile uint16_t tickCount[TMR_COUNT];
59:            char buffer[256];
60:            
61:            void led_flash(void);
62:            
63:            /*
64:             *			 Main application
65:             */
66:            void main(void)
67:            {
68:            
69:            	// Initialize the device
70:            	SYSTEM_Initialize();
10DB2  EC33     CALL 0x11866, 0
10DB4  F08C     NOP
71:            	TMR4_Stop();
10DB6  EC33     CALL 0x11C66, 0
10DB8  F08E     NOP
72:            	TMR5_SetInterruptHandler(led_flash);
10DBA  0E52     MOVLW 0x52
10DBC  6E0E     MOVWF 0xE, ACCESS
10DBE  0E1B     MOVLW 0x1B
10DC0  6E0F     MOVWF 0xF, ACCESS
10DC2  0E01     MOVLW 0x1
10DC4  6E10     MOVWF 0x10, ACCESS
10DC6  ECFA     CALL 0x11BF4, 0
10DC8  F08D     NOP
73:            
74:            	// Enable high priority global interrupts
75:            	INTERRUPT_GlobalInterruptHighEnable();
10DCA  8ED6     BSF 0xFD6, 7, ACCESS
76:            
77:            	// Enable low priority global interrupts.
78:            	INTERRUPT_GlobalInterruptLowEnable();
10DCC  8CD6     BSF 0xFD6, 6, ACCESS
79:            
80:            	SPI1CON0bits.EN = 1;
10DCE  0100     MOVLB 0x0
10DD0  8F84     BSF SPI1CON0, 7, BANKED
81:            	init_display();
10DD2  EC0D     CALL 0x1121A, 0
10DD4  F089     NOP
82:            	sprintf(buffer, "%s ", build_version);
10DD6  0E00     MOVLW 0x0
10DD8  0106     MOVLB 0x6
10DDA  6FE3     MOVWF 0xE3, BANKED
10DDC  0E0A     MOVLW 0xA
10DDE  6FE4     MOVWF 0xE4, BANKED
10DE0  0EFA     MOVLW 0xFA
10DE2  6FE5     MOVWF 0xE5, BANKED
10DE4  0EFF     MOVLW 0xFF
10DE6  6FE6     MOVWF 0xE6, BANKED
10DE8  0ED4     MOVLW 0xD4
10DEA  6FE7     MOVWF 0xE7, BANKED
10DEC  0EFF     MOVLW 0xFF
10DEE  6FE8     MOVWF DMASELECT, BANKED
10DF0  EC6D     CALL 0x114DA, 0
10DF2  F08A     NOP
83:            	eaDogM_WriteStringAtPos(0, 0, buffer);
10DF4  0E00     MOVLW 0x0
10DF6  6E22     MOVWF 0x22, ACCESS
10DF8  0E00     MOVLW 0x0
10DFA  6E23     MOVWF 0x23, ACCESS
10DFC  0E0A     MOVLW 0xA
10DFE  6E24     MOVWF 0x24, ACCESS
10E00  0E00     MOVLW 0x0
10E02  EC8C     CALL 0x11318, 0
10E04  F089     NOP
84:            	sprintf(buffer, "%s ", build_date);
10E06  0E00     MOVLW 0x0
10E08  0106     MOVLB 0x6
10E0A  6FE3     MOVWF 0xE3, BANKED
10E0C  0E0A     MOVLW 0xA
10E0E  6FE4     MOVWF 0xE4, BANKED
10E10  0EFA     MOVLW 0xFA
10E12  6FE5     MOVWF 0xE5, BANKED
10E14  0EFF     MOVLW 0xFF
10E16  6FE6     MOVWF 0xE6, BANKED
10E18  0EE5     MOVLW 0xE5
10E1A  6FE7     MOVWF 0xE7, BANKED
10E1C  0EFF     MOVLW 0xFF
10E1E  6FE8     MOVWF DMASELECT, BANKED
10E20  EC6D     CALL 0x114DA, 0
10E22  F08A     NOP
85:            	eaDogM_WriteStringAtPos(1, 0, buffer);
10E24  0E00     MOVLW 0x0
10E26  6E22     MOVWF 0x22, ACCESS
10E28  0E00     MOVLW 0x0
10E2A  6E23     MOVWF 0x23, ACCESS
10E2C  0E0A     MOVLW 0xA
10E2E  6E24     MOVWF 0x24, ACCESS
10E30  0E01     MOVLW 0x1
10E32  EC8C     CALL 0x11318, 0
10E34  F089     NOP
86:            	sprintf(buffer, "%s ", build_time);
10E36  0E00     MOVLW 0x0
10E38  0106     MOVLB 0x6
10E3A  6FE3     MOVWF 0xE3, BANKED
10E3C  0E0A     MOVLW 0xA
10E3E  6FE4     MOVWF 0xE4, BANKED
10E40  0EFA     MOVLW 0xFA
10E42  6FE5     MOVWF 0xE5, BANKED
10E44  0EFF     MOVLW 0xFF
10E46  6FE6     MOVWF 0xE6, BANKED
10E48  0EF1     MOVLW 0xF1
10E4A  6FE7     MOVWF 0xE7, BANKED
10E4C  0EFF     MOVLW 0xFF
10E4E  6FE8     MOVWF DMASELECT, BANKED
10E50  EC6D     CALL 0x114DA, 0
10E52  F08A     NOP
87:            	eaDogM_WriteStringAtPos(2, 0, buffer);
10E54  0E00     MOVLW 0x0
10E56  6E22     MOVWF 0x22, ACCESS
10E58  0E00     MOVLW 0x0
10E5A  6E23     MOVWF 0x23, ACCESS
10E5C  0E0A     MOVLW 0xA
10E5E  6E24     MOVWF 0x24, ACCESS
10E60  0E02     MOVLW 0x2
10E62  EC8C     CALL 0x11318, 0
10E64  F089     NOP
88:            	BLED_SetLow();
10E66  90C2     BCF 0xFC2, 0, ACCESS
89:            
90:            	StartTimer(TMR_DIS, 500);
10E68  0E01     MOVLW 0x1
10E6A  6E0F     MOVWF 0xF, ACCESS
10E6C  0EF4     MOVLW 0xF4
10E6E  6E0E     MOVWF 0xE, ACCESS
10E70  0E06     MOVLW 0x6
10E72  ECE5     CALL 0x119CA, 0
10E74  F08C     NOP
91:            
92:            	TMR6_Stop(); // disable software timers to stop scan-line jitter
10E76  EC3F     CALL 0x11C7E, 0
10E78  F08E     NOP
93:            	ntsc_init();
10E7A  EC38     CALL 0x10670, 0
10E7C  F083     NOP
94:            
95:            	while (true) {
96:            		// Add your application code
97:            		BLED_Toggle(); // application code blink LED
10E7E  A0C2     BTFSS 0xFC2, 0, ACCESS
10E80  D002     BRA 0xE86
10E82  0E01     MOVLW 0x1
10E84  D001     BRA 0xE88
10E86  0E00     MOVLW 0x0
10E88  0AFF     XORLW 0xFF
10E8A  6E3F     MOVWF 0x3F, ACCESS
10E8C  50C2     MOVF 0xFC2, W, ACCESS
10E8E  183F     XORWF 0x3F, W, ACCESS
10E90  0BFE     ANDLW 0xFE
10E92  183F     XORWF 0x3F, W, ACCESS
10E94  6EC2     MOVWF 0xFC2, ACCESS
98:            //		scan_line++; // back from idle ISR 
99:            		if (scan_line>210)
10E96  0ED2     MOVLW 0xD2
10E98  6445     CPFSGT NVMADRU, ACCESS
10E9A  D7F1     BRA 0xE7E
100:           			scan_line=5;
10E9C  0E05     MOVLW 0x5
10E9E  6E45     MOVWF NVMADRU, ACCESS
10EA0  D7EE     BRA 0xE7E
101:           	}
102:           }
103:           
104:           /*
105:            * This runs in the timer5 ISR
106:            */
107:           void led_flash(void)
108:           {
109:           	LED2_Toggle(); // ISR code blink LED
11B52  A2C1     BTFSS 0xFC1, 1, ACCESS
11B54  D002     BRA 0x1B5A
11B56  0E01     MOVLW 0x1
11B58  D001     BRA 0x1B5C
11B5A  0E00     MOVLW 0x0
11B5C  0AFF     XORLW 0xFF
11B5E  6E04     MOVWF 0x4, ACCESS
11B60  4604     RLNCF 0x4, F, ACCESS
11B62  50C1     MOVF 0xFC1, W, ACCESS
11B64  1804     XORWF 0x4, W, ACCESS
11B66  0BFD     ANDLW 0xFD
11B68  1804     XORWF 0x4, W, ACCESS
11B6A  6EC1     MOVWF 0xFC1, ACCESS
110:           }
1189E  F360     NOP
118A0  F509     NOP
11B6C  0012     RETURN 0
111:           /**
112:            End of File
113:            */
---  /fred/pic18_k42/q43_board/q43_ntsc.X/eadog.c  ------------------------------------------------------
1:             #include <string.h>
2:             #include "qconfig.h"
3:             #include "eadog.h"
4:             #include "ringbufs.h"
5:             
6:             #define max_strlen	21
7:             #define max_port_data	1024
8:             
9:             volatile struct spi_link_type spi_link;
10:            struct ringBufS_t ring_buf1;
11:            static uint8_t port_data[max_port_data] = {255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0};
12:            
13:            static void send_lcd_cmd_long(uint8_t); // for display init only
14:            static void send_lcd_data(uint8_t);
15:            static void send_lcd_cmd(uint8_t);
16:            
17:            void wdtdelay(uint32_t delay)
18:            {
19:            	static uint32_t dcount;
20:            
21:            	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
117B4  0E00     MOVLW 0x0
117B6  0105     MOVLB 0x5
117B8  6FBE     MOVWF MAINPR, BANKED
117BA  0E00     MOVLW 0x0
117BC  6FBF     MOVWF ISRPR, BANKED
117BE  0E00     MOVLW 0x0
117C0  6FC0     MOVWF 0xC0, BANKED
117C2  0E00     MOVLW 0x0
117C4  6FC1     MOVWF 0xC1, BANKED
117C6  D009     BRA 0x17DA
22:            		Nop();
117C8  F000     NOP
23:            		ClrWdt(); // reset the WDT timer
117CA  0004     CLRWDT
24:            	};
117CC  0E01     MOVLW 0x1
117CE  0105     MOVLB 0x5
117D0  27BE     ADDWF MAINPR, F, BANKED
117D2  0E00     MOVLW 0x0
117D4  23BF     ADDWFC ISRPR, F, BANKED
117D6  23C0     ADDWFC 0xC0, F, BANKED
117D8  23C1     ADDWFC 0xC1, F, BANKED
117DA  51BE     MOVF MAINPR, W, BANKED
117DC  5C0E     SUBWF 0xE, W, ACCESS
117DE  51BF     MOVF ISRPR, W, BANKED
117E0  580F     SUBWFB 0xF, W, ACCESS
117E2  51C0     MOVF 0xC0, W, BANKED
117E4  5810     SUBWFB 0x10, W, ACCESS
117E6  51C1     MOVF 0xC1, W, BANKED
117E8  5811     SUBWFB 0x11, W, ACCESS
117EA  A0D8     BTFSS 0xFD8, 0, ACCESS
117EC  0012     RETURN 0
117EE  D7EC     BRA 0x17C8
25:            }
26:            
27:            /*
28:             * Init the NHD-0420D3Z-NSW-BBW-V3 in 8-bit serial mode
29:             * channel 1 DMA
30:             */
31:            void init_display(void)
32:            {
33:            	spi_link.tx1a = &ring_buf1;
1121A  0EA0     MOVLW 0xA0
1121C  0105     MOVLB 0x5
1121E  6FB4     MOVWF PRLOCK, BANKED
11220  0E06     MOVLW 0x6
11222  6FB5     MOVWF SCANPR, BANKED
34:            	ringBufS_init(spi_link.tx1a);
11224  C5B4     MOVFF 0x5B4, _this
11226  F51A     NOP
11228  C5B5     MOVFF 0x5B5, ptr
1122A  F51B     NOP
1122C  EC8C     CALL 0x11B18, 0
1122E  F08D     NOP
35:            
36:            #ifdef DEBUG_DISP2
37:            	DLED2 = true;
38:            #endif
39:            #ifdef NHD
40:            	wdtdelay(350000); // > 400ms power up delay
11230  0E30     MOVLW 0x30
11232  6E0E     MOVWF 0xE, ACCESS
11234  0E57     MOVLW 0x57
11236  6E0F     MOVWF 0xF, ACCESS
11238  0E05     MOVLW 0x5
1123A  6E10     MOVWF 0x10, ACCESS
1123C  0E00     MOVLW 0x0
1123E  6E11     MOVWF 0x11, ACCESS
11240  ECDA     CALL 0x117B4, 0
11242  F08B     NOP
41:            	send_lcd_cmd(0x46); // home cursor
11244  0E46     MOVLW 0x46
11246  EC16     CALL 0x1182C, 0
11248  F08C     NOP
42:            	wdtdelay(800);
1124A  0E20     MOVLW 0x20
1124C  6E0E     MOVWF 0xE, ACCESS
1124E  0E03     MOVLW 0x3
11250  6E0F     MOVWF 0xF, ACCESS
11252  0E00     MOVLW 0x0
11254  6E10     MOVWF 0x10, ACCESS
11256  0E00     MOVLW 0x0
11258  6E11     MOVWF 0x11, ACCESS
1125A  ECDA     CALL 0x117B4, 0
1125C  F08B     NOP
43:            	send_lcd_cmd(0x41); // display on
1125E  0E41     MOVLW 0x41
11260  EC16     CALL 0x1182C, 0
11262  F08C     NOP
44:            	wdtdelay(80);
11264  0E50     MOVLW 0x50
11266  6E0E     MOVWF 0xE, ACCESS
11268  0E00     MOVLW 0x0
1126A  6E0F     MOVWF 0xF, ACCESS
1126C  0E00     MOVLW 0x0
1126E  6E10     MOVWF 0x10, ACCESS
11270  0E00     MOVLW 0x0
11272  6E11     MOVWF 0x11, ACCESS
11274  ECDA     CALL 0x117B4, 0
11276  F08B     NOP
45:            	send_lcd_cmd(0x53); // set back-light level
11278  0E53     MOVLW 0x53
1127A  EC16     CALL 0x1182C, 0
1127C  F08C     NOP
46:            	send_lcd_data(NHD_BL_LOW);
1127E  0E02     MOVLW 0x2
11280  EC5C     CALL 0x11AB8, 0
11282  F08D     NOP
47:            	wdtdelay(80);
11284  0E50     MOVLW 0x50
11286  6E0E     MOVWF 0xE, ACCESS
11288  0E00     MOVLW 0x0
1128A  6E0F     MOVWF 0xF, ACCESS
1128C  0E00     MOVLW 0x0
1128E  6E10     MOVWF 0x10, ACCESS
11290  0E00     MOVLW 0x0
11292  6E11     MOVWF 0x11, ACCESS
11294  ECDA     CALL 0x117B4, 0
11296  F08B     NOP
48:            	send_lcd_cmd(0x51); // clear screen
11298  0E51     MOVLW 0x51
1129A  EC16     CALL 0x1182C, 0
1129C  F08C     NOP
49:            	wdtdelay(800);
1129E  0E20     MOVLW 0x20
112A0  6E0E     MOVWF 0xE, ACCESS
112A2  0E03     MOVLW 0x3
112A4  6E0F     MOVWF 0xF, ACCESS
112A6  0E00     MOVLW 0x0
112A8  6E10     MOVWF 0x10, ACCESS
112AA  0E00     MOVLW 0x0
112AC  6E11     MOVWF 0x11, ACCESS
112AE  ECDA     CALL 0x117B4, 0
112B0  F08B     NOP
50:            
51:            #else
52:            	CSB_SetHigh();
53:            	wdtdelay(350000); // > 400ms power up delay
54:            	send_lcd_cmd_dma(0x39);
55:            	send_lcd_cmd_dma(0x1d);
56:            	send_lcd_cmd_dma(0x50);
57:            	send_lcd_cmd_dma(0x6c);
58:            	send_lcd_cmd_dma(0x76); // contrast last 4 bits
59:            	send_lcd_cmd_dma(0x38); // follower control
60:            	wdtdelay(800);
61:            	send_lcd_cmd_dma(0x0f);
62:            	send_lcd_cmd_dma(0x01); // clear
63:            	wdtdelay(800);
64:            	send_lcd_cmd_dma(0x02);
65:            	send_lcd_cmd_dma(0x06);
66:            	wdtdelay(30);
67:            	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
68:            #endif
69:            	//	SPI1INTFbits.SPI1TXUIF = 0;
70:            	//	DMA1CON1bits.DMODE = 0;
71:            	//	DMA1CON1bits.DSTP = 0;
72:            	//	DMA1CON1bits.SMODE = 1;
73:            	//	DMA1CON1bits.SMR = 0;
74:            	//	DMA1CON1bits.SSTP = 1;
75:            	//	DMA1SSA = (uint32_t) & ring_buf1;
76:            	//	DMA1CON0bits.DGO = 0;
77:            	//	SPI1INTFbits.SPI1TXUIF = 1;
78:            #ifdef DEBUG_DISP2
79:            	DLED2 = false;
80:            #endif
81:            #ifdef USE_DMA
82:            	DMA1_SetSCNTIInterruptHandler(clear_lcd_done);
83:            	DMA2_SetDCNTIInterruptHandler(spi_rec_done);
84:            #endif
85:            }
112B2  0012     RETURN 0
86:            
87:            /*
88:             * channel DMA
89:             */
90:            void init_port_dma(void)
91:            {
92:            }
93:            
94:            #ifdef NHD
95:            
96:            /*
97:             * R2 short on LCD NHD-0420D3Z-NSW-BBW-V3 board
98:             */
99:            
100:           static void send_lcd_data(const uint8_t data)
11AB8  6E12     MOVWF 0x12, ACCESS
101:           {
102:           	CSB_SetLow();
11ABA  94C0     BCF 0xFC0, 2, ACCESS
103:           	SPI1_ExchangeByte(data);
11ABC  5012     MOVF 0x12, W, ACCESS
11ABE  ECC4     CALL 0x11B88, 0
11AC0  F08D     NOP
104:           	wdtdelay(8);
11AC2  0E08     MOVLW 0x8
11AC4  6E0E     MOVWF 0xE, ACCESS
11AC6  0E00     MOVLW 0x0
11AC8  6E0F     MOVWF 0xF, ACCESS
11ACA  0E00     MOVLW 0x0
11ACC  6E10     MOVWF 0x10, ACCESS
11ACE  0E00     MOVLW 0x0
11AD0  6E11     MOVWF 0x11, ACCESS
11AD2  ECDA     CALL 0x117B4, 0
11AD4  F08B     NOP
105:           }
11AD6  0012     RETURN 0
106:           
107:           static void send_lcd_cmd(const uint8_t cmd)
1182C  6E12     MOVWF 0x12, ACCESS
108:           {
109:           	CSB_SetLow();
1182E  94C0     BCF 0xFC0, 2, ACCESS
110:           	SPI1_ExchangeByte(NHD_CMD);
11830  0EFE     MOVLW 0xFE
11832  ECC4     CALL 0x11B88, 0
11834  F08D     NOP
111:           	wdtdelay(8);
11836  0E08     MOVLW 0x8
11838  6E0E     MOVWF 0xE, ACCESS
1183A  0E00     MOVLW 0x0
1183C  6E0F     MOVWF 0xF, ACCESS
1183E  0E00     MOVLW 0x0
11840  6E10     MOVWF 0x10, ACCESS
11842  0E00     MOVLW 0x0
11844  6E11     MOVWF 0x11, ACCESS
11846  ECDA     CALL 0x117B4, 0
11848  F08B     NOP
112:           	SPI1_ExchangeByte(cmd);
1184A  5012     MOVF 0x12, W, ACCESS
1184C  ECC4     CALL 0x11B88, 0
1184E  F08D     NOP
113:           	wdtdelay(8);
11850  0E08     MOVLW 0x8
11852  6E0E     MOVWF 0xE, ACCESS
11854  0E00     MOVLW 0x0
11856  6E0F     MOVWF 0xF, ACCESS
11858  0E00     MOVLW 0x0
1185A  6E10     MOVWF 0x10, ACCESS
1185C  0E00     MOVLW 0x0
1185E  6E11     MOVWF 0x11, ACCESS
11860  ECDA     CALL 0x117B4, 0
11862  F08B     NOP
114:           }
11864  0012     RETURN 0
115:           
116:           static void send_lcd_cmd_long(const uint8_t cmd)
117:           {
118:           	CSB_SetLow();
119:           	SPI1_ExchangeByte(NHD_CMD);
120:           	wdtdelay(8);
121:           	SPI1_ExchangeByte(cmd);
122:           	wdtdelay(800);
123:           }
124:           
125:           /*
126:            * uses DMA channel 1 for transfers
127:            */
128:           void eaDogM_WriteString(char *strPtr)
129:           {
130:           	uint8_t len = (uint8_t) strlen(strPtr);
112B4  C51F     MOVFF strPtr, InterruptHandler
112B6  F50E     NOP
112B8  C520     MOVFF 0x520, 0x50F
112BA  F50F     NOP
112BC  EC2C     CALL 0x11658, 0
112BE  F08B     NOP
112C0  500E     MOVF 0xE, W, ACCESS
112C2  6E21     MOVWF 0x21, ACCESS
131:           
132:           #ifdef DEBUG_DISP1
133:           	DLED1 = true;
134:           #endif
135:           	wait_lcd_done();
112C4  EC2F     CALL 0x11C5E, 0
112C6  F08E     NOP
136:           	wait_lcd_set();
112C8  EC3C     CALL 0x11C78, 0
112CA  F08E     NOP
137:           	/* reset buffer for DMA */
138:           	ringBufS_flush(spi_link.tx1a, false);
112CC  C5B4     MOVFF 0x5B4, _this
112CE  F51A     NOP
112D0  C5B5     MOVFF 0x5B5, ptr
112D2  F51B     NOP
112D4  0E00     MOVLW 0x0
112D6  6E1C     MOVWF 0x1C, ACCESS
112D8  EC1A     CALL 0x11434, 0
112DA  F08A     NOP
139:           	CSB_SetLow(); /* SPI select display */
112DC  94C0     BCF 0xFC0, 2, ACCESS
140:           	if (len > (uint8_t) max_strlen) {
112DE  0E15     MOVLW 0x15
112E0  6421     CPFSGT 0x21, ACCESS
112E2  D002     BRA 0x12E8
141:           		len = max_strlen;
112E4  0E15     MOVLW 0x15
112E6  6E21     MOVWF 0x21, ACCESS
142:           	}
143:           	ringBufS_put_dma_cpy(spi_link.tx1a, strPtr, len);
112E8  C5B4     MOVFF 0x5B4, _this
112EA  F519     NOP
112EC  C5B5     MOVFF 0x5B5, _this
112EE  F51A     NOP
112F0  C51F     MOVFF strPtr, ptr
112F2  F51B     NOP
112F4  C520     MOVFF 0x520, clearBuffer
112F6  F51C     NOP
112F8  C521     MOVFF len, len
112FA  F51D     NOP
112FC  EC44     CALL 0x11488, 0
112FE  F08A     NOP
144:           #ifdef USE_DMA
145:           	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
146:           	DMA1_SetSourceSize(len);
147:           	DMA1_SetDestinationSize(1);
148:           	DMA2_SetSourceSize(1);
149:           	DMA2_SetDestinationSize(len);
150:           #else
151:           	SPI1_ExchangeBlock(spi_link.tx1a, len);
11300  C5B4     MOVFF 0x5B4, InterruptHandler
11302  F50E     NOP
11304  C5B5     MOVFF 0x5B5, 0x50F
11306  F50F     NOP
11308  C521     MOVFF len, blockSize
1130A  F510     NOP
1130C  6A11     CLRF 0x11, ACCESS
1130E  ECE2     CALL 0x115C4, 0
11310  F08A     NOP
152:           #endif
153:           	start_lcd(); // start DMA transfer
11312  EC51     CALL 0x11CA2, 0
11314  F08E     NOP
154:           #ifdef DISPLAY_SLOW
155:           	wdtdelay(9000);
156:           #endif
157:           #ifdef DEBUG_DISP1
158:           	DLED1 = false;
159:           #endif
160:           }
11316  0012     RETURN 0
161:           
162:           /*
163:            * uses DMA channel 1 for transfers
164:            */
165:           void send_lcd_cmd_dma(const uint8_t strPtr)
166:           {
167:           	wait_lcd_done();
168:           	send_lcd_data_dma(NHD_CMD); //prefix
169:           	wait_lcd_done();
170:           	send_lcd_data_dma(strPtr); // cmd code
171:           	wait_lcd_done();
172:           }
173:           
174:           /*
175:            * uses DMA channel 1 for transfers
176:            */
177:           void send_lcd_data_dma(const uint8_t strPtr)
178:           {
179:           #ifdef DEBUG_DISP2
180:           	DLED2 = true;
181:           #endif
182:           	wait_lcd_set();
183:           	/* reset buffer for DMA */
184:           	ringBufS_flush(spi_link.tx1a, false);
185:           	CSB_SetLow(); /* SPI select display */
186:           	ringBufS_put_dma(spi_link.tx1a, strPtr); // don't use printf to send zeros
187:           #ifdef USE_DMA
188:           	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
189:           	DMA1_SetSourceSize(1);
190:           	DMA1_SetDestinationSize(1);
191:           	DMA2_SetSourceSize(1);
192:           	DMA2_SetDestinationSize(1);
193:           #endif
194:           	start_lcd(); // start DMA transfer
195:           #ifdef DEBUG_DISP2
196:           	DLED2 = false;
197:           #endif
198:           }
199:           
200:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
11318  6E27     MOVWF 0x27, ACCESS
201:           {
202:           	uint8_t row;
203:           
204:           	switch (r) {
1131A  D009     BRA 0x132E
205:           	case 0:
206:           		row = 0x40;
1131C  0E40     MOVLW 0x40
1131E  D005     BRA 0x132A
207:           		break;
208:           	case 1:
209:           		row = 0x14;
11320  0E14     MOVLW 0x14
11322  D003     BRA 0x132A
210:           		break;
211:           	case 2:
212:           		row = 0x54;
11324  0E54     MOVLW 0x54
11326  D001     BRA 0x132A
213:           		break;
214:           	case 3:
215:           		row = 0x00;
11328  0E00     MOVLW 0x0
1132A  6E28     MOVWF 0x28, ACCESS
216:           		break;
1132C  D015     BRA 0x1358
217:           	default:
218:           		row = 0x40;
219:           		break;
220:           	}
1132E  5027     MOVF 0x27, W, ACCESS
11330  6E25     MOVWF 0x25, ACCESS
11332  6A26     CLRF 0x26, ACCESS
11334  5026     MOVF 0x26, W, ACCESS
11336  0A00     XORLW 0x0
11338  A4D8     BTFSS 0xFD8, 2, ACCESS
1133A  D7F0     BRA 0x131C
1133C  5025     MOVF 0x25, W, ACCESS
1133E  0A00     XORLW 0x0
11340  B4D8     BTFSC 0xFD8, 2, ACCESS
11342  D7EC     BRA 0x131C
11344  0A01     XORLW 0x1
11346  B4D8     BTFSC 0xFD8, 2, ACCESS
11348  D7EB     BRA 0x1320
1134A  0A03     XORLW 0x3
1134C  B4D8     BTFSC 0xFD8, 2, ACCESS
1134E  D7EA     BRA 0x1324
11350  0A01     XORLW 0x1
11352  B4D8     BTFSC 0xFD8, 2, ACCESS
11354  D7E9     BRA 0x1328
11356  D7E2     BRA 0x131C
221:           	send_lcd_cmd(0x45);
11358  0E45     MOVLW 0x45
1135A  EC16     CALL 0x1182C, 0
1135C  F08C     NOP
222:           	send_lcd_data(row + c);
1135E  5028     MOVF 0x28, W, ACCESS
11360  2422     ADDWF 0x22, W, ACCESS
11362  EC5C     CALL 0x11AB8, 0
11364  F08D     NOP
223:           	wait_lcd_done();
11366  EC2F     CALL 0x11C5E, 0
11368  F08E     NOP
224:           	CSB_SetHigh(); /* SPI deselect display */
1136A  84C0     BSF 0xFC0, 2, ACCESS
225:           	eaDogM_WriteString(strPtr);
1136C  C523     MOVFF strPtr, strPtr
1136E  F51F     NOP
11370  C524     MOVFF 0x524, 0x520
11372  F520     NOP
11374  EC5A     CALL 0x112B4, 0
11376  F089     NOP
226:           }
11378  0012     RETURN 0
227:           
228:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
229:           {
230:           
231:           }
232:           
233:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
234:           {
235:           
236:           }
237:           
238:           void eaDogM_ClearRow(const uint8_t r)
239:           {
240:           
241:           }
242:           
243:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
244:           {
245:           
246:           }
247:           
248:           #else
249:           
250:           /*
251:            * add short spi delay (default)
252:            */
253:           static void send_lcd_data(const uint8_t data)
254:           {
255:           	RS_SetHigh();
256:           	CSB_SetLow();
257:           	SPI1_Exchange8bit(data);
258:           	wdtdelay(8);
259:           }
260:           
261:           /*
262:            * add inst spi delay
263:            */
264:           static void send_lcd_cmd(const uint8_t cmd)
265:           {
266:           	RS_SetLow();
267:           	CSB_SetLow();
268:           	SPI1_Exchange8bit(cmd);
269:           	wdtdelay(30);
270:           	RS_SetHigh();
271:           }
272:           
273:           /*
274:            * add clear/home spi delay
275:            */
276:           static void send_lcd_cmd_long(const uint8_t cmd)
277:           {
278:           	RS_SetLow();
279:           	CSB_SetLow();
280:           	SPI1_Exchange8bit(cmd);
281:           	wdtdelay(800);
282:           	RS_SetHigh();
283:           }
284:           
285:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
286:           {
287:           	uint8_t cmdPos;
288:           	cmdPos = (uint8_t) EADOGM_CMD_DDRAM_ADDR + (uint8_t) ((uint8_t) r * (uint8_t) EADOGM_COLSPAN) + (uint8_t) c;
289:           	eaDogM_WriteCommand(cmdPos);
290:           }
291:           
292:           void eaDogM_ClearRow(const uint8_t r)
293:           {
294:           	uint8_t i;
295:           	eaDogM_SetPos(r, 0);
296:           	for (i = 0; i < EADOGM_COLSPAN; i++) {
297:           		eaDogM_WriteChr(' ');
298:           	}
299:           }
300:           
301:           /*
302:            * uses DMA channel 1 for transfers
303:            */
304:           void eaDogM_WriteString(char *strPtr)
305:           {
306:           	wait_lcd_set();
307:           	/* reset buffer for DMA */
308:           	ringBufS_flush(spi_link.tx1a, false);
309:           	CSB_SetLow(); /* SPI select display */
310:           	if (strlen(strPtr) > max_strlen) strPtr[max_strlen] = 0; // buffer overflow check
311:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
312:           	DMA1SSZ = strlen(strPtr);
313:           	DMA1CON0bits.EN = 1; /* enable DMA */
314:           	printf("%s", strPtr); // testing copy method using STDIO redirect to buffer
315:           	start_lcd();
316:           #ifdef DISPLAY_SLOW
317:           	wdtdelay(9000);
318:           #endif
319:           }
320:           
321:           /*
322:            * uses DMA channel 1 for transfers
323:            */
324:           void send_lcd_cmd_dma(uint8_t strPtr)
325:           {
326:           	wait_lcd_set();
327:           	/* reset buffer for DMA */
328:           	ringBufS_flush(spi_link.tx1a, false);
329:           	RS_SetLow();
330:           	CSB_SetLow(); /* SPI select display */
331:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
332:           	DMA1SSZ = 1;
333:           	DMA1CON0bits.EN = 1; /* enable DMA */
334:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
335:           	start_lcd();
336:           	wait_lcd_done();
337:           	RS_SetHigh();
338:           }
339:           
340:           /*
341:            * uses DMA channel 1 for transfers
342:            */
343:           void send_lcd_data_dma(uint8_t strPtr)
344:           {
345:           	wait_lcd_set();
346:           	/* reset buffer for DMA */
347:           	ringBufS_flush(spi_link.tx1a, false);
348:           	RS_SetHigh();
349:           	CSB_SetLow(); /* SPI select display */
350:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
351:           	DMA1SSZ = 1;
352:           	DMA1CON0bits.EN = 1; /* enable DMA */
353:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
354:           	start_lcd();
355:           }
356:           
357:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
358:           {
359:           	send_lcd_cmd_dma((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
360:           	eaDogM_WriteString(strPtr);
361:           }
362:           
363:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
364:           {
365:           	eaDogM_WriteCommand((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
366:           
367:           	eaDogM_WriteChr(i / 10 + '0');
368:           	eaDogM_WriteChr(i % 10 + '0');
369:           
370:           }
371:           
372:           // this writes a byte to the internal CGRAM (v2.02)
373:           // format for ndx: 00CCCRRR = CCC = character 0 to 7, RRR = row 0 to 7
374:           
375:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
376:           {
377:           	uint8_t cmd;
378:           
379:           	cmd = ndx & 0b00111111; // mask off upper to bits
380:           	cmd = cmd | EADOGM_CMD_CGRAM_ADDR; // set bit cmd bits
381:           
382:           	eaDogM_WriteCommand(cmd);
383:           	eaDogM_WriteChr(data);
384:           
385:           	// this is done to make sure we are back in data mode
386:           	eaDogM_SetPos(0, 0);
387:           }
388:           #endif
389:           
390:           void eaDogM_WriteCommand(const uint8_t cmd)
391:           {
392:           	send_lcd_cmd(cmd);
393:           }
394:           
395:           void eaDogM_WriteChr(const int8_t value)
396:           {
397:           	send_lcd_data((uint8_t) value);
398:           }
399:           
400:           /*
401:            * uses DMA channel 2 for transfers
402:            */
403:           void send_port_data_dma(uint16_t dsize)
404:           {
405:           	if (dsize > max_port_data)
406:           		dsize = max_port_data;
407:           }
408:           
409:           /*
410:            * return pointer to internal data buffer for DMA
411:            */
412:           uint8_t* port_data_dma_ptr(void)
413:           {
414:           	return port_data;
415:           }
416:           
417:           /*
418:            * Trigger the SPI DMA transfer to the LCD display
419:            */
420:           void start_lcd(void)
421:           {
422:           #ifdef USE_DMA
423:           	DMA2_StartTransferWithTrigger();
424:           	DMA1_StartTransfer();
425:           #endif
426:           }
11CA2  0012     RETURN 0
427:           
428:           void wait_lcd_set(void)
429:           {
430:           	spi_link.LCD_DATA = true;
11C78  0105     MOVLB 0x5
11C7A  87AE     BSF OSCCON2, 3, BANKED
431:           }
11C7C  0012     RETURN 0
432:           
433:           bool wait_lcd_check(void)
434:           {
435:           	return spi_link.LCD_DATA;
436:           }
437:           
438:           void wait_lcd_done(void)
439:           {
440:           #ifdef USE_DMA
441:           	while (spi_link.LCD_DATA) {
442:           	};
443:           #endif
444:           	while (!SPI1STATUSbits.TXBE) {
11C5E  0100     MOVLB 0x0
11C60  BB87     BTFSC SPI1STATUS, 5, BANKED
11C62  0012     RETURN 0
11C64  D7FC     BRA 0x1C5E
445:           	};
446:           }
447:           
448:           void clear_lcd_done(void)
449:           {
450:           	spi_link.LCD_DATA = false;
451:           }
452:           
453:           
454:           void spi_rec_done(void)
455:           {
456:           }
