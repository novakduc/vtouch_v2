Disassembly Listing for q43_ntsc
Generated From:
/root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/dist/default/production/q43_ntsc.X.production.elf
Jan 6, 2021 11:55:44 AM

---  /tmp/xcXeafgjl.s  ----------------------------------------------------------------------------------
329A  0E32     MOVLW 0x32
329C  6EF6     MOVWF 0xFF6, ACCESS
329E  0E26     MOVLW 0x26
32A0  6EF7     MOVWF 0xFF7, ACCESS
32A2  0E00     MOVLW 0x0
32A4  6EF8     MOVWF 0xFF8, ACCESS
32A6  EE03     LFSR 0, 0xE00
32AA  EE11     LFSR 1, 0x400
32AE  0009     TBLRD*+
32B0  C4F5     MOVFF TABLAT, POSTINC0
32B4  50E5     MOVF 0xFE5, W, ACCESS
32B6  50E1     MOVF 0xFE1, W, ACCESS
32B8  E1FA     BNZ 0x32AE
32BA  50E2     MOVF 0xFE2, W, ACCESS
32BC  E1F8     BNZ 0x32AE
32BE  0E22     MOVLW 0x22
32C0  6EF6     MOVWF 0xFF6, ACCESS
32C2  0E40     MOVLW 0x40
32C4  6EF7     MOVWF 0xFF7, ACCESS
32C6  0E00     MOVLW 0x0
32C8  6EF8     MOVWF 0xFF8, ACCESS
32CA  EE01     LFSR 0, 0x5F1
32CE  EE10     LFSR 1, 0x7
32D2  0009     TBLRD*+
32D4  C4F5     MOVFF TABLAT, POSTINC0
32D8  50E5     MOVF 0xFE5, W, ACCESS
32DA  50E1     MOVF 0xFE1, W, ACCESS
32DC  E1FA     BNZ 0x32D2
32DE  0E60     MOVLW 0x60
32E0  6EF6     MOVWF 0xFF6, ACCESS
32E2  0E40     MOVLW 0x40
32E4  6EF7     MOVWF 0xFF7, ACCESS
32E6  0E00     MOVLW 0x0
32E8  6EF8     MOVWF 0xFF8, ACCESS
32EA  EE01     LFSR 0, 0x54D
32EE  EE10     LFSR 1, 0x4
32F2  0009     TBLRD*+
32F4  C4F5     MOVFF TABLAT, POSTINC0
32F8  50E5     MOVF 0xFE5, W, ACCESS
32FA  50E1     MOVF 0xFE1, W, ACCESS
32FC  E1FA     BNZ 0x32F2
32FE  EE02     LFSR 0, 0x800
3302  EE11     LFSR 1, 0x600
3306  6AEE     CLRF 0xFEE, ACCESS
3308  50E5     MOVF 0xFE5, W, ACCESS
330A  50E1     MOVF 0xFE1, W, ACCESS
330C  E1FC     BNZ 0x3306
330E  50E2     MOVF 0xFE2, W, ACCESS
3310  E1FA     BNZ 0x3306
3312  EE01     LFSR 0, 0x700
3316  EE10     LFSR 1, 0x100
331A  6AEE     CLRF 0xFEE, ACCESS
331C  50E5     MOVF 0xFE5, W, ACCESS
331E  50E1     MOVF 0xFE1, W, ACCESS
3320  E1FC     BNZ 0x331A
3322  50E2     MOVF 0xFE2, W, ACCESS
3324  E1FA     BNZ 0x331A
3326  EE01     LFSR 0, 0x600
332A  0EE3     MOVLW 0xE3
332C  6AEE     CLRF 0xFEE, ACCESS
332E  06E8     DECF 0xFE8, F, ACCESS
3330  E1FD     BNZ 0x332C
3332  EE01     LFSR 0, 0x560
3336  0E91     MOVLW 0x91
3338  6AEE     CLRF 0xFEE, ACCESS
333A  06E8     DECF 0xFE8, F, ACCESS
333C  E1FD     BNZ 0x3338
333E  EE01     LFSR 0, 0x53D
3342  0E10     MOVLW 0x10
3344  6AEE     CLRF 0xFEE, ACCESS
3346  06E8     DECF 0xFE8, F, ACCESS
3348  E1FD     BNZ 0x3344
334A  0104     MOVLB 0x4
334C  0E08     MOVLW 0x8
334E  6F5D     MOVWF 0x5D, BANKED
3350  0E00     MOVLW 0x0
3352  6F5E     MOVWF 0x5E, BANKED
3354  0E00     MOVLW 0x0
3356  6F5F     MOVWF 0x5F, BANKED
3358  0100     MOVLB 0x0
335A  EFD6     GOTO 0x31AC
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/timers.c  --------------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "timers.h"
5:             
6:             extern volatile uint16_t tickCount[TMR_COUNT];
7:             
8:             //**********************************************************************************************************************
9:             // Start one of the software timers
10:            
11:            void StartTimer(const uint8_t timer, const uint16_t count)
3D6E  6E11     MOVWF 0x11, ACCESS
12:            {
13:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
3D70  C50D     MOVFF d1, s1
3D72  F50F     NOP
3D74  C50E     MOVFF 0x50E, 0x510
3D76  F510     NOP
3D78  90D8     BCF 0xFD8, 0, ACCESS
3D7A  360F     RLCF 0xF, F, ACCESS
3D7C  3610     RLCF 0x10, F, ACCESS
3D7E  5011     MOVF 0x11, W, ACCESS
3D80  0D02     MULLW 0x2
3D82  0EA0     MOVLW 0xA0
3D84  24F3     ADDWF 0xFF3, W, ACCESS
3D86  6ED9     MOVWF 0xFD9, ACCESS
3D88  0E05     MOVLW 0x5
3D8A  20F4     ADDWFC 0xFF4, W, ACCESS
3D8C  6EDA     MOVWF 0xFDA, ACCESS
3D90  F43C     NOP
3D92  F4DE     NOP
3D96  F440     NOP
3D98  F4DD     NOP
14:            }
3D9A  0012     RETURN 0
15:            
16:            //**********************************************************************************************************************
17:            // Check if one of the software software timers has timed out
18:            
19:            bool TimerDone(const uint8_t timer)
20:            {
21:            	bool td = false;
22:            
23:            	ClrWdt(); // reset the WDT timer
24:            	if (tickCount[timer] == (uint16_t) 0) { //Check if counted down to zero
25:            		td = true; //then return true
26:            	}
27:            	return td;
28:            }
29:            
30:            //**********************************************************************************************************************
31:            // Simple delay for n milliseconds (blocking)
32:            
33:            void WaitMs(const uint16_t numMilliseconds)
34:            {
35:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
36:            	while (!TimerDone(TMR_INTERNAL)) {
37:            		Nop();
38:            		Nop();
39:            		Nop();
40:            		Nop();
41:            		ClrWdt(); // reset the WDT timer
42:            		//		Idle();
43:            	} //Enter idle mode to reduce power while waiting
44:            } //(timer interrupt will wake part from idle)
45:            
46:            
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/ringbufs.c  ------------------------------------
1:             #include  <string.h>
2:             #include  "ringbufs.h"
3:             
4:             /*
5:              * general ring buffer fuctions from the internet
6:              */
7:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
8:             {
9:             	uint8_t my_value = value + 1;
10:            	if (my_value >= modulus) {
11:            		my_value = 0;
12:            	}
13:            	return my_value;
14:            }
15:            
16:            uint8_t modulo_dec(const uint8_t value, const uint8_t modulus)
17:            {
18:            	uint8_t my_value = (0 == value) ? (modulus - 1) : (value - 1);
19:            	return my_value;
20:            }
21:            
22:            void ringBufS_init(volatile ringBufS_t *_this)
23:            {
24:            	/*****
25:            	  The following clears:
26:            	    -> buf
27:            	    -> head
28:            	    -> tail
29:            	    -> count
30:            	  and sets head = tail
31:            	 ***/
32:            	memset((void*) _this, 0, sizeof(*_this));
3F04  C519     MOVFF _this, d1
3F06  F50D     NOP
3F08  C51A     MOVFF ptr, 0x50E
3F0A  F50E     NOP
3F0C  0E00     MOVLW 0x0
3F0E  6E10     MOVWF 0x10, ACCESS
3F10  0E00     MOVLW 0x0
3F12  6E0F     MOVWF 0xF, ACCESS
3F14  0E00     MOVLW 0x0
3F16  6E12     MOVWF 0x12, ACCESS
3F18  0E43     MOVLW 0x43
3F1A  6E11     MOVWF 0x11, ACCESS
3F1C  EC8C     CALL 0x2F18, 0
3F1E  F017     NOP
33:            }
3F20  0012     RETURN 0
34:            
35:            int8_t ringBufS_empty(ringBufS_t *_this)
36:            {
37:            	return(0 == _this->count);
38:            }
39:            
40:            int8_t ringBufS_full(ringBufS_t *_this)
41:            {
42:            	return(_this->count >= RBUF_SIZE);
43:            }
44:            
45:            uint8_t ringBufS_get(ringBufS_t *_this)
46:            {
47:            	uint8_t c;
48:            	if (_this->count > 0) {
49:            		c = _this->buf[_this->tail];
50:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
51:            		--_this->count;
52:            	} else {
53:            		c = 0; // return null with empty buffer
54:            	}
55:            	return(c);
56:            }
57:            
58:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
59:            {
60:            	if (_this->count < RBUF_SIZE) {
61:            		_this->buf[_this->head] = c;
62:            		_this->head = modulo_inc(_this->head, RBUF_SIZE);
63:            		++_this->count;
64:            	}
65:            }
66:            
67:            void ringBufS_put_dma(ringBufS_t *_this, const uint8_t c)
68:            {
69:            	if (_this->count < RBUF_SIZE) {
70:            		_this->buf[_this->head] = c;
71:            		++_this->head;
72:            		++_this->count;
73:            	}
74:            }
75:            
76:            void ringBufS_put_dma_cpy(ringBufS_t *_this, const char *ptr, const uint8_t len)
77:            {
78:            	if (_this->count < RBUF_SIZE) {
38CA  EE20     LFSR 2, 0x42
38CC  F042     NOP
38CE  5018     MOVF 0x18, W, ACCESS
38D0  26D9     ADDWF 0xFD9, F, ACCESS
38D2  5019     MOVF 0x19, W, ACCESS
38D4  22DA     ADDWFC 0xFDA, F, ACCESS
38D6  0E40     MOVLW 0x40
38D8  60DF     CPFSLT 0xFDF, ACCESS
38DA  0012     RETURN 0
79:            		memcpy(_this->buf, ptr, len);
38DC  C518     MOVFF _this, d1
38DE  F50D     NOP
38E0  C519     MOVFF _this, 0x50E
38E2  F50E     NOP
38E4  C51A     MOVFF ptr, s1
38E6  F50F     NOP
38E8  C51B     MOVFF clearBuffer, 0x510
38EA  F510     NOP
38EC  C51C     MOVFF len, n
38EE  F511     NOP
38F0  6A12     CLRF 0x12, ACCESS
38F2  EC8E     CALL 0x391C, 0
38F4  F01C     NOP
80:            		_this->head = len;
38F6  EE20     LFSR 2, 0x40
38F8  F040     NOP
38FA  5018     MOVF 0x18, W, ACCESS
38FC  26D9     ADDWF 0xFD9, F, ACCESS
38FE  5019     MOVF 0x19, W, ACCESS
3900  22DA     ADDWFC 0xFDA, F, ACCESS
3904  F470     NOP
3906  F4DF     NOP
81:            		_this->count = len;
3908  EE20     LFSR 2, 0x42
390A  F042     NOP
390C  5018     MOVF 0x18, W, ACCESS
390E  26D9     ADDWF 0xFD9, F, ACCESS
3910  5019     MOVF 0x19, W, ACCESS
3912  22DA     ADDWFC 0xFDA, F, ACCESS
3916  F470     NOP
3918  F4DF     NOP
82:            	}
83:            }
391A  0012     RETURN 0
84:            
85:            void ringBufS_flush(ringBufS_t *_this, const bool clearBuffer)
86:            {
87:            	_this->count = 0;
3876  EE20     LFSR 2, 0x42
3878  F042     NOP
387A  5019     MOVF 0x19, W, ACCESS
387C  26D9     ADDWF 0xFD9, F, ACCESS
387E  501A     MOVF 0x1A, W, ACCESS
3880  22DA     ADDWFC 0xFDA, F, ACCESS
3882  0E00     MOVLW 0x0
3884  6EDF     MOVWF 0xFDF, ACCESS
88:            	_this->head = 0;
3886  EE20     LFSR 2, 0x40
3888  F040     NOP
388A  5019     MOVF 0x19, W, ACCESS
388C  26D9     ADDWF 0xFD9, F, ACCESS
388E  501A     MOVF 0x1A, W, ACCESS
3890  22DA     ADDWFC 0xFDA, F, ACCESS
3892  0E00     MOVLW 0x0
3894  6EDF     MOVWF 0xFDF, ACCESS
89:            	_this->tail = 0;
3896  EE20     LFSR 2, 0x41
3898  F041     NOP
389A  5019     MOVF 0x19, W, ACCESS
389C  26D9     ADDWF 0xFD9, F, ACCESS
389E  501A     MOVF 0x1A, W, ACCESS
38A0  22DA     ADDWFC 0xFDA, F, ACCESS
38A2  0E00     MOVLW 0x0
38A4  6EDF     MOVWF 0xFDF, ACCESS
90:            	if (clearBuffer) {
38A6  501B     MOVF 0x1B, W, ACCESS
38A8  B4D8     BTFSC 0xFD8, 2, ACCESS
38AA  0012     RETURN 0
91:            		memset(_this->buf, 0, sizeof(_this->buf));
38AC  C519     MOVFF _this, d1
38AE  F50D     NOP
38B0  C51A     MOVFF ptr, 0x50E
38B2  F50E     NOP
38B4  0E00     MOVLW 0x0
38B6  6E10     MOVWF 0x10, ACCESS
38B8  0E00     MOVLW 0x0
38BA  6E0F     MOVWF 0xF, ACCESS
38BC  0E00     MOVLW 0x0
38BE  6E12     MOVWF 0x12, ACCESS
38C0  0E40     MOVLW 0x40
38C2  6E11     MOVWF 0x11, ACCESS
38C4  EC8C     CALL 0x2F18, 0
38C6  F017     NOP
92:            	}
93:            }
38C8  0012     RETURN 0
94:            
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/ntsc.c  ----------------------------------------
1:             #include "ntsc.h"
2:             
3:             volatile uint32_t vcounts = 0;
4:             volatile uint8_t vfcounts = 0, scan_line = 0;
5:             volatile bool ntsc_vid = true, ntsc_flip = false, task_hold = true;
6:             
7:             volatile enum s_mode_t s_mode;
8:             volatile uint8_t vbuffer[V_BUF_SIZ], *vbuf_ptr;
9:             
10:            void vcntd(void);
11:            void vcnts(void);
12:            
13:            /*
14:             * setup the data formats and hardware for the DMA engine
15:             */
16:            void ntsc_init(void)
17:            {
18:            	uint16_t count = 0;
19:            
20:            	/*
21:            	 * Interrupt driven task manager
22:            	 * after the H sync pulse there are V syncs with no video
23:            	 * main-line code runs for the duration of one timer 4 interrupt period
24:            	 * ~200us for testing, then goes back to idle
25:            	 * until re-triggered the next H sync cycle
26:            	 */
27:            	TMR4_Stop();
2A32  EC15     CALL 0x402A, 0
2A34  F020     NOP
28:            	TMR4_SetInterruptHandler(vcntd);
2A36  0ED6     MOVLW 0xD6
2A38  6E0D     MOVWF 0xD, ACCESS
2A3A  0E3A     MOVLW 0x3A
2A3C  6E0E     MOVWF 0xE, ACCESS
2A3E  0E00     MOVLW 0x0
2A40  6E0F     MOVWF 0xF, ACCESS
2A42  ECE9     CALL 0x3FD2, 0
2A44  F01F     NOP
29:            
30:            	/*
31:            	 * DMA hardware registers data setup
32:            	 */
33:            	DMA5_StopTransfer();
2A46  ECF7     CALL 0x3FEE, 0
2A48  F01F     NOP
34:            	vbuf_ptr = vsync;
2A4A  0E00     MOVLW 0x0
2A4C  6E3D     MOVWF 0x3D, ACCESS
2A4E  0E0C     MOVLW 0xC
2A50  6E3E     MOVWF 0x3E, ACCESS
35:            	SLRCONB = 0xff; // reduce PORTB slewrate
2A52  0104     MOVLB 0x4
2A54  690B     SETF 0xB, BANKED
36:            	DMA5_SetDMAPriority(0);
2A56  0E00     MOVLW 0x0
2A58  EC42     CALL 0x3E84, 0
2A5A  F01F     NOP
37:            	DMA5_SetDCNTIInterruptHandler(vcnts);
2A5C  0EC4     MOVLW 0xC4
2A5E  6E0D     MOVWF 0xD, ACCESS
2A60  0E2D     MOVLW 0x2D
2A62  6E0E     MOVWF 0xE, ACCESS
2A64  0E00     MOVLW 0x0
2A66  6E0F     MOVWF 0xF, ACCESS
2A68  ECF0     CALL 0x3FE0, 0
2A6A  F01F     NOP
38:            	DMASELECT = DMA_M;
2A6C  0E04     MOVLW 0x4
2A6E  6FE8     MOVWF DMASELECT, BANKED
39:            	DMAnCON0bits.EN = 0;
2A70  9FFC     BCF DMAnCON0, 7, BANKED
40:            	DMAnSSA = (volatile uint24_t) vbuf_ptr;
2A74  F4F4     NOP
2A76  F0F9     NOP
2A7A  F4F8     NOP
2A7C  F0FA     NOP
2A7E  6BFB     CLRF DMAnSSAU, BANKED
41:            	DMAnSSZ = DMA_B;
2A80  0E01     MOVLW 0x1
2A82  6FF8     MOVWF DMAnSSZH, BANKED
2A84  0ED9     MOVLW 0xD9
2A86  6FF7     MOVWF DMAnSSZ, BANKED
42:            	DMAnDSZ = DMAnSSZ;
2A88  C0F7     MOVFF DMAnSSZ, DMAnDSZ
2A8A  F0EE     NOP
2A8C  C0F8     MOVFF DMAnSSZH, DMAnDSZH
2A8E  F0EF     NOP
43:            	DMAnCON0bits.EN = 1;
2A90  8FFC     BSF DMAnCON0, 7, BANKED
44:            
45:            	/*
46:            	 * setup the static V, H and video patterns for DMA transfer engine to PORTB
47:            	 */
48:            	for (count = 0; count < B_START; count++) {
2A92  0E00     MOVLW 0x0
2A94  6E12     MOVWF 0x12, ACCESS
2A96  0E00     MOVLW 0x0
2A98  6E11     MOVWF 0x11, ACCESS
49:            		vsync[count] = SYNC_LEVEL;
2A9A  0E00     MOVLW 0x0
2A9C  2411     ADDWF 0x11, W, ACCESS
2A9E  6ED9     MOVWF 0xFD9, ACCESS
2AA0  0E0C     MOVLW 0xC
2AA2  2012     ADDWFC 0x12, W, ACCESS
2AA4  6EDA     MOVWF 0xFDA, ACCESS
2AA6  0E00     MOVLW 0x0
2AA8  6EDF     MOVWF 0xFDF, ACCESS
50:            		vbuffer[count] = SYNC_LEVEL;
2AAA  0E00     MOVLW 0x0
2AAC  2411     ADDWF 0x11, W, ACCESS
2AAE  6ED9     MOVWF 0xFD9, ACCESS
2AB0  0E08     MOVLW 0x8
2AB2  2012     ADDWFC 0x12, W, ACCESS
2AB4  6EDA     MOVWF 0xFDA, ACCESS
2AB6  0E00     MOVLW 0x0
2AB8  6EDF     MOVWF 0xFDF, ACCESS
51:            		hsync[count] = SYNC_LEVEL;
2ABA  0E00     MOVLW 0x0
2ABC  2411     ADDWF 0x11, W, ACCESS
2ABE  6ED9     MOVWF 0xFD9, ACCESS
2AC0  0E0A     MOVLW 0xA
2AC2  2012     ADDWFC 0x12, W, ACCESS
2AC4  6EDA     MOVWF 0xFDA, ACCESS
2AC6  0E00     MOVLW 0x0
2AC8  6EDF     MOVWF 0xFDF, ACCESS
52:            	}
2ACA  4A11     INFSNZ 0x11, F, ACCESS
2ACC  2A12     INCF 0x12, F, ACCESS
2ACE  5012     MOVF 0x12, W, ACCESS
2AD0  E104     BNZ 0x2ADA
2AD2  0E30     MOVLW 0x30
2AD4  5C11     SUBWF 0x11, W, ACCESS
2AD6  A0D8     BTFSS 0xFD8, 0, ACCESS
2AD8  D7E0     BRA 0x2A9A
53:            
54:            	for (count = S_END; count < B_START; count++) {
2ADA  0E00     MOVLW 0x0
2ADC  6E12     MOVWF 0x12, ACCESS
2ADE  0E25     MOVLW 0x25
2AE0  6E11     MOVWF 0x11, ACCESS
55:            		vsync[count] = BLANK_LEVEL;
2AE2  0E00     MOVLW 0x0
2AE4  2411     ADDWF 0x11, W, ACCESS
2AE6  6ED9     MOVWF 0xFD9, ACCESS
2AE8  0E0C     MOVLW 0xC
2AEA  2012     ADDWFC 0x12, W, ACCESS
2AEC  6EDA     MOVWF 0xFDA, ACCESS
2AEE  0E01     MOVLW 0x1
2AF0  6EDF     MOVWF 0xFDF, ACCESS
56:            		vbuffer[count] = BLANK_LEVEL;
2AF2  0E00     MOVLW 0x0
2AF4  2411     ADDWF 0x11, W, ACCESS
2AF6  6ED9     MOVWF 0xFD9, ACCESS
2AF8  0E08     MOVLW 0x8
2AFA  2012     ADDWFC 0x12, W, ACCESS
2AFC  6EDA     MOVWF 0xFDA, ACCESS
2AFE  0E01     MOVLW 0x1
2B00  6EDF     MOVWF 0xFDF, ACCESS
57:            		hsync[count] = SYNC_LEVEL;
2B02  0E00     MOVLW 0x0
2B04  2411     ADDWF 0x11, W, ACCESS
2B06  6ED9     MOVWF 0xFD9, ACCESS
2B08  0E0A     MOVLW 0xA
2B0A  2012     ADDWFC 0x12, W, ACCESS
2B0C  6EDA     MOVWF 0xFDA, ACCESS
2B0E  0E00     MOVLW 0x0
2B10  6EDF     MOVWF 0xFDF, ACCESS
58:            	}
2B12  4A11     INFSNZ 0x11, F, ACCESS
2B14  2A12     INCF 0x12, F, ACCESS
2B16  5012     MOVF 0x12, W, ACCESS
2B18  E104     BNZ 0x2B22
2B1A  0E30     MOVLW 0x30
2B1C  5C11     SUBWF 0x11, W, ACCESS
2B1E  A0D8     BTFSS 0xFD8, 0, ACCESS
2B20  D7E0     BRA 0x2AE2
59:            
60:            	for (count = V_START; count < V_END; count++) {
2B22  0E00     MOVLW 0x0
2B24  6E12     MOVWF 0x12, ACCESS
2B26  0E30     MOVLW 0x30
2B28  6E11     MOVWF 0x11, ACCESS
61:            		vsync[count] = BLANK_LEVEL;
2B2A  0E00     MOVLW 0x0
2B2C  2411     ADDWF 0x11, W, ACCESS
2B2E  6ED9     MOVWF 0xFD9, ACCESS
2B30  0E0C     MOVLW 0xC
2B32  2012     ADDWFC 0x12, W, ACCESS
2B34  6EDA     MOVWF 0xFDA, ACCESS
2B36  0E01     MOVLW 0x1
2B38  6EDF     MOVWF 0xFDF, ACCESS
62:            		vbuffer[count] = BLANK_LEVEL;
2B3A  0E00     MOVLW 0x0
2B3C  2411     ADDWF 0x11, W, ACCESS
2B3E  6ED9     MOVWF 0xFD9, ACCESS
2B40  0E08     MOVLW 0x8
2B42  2012     ADDWFC 0x12, W, ACCESS
2B44  6EDA     MOVWF 0xFDA, ACCESS
2B46  0E01     MOVLW 0x1
2B48  6EDF     MOVWF 0xFDF, ACCESS
63:            		hsync[count] = SYNC_LEVEL;
2B4A  0E00     MOVLW 0x0
2B4C  2411     ADDWF 0x11, W, ACCESS
2B4E  6ED9     MOVWF 0xFD9, ACCESS
2B50  0E0A     MOVLW 0xA
2B52  2012     ADDWFC 0x12, W, ACCESS
2B54  6EDA     MOVWF 0xFDA, ACCESS
2B56  0E00     MOVLW 0x0
2B58  6EDF     MOVWF 0xFDF, ACCESS
64:            		if ((count % 8)) { // add a bit of default texture
2B5A  C511     MOVFF n, 0x510
2B5C  F510     NOP
2B5E  0E07     MOVLW 0x7
2B60  1610     ANDWF 0x10, F, ACCESS
2B62  B4D8     BTFSC 0xFD8, 2, ACCESS
2B64  D00B     BRA 0x2B7C
65:            			if (count > V_DOTS)
2B66  5012     MOVF 0x12, W, ACCESS
2B68  E104     BNZ 0x2B72
2B6A  0EA1     MOVLW 0xA1
2B6C  5C11     SUBWF 0x11, W, ACCESS
2B6E  A0D8     BTFSS 0xFD8, 0, ACCESS
2B70  D019     BRA 0x2BA4
66:            				vsync[count] += VIDEO_LEVEL; // set bit 1 of PORTB
2B72  0E00     MOVLW 0x0
2B74  2411     ADDWF 0x11, W, ACCESS
2B76  6ED9     MOVWF 0xFD9, ACCESS
2B78  0E0C     MOVLW 0xC
2B7A  D010     BRA 0x2B9C
67:            		} else {
68:            			if (!(count % 8)) { // add a bit of default texture
2B7C  C511     MOVFF n, 0x510
2B7E  F510     NOP
2B80  0E07     MOVLW 0x7
2B82  1610     ANDWF 0x10, F, ACCESS
2B84  A4D8     BTFSS 0xFD8, 2, ACCESS
2B86  D00E     BRA 0x2BA4
69:            				if (count > V_DOTS)
2B88  5012     MOVF 0x12, W, ACCESS
2B8A  E104     BNZ 0x2B94
2B8C  0EA1     MOVLW 0xA1
2B8E  5C11     SUBWF 0x11, W, ACCESS
2B90  A0D8     BTFSS 0xFD8, 0, ACCESS
2B92  D008     BRA 0x2BA4
70:            					vbuffer[count] += VIDEO_LEVEL; // set bit 1 of PORTB
2B94  0E00     MOVLW 0x0
2B96  2411     ADDWF 0x11, W, ACCESS
2B98  6ED9     MOVWF 0xFD9, ACCESS
2B9A  0E08     MOVLW 0x8
2B9C  2012     ADDWFC 0x12, W, ACCESS
2B9E  6EDA     MOVWF 0xFDA, ACCESS
2BA0  0E02     MOVLW 0x2
2BA2  26DF     ADDWF 0xFDF, F, ACCESS
71:            			}
72:            		}
73:            	}
2BA4  4A11     INFSNZ 0x11, F, ACCESS
2BA6  2A12     INCF 0x12, F, ACCESS
2BA8  0E90     MOVLW 0x90
2BAA  5C11     SUBWF 0x11, W, ACCESS
2BAC  0E01     MOVLW 0x1
2BAE  5812     SUBWFB 0x12, W, ACCESS
2BB0  A0D8     BTFSS 0xFD8, 0, ACCESS
2BB2  D7BB     BRA 0x2B2A
74:            	for (count = V_END; count < (V_BUF_SIZ - 1); count++) {
2BB4  0E01     MOVLW 0x1
2BB6  6E12     MOVWF 0x12, ACCESS
2BB8  0E90     MOVLW 0x90
2BBA  6E11     MOVWF 0x11, ACCESS
75:            		vsync[count] = BLANK_LEVEL;
2BBC  0E00     MOVLW 0x0
2BBE  2411     ADDWF 0x11, W, ACCESS
2BC0  6ED9     MOVWF 0xFD9, ACCESS
2BC2  0E0C     MOVLW 0xC
2BC4  2012     ADDWFC 0x12, W, ACCESS
2BC6  6EDA     MOVWF 0xFDA, ACCESS
2BC8  0E01     MOVLW 0x1
2BCA  6EDF     MOVWF 0xFDF, ACCESS
76:            		vbuffer[count] = BLANK_LEVEL;
2BCC  0E00     MOVLW 0x0
2BCE  2411     ADDWF 0x11, W, ACCESS
2BD0  6ED9     MOVWF 0xFD9, ACCESS
2BD2  0E08     MOVLW 0x8
2BD4  2012     ADDWFC 0x12, W, ACCESS
2BD6  6EDA     MOVWF 0xFDA, ACCESS
2BD8  0E01     MOVLW 0x1
2BDA  6EDF     MOVWF 0xFDF, ACCESS
77:            		hsync[count] = SYNC_LEVEL;
2BDC  0E00     MOVLW 0x0
2BDE  2411     ADDWF 0x11, W, ACCESS
2BE0  6ED9     MOVWF 0xFD9, ACCESS
2BE2  0E0A     MOVLW 0xA
2BE4  2012     ADDWFC 0x12, W, ACCESS
2BE6  6EDA     MOVWF 0xFDA, ACCESS
2BE8  0E00     MOVLW 0x0
2BEA  6EDF     MOVWF 0xFDF, ACCESS
78:            	}
2BEC  4A11     INFSNZ 0x11, F, ACCESS
2BEE  2A12     INCF 0x12, F, ACCESS
2BF0  2811     INCF 0x11, W, ACCESS
2BF2  0E01     MOVLW 0x1
2BF4  5812     SUBWFB 0x12, W, ACCESS
2BF6  A0D8     BTFSS 0xFD8, 0, ACCESS
2BF8  D7E1     BRA 0x2BBC
79:            
80:            	for (count = (DMA_B - 5); count < (V_BUF_SIZ - 1); count++) {
2BFA  0E01     MOVLW 0x1
2BFC  6E12     MOVWF 0x12, ACCESS
2BFE  0ED4     MOVLW 0xD4
2C00  6E11     MOVWF 0x11, ACCESS
81:            		hsync[count] = BLANK_LEVEL;
2C02  0E00     MOVLW 0x0
2C04  2411     ADDWF 0x11, W, ACCESS
2C06  6ED9     MOVWF 0xFD9, ACCESS
2C08  0E0A     MOVLW 0xA
2C0A  2012     ADDWFC 0x12, W, ACCESS
2C0C  6EDA     MOVWF 0xFDA, ACCESS
2C0E  0E01     MOVLW 0x1
2C10  6EDF     MOVWF 0xFDF, ACCESS
82:            	}
2C12  4A11     INFSNZ 0x11, F, ACCESS
2C14  2A12     INCF 0x12, F, ACCESS
2C16  2811     INCF 0x11, W, ACCESS
2C18  0E01     MOVLW 0x1
2C1A  5812     SUBWFB 0x12, W, ACCESS
2C1C  A0D8     BTFSS 0xFD8, 0, ACCESS
2C1E  D7F1     BRA 0x2C02
83:            
84:            	for (count = V_H; count < (V_H + 10); count++) {
2C20  0E00     MOVLW 0x0
2C22  6E12     MOVWF 0x12, ACCESS
2C24  0EEC     MOVLW 0xEC
2C26  6E11     MOVWF 0x11, ACCESS
85:            		hsync[count] = BLANK_LEVEL; // double speed H pulses
2C28  0E00     MOVLW 0x0
2C2A  2411     ADDWF 0x11, W, ACCESS
2C2C  6ED9     MOVWF 0xFD9, ACCESS
2C2E  0E0A     MOVLW 0xA
2C30  2012     ADDWFC 0x12, W, ACCESS
2C32  6EDA     MOVWF 0xFDA, ACCESS
2C34  0E01     MOVLW 0x1
2C36  6EDF     MOVWF 0xFDF, ACCESS
86:            	}
2C38  4A11     INFSNZ 0x11, F, ACCESS
2C3A  2A12     INCF 0x12, F, ACCESS
2C3C  5012     MOVF 0x12, W, ACCESS
2C3E  E104     BNZ 0x2C48
2C40  0EF6     MOVLW 0xF6
2C42  5C11     SUBWF 0x11, W, ACCESS
2C44  A0D8     BTFSS 0xFD8, 0, ACCESS
2C46  D7F0     BRA 0x2C28
87:            
88:            	// default scan mode to all lines
89:            	s_mode = sync1;
2C48  0E01     MOVLW 0x1
2C4A  6E41     MOVWF NVMCON1, ACCESS
90:            
91:            	/*
92:            	 * kickstart the DMA engine
93:            	 */
94:            	DMA5_StartTransfer();
2C4C  EC03     CALL 0x4006, 0
2C4E  F020     NOP
95:            	TMR4_StartTimer();
2C50  EC18     CALL 0x4030, 0
2C52  F020     NOP
96:            }
2C54  0012     RETURN 0
97:            
98:            /*
99:             * low priority idle task for timer 4 ISR
100:            * waits checking task_hold until its false (set to false in DMA state machine)
101:            * this task is interruptible from all high pri interrupts and control returns after high pri processing
102:            * when it exits the hold loop, program flow returns to main for application processing
103:            * until another timer 4 interrupt returns program flow to here.
104:            */
105:           void vcntd(void) // each timer 4 interrupt
106:           {
107:           	IO_RB4_Toggle();
3AD6  A8BF     BTFSS 0xFBF, 4, ACCESS
3AD8  D002     BRA 0x3ADE
3ADA  0E01     MOVLW 0x1
3ADC  D001     BRA 0x3AE0
3ADE  0E00     MOVLW 0x0
3AE0  0AFF     XORLW 0xFF
3AE2  6E0B     MOVWF 0xB, ACCESS
3AE4  3A0B     SWAPF 0xB, F, ACCESS
3AE6  50BF     MOVF 0xFBF, W, ACCESS
3AE8  180B     XORWF 0xB, W, ACCESS
3AEA  0BEF     ANDLW 0xEF
3AEC  180B     XORWF 0xB, W, ACCESS
3AEE  6EBF     MOVWF 0xFBF, ACCESS
108:           	TMR4_Stop();
3AF0  EC27     CALL 0x404E, 0
3AF2  F020     NOP
109:           	task_hold = true;
3AF4  0E01     MOVLW 0x1
3AF6  6E50     MOVWF 0x50, ACCESS
110:           	while (task_hold) {
3AF8  5050     MOVF 0x50, W, ACCESS
3AFA  A4D8     BTFSS 0xFD8, 2, ACCESS
3AFC  D7FD     BRA 0x3AF8
111:           	};
112:           	IO_RB4_Toggle();
3AFE  A8BF     BTFSS 0xFBF, 4, ACCESS
3B00  D002     BRA 0x3B06
3B02  0E01     MOVLW 0x1
3B04  D001     BRA 0x3B08
3B06  0E00     MOVLW 0x0
3B08  0AFF     XORLW 0xFF
3B0A  6E0B     MOVWF 0xB, ACCESS
3B0C  3A0B     SWAPF 0xB, F, ACCESS
3B0E  50BF     MOVF 0xFBF, W, ACCESS
3B10  180B     XORWF 0xB, W, ACCESS
3B12  0BEF     ANDLW 0xEF
3B14  180B     XORWF 0xB, W, ACCESS
3B16  6EBF     MOVWF 0xFBF, ACCESS
113:           }
3B18  0012     RETURN 0
114:           
115:           /*
116:            * NTSC DMA state machine
117:            * ISR triggered by the completed DMA transfer of the data buffer to PORTB
118:            * Generates the required HV sync for fake-progressive NTSC scanning on most modern TV sets
119:            * http://people.ece.cornell.edu/land/courses/ece5760/video/gvworks/GV%27s%20works%20%20NTSC%20demystified%20-%20B&W%20Video%20and%20Sync%20-%20Part%201.htm
120:            */
121:           void vcnts(void) // each scan line interrupt, 262 total for scan lines and V sync
122:           {
123:           	vfcounts++;
2DC4  2A43     INCF NVMADR, F, ACCESS
124:           
125:           	switch (s_mode) {
2DC6  D090     BRA 0x2EE8
126:           	case sync0: // H sync and video, one line
127:           		if (vfcounts >= S_COUNT) { // 243
2DC8  0EF6     MOVLW 0xF6
2DCA  6443     CPFSGT NVMADR, ACCESS
2DCC  D00F     BRA 0x2DEC
2DCE  D016     BRA 0x2DFC
128:           			vfcounts = 0;
129:           			s_mode = sync2;
130:           			DMASELECT = DMA_M;
131:           			DMAnCON0bits.EN = 0;
2DD0  9FFC     BCF DMAnCON0, 7, BANKED
132:           			DMAnSSA = (volatile uint24_t) & hsync;
2DD2  0E00     MOVLW 0x0
2DD4  6FF9     MOVWF DMAnSSA, BANKED
2DD6  0E0A     MOVLW 0xA
2DD8  6FFA     MOVWF DMAnSSAH, BANKED
2DDA  0E00     MOVLW 0x0
2DDC  6FFB     MOVWF DMAnSSAU, BANKED
133:           			DMAnSSZ = DMA_B;
2DDE  0E01     MOVLW 0x1
2DE0  6FF8     MOVWF DMAnSSZH, BANKED
2DE2  0ED9     MOVLW 0xD9
2DE4  6FF7     MOVWF DMAnSSZ, BANKED
134:           			DMAnDSZ = DMAnSSZ;
2DE6  D05B     BRA 0x2E9E
135:           			DMAnCON0bits.EN = 1;
2DE8  8FFC     BSF DMAnCON0, 7, BANKED
136:           		} else {
2DEA  D093     BRA 0x2F12
137:           			if (vfcounts == scan_line) {
2DEC  5042     MOVF NVMLOCK, W, ACCESS
2DEE  1843     XORWF NVMADR, W, ACCESS
2DF0  A4D8     BTFSS 0xFD8, 2, ACCESS
2DF2  D00F     BRA 0x2E12
138:           				IO_RB1_SetDigitalOutput();
2DF4  D077     BRA 0x2EE4
139:           			} else {
140:           				IO_RB1_SetDigitalInput();
141:           			}
142:           		}
143:           		break;
144:           	case sync1: // H sync and video, all lines
145:           		if (vfcounts >= S_COUNT) {
2DF6  0EF6     MOVLW 0xF6
2DF8  6443     CPFSGT NVMADR, ACCESS
2DFA  D008     BRA 0x2E0C
146:           			vfcounts = 0;
2DFC  0E00     MOVLW 0x0
2DFE  6E43     MOVWF NVMADR, ACCESS
147:           			s_mode = sync2;
2E00  0E02     MOVLW 0x2
2E02  6E41     MOVWF NVMCON1, ACCESS
148:           			DMASELECT = DMA_M;
2E04  0E04     MOVLW 0x4
2E06  0100     MOVLB 0x0
2E08  6FE8     MOVWF DMASELECT, BANKED
149:           			DMAnCON0bits.EN = 0;
2E0A  D7E2     BRA 0x2DD0
150:           			DMAnSSA = (volatile uint24_t) & hsync;
151:           			DMAnSSZ = DMA_B;
152:           			DMAnDSZ = DMAnSSZ;
153:           			DMAnCON0bits.EN = 1;
154:           		} else {
155:           			if (ntsc_vid) {
2E0C  504D     MOVF 0x4D, W, ACCESS
2E0E  A4D8     BTFSS 0xFD8, 2, ACCESS
156:           				IO_RB1_SetDigitalOutput();
2E10  D069     BRA 0x2EE4
157:           			} else {
158:           				IO_RB1_SetDigitalInput();
2E12  82C7     BSF 0xFC7, 1, ACCESS
2E14  D07E     BRA 0x2F12
159:           			}
160:           		}
161:           		break;
162:           	case sync2: // V sync and no video
163:           		if (vfcounts >= H_SYNC) {
2E16  0E02     MOVLW 0x2
2E18  6443     CPFSGT NVMADR, ACCESS
2E1A  D07B     BRA 0x2F12
164:           			vfcounts = 0;
2E1C  0E00     MOVLW 0x0
2E1E  6E43     MOVWF NVMADR, ACCESS
165:           			s_mode = sync3;
2E20  0E03     MOVLW 0x3
2E22  6E41     MOVWF NVMCON1, ACCESS
166:           			DMASELECT = DMA_M;
2E24  0E04     MOVLW 0x4
2E26  0100     MOVLB 0x0
2E28  6FE8     MOVWF DMASELECT, BANKED
167:           			DMAnCON0bits.EN = 0;
2E2A  9FFC     BCF DMAnCON0, 7, BANKED
168:           			DMAnSSA = (volatile uint24_t) vbuf_ptr;
2E2E  F4F4     NOP
2E30  F0F9     NOP
2E34  F4F8     NOP
2E36  F0FA     NOP
2E38  6BFB     CLRF DMAnSSAU, BANKED
169:           			DMAnSSZ = DMA_B;
2E3A  0E01     MOVLW 0x1
2E3C  6FF8     MOVWF DMAnSSZH, BANKED
2E3E  0ED9     MOVLW 0xD9
2E40  6FF7     MOVWF DMAnSSZ, BANKED
170:           			DMAnDSZ = DMAnSSZ;
2E42  C0F7     MOVFF DMAnSSZ, DMAnDSZ
2E44  F0EE     NOP
2E46  C0F8     MOVFF DMAnSSZH, DMAnDSZH
2E48  F0EF     NOP
171:           			DMAnCON0bits.EN = 1;
2E4A  8FFC     BSF DMAnCON0, 7, BANKED
172:           			IO_RB1_SetDigitalInput(); // turn-off video bits
2E4C  82C7     BSF 0xFC7, 1, ACCESS
173:           			/*
174:           			 * trigger main task processing using the task manager
175:           			 */
176:           			task_hold = false; // clear idle routine run flag
2E4E  0E00     MOVLW 0x0
2E50  6E50     MOVWF 0x50, ACCESS
177:           			TMR4_StartTimer(); // run in main for timer 4 interrupt period then back to idle
2E52  EC2A     CALL 0x4054, 0
2E54  F020     NOP
2E56  D05D     BRA 0x2F12
178:           		}
179:           		break;
180:           	case sync3: // H sync and no video
181:           		if (vfcounts >= H_COUNT) {
2E58  0E0B     MOVLW 0xB
2E5A  6443     CPFSGT NVMADR, ACCESS
2E5C  D05A     BRA 0x2F12
182:           			vfcounts = 0;
2E5E  0E00     MOVLW 0x0
2E60  6E43     MOVWF NVMADR, ACCESS
183:           			if ((bool) scan_line) {
2E62  5042     MOVF NVMLOCK, W, ACCESS
2E64  B4D8     BTFSC 0xFD8, 2, ACCESS
2E66  D002     BRA 0x2E6C
184:           				s_mode = sync0;
2E68  0E00     MOVLW 0x0
2E6A  D001     BRA 0x2E6E
185:           			} else {
186:           				s_mode = sync1;
2E6C  0E01     MOVLW 0x1
2E6E  6E41     MOVWF NVMCON1, ACCESS
187:           			}
188:           			DMASELECT = DMA_M;
2E70  0E04     MOVLW 0x4
2E72  0100     MOVLB 0x0
2E74  6FE8     MOVWF DMASELECT, BANKED
189:           			DMAnCON0bits.EN = 0;
2E76  9FFC     BCF DMAnCON0, 7, BANKED
190:           			if (ntsc_flip) {
2E78  5044     MOVF NVMADRH, W, ACCESS
2E7A  B4D8     BTFSC 0xFD8, 2, ACCESS
2E7C  D004     BRA 0x2E86
191:           				vbuf_ptr = vbuffer;
2E7E  0E00     MOVLW 0x0
2E80  6E3D     MOVWF 0x3D, ACCESS
2E82  0E08     MOVLW 0x8
2E84  D003     BRA 0x2E8C
192:           			} else {
193:           				vbuf_ptr = vsync;
2E86  0E00     MOVLW 0x0
2E88  6E3D     MOVWF 0x3D, ACCESS
2E8A  0E0C     MOVLW 0xC
2E8C  6E3E     MOVWF 0x3E, ACCESS
194:           			}
195:           			DMAnSSA = (volatile uint24_t) vbuf_ptr;
2E90  F4F4     NOP
2E92  F0F9     NOP
2E96  F4F8     NOP
2E98  F0FA     NOP
2E9A  6BFB     CLRF DMAnSSAU, BANKED
196:           			DMAnSSZ = DMA_B;
2E9C  D7A0     BRA 0x2DDE
197:           			DMAnDSZ = DMAnSSZ;
2E9E  C0F7     MOVFF DMAnSSZ, DMAnDSZ
2EA0  F0EE     NOP
2EA2  C0F8     MOVFF DMAnSSZH, DMAnDSZH
2EA4  F0EF     NOP
198:           			DMAnCON0bits.EN = 1;
2EA6  D7A0     BRA 0x2DE8
199:           		}
200:           		break;
201:           	default:
202:           		vfcounts = 0;
2EA8  0E00     MOVLW 0x0
2EAA  6E43     MOVWF NVMADR, ACCESS
203:           		s_mode = sync1;
2EAC  0E01     MOVLW 0x1
2EAE  6E41     MOVWF NVMCON1, ACCESS
204:           		DMASELECT = DMA_M;
2EB0  0E04     MOVLW 0x4
2EB2  0100     MOVLB 0x0
2EB4  6FE8     MOVWF DMASELECT, BANKED
205:           		DMAnCON0bits.EN = 0;
2EB6  9FFC     BCF DMAnCON0, 7, BANKED
206:           		ntsc_flip = false;
2EB8  0E00     MOVLW 0x0
2EBA  6E44     MOVWF NVMADRH, ACCESS
207:           		vbuf_ptr = vsync;
2EBC  0E00     MOVLW 0x0
2EBE  6E3D     MOVWF 0x3D, ACCESS
2EC0  0E0C     MOVLW 0xC
2EC2  6E3E     MOVWF 0x3E, ACCESS
208:           		DMAnSSA = (volatile uint24_t) vbuf_ptr;
2EC6  F4F4     NOP
2EC8  F0F9     NOP
2ECC  F4F8     NOP
2ECE  F0FA     NOP
2ED0  6BFB     CLRF DMAnSSAU, BANKED
209:           		DMAnSSZ = DMA_B;
2ED2  0E01     MOVLW 0x1
2ED4  6FF8     MOVWF DMAnSSZH, BANKED
2ED6  0ED9     MOVLW 0xD9
2ED8  6FF7     MOVWF DMAnSSZ, BANKED
210:           		DMAnDSZ = DMAnSSZ;
2EDA  C0F7     MOVFF DMAnSSZ, DMAnDSZ
2EDC  F0EE     NOP
2EDE  C0F8     MOVFF DMAnSSZH, DMAnDSZH
2EE0  F0EF     NOP
211:           		DMAnCON0bits.EN = 1;
2EE2  8FFC     BSF DMAnCON0, 7, BANKED
212:           		IO_RB1_SetDigitalOutput(); // video bits, on
2EE4  92C7     BCF 0xFC7, 1, ACCESS
2EE6  D015     BRA 0x2F12
213:           		break;
214:           	}
2EE8  5041     MOVF NVMCON1, W, ACCESS
2EEA  6E01     MOVWF 0x1, ACCESS
2EEC  6A02     CLRF 0x2, ACCESS
2EEE  5002     MOVF 0x2, W, ACCESS
2EF0  0A00     XORLW 0x0
2EF2  A4D8     BTFSS 0xFD8, 2, ACCESS
2EF4  D7D9     BRA 0x2EA8
2EF6  5001     MOVF 0x1, W, ACCESS
2EF8  0A00     XORLW 0x0
2EFA  B4D8     BTFSC 0xFD8, 2, ACCESS
2EFC  D765     BRA 0x2DC8
2EFE  0A01     XORLW 0x1
2F00  B4D8     BTFSC 0xFD8, 2, ACCESS
2F02  D779     BRA 0x2DF6
2F04  0A03     XORLW 0x3
2F06  B4D8     BTFSC 0xFD8, 2, ACCESS
2F08  D786     BRA 0x2E16
2F0A  0A01     XORLW 0x1
2F0C  B4D8     BTFSC 0xFD8, 2, ACCESS
2F0E  D7A4     BRA 0x2E58
2F10  D7CB     BRA 0x2EA8
215:           
216:           	/*
217:           	 * re-trigger the state machine for a new scanline
218:           	 */
219:           	DMA5_StartTransfer();
2F12  EC08     CALL 0x4010, 0
2F14  F020     NOP
220:           }
2F16  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/uart1.c  -------------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.4.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            #include "interrupt_manager.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            #define UART1_TX_BUFFER_SIZE 64
58:            #define UART1_RX_BUFFER_SIZE 64
59:            
60:            /**
61:              Section: Global Variables
62:            */
63:            
64:            static volatile uint8_t uart1TxHead = 0;
65:            static volatile uint8_t uart1TxTail = 0;
66:            static volatile uint8_t uart1TxBuffer[UART1_TX_BUFFER_SIZE];
67:            volatile uint8_t uart1TxBufferRemaining;
68:            
69:            static volatile uint8_t uart1RxHead = 0;
70:            static volatile uint8_t uart1RxTail = 0;
71:            static volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
72:            static volatile uart1_status_t uart1RxStatusBuffer[UART1_RX_BUFFER_SIZE];
73:            volatile uint8_t uart1RxCount;
74:            static volatile uart1_status_t uart1RxLastError;
75:            
76:            /**
77:              Section: UART1 APIs
78:            */
79:            void (*UART1_FramingErrorHandler)(void);
80:            void (*UART1_OverrunErrorHandler)(void);
81:            void (*UART1_ErrorHandler)(void);
82:            
83:            void UART1_DefaultFramingErrorHandler(void);
84:            void UART1_DefaultOverrunErrorHandler(void);
85:            void UART1_DefaultErrorHandler(void);
86:            
87:            void UART1_Initialize(void)
88:            {
89:                // Disable interrupts before changing states
90:                PIE4bits.U1RXIE = 0;
3412  90A2     BCF 0xFA2, 0, ACCESS
91:                UART1_SetRxInterruptHandler(UART1_Receive_ISR);
3414  0E72     MOVLW 0x72
3416  6E0D     MOVWF 0xD, ACCESS
3418  0E35     MOVLW 0x35
341A  6E0E     MOVWF 0xE, ACCESS
341C  0E00     MOVLW 0x0
341E  6E0F     MOVWF 0xF, ACCESS
3420  ECBF     CALL 0x3F7E, 0
3422  F01F     NOP
92:                PIE4bits.U1TXIE = 0;
3424  92A2     BCF 0xFA2, 1, ACCESS
93:                UART1_SetTxInterruptHandler(UART1_Transmit_ISR);
3426  0E9C     MOVLW 0x9C
3428  6E0D     MOVWF 0xD, ACCESS
342A  0E3D     MOVLW 0x3D
342C  6E0E     MOVWF 0xE, ACCESS
342E  0E00     MOVLW 0x0
3430  6E0F     MOVWF 0xF, ACCESS
3432  ECB8     CALL 0x3F70, 0
3434  F01F     NOP
94:            
95:                // Set the UART1 module to the options selected in the user interface.
96:            
97:                // P1L 0; 
98:                U1P1L = 0x00;
3436  0E00     MOVLW 0x0
3438  0102     MOVLB 0x2
343A  6FA5     MOVWF 0xA5, BANKED
99:            
100:               // P1H 0; 
101:               U1P1H = 0x00;
343C  0E00     MOVLW 0x0
343E  6FA6     MOVWF 0xA6, BANKED
102:           
103:               // P2L 0; 
104:               U1P2L = 0x00;
3440  0E00     MOVLW 0x0
3442  6FA7     MOVWF 0xA7, BANKED
105:           
106:               // P2H 0; 
107:               U1P2H = 0x00;
3444  0E00     MOVLW 0x0
3446  6FA8     MOVWF 0xA8, BANKED
108:           
109:               // P3L 0; 
110:               U1P3L = 0x00;
3448  0E00     MOVLW 0x0
344A  6FA9     MOVWF 0xA9, BANKED
111:           
112:               // P3H 0; 
113:               U1P3H = 0x00;
344C  0E00     MOVLW 0x0
344E  6FAA     MOVWF 0xAA, BANKED
114:           
115:               // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
116:               U1CON0 = 0xB0;
3450  0EB0     MOVLW 0xB0
3452  6FAB     MOVWF 0xAB, BANKED
117:           
118:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
119:               U1CON1 = 0x80;
3454  0E80     MOVLW 0x80
3456  6FAC     MOVWF ACTCON, BANKED
120:           
121:               // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
122:               U1CON2 = 0x00;
3458  0E00     MOVLW 0x0
345A  6FAD     MOVWF OSCCON1, BANKED
123:           
124:               // BRGL 130; 
125:               U1BRGL = 0x82;
345C  0E82     MOVLW 0x82
345E  6FAE     MOVWF OSCCON2, BANKED
126:           
127:               // BRGH 6; 
128:               U1BRGH = 0x06;
3460  0E06     MOVLW 0x6
3462  6FAF     MOVWF OSCCON3, BANKED
129:           
130:               // STPMD in middle of first Stop bit; TXWRE No error; 
131:               U1FIFO = 0x00;
3464  0E00     MOVLW 0x0
3466  6FB0     MOVWF OSCTUNE, BANKED
132:           
133:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
134:               U1UIR = 0x00;
3468  0E00     MOVLW 0x0
346A  6FB1     MOVWF OSCFRQ, BANKED
135:           
136:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
137:               U1ERRIR = 0x00;
346C  0E00     MOVLW 0x0
346E  6FB2     MOVWF OSCSTAT, BANKED
138:           
139:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
140:               U1ERRIE = 0x00;
3470  0E00     MOVLW 0x0
3472  6FB3     MOVWF OSCEN, BANKED
141:           
142:           
143:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
3474  0E6C     MOVLW 0x6C
3476  6E0D     MOVWF 0xD, ACCESS
3478  0E40     MOVLW 0x40
347A  6E0E     MOVWF 0xE, ACCESS
347C  0E00     MOVLW 0x0
347E  6E0F     MOVWF 0xF, ACCESS
3480  ECCD     CALL 0x3F9A, 0
3482  F01F     NOP
144:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
3484  0E6A     MOVLW 0x6A
3486  6E0D     MOVWF 0xD, ACCESS
3488  0E40     MOVLW 0x40
348A  6E0E     MOVWF 0xE, ACCESS
348C  0E00     MOVLW 0x0
348E  6E0F     MOVWF 0xF, ACCESS
3490  ECC6     CALL 0x3F8C, 0
3492  F01F     NOP
145:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
3494  0E48     MOVLW 0x48
3496  6E0D     MOVWF 0xD, ACCESS
3498  0E40     MOVLW 0x40
349A  6E0E     MOVWF 0xE, ACCESS
349C  0E00     MOVLW 0x0
349E  6E0F     MOVWF 0xF, ACCESS
34A0  ECD4     CALL 0x3FA8, 0
34A2  F01F     NOP
146:           
147:               uart1RxLastError.status = 0;
34A4  0E00     MOVLW 0x0
34A6  6E45     MOVWF NVMADRU, ACCESS
148:           
149:               // initializing the driver state
150:               uart1TxHead = 0;
34A8  0E00     MOVLW 0x0
34AA  6E4B     MOVWF HLVDCON1, ACCESS
151:               uart1TxTail = 0;
34AC  0E00     MOVLW 0x0
34AE  6E4A     MOVWF HLVDCON0, ACCESS
152:               uart1TxBufferRemaining = sizeof(uart1TxBuffer);
34B0  0E40     MOVLW 0x40
34B2  6E49     MOVWF BORCON, ACCESS
153:               uart1RxHead = 0;
34B4  0E00     MOVLW 0x0
34B6  6E48     MOVWF VREGCON, ACCESS
154:               uart1RxTail = 0;
34B8  0E00     MOVLW 0x0
34BA  6E47     MOVWF NVMDATH, ACCESS
155:               uart1RxCount = 0;
34BC  0E00     MOVLW 0x0
34BE  6E46     MOVWF NVMDAT, ACCESS
156:           
157:               // enable receive interrupt
158:               PIE4bits.U1RXIE = 1;
34C0  80A2     BSF 0xFA2, 0, ACCESS
159:           }
34C2  0012     RETURN 0
160:           
161:           bool UART1_is_rx_ready(void)
162:           {
163:               return (uart1RxCount ? true : false);
164:           }
165:           
166:           bool UART1_is_tx_ready(void)
167:           {
168:               return (uart1TxBufferRemaining ? true : false);
169:           }
170:           
171:           bool UART1_is_tx_done(void)
172:           {
173:               return U1ERRIRbits.TXMTIF;
174:           }
175:           
176:           uart1_status_t UART1_get_last_status(void){
177:               return uart1RxLastError;
178:           }
179:           
180:           uint8_t UART1_Read(void)
181:           {
182:               uint8_t readValue  = 0;
183:               
184:               while(0 == uart1RxCount)
185:               {
186:               }
187:           
188:               uart1RxLastError = uart1RxStatusBuffer[uart1RxTail];
189:           
190:               readValue = uart1RxBuffer[uart1RxTail++];
191:              	if(sizeof(uart1RxBuffer) <= uart1RxTail)
192:               {
193:                   uart1RxTail = 0;
194:               }
195:               PIE4bits.U1RXIE = 0;
196:               uart1RxCount--;
197:               PIE4bits.U1RXIE = 1;
198:           
199:               return readValue;
200:           }
201:           
202:           void UART1_Write(uint8_t txData)
203:           {
204:               while(0 == uart1TxBufferRemaining)
205:               {
206:               }
207:           
208:               if(0 == PIE4bits.U1TXIE)
209:               {
210:                   U1TXB = txData;
211:               }
212:               else
213:               {
214:                   PIE4bits.U1TXIE = 0;
215:                   uart1TxBuffer[uart1TxHead++] = txData;
216:                   if(sizeof(uart1TxBuffer) <= uart1TxHead)
217:                   {
218:                       uart1TxHead = 0;
219:                   }
220:                   uart1TxBufferRemaining--;
221:               }
222:               PIE4bits.U1TXIE = 1;
223:           }
224:           
225:           void __interrupt(irq(U1TX),base(8),low_priority) UART1_tx_vect_isr()
226:           {   
227:               if(UART1_TxInterruptHandler)
3CAE  0105     MOVLB 0x5
3CB0  51D7     MOVF CLCnPOL, W, BANKED
3CB2  11D8     IORWF CLCnSEL0, W, BANKED
3CB4  11D9     IORWF CLCnSEL1, W, BANKED
3CB6  B4D8     BTFSC 0xFD8, 2, ACCESS
3CB8  D00C     BRA 0x3CD2
228:               {
229:                   UART1_TxInterruptHandler();
3CBA  D801     RCALL 0x3CBE
3CBC  D00A     BRA 0x3CD2
3CBE  0005     PUSH
3CC0  6EFA     MOVWF 0xFFA, ACCESS
3CC2  51D7     MOVF CLCnPOL, W, BANKED
3CC4  6EFD     MOVWF 0xFFD, ACCESS
3CC6  51D8     MOVF CLCnSEL0, W, BANKED
3CC8  6EFE     MOVWF 0xFFE, ACCESS
3CCA  51D9     MOVF CLCnSEL1, W, BANKED
3CCC  6EFF     MOVWF 0xFFF, ACCESS
3CCE  50FA     MOVF 0xFFA, W, ACCESS
3CD0  0012     RETURN 0
230:               }
231:           }
3CD4  F424     NOP
3CD6  F4D8     NOP
3CD8  0011     RETFIE 1
232:           
233:           void __interrupt(irq(U1RX),base(8),low_priority) UART1_rx_vect_isr()
234:           {
235:               if(UART1_RxInterruptHandler)
3CE2  0105     MOVLB 0x5
3CE4  51DA     MOVF CLCnSEL2, W, BANKED
3CE6  11DB     IORWF CLCnSEL3, W, BANKED
3CE8  11DC     IORWF CLCnGLS0, W, BANKED
3CEA  B4D8     BTFSC 0xFD8, 2, ACCESS
3CEC  D00C     BRA 0x3D06
236:               {
237:                   UART1_RxInterruptHandler();
3CEE  D801     RCALL 0x3CF2
3CF0  D00A     BRA 0x3D06
3CF2  0005     PUSH
3CF4  6EFA     MOVWF 0xFFA, ACCESS
3CF6  51DA     MOVF CLCnSEL2, W, BANKED
3CF8  6EFD     MOVWF 0xFFD, ACCESS
3CFA  51DB     MOVF CLCnSEL3, W, BANKED
3CFC  6EFE     MOVWF 0xFFE, ACCESS
3CFE  51DC     MOVF CLCnGLS0, W, BANKED
3D00  6EFF     MOVWF 0xFFF, ACCESS
3D02  50FA     MOVF 0xFFA, W, ACCESS
3D04  0012     RETURN 0
238:               }
239:           }
240:           
241:           
242:           
243:           void UART1_Transmit_ISR(void)
244:           {
245:               // use this default transmit interrupt handler code
246:               if(sizeof(uart1TxBuffer) > uart1TxBufferRemaining)
3D9C  0E40     MOVLW 0x40
3D9E  6049     CPFSLT BORCON, ACCESS
3DA0  D011     BRA 0x3DC4
247:               {
248:                   U1TXB = uart1TxBuffer[uart1TxTail++];
3DA2  0E40     MOVLW 0x40
3DA4  244A     ADDWF HLVDCON0, W, ACCESS
3DA6  6ED9     MOVWF 0xFD9, ACCESS
3DA8  6ADA     CLRF 0xFDA, ACCESS
3DAA  0E06     MOVLW 0x6
3DAC  22DA     ADDWFC 0xFDA, F, ACCESS
3DAE  50DF     MOVF 0xFDF, W, ACCESS
3DB0  0102     MOVLB 0x2
3DB2  6FA3     MOVWF 0xA3, BANKED
3DB4  2A4A     INCF HLVDCON0, F, ACCESS
249:                  if(sizeof(uart1TxBuffer) <= uart1TxTail)
3DB6  0E3F     MOVLW 0x3F
3DB8  644A     CPFSGT HLVDCON0, ACCESS
3DBA  D002     BRA 0x3DC0
250:                   {
251:                       uart1TxTail = 0;
3DBC  0E00     MOVLW 0x0
3DBE  6E4A     MOVWF HLVDCON0, ACCESS
252:                   }
253:                   uart1TxBufferRemaining++;
3DC0  2A49     INCF BORCON, F, ACCESS
254:               }
3DC2  0012     RETURN 0
255:               else
256:               {
257:                   PIE4bits.U1TXIE = 0;
3DC4  92A2     BCF 0xFA2, 1, ACCESS
258:               }
259:               
260:               // or set custom function using UART1_SetTxInterruptHandler()
261:           }
3CDE  F360     NOP
3CE0  F50A     NOP
3DC6  0012     RETURN 0
262:           
263:           void UART1_Receive_ISR(void)
264:           {
265:               // use this default receive interrupt handler code
266:               uart1RxStatusBuffer[uart1RxHead].status = 0;
3572  0E60     MOVLW 0x60
3574  2448     ADDWF VREGCON, W, ACCESS
3576  6ED9     MOVWF 0xFD9, ACCESS
3578  6ADA     CLRF 0xFDA, ACCESS
357A  0E05     MOVLW 0x5
357C  22DA     ADDWFC 0xFDA, F, ACCESS
357E  0E00     MOVLW 0x0
3580  6EDF     MOVWF 0xFDF, ACCESS
267:           
268:               if(U1ERRIRbits.FERIF){
3582  0102     MOVLB 0x2
3584  A7B2     BTFSS OSCSTAT, 3, BANKED
3586  D014     BRA 0x35B0
269:                   uart1RxStatusBuffer[uart1RxHead].ferr = 1;
3588  0E60     MOVLW 0x60
358A  2448     ADDWF VREGCON, W, ACCESS
358C  6ED9     MOVWF 0xFD9, ACCESS
358E  6ADA     CLRF 0xFDA, ACCESS
3590  0E05     MOVLW 0x5
3592  22DA     ADDWFC 0xFDA, F, ACCESS
3594  0105     MOVLB 0x5
3596  82DF     BSF 0xFDF, 1, ACCESS
270:                   UART1_FramingErrorHandler();
3598  D801     RCALL 0x359C
359A  D00A     BRA 0x35B0
359C  0005     PUSH
359E  6EFA     MOVWF 0xFFA, ACCESS
35A0  51CE     MOVF 0xCE, W, BANKED
35A2  6EFD     MOVWF 0xFFD, ACCESS
35A4  51CF     MOVF 0xCF, W, BANKED
35A6  6EFE     MOVWF 0xFFE, ACCESS
35A8  51D0     MOVF 0xD0, W, BANKED
35AA  6EFF     MOVWF 0xFFF, ACCESS
35AC  50FA     MOVF 0xFFA, W, ACCESS
35AE  0012     RETURN 0
271:               }
272:               
273:               if(U1ERRIRbits.RXFOIF){
35B0  0102     MOVLB 0x2
35B2  A3B2     BTFSS OSCSTAT, 1, BANKED
35B4  D014     BRA 0x35DE
274:                   uart1RxStatusBuffer[uart1RxHead].oerr = 1;
35B6  0E60     MOVLW 0x60
35B8  2448     ADDWF VREGCON, W, ACCESS
35BA  6ED9     MOVWF 0xFD9, ACCESS
35BC  6ADA     CLRF 0xFDA, ACCESS
35BE  0E05     MOVLW 0x5
35C0  22DA     ADDWFC 0xFDA, F, ACCESS
35C2  0105     MOVLB 0x5
35C4  84DF     BSF 0xFDF, 2, ACCESS
275:                   UART1_OverrunErrorHandler();
35C6  D801     RCALL 0x35CA
35C8  D00A     BRA 0x35DE
35CA  0005     PUSH
35CC  6EFA     MOVWF 0xFFA, ACCESS
35CE  51CB     MOVF 0xCB, W, BANKED
35D0  6EFD     MOVWF 0xFFD, ACCESS
35D2  51CC     MOVF 0xCC, W, BANKED
35D4  6EFE     MOVWF 0xFFE, ACCESS
35D6  51CD     MOVF 0xCD, W, BANKED
35D8  6EFF     MOVWF 0xFFF, ACCESS
35DA  50FA     MOVF 0xFFA, W, ACCESS
35DC  0012     RETURN 0
276:               }
277:               
278:               if(uart1RxStatusBuffer[uart1RxHead].status){
35DE  0E60     MOVLW 0x60
35E0  2448     ADDWF VREGCON, W, ACCESS
35E2  6ED9     MOVWF 0xFD9, ACCESS
35E4  6ADA     CLRF 0xFDA, ACCESS
35E6  0E05     MOVLW 0x5
35E8  22DA     ADDWFC 0xFDA, F, ACCESS
35EA  50DF     MOVF 0xFDF, W, ACCESS
35EC  B4D8     BTFSC 0xFD8, 2, ACCESS
35EE  D00D     BRA 0x360A
279:                   UART1_ErrorHandler();
35F0  D801     RCALL 0x35F4
35F2  0012     RETURN 0
35F4  0005     PUSH
35F6  6EFA     MOVWF 0xFFA, ACCESS
35F8  0105     MOVLB 0x5
35FA  51C8     MOVF 0xC8, W, BANKED
35FC  6EFD     MOVWF 0xFFD, ACCESS
35FE  51C9     MOVF 0xC9, W, BANKED
3600  6EFE     MOVWF 0xFFE, ACCESS
3602  51CA     MOVF 0xCA, W, BANKED
3604  6EFF     MOVWF 0xFFF, ACCESS
3606  50FA     MOVF 0xFFA, W, ACCESS
3608  0012     RETURN 0
280:               } else {
281:                   UART1_RxDataHandler();
360A  EC72     CALL 0x3EE4, 0
360C  F01F     NOP
282:               }
283:           
284:               // or set custom function using UART1_SetRxInterruptHandler()
285:           }
360E  0012     RETURN 0
286:           
287:           void UART1_RxDataHandler(void){
288:               // use this default receive interrupt handler code
289:               uart1RxBuffer[uart1RxHead++] = U1RXB;
3EE4  0E00     MOVLW 0x0
3EE6  2448     ADDWF VREGCON, W, ACCESS
3EE8  6ED9     MOVWF 0xFD9, ACCESS
3EEA  6ADA     CLRF 0xFDA, ACCESS
3EEC  0E06     MOVLW 0x6
3EEE  22DA     ADDWFC 0xFDA, F, ACCESS
3EF0  C2A1     MOVFF U1RXB, INDF2
3EF2  F4DF     NOP
3EF4  2A48     INCF VREGCON, F, ACCESS
290:               if(sizeof(uart1RxBuffer) <= uart1RxHead)
3EF6  0E3F     MOVLW 0x3F
3EF8  6448     CPFSGT VREGCON, ACCESS
3EFA  D002     BRA 0x3F00
291:               {
292:                   uart1RxHead = 0;
3EFC  0E00     MOVLW 0x0
3EFE  6E48     MOVWF VREGCON, ACCESS
293:               }
294:               uart1RxCount++;
3F00  2A46     INCF NVMDAT, F, ACCESS
295:           }
3C76  F360     NOP
3C78  F50C     NOP
3F02  0012     RETURN 0
296:           
297:           void UART1_DefaultFramingErrorHandler(void){}
406C  0012     RETURN 0
298:           
299:           void UART1_DefaultOverrunErrorHandler(void){}
406A  0012     RETURN 0
300:           
301:           void UART1_DefaultErrorHandler(void){
302:               UART1_RxDataHandler();
4048  EC72     CALL 0x3EE4, 0
404A  F01F     NOP
303:           }
404C  0012     RETURN 0
304:           
305:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
306:               UART1_FramingErrorHandler = interruptHandler;
3F9A  C50D     MOVFF d1, UART1_FramingErrorHandler
3F9C  F5CE     NOP
3F9E  C50E     MOVFF 0x50E, 0x5CF
3FA0  F5CF     NOP
3FA2  C50F     MOVFF s1, 0x5D0
3FA4  F5D0     NOP
307:           }
3FA6  0012     RETURN 0
308:           
309:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
310:               UART1_OverrunErrorHandler = interruptHandler;
3F8C  C50D     MOVFF d1, UART1_OverrunErrorHandler
3F8E  F5CB     NOP
3F90  C50E     MOVFF 0x50E, 0x5CC
3F92  F5CC     NOP
3F94  C50F     MOVFF s1, 0x5CD
3F96  F5CD     NOP
311:           }
3F98  0012     RETURN 0
312:           
313:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
314:               UART1_ErrorHandler = interruptHandler;
3FA8  C50D     MOVFF d1, UART1_ErrorHandler
3FAA  F5C8     NOP
3FAC  C50E     MOVFF 0x50E, 0x5C9
3FAE  F5C9     NOP
3FB0  C50F     MOVFF s1, 0x5CA
3FB2  F5CA     NOP
315:           }
3FB4  0012     RETURN 0
316:           
317:           
318:           
319:           void UART1_SetRxInterruptHandler(void (* InterruptHandler)(void)){
320:               UART1_RxInterruptHandler = InterruptHandler;
3F7E  C50D     MOVFF d1, UART1_RxInterruptHandler
3F80  F5DA     NOP
3F82  C50E     MOVFF 0x50E, 0x5DB
3F84  F5DB     NOP
3F86  C50F     MOVFF s1, 0x5DC
3F88  F5DC     NOP
321:           }
3F8A  0012     RETURN 0
322:           
323:           void UART1_SetTxInterruptHandler(void (* InterruptHandler)(void)){
324:               UART1_TxInterruptHandler = InterruptHandler;
3F70  C50D     MOVFF d1, UART1_TxInterruptHandler
3F72  F5D7     NOP
3F74  C50E     MOVFF 0x50E, 0x5D8
3F76  F5D8     NOP
3F78  C50F     MOVFF s1, 0x5D9
3F7A  F5D9     NOP
325:           }
3F7C  0012     RETURN 0
326:           
327:           
328:           /**
329:             End of File
330:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/tmr6.c  --------------------
1:             /**
2:               TMR6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR6.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:            	Device            :  PIC18F47Q43
18:            	Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 2.30 and above 
21:            	MPLAB 	          :  MPLAB X 5.40
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "tmr6.h"
53:            #include "interrupt_manager.h"
54:            #include "../timers.h"
55:            
56:            /**
57:              Section: Global Variables Definitions
58:             */
59:            extern volatile uint16_t tickCount[TMR_COUNT];
60:            
61:            void (*TMR6_InterruptHandler)(void);
62:            
63:            /**
64:              Section: TMR6 APIs
65:             */
66:            
67:            void TMR6_Initialize(void)
68:            {
69:            	// Set TMR6 to the options selected in the User Interface
70:            
71:            	// T6CS FOSC/4; 
72:            	T6CLKCON = 0x01;
3D0E  0E01     MOVLW 0x1
3D10  0103     MOVLB 0x3
3D12  6F3E     MOVWF 0x3E, BANKED
73:            
74:            	// T6PSYNC Not Synchronized; T6MODE Software control; T6CKPOL Rising Edge; T6CKSYNC Synchronized; 
75:            	T6HLT = 0x20;
3D14  0E20     MOVLW 0x20
3D16  6F3D     MOVWF 0x3D, BANKED
76:            
77:            	// T6RSEL T6CKIPPS pin; 
78:            	T6RST = 0x00;
3D18  0E00     MOVLW 0x0
3D1A  6F3F     MOVWF 0x3F, BANKED
79:            
80:            	// PR6 249; 
81:            	T6PR = 0xF9;
3D1C  0EF9     MOVLW 0xF9
3D1E  6F3B     MOVWF 0x3B, BANKED
82:            
83:            	// TMR6 0; 
84:            	T6TMR = 0x00;
3D20  0E00     MOVLW 0x0
3D22  6F3A     MOVWF CLKRCLK, BANKED
85:            
86:            	// Clearing IF flag before enabling the interrupt.
87:            	PIR15bits.TMR6IF = 0;
3D24  96BD     BCF 0xFBD, 3, ACCESS
88:            
89:            	// Enabling TMR6 interrupt.
90:            	PIE15bits.TMR6IE = 1;
3D26  86AD     BSF 0xFAD, 3, ACCESS
91:            
92:            	// Set Default Interrupt Handler
93:            	TMR6_SetInterruptHandler(TMR6_DefaultInterruptHandler);
3D28  0E1A     MOVLW 0x1A
3D2A  6E0D     MOVWF 0xD, ACCESS
3D2C  0E3B     MOVLW 0x3B
3D2E  6E0E     MOVWF 0xE, ACCESS
3D30  0E00     MOVLW 0x0
3D32  6E0F     MOVWF 0xF, ACCESS
3D34  ECDB     CALL 0x3FB6, 0
3D36  F01F     NOP
94:            
95:            	// T6CKPS 1:8; T6OUTPS 1:4; TMR6ON on; 
96:            	T6CON = 0xB3;
3D38  0EB3     MOVLW 0xB3
3D3A  6F3C     MOVWF 0x3C, BANKED
97:            }
3D3C  0012     RETURN 0
98:            
99:            void TMR6_ModeSet(TMR6_HLT_MODE mode)
100:           {
101:           	// Configure different types HLT mode
102:           	T6HLTbits.MODE = mode;
103:           }
104:           
105:           void TMR6_ExtResetSourceSet(TMR6_HLT_EXT_RESET_SOURCE reset)
106:           {
107:           	//Configure different types of HLT external reset source
108:           	T6RSTbits.RSEL = reset;
109:           }
110:           
111:           void TMR6_Start(void)
112:           {
113:           	// Start the Timer by writing to TMRxON bit
114:           	T6CONbits.TMR6ON = 1;
115:           }
116:           
117:           void TMR6_StartTimer(void)
118:           {
119:           	TMR6_Start();
120:           }
121:           
122:           void TMR6_Stop(void)
123:           {
124:           	// Stop the Timer by writing to TMRxON bit
125:           	T6CONbits.TMR6ON = 0;
4042  0103     MOVLB 0x3
4044  9F3C     BCF 0x3C, 7, BANKED
126:           }
4046  0012     RETURN 0
127:           
128:           void TMR6_StopTimer(void)
129:           {
130:           	TMR6_Stop();
131:           }
132:           
133:           uint8_t TMR6_Counter8BitGet(void)
134:           {
135:           	uint8_t readVal;
136:           
137:           	readVal = TMR6;
138:           
139:           	return readVal;
140:           }
141:           
142:           uint8_t TMR6_ReadTimer(void)
143:           {
144:           	return TMR6_Counter8BitGet();
145:           }
146:           
147:           void TMR6_Counter8BitSet(uint8_t timerVal)
148:           {
149:           	// Write to the Timer6 register
150:           	TMR6 = timerVal;
151:           }
152:           
153:           void TMR6_WriteTimer(uint8_t timerVal)
154:           {
155:           	TMR6_Counter8BitSet(timerVal);
156:           }
157:           
158:           void TMR6_Period8BitSet(uint8_t periodVal)
159:           {
160:           	PR6 = periodVal;
161:           }
162:           
163:           void TMR6_LoadPeriodRegister(uint8_t periodVal)
164:           {
165:           	TMR6_Period8BitSet(periodVal);
166:           }
167:           
168:           void __interrupt(irq(TMR6), base(8), low_priority) TMR6_ISR()
3C42  F360     NOP
3C44  F508     NOP
169:           {
170:           
171:           	// clear the TMR6 interrupt flag
172:           	PIR15bits.TMR6IF = 0;
3C46  96BD     BCF 0xFBD, 3, ACCESS
173:           
174:           	if (TMR6_InterruptHandler) {
3C48  0105     MOVLB 0x5
3C4A  51D1     MOVF 0xD1, W, BANKED
3C4C  11D2     IORWF 0xD2, W, BANKED
3C4E  11D3     IORWF 0xD3, W, BANKED
3C50  B4D8     BTFSC 0xFD8, 2, ACCESS
3C52  D00C     BRA 0x3C6C
175:           		TMR6_InterruptHandler();
3C54  D801     RCALL 0x3C58
3C56  D00A     BRA 0x3C6C
3C58  0005     PUSH
3C5A  6EFA     MOVWF 0xFFA, ACCESS
3C5C  51D1     MOVF 0xD1, W, BANKED
3C5E  6EFD     MOVWF 0xFFD, ACCESS
3C60  51D2     MOVF 0xD2, W, BANKED
3C62  6EFE     MOVWF 0xFFE, ACCESS
3C64  51D3     MOVF 0xD3, W, BANKED
3C66  6EFF     MOVWF 0xFFF, ACCESS
3C68  50FA     MOVF 0xFFA, W, ACCESS
3C6A  0012     RETURN 0
176:           	}
177:           }
3C6E  F420     NOP
3C70  F4D8     NOP
3C72  0011     RETFIE 1
178:           
179:           void TMR6_SetInterruptHandler(void (* InterruptHandler)(void))
180:           {
181:           	TMR6_InterruptHandler = InterruptHandler;
3FB6  C50D     MOVFF d1, TMR6_InterruptHandler
3FB8  F5D1     NOP
3FBA  C50E     MOVFF 0x50E, 0x5D2
3FBC  F5D2     NOP
3FBE  C50F     MOVFF s1, 0x5D3
3FC0  F5D3     NOP
182:           }
3FC2  0012     RETURN 0
183:           
184:           void TMR6_DefaultInterruptHandler(void)
185:           {
186:           	static uint8_t i = 0;
187:           	// add your TMR6 interrupt custom code
188:           	// or set custom function using TMR6_SetInterruptHandler()
189:           	//Decrement each software timer
190:           	for (i = 0; i < TMR_COUNT; i++) {
3B1A  0E00     MOVLW 0x0
3B1C  6E4C     MOVWF ZCDCON, ACCESS
3B1E  0E06     MOVLW 0x6
3B20  644C     CPFSGT ZCDCON, ACCESS
3B22  D001     BRA 0x3B26
3B24  0012     RETURN 0
191:           		if (tickCount[i] != 0) {
3B26  504C     MOVF ZCDCON, W, ACCESS
3B28  0D02     MULLW 0x2
3B2A  0EA0     MOVLW 0xA0
3B2C  24F3     ADDWF 0xFF3, W, ACCESS
3B2E  6ED9     MOVWF 0xFD9, ACCESS
3B30  0E05     MOVLW 0x5
3B32  20F4     ADDWFC 0xFF4, W, ACCESS
3B34  6EDA     MOVWF 0xFDA, ACCESS
3B36  50DE     MOVF 0xFDE, W, ACCESS
3B38  10DE     IORWF 0xFDE, W, ACCESS
3B3A  B4D8     BTFSC 0xFD8, 2, ACCESS
3B3C  D00B     BRA 0x3B54
192:           			tickCount[i]--;
3B3E  504C     MOVF ZCDCON, W, ACCESS
3B40  0D02     MULLW 0x2
3B42  0EA0     MOVLW 0xA0
3B44  24F3     ADDWF 0xFF3, W, ACCESS
3B46  6ED9     MOVWF 0xFD9, ACCESS
3B48  0E05     MOVLW 0x5
3B4A  20F4     ADDWFC 0xFF4, W, ACCESS
3B4C  6EDA     MOVWF 0xFDA, ACCESS
3B4E  06DE     DECF 0xFDE, F, ACCESS
3B50  0E00     MOVLW 0x0
3B52  5ADD     SUBWFB 0xFDD, F, ACCESS
193:           		}
194:           	}
3B54  2A4C     INCF ZCDCON, F, ACCESS
3B56  D7E3     BRA 0x3B1E
195:           }
3CAA  F360     NOP
3CAC  F509     NOP
196:           
197:           /**
198:             End of File
199:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/tmr5.c  --------------------
1:             /**
2:               TMR5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR5.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr5.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer5ReloadVal;
59:            void (*TMR5_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR5 APIs
63:            */
64:            
65:            void TMR5_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T5GE disabled; T5GTM disabled; T5GPOL low; T5GGO done; T5GSPM disabled; 
70:                T5GCON = 0x00;
3A90  0E00     MOVLW 0x0
3A92  6F37     MOVWF 0x37, BANKED
71:            
72:                //GSS T5G_pin; 
73:                T5GATE = 0x00;
3A94  0E00     MOVLW 0x0
3A96  6F38     MOVWF 0x38, BANKED
74:            
75:                //CS FOSC/4; 
76:                T5CLK = 0x01;
3A98  0E01     MOVLW 0x1
3A9A  6F39     MOVWF CLKRCON, BANKED
77:            
78:                //TMR5H 177; 
79:                TMR5H = 0xB1;
3A9C  0EB1     MOVLW 0xB1
3A9E  6F35     MOVWF 0x35, BANKED
80:            
81:                //TMR5L 224; 
82:                TMR5L = 0xE0;
3AA0  0EE0     MOVLW 0xE0
3AA2  6F34     MOVWF 0x34, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR8bits.TMR5IF = 0;
3AA4  98B6     BCF 0xFB6, 4, ACCESS
86:            
87:                // Load the TMR value to reload variable
88:                timer5ReloadVal=(uint16_t)((TMR5H << 8) | TMR5L);
3AA6  5134     MOVF 0x34, W, BANKED
3AAA  FCD4     NOP
3AAC  F510     NOP
3AAE  6A11     CLRF 0x11, ACCESS
3AB0  C510     MOVFF 0x510, n
3AB2  F511     NOP
3AB4  6A10     CLRF 0x10, ACCESS
3AB6  1010     IORWF 0x10, W, ACCESS
3AB8  6E3F     MOVWF 0x3F, ACCESS
3ABA  5011     MOVF 0x11, W, ACCESS
3ABC  6E40     MOVWF NVMCON0, ACCESS
89:            
90:                // Enabling TMR5 interrupt.
91:                PIE8bits.TMR5IE = 1;
3ABE  88A6     BSF 0xFA6, 4, ACCESS
92:            
93:                // Set Default Interrupt Handler
94:                TMR5_SetInterruptHandler(TMR5_DefaultInterruptHandler);
3AC0  0E68     MOVLW 0x68
3AC2  6E0D     MOVWF 0xD, ACCESS
3AC4  0E40     MOVLW 0x40
3AC6  6E0E     MOVWF 0xE, ACCESS
3AC8  0E00     MOVLW 0x0
3ACA  6E0F     MOVWF 0xF, ACCESS
3ACC  ECE2     CALL 0x3FC4, 0
3ACE  F01F     NOP
95:            
96:                // CKPS 1:8; NOT_SYNC synchronize; TMR5ON enabled; T5RD16 disabled; 
97:                T5CON = 0x31;
3AD0  0E31     MOVLW 0x31
3AD2  6F36     MOVWF 0x36, BANKED
98:            }
3AD4  0012     RETURN 0
99:            
100:           void TMR5_StartTimer(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T5CONbits.TMR5ON = 1;
104:           }
105:           
106:           void TMR5_StopTimer(void)
107:           {
108:               // Stop the Timer by writing to TMRxON bit
109:               T5CONbits.TMR5ON = 0;
110:           }
111:           
112:           uint16_t TMR5_ReadTimer(void)
113:           {
114:               uint16_t readVal;
115:               uint8_t readValHigh;
116:               uint8_t readValLow;
117:               
118:               T5CONbits.T5RD16 = 1;
119:           	
120:               readValLow = TMR5L;
121:               readValHigh = TMR5H;
122:               
123:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
124:           
125:               return readVal;
126:           }
127:           
128:           void TMR5_WriteTimer(uint16_t timerVal)
129:           {
130:               if (T5CONbits.NOT_SYNC == 1)
3DF2  0103     MOVLB 0x3
3DF4  A536     BTFSS 0x36, 2, BANKED
3DF6  D009     BRA 0x3E0A
131:               {
132:                   // Stop the Timer by writing to TMRxON bit
133:                   T5CONbits.TMR5ON = 0;
3DF8  9136     BCF 0x36, 0, BANKED
134:           
135:                   // Write to the Timer5 register
136:                   TMR5H = (timerVal >> 8);
3DFC  F410     NOP
3DFE  F335     NOP
137:                   TMR5L = timerVal;
3E02  F40C     NOP
3E04  F334     NOP
138:           
139:                   // Start the Timer after writing to the register
140:                   T5CONbits.TMR5ON =1;
3E06  8136     BSF 0x36, 0, BANKED
141:               }
3E08  0012     RETURN 0
142:               else
143:               {
144:                   // Write to the Timer5 register
145:                   TMR5H = (timerVal >> 8);
3E0C  F410     NOP
3E0E  F335     NOP
146:                   TMR5L = timerVal;
3E12  F40C     NOP
3E14  F334     NOP
147:               }
148:           }
3E16  0012     RETURN 0
149:           
150:           void TMR5_Reload(void)
151:           {
152:               TMR5_WriteTimer(timer5ReloadVal);
153:           }
154:           
155:           void TMR5_StartSinglePulseAcquisition(void)
156:           {
157:               T5GCONbits.T5GGO = 1;
158:           }
159:           
160:           uint8_t TMR5_CheckGateValueStatus(void)
161:           {
162:               return (T5GCONbits.T5GVAL);
163:           }
164:           
165:           void __interrupt(irq(TMR5),base(8),low_priority) TMR5_ISR()
3B96  F360     NOP
3B98  F505     NOP
166:           {
167:               static volatile unsigned int CountCallBack = 0;
168:           
169:               // Clear the TMR5 interrupt flag
170:               PIR8bits.TMR5IF = 0;
3B9A  98B6     BCF 0xFB6, 4, ACCESS
171:               TMR5_WriteTimer(timer5ReloadVal);
3B9C  C53F     MOVFF timer5ReloadVal, timerVal
3B9E  F503     NOP
3BA0  C540     MOVFF 0x540, 0x504
3BA2  F504     NOP
3BA4  ECF9     CALL 0x3DF2, 0
3BA6  F01E     NOP
172:           
173:               // callback function - called every 100th pass
174:               if (++CountCallBack >= TMR5_INTERRUPT_TICKER_FACTOR)
3BA8  0105     MOVLB 0x5
3BAA  4BE5     INFSNZ 0xE5, F, BANKED
3BAC  2BE6     INCF 0xE6, F, BANKED
3BAE  51E6     MOVF 0xE6, W, BANKED
3BB0  E104     BNZ 0x3BBA
3BB2  0E64     MOVLW 0x64
3BB4  5DE5     SUBWF 0xE5, W, BANKED
3BB6  A0D8     BTFSS 0xFD8, 0, ACCESS
3BB8  D007     BRA 0x3BC8
175:               {
176:                   // ticker function call
177:                   TMR5_CallBack();
3BBA  EC31     CALL 0x3E62, 0
3BBC  F01F     NOP
178:           
179:                   // reset ticker counter
180:                   CountCallBack = 0;
3BBE  0E00     MOVLW 0x0
3BC0  0105     MOVLB 0x5
3BC2  6FE6     MOVWF 0xE6, BANKED
3BC4  0E00     MOVLW 0x0
3BC6  6FE5     MOVWF 0xE5, BANKED
181:               }
182:           }
3BCA  F414     NOP
3BCC  F4D8     NOP
3BCE  0011     RETFIE 1
183:           
184:           void TMR5_CallBack(void)
185:           {
186:               // Add your custom callback code here
187:               if(TMR5_InterruptHandler)
3E62  51D4     MOVF CLCDATA, W, BANKED
3E64  11D5     IORWF CLCSELECT, W, BANKED
3E66  11D6     IORWF CLCnCON, W, BANKED
3E68  B4D8     BTFSC 0xFD8, 2, ACCESS
3E6A  0012     RETURN 0
188:               {
189:                   TMR5_InterruptHandler();
3E6C  D801     RCALL 0x3E70
3E6E  0012     RETURN 0
3E70  0005     PUSH
3E72  6EFA     MOVWF 0xFFA, ACCESS
3E74  51D4     MOVF CLCDATA, W, BANKED
3E76  6EFD     MOVWF 0xFFD, ACCESS
3E78  51D5     MOVF CLCSELECT, W, BANKED
3E7A  6EFE     MOVWF 0xFFE, ACCESS
3E7C  51D6     MOVF CLCnCON, W, BANKED
3E7E  6EFF     MOVWF 0xFFF, ACCESS
3E80  50FA     MOVF 0xFFA, W, ACCESS
3E82  0012     RETURN 0
190:               }
191:           }
192:           
193:           void TMR5_SetInterruptHandler(void (* InterruptHandler)(void)){
194:               TMR5_InterruptHandler = InterruptHandler;
3FC4  C50D     MOVFF d1, TMR5_InterruptHandler
3FC6  F5D4     NOP
3FC8  C50E     MOVFF 0x50E, 0x5D5
3FCA  F5D5     NOP
3FCC  C50F     MOVFF s1, 0x5D6
3FCE  F5D6     NOP
195:           }
3FD0  0012     RETURN 0
196:           
197:           void TMR5_DefaultInterruptHandler(void){
198:               // add your TMR5 interrupt custom code
199:               // or set custom function using TMR5_SetInterruptHandler()
200:           }
4068  0012     RETURN 0
201:           
202:           /**
203:             End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/tmr4.c  --------------------
1:             /**
2:               TMR4 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr4.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR4 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR4.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above 
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr4.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            
59:            void (*TMR4_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR4 APIs
63:            */
64:            
65:            void TMR4_Initialize(void)
66:            {
67:                // Set TMR4 to the options selected in the User Interface
68:            
69:                // T4CS FOSC/4; 
70:                T4CLKCON = 0x01;
3D3E  0E01     MOVLW 0x1
3D40  0103     MOVLB 0x3
3D42  6F32     MOVWF 0x32, BANKED
71:            
72:                // T4PSYNC Not Synchronized; T4MODE Software control; T4CKPOL Rising Edge; T4CKSYNC Synchronized; 
73:                T4HLT = 0x20;
3D44  0E20     MOVLW 0x20
3D46  6F31     MOVWF 0x31, BANKED
74:            
75:                // T4RSEL T4CKIPPS pin; 
76:                T4RST = 0x00;
3D48  0E00     MOVLW 0x0
3D4A  6F33     MOVWF 0x33, BANKED
77:            
78:                // PR4 24; 
79:                T4PR = 0x18;
3D4C  0E18     MOVLW 0x18
3D4E  6F2F     MOVWF 0x2F, BANKED
80:            
81:                // TMR4 0; 
82:                T4TMR = 0x00;
3D50  0E00     MOVLW 0x0
3D52  6F2E     MOVWF 0x2E, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR11bits.TMR4IF = 0;
3D54  96B9     BCF 0xFB9, 3, ACCESS
86:            
87:                // Enabling TMR4 interrupt.
88:                PIE11bits.TMR4IE = 1;
3D56  86A9     BSF 0xFA9, 3, ACCESS
89:            
90:                // Set Default Interrupt Handler
91:                TMR4_SetInterruptHandler(TMR4_DefaultInterruptHandler);
3D58  0E6E     MOVLW 0x6E
3D5A  6E0D     MOVWF 0xD, ACCESS
3D5C  0E40     MOVLW 0x40
3D5E  6E0E     MOVWF 0xE, ACCESS
3D60  0E00     MOVLW 0x0
3D62  6E0F     MOVWF 0xF, ACCESS
3D64  ECE9     CALL 0x3FD2, 0
3D66  F01F     NOP
92:            
93:                // T4CKPS 1:8; T4OUTPS 1:16; TMR4ON on; 
94:                T4CON = 0xBF;
3D68  0EBF     MOVLW 0xBF
3D6A  6F30     MOVWF 0x30, BANKED
95:            }
3D6C  0012     RETURN 0
96:            
97:            void TMR4_ModeSet(TMR4_HLT_MODE mode)
98:            {
99:               // Configure different types HLT mode
100:               T4HLTbits.MODE = mode;
101:           }
102:           
103:           void TMR4_ExtResetSourceSet(TMR4_HLT_EXT_RESET_SOURCE reset)
104:           {
105:               //Configure different types of HLT external reset source
106:               T4RSTbits.RSEL = reset;
107:           }
108:           
109:           void TMR4_Start(void)
110:           {
111:               // Start the Timer by writing to TMRxON bit
112:               T4CONbits.TMR4ON = 1;
4036  0103     MOVLB 0x3
4038  8F30     BSF 0x30, 7, BANKED
405A  0103     MOVLB 0x3
113:           }
403A  0012     RETURN 0
405E  0012     RETURN 0
114:           
115:           void TMR4_StartTimer(void)
116:           {
117:               TMR4_Start();
4030  EC1B     CALL 0x4036, 0
4032  F020     NOP
4054  EC2D     CALL 0x405A, 0
118:           }
4034  0012     RETURN 0
4058  0012     RETURN 0
119:           
120:           void TMR4_Stop(void)
121:           {
122:               // Stop the Timer by writing to TMRxON bit
123:               T4CONbits.TMR4ON = 0;
402A  0103     MOVLB 0x3
402C  9F30     BCF 0x30, 7, BANKED
404E  0103     MOVLB 0x3
124:           }
402E  0012     RETURN 0
4052  0012     RETURN 0
4070  0011     RETFIE 1
125:           
126:           void TMR4_StopTimer(void)
127:           {
128:               TMR4_Stop();
129:           }
130:           
131:           uint8_t TMR4_Counter8BitGet(void)
132:           {
133:               uint8_t readVal;
134:           
135:               readVal = TMR4;
136:           
137:               return readVal;
138:           }
139:           
140:           uint8_t TMR4_ReadTimer(void)
141:           {
142:               return TMR4_Counter8BitGet();
143:           }
144:           
145:           void TMR4_Counter8BitSet(uint8_t timerVal)
146:           {
147:               // Write to the Timer4 register
148:               TMR4 = timerVal;
149:           }
150:           
151:           void TMR4_WriteTimer(uint8_t timerVal)
152:           {
153:               TMR4_Counter8BitSet(timerVal);
154:           }
155:           
156:           void TMR4_Period8BitSet(uint8_t periodVal)
157:           {
158:              PR4 = periodVal;
159:           }
160:           
161:           void TMR4_LoadPeriodRegister(uint8_t periodVal)
162:           {
163:              TMR4_Period8BitSet(periodVal);
164:           }
165:           
166:           void __interrupt(irq(TMR4),base(8),low_priority) TMR4_ISR()
167:           {
168:           
169:               // clear the TMR4 interrupt flag
170:               PIR11bits.TMR4IF = 0;
3C7A  96B9     BCF 0xFB9, 3, ACCESS
171:           
172:               if(TMR4_InterruptHandler)
3C7C  0105     MOVLB 0x5
3C7E  51C2     MOVF 0xC2, W, BANKED
3C80  11C3     IORWF 0xC3, W, BANKED
3C82  11C4     IORWF 0xC4, W, BANKED
3C84  B4D8     BTFSC 0xFD8, 2, ACCESS
3C86  D00C     BRA 0x3CA0
173:               {
174:                   TMR4_InterruptHandler();
3C88  D801     RCALL 0x3C8C
3C8A  D00A     BRA 0x3CA0
3C8C  0005     PUSH
3C8E  6EFA     MOVWF 0xFFA, ACCESS
3C90  51C2     MOVF 0xC2, W, BANKED
3C92  6EFD     MOVWF 0xFFD, ACCESS
3C94  51C3     MOVF 0xC3, W, BANKED
3C96  6EFE     MOVWF 0xFFE, ACCESS
3C98  51C4     MOVF 0xC4, W, BANKED
3C9A  6EFF     MOVWF 0xFFF, ACCESS
3C9C  50FA     MOVF 0xFFA, W, ACCESS
3C9E  0012     RETURN 0
175:               }
176:           }
3CA2  F430     NOP
3CA4  F4D8     NOP
3CA6  0011     RETFIE 1
177:           
178:           
179:           void TMR4_SetInterruptHandler(void (* InterruptHandler)(void)){
180:               TMR4_InterruptHandler = InterruptHandler;
3FD2  C50D     MOVFF d1, TMR4_InterruptHandler
3FD4  F5C2     NOP
3FD6  C50E     MOVFF 0x50E, 0x5C3
3FD8  F5C3     NOP
3FDA  C50F     MOVFF s1, 0x5C4
3FDC  F5C4     NOP
181:           }
3FDE  0012     RETURN 0
182:           
183:           void TMR4_DefaultInterruptHandler(void){
184:               // add your TMR4 interrupt custom code
185:               // or set custom function using TMR4_SetInterruptHandler()
186:           }
406E  0012     RETURN 0
187:           
188:           /**
189:             End of File
190:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/tmr2.c  --------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above 
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
3F22  0E01     MOVLW 0x1
3F24  6F26     MOVWF 0x26, BANKED
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
3F26  0E00     MOVLW 0x0
3F28  6F25     MOVWF 0x25, BANKED
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
3F2A  0E00     MOVLW 0x0
3F2C  6F27     MOVWF 0x27, BANKED
74:            
75:                // PR2 15; 
76:                T2PR = 0x0F;
3F2E  0E0F     MOVLW 0xF
3F30  6F23     MOVWF 0x23, BANKED
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
3F32  0E00     MOVLW 0x0
3F34  6F22     MOVWF 0x22, BANKED
80:            
81:                // Clearing IF flag.
82:                PIR3bits.TMR2IF = 0;
3F36  96B1     BCF 0xFB1, 3, ACCESS
83:            
84:                // T2CKPS 1:1; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0x80;
3F38  0E80     MOVLW 0x80
3F3A  6F24     MOVWF 0x24, BANKED
86:            }
3F3C  0012     RETURN 0
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR3bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR3bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/spi1.c  --------------------
1:             /**
2:               SPI1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the SPI1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for SPI1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above or later
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "spi1.h"
48:            #include <xc.h>
49:            
50:            typedef struct { 
51:                uint8_t con0; 
52:                uint8_t con1; 
53:                uint8_t con2; 
54:                uint8_t baud; 
55:                uint8_t operation;
56:            } spi1_configuration_t;
57:            
58:            
59:            //con0 == SPIxCON0, con1 == SPIxCON1, con2 == SPIxCON2, baud == SPIxBAUD, operation == Master/Slave
60:            static const spi1_configuration_t spi1_configuration[] = {   
61:                { 0x3, 0x24, 0x3, 0x4, 0 }
62:            };
63:            
64:            void SPI1_Initialize(void)
65:            {
66:                //EN disabled; LSBF MSb first; MST bus master; BMODE every byte; 
67:                SPI1CON0 = 0x03;
3F3E  0E03     MOVLW 0x3
3F40  0100     MOVLB 0x0
3F42  6F84     MOVWF SPI1CON0, BANKED
68:                //SMP Middle; CKE Idle to active; CKP Idle:High, Active:Low; FST disabled; SSP active low; SDIP active high; SDOP active high; 
69:                SPI1CON1 = 0x24;
3F44  0E24     MOVLW 0x24
3F46  6F85     MOVWF SPI1CON1, BANKED
70:                //SSET disabled; TXR required for a transfer; RXR suspended if the RxFIFO is full; 
71:                SPI1CON2 = 0x03;
3F48  0E03     MOVLW 0x3
3F4A  6F86     MOVWF SPI1CON2, BANKED
72:                //CLKSEL MFINTOSC; 
73:                SPI1CLK = 0x02;
3F4C  0E02     MOVLW 0x2
3F4E  6F8C     MOVWF SPI1CLK, BANKED
74:                //BAUD 4; 
75:                SPI1BAUD = 0x04;
3F50  0E04     MOVLW 0x4
3F52  6F89     MOVWF SPI1BAUD, BANKED
76:                TRISCbits.TRISC3 = 0;
3F54  96C8     BCF 0xFC8, 3, ACCESS
77:            }
3F56  0012     RETURN 0
78:            
79:            bool SPI1_Open(spi1_modes_t spi1UniqueConfiguration)
80:            {
81:                if(!SPI1CON0bits.EN)
82:                {
83:                    SPI1CON0 = spi1_configuration[spi1UniqueConfiguration].con0;
84:                    SPI1CON1 = spi1_configuration[spi1UniqueConfiguration].con1;
85:                    SPI1CON2 = spi1_configuration[spi1UniqueConfiguration].con2 | (_SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK);
86:                    SPI1CLK  = 0x00;
87:                    SPI1BAUD = spi1_configuration[spi1UniqueConfiguration].baud;        
88:                    TRISCbits.TRISC3 = spi1_configuration[spi1UniqueConfiguration].operation;
89:                    SPI1CON0bits.EN = 1;
90:                    return true;
91:                }
92:                return false;
93:            }
94:            
95:            void SPI1_Close(void)
96:            {
97:                SPI1CON0bits.EN = 0;
98:            }
99:            
100:           uint8_t SPI1_ExchangeByte(uint8_t data)
3F58  6E0D     MOVWF 0xD, ACCESS
101:           {
102:               SPI1TCNTL = 1;
3F5A  0E01     MOVLW 0x1
3F5C  0100     MOVLB 0x0
3F5E  6F82     MOVWF SPI1TCNT, BANKED
103:               SPI1TXB = data;
3F62  F434     NOP
3F64  F081     NOP
104:               while(!PIR3bits.SPI1RXIF);
3F66  A0B1     BTFSS 0xFB1, 0, ACCESS
3F68  D7FE     BRA 0x3F66
105:               return SPI1RXB;
3F6A  0100     MOVLB 0x0
3F6C  5180     MOVF SPI1RXB, W, BANKED
106:           }
3F6E  0012     RETURN 0
107:           
108:           void SPI1_ExchangeBlock(void *block, size_t blockSize)
109:           {
110:               uint8_t *data = block;
39B6  C50D     MOVFF d1, n
39B8  F511     NOP
39BA  C50E     MOVFF 0x50E, 0x512
39BC  F512     NOP
111:               while(blockSize--)
39BE  D017     BRA 0x39EE
39EE  060F     DECF 0xF, F, ACCESS
112:               {
113:                   SPI1TCNTL = 1;
39C0  0E01     MOVLW 0x1
39C2  0100     MOVLB 0x0
39C4  6F82     MOVWF SPI1TCNT, BANKED
114:                   SPI1TXB = *data;
39C8  F444     NOP
39CA  F4D9     NOP
39CE  F448     NOP
39D0  F4DA     NOP
39D2  50DF     MOVF 0xFDF, W, ACCESS
39D4  6F81     MOVWF SPI1TXB, BANKED
115:                   while(!PIR3bits.SPI1RXIF);
39D6  A0B1     BTFSS 0xFB1, 0, ACCESS
39D8  D7FE     BRA 0x39D6
116:                   *data++ = SPI1RXB;
39DC  F444     NOP
39DE  F4D9     NOP
39E2  F448     NOP
39E4  F4DA     NOP
39E6  C080     MOVFF SPI1RXB, INDF2
39E8  F4DF     NOP
39EA  4A11     INFSNZ 0x11, F, ACCESS
39EC  2A12     INCF 0x12, F, ACCESS
39EE  060F     DECF 0xF, F, ACCESS
39F0  A0D8     BTFSS 0xFD8, 0, ACCESS
39F2  0610     DECF 0x10, F, ACCESS
39F4  280F     INCF 0xF, W, ACCESS
39F6  E1E4     BNZ 0x39C0
39F8  2810     INCF 0x10, W, ACCESS
39FA  B4D8     BTFSC 0xFD8, 2, ACCESS
39FC  0012     RETURN 0
39FE  D7E0     BRA 0x39C0
117:               }
118:           }
119:           
120:           // Half Duplex SPI Functions
121:           void SPI1_WriteBlock(void *block, size_t blockSize)
122:           {
123:               uint8_t *data = block;
124:               while(blockSize--)
125:               {
126:                   SPI1_ExchangeByte(*data++);
127:               }
128:           }
129:           
130:           void SPI1_ReadBlock(void *block, size_t blockSize)
131:           {
132:               uint8_t *data = block;
133:               while(blockSize--)
134:               {
135:                   *data++ = SPI1_ExchangeByte(0);
136:               }
137:           }
138:           
139:           void SPI1_WriteByte(uint8_t byte)
140:           {
141:               SPI1TXB = byte;
142:           }
143:           
144:           uint8_t SPI1_ReadByte(void)
145:           {
146:               return SPI1RXB;
147:           }
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/pin_manager.c  -------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB             :  MPLAB X 5.40
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x07;
335E  0E07     MOVLW 0x7
3360  6EC2     MOVWF 0xFC2, ACCESS
61:                LATD = 0x00;
3362  0E00     MOVLW 0x0
3364  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
3366  0E00     MOVLW 0x0
3368  6EBE     MOVWF 0xFBE, ACCESS
63:                LATB = 0x00;
336A  0E00     MOVLW 0x0
336C  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x2E;
336E  0E2E     MOVLW 0x2E
3370  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x00;
3372  0E00     MOVLW 0x0
3374  6ECA     MOVWF 0xFCA, ACCESS
70:                TRISA = 0xD5;
3376  0ED5     MOVLW 0xD5
3378  6EC6     MOVWF 0xFC6, ACCESS
71:                TRISB = 0x80;
337A  0E80     MOVLW 0x80
337C  6EC7     MOVWF 0xFC7, ACCESS
72:                TRISC = 0x91;
337E  0E91     MOVLW 0x91
3380  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0x3C;
3382  0E3C     MOVLW 0x3C
3384  6EC9     MOVWF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0x3C;
3386  0E3C     MOVLW 0x3C
3388  0104     MOVLB 0x4
338A  6F18     MOVWF 0x18, BANKED
79:                ANSELC = 0x01;
338C  0E01     MOVLW 0x1
338E  6F10     MOVWF 0x10, BANKED
80:                ANSELB = 0x80;
3390  0E80     MOVLW 0x80
3392  6F08     MOVWF 0x8, BANKED
81:                ANSELE = 0x00;
3394  0E00     MOVLW 0x0
3396  6F20     MOVWF 0x20, BANKED
82:                ANSELA = 0xC0;
3398  0EC0     MOVLW 0xC0
339A  6F00     MOVWF data, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
339C  0E00     MOVLW 0x0
339E  6F19     MOVWF 0x19, BANKED
88:                WPUE = 0x06;
33A0  0E06     MOVLW 0x6
33A2  6F21     MOVWF 0x21, BANKED
89:                WPUB = 0x00;
33A4  0E00     MOVLW 0x0
33A6  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x15;
33A8  0E15     MOVLW 0x15
33AA  6F01     MOVWF 0x1, BANKED
91:                WPUC = 0x06;
33AC  0E06     MOVLW 0x6
33AE  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                RxyI2C registers
95:                */
96:                RB1I2C = 0x00;
33B0  0E00     MOVLW 0x0
33B2  0102     MOVLB 0x2
33B4  6F89     MOVWF SPI1BAUD, BANKED
97:                RB2I2C = 0x00;
33B6  0E00     MOVLW 0x0
33B8  6F88     MOVWF SPI1TWIDTH, BANKED
98:                RC3I2C = 0x00;
33BA  0E00     MOVLW 0x0
33BC  6F87     MOVWF SPI1STATUS, BANKED
99:                RC4I2C = 0x00;
33BE  0E00     MOVLW 0x0
33C0  6F86     MOVWF SPI1CON2, BANKED
100:           
101:               /**
102:               ODx registers
103:               */
104:               ODCONE = 0x00;
33C2  0E00     MOVLW 0x0
33C4  0104     MOVLB 0x4
33C6  6F22     MOVWF 0x22, BANKED
105:               ODCONA = 0x00;
33C8  0E00     MOVLW 0x0
33CA  6F02     MOVWF 0x2, BANKED
106:               ODCONB = 0x00;
33CC  0E00     MOVLW 0x0
33CE  6F0A     MOVWF 0xA, BANKED
107:               ODCONC = 0x00;
33D0  0E00     MOVLW 0x0
33D2  6F12     MOVWF 0x12, BANKED
108:               ODCOND = 0x00;
33D4  0E00     MOVLW 0x0
33D6  6F1A     MOVWF 0x1A, BANKED
109:           
110:               /**
111:               SLRCONx registers
112:               */
113:               SLRCONA = 0x00;
33D8  0E00     MOVLW 0x0
33DA  6F03     MOVWF 0x3, BANKED
114:               SLRCONB = 0x00;
33DC  0E00     MOVLW 0x0
33DE  6F0B     MOVWF 0xB, BANKED
115:               SLRCONC = 0xFF;
33E0  6913     SETF 0x13, BANKED
116:               SLRCOND = 0x00;
33E2  0E00     MOVLW 0x0
33E4  6F1B     MOVWF 0x1B, BANKED
117:               SLRCONE = 0x00;
33E6  0E00     MOVLW 0x0
33E8  6F23     MOVWF 0x23, BANKED
118:           
119:               /**
120:               INLVLx registers
121:               */
122:               INLVLA = 0xFF;
33EA  6904     SETF 0x4, BANKED
123:               INLVLB = 0xFF;
33EC  690C     SETF 0xC, BANKED
124:               INLVLC = 0xFF;
33EE  6914     SETF 0x14, BANKED
125:               INLVLD = 0xFF;
33F0  691C     SETF 0x1C, BANKED
126:               INLVLE = 0x0F;
33F2  0E0F     MOVLW 0xF
33F4  6F24     MOVWF 0x24, BANKED
127:           
128:           
129:           
130:           
131:           
132:              
133:               
134:           	
135:               SPI1SCKPPS = 0x13;   //RC3->SPI1:SCK1;    
33F6  0E13     MOVLW 0x13
33F8  0102     MOVLB 0x2
33FA  6F6A     MOVWF MD1CON0, BANKED
136:               RC3PPS = 0x31;   //RC3->SPI1:SCK1;    
33FC  0E31     MOVLW 0x31
33FE  6F14     MOVWF 0x14, BANKED
137:               RC5PPS = 0x32;   //RC5->SPI1:SDO1;    
3400  0E32     MOVLW 0x32
3402  6F16     MOVWF 0x16, BANKED
138:               RC6PPS = 0x20;   //RC6->UART1:TX1;    
3404  0E20     MOVLW 0x20
3406  6F17     MOVWF 0x17, BANKED
139:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
3408  0E17     MOVLW 0x17
340A  6F72     MOVWF CM1NCH, BANKED
140:               SPI1SDIPPS = 0x14;   //RC4->SPI1:SDI1;    
340C  0E14     MOVLW 0x14
340E  6F6B     MOVWF MD1CON1, BANKED
141:           }
3410  0012     RETURN 0
142:             
143:           void PIN_MANAGER_IOC(void)
144:           {   
145:           }
146:           
147:           /**
148:            End of File
149:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/mcc.c  ---------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above or later
21:                    MPLAB             :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
3C0A  EC24     CALL 0x3A48, 0
3C0C  F01D     NOP
53:                PMD_Initialize();
3C0E  EC1F     CALL 0x3E3E, 0
3C10  F01F     NOP
54:                PIN_MANAGER_Initialize();
3C12  ECAF     CALL 0x335E, 0
3C14  F019     NOP
55:                OSCILLATOR_Initialize();
3C16  EC62     CALL 0x3EC4, 0
3C18  F01F     NOP
56:                TMR6_Initialize();
3C1A  EC87     CALL 0x3D0E, 0
3C1C  F01E     NOP
57:                DMA6_Initialize();
3C1E  ECB5     CALL 0x396A, 0
3C20  F01C     NOP
58:                DMA5_Initialize();
3C22  ECB8     CALL 0x3770, 0
3C24  F01B     NOP
59:                TMR4_Initialize();
3C26  EC9F     CALL 0x3D3E, 0
3C28  F01E     NOP
60:                TMR2_Initialize();
3C2A  EC91     CALL 0x3F22, 0
3C2C  F01F     NOP
61:                TMR5_Initialize();
3C2E  EC48     CALL 0x3A90, 0
3C30  F01D     NOP
62:                UART1_Initialize();
3C32  EC09     CALL 0x3412, 0
3C34  F01A     NOP
63:                SPI1_Initialize();
3C36  EC9F     CALL 0x3F3E, 0
3C38  F01F     NOP
64:                SystemArbiter_Initialize();
3C3A  ECFD     CALL 0x3FFA, 0
3C3C  F01F     NOP
65:            }
3C3E  0012     RETURN 0
66:            
67:            void OSCILLATOR_Initialize(void)
68:            {
69:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
70:                OSCCON1 = 0x20;
3EC4  0E20     MOVLW 0x20
3EC6  0100     MOVLB 0x0
3EC8  6FAD     MOVWF OSCCON1, BANKED
71:                // CSWHOLD may proceed; SOSCPWR Low power; 
72:                OSCCON3 = 0x00;
3ECA  0E00     MOVLW 0x0
3ECC  6FAF     MOVWF OSCCON3, BANKED
73:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
74:                OSCEN = 0x00;
3ECE  0E00     MOVLW 0x0
3ED0  6FB3     MOVWF OSCEN, BANKED
75:                // HFFRQ 4_MHz; 
76:                OSCFRQ = 0x02;
3ED2  0E02     MOVLW 0x2
3ED4  6FB1     MOVWF OSCFRQ, BANKED
77:                // TUN 0; 
78:                OSCTUNE = 0x00;
3ED6  0E00     MOVLW 0x0
3ED8  6FB0     MOVWF OSCTUNE, BANKED
79:                // ACTUD enabled; ACTEN disabled; 
80:                ACTCON = 0x00;
3EDA  0E00     MOVLW 0x0
3EDC  6FAC     MOVWF ACTCON, BANKED
81:                // Wait for PLL to stabilize
82:                while(PLLR == 0)
83:                {
84:                }
3EDE  B1B2     BTFSC OSCSTAT, 0, BANKED
3EE0  0012     RETURN 0
3EE2  D7FD     BRA 0x3EDE
85:            }
86:            
87:            void PMD_Initialize(void)
88:            {
89:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; 
90:                PMD0 = 0x00;
3E3E  0E00     MOVLW 0x0
3E40  0100     MOVLB 0x0
3E42  6F60     MOVWF PMD0, BANKED
91:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
92:                PMD1 = 0x00;
3E44  0E00     MOVLW 0x0
3E46  6F61     MOVWF PMD1, BANKED
93:                // ZCDMD ZCD enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; DAC1MD DAC1 enabled; 
94:                PMD3 = 0x00;
3E48  0E00     MOVLW 0x0
3E4A  6F63     MOVWF PMD3, BANKED
95:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
96:                PMD4 = 0x00;
3E4C  0E00     MOVLW 0x0
3E4E  6F64     MOVWF PMD4, BANKED
97:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM3MD PWM3 enabled; 
98:                PMD5 = 0x00;
3E50  0E00     MOVLW 0x0
3E52  6F65     MOVWF PMD5, BANKED
99:                // U5MD UART5 enabled; U4MD UART4 enabled; U3MD UART3 enabled; U2MD UART2 enabled; U1MD UART1 enabled; SPI2MD SPI2 enabled; SPI1MD SPI1 enabled; I2C1MD I2C1 enabled; 
100:               PMD6 = 0x00;
3E54  0E00     MOVLW 0x0
3E56  6F66     MOVWF PMD6, BANKED
101:               // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
102:               PMD7 = 0x00;
3E58  0E00     MOVLW 0x0
3E5A  6F67     MOVWF PMD7, BANKED
103:               // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
104:               PMD8 = 0x00;
3E5C  0E00     MOVLW 0x0
3E5E  6F68     MOVWF PMD8, BANKED
105:           }
3E60  0012     RETURN 0
106:           
107:           
108:           void SystemArbiter_Initialize(void)
109:           {
110:               // This function is dependant on the PR1WAY CONFIG bit
111:               PRLOCK = 0x55;
3FFA  0E55     MOVLW 0x55
3FFC  6FB4     MOVWF PRLOCK, BANKED
112:               PRLOCK = 0xAA;
3FFE  0EAA     MOVLW 0xAA
4000  6FB4     MOVWF PRLOCK, BANKED
113:               PRLOCKbits.PRLOCKED = 1;
4002  81B4     BSF PRLOCK, 0, BANKED
114:           }
4004  0012     RETURN 0
115:           /**
116:            End of File
117:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/interrupt_manager.c  -------
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
19:                    Device            :  PIC18F47Q43
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.30 and above or later
23:                    MPLAB 	          :  MPLAB X 5.40
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                INTCON0bits.IPEN = 1;
3A48  8AD6     BSF 0xFD6, 5, ACCESS
55:            
56:                bool state = (unsigned char)GIE;
3A4A  0E00     MOVLW 0x0
3A4C  BED6     BTFSC 0xFD6, 7, ACCESS
3A4E  0E01     MOVLW 0x1
3A50  6E0D     MOVWF 0xD, ACCESS
57:                GIE = 0;
3A52  9ED6     BCF 0xFD6, 7, ACCESS
58:                IVTLOCK = 0x55;
3A54  0E55     MOVLW 0x55
3A56  0104     MOVLB 0x4
3A58  6F59     MOVWF 0x59, BANKED
59:                IVTLOCK = 0xAA;
3A5A  0EAA     MOVLW 0xAA
3A5C  6F59     MOVWF 0x59, BANKED
60:                IVTLOCKbits.IVTLOCKED = 0x00; // unlock IVT
3A5E  9159     BCF 0x59, 0, BANKED
61:            
62:                IVTBASEU = 0;
3A60  0E00     MOVLW 0x0
3A62  6F5F     MOVWF 0x5F, BANKED
63:                IVTBASEH = 0;
3A64  0E00     MOVLW 0x0
3A66  6F5E     MOVWF 0x5E, BANKED
64:                IVTBASEL = 8;
3A68  0E08     MOVLW 0x8
3A6A  6F5D     MOVWF 0x5D, BANKED
65:            
66:                IVTLOCK = 0x55;
3A6C  0E55     MOVLW 0x55
3A6E  6F59     MOVWF 0x59, BANKED
67:                IVTLOCK = 0xAA;
3A70  0EAA     MOVLW 0xAA
3A72  6F59     MOVWF 0x59, BANKED
68:                IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
3A74  8159     BSF 0x59, 0, BANKED
69:            
70:                GIE = state;
3A76  B00D     BTFSC 0xD, 0, ACCESS
3A78  D002     BRA 0x3A7E
3A7A  9ED6     BCF 0xFD6, 7, ACCESS
3A7C  D001     BRA 0x3A80
3A7E  8ED6     BSF 0xFD6, 7, ACCESS
71:                // Assign peripheral interrupt priority vectors
72:                IPR12bits.DMA5DCNTIP = 1;
3A80  0103     MOVLB 0x3
3A82  8B6E     BSF MD1CARH, 5, BANKED
73:                IPR4bits.U1TXIP = 0;
3A84  9366     BCF PMD6, 1, BANKED
74:                IPR4bits.U1RXIP = 0;
3A86  9166     BCF PMD6, 0, BANKED
75:                IPR15bits.TMR6IP = 0;
3A88  9771     BCF CM1CON1, 3, BANKED
76:                IPR8bits.TMR5IP = 0;
3A8A  996A     BCF MD1CON0, 4, BANKED
77:                IPR11bits.TMR4IP = 0;
3A8C  976D     BCF MD1CARL, 3, BANKED
78:            }
3A8E  0012     RETURN 0
79:            
80:            void __interrupt(irq(default),base(8)) Default_ISR()
4070  0011     RETFIE 1
81:            {
82:            }
3E18  9ABA     BCF 0xFBA, 5, ACCESS
83:            
84:            /**
85:             End of File
86:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/dma6.c  --------------------
1:             /**
2:               DMA6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA6.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma6.h"
53:            
54:            
55:            /**
56:              Section: DMA6 APIs
57:            */
58:            
59:            void DMA6_Initialize(void)
60:            {
61:                //DMA Instance Selection : 0x05
62:                DMASELECT = 0x05;
396A  0E05     MOVLW 0x5
396C  0100     MOVLB 0x0
396E  6FE8     MOVWF DMASELECT, BANKED
63:                //Source Address : hsync
64:                DMAnSSA = &hsync;
3970  0E00     MOVLW 0x0
3972  6FF9     MOVWF DMAnSSA, BANKED
3974  0E0A     MOVLW 0xA
3976  6FFA     MOVWF DMAnSSAH, BANKED
3978  0E00     MOVLW 0x0
397A  6FFB     MOVWF DMAnSSAU, BANKED
65:                //Destination Address : &DstVarName5
66:                DMAnDSA= &DstVarName5;
397C  0E05     MOVLW 0x5
397E  6FF1     MOVWF DMAnDSAH, BANKED
3980  0EE7     MOVLW 0xE7
3982  6FF0     MOVWF DMAnDSA, BANKED
67:                //DMODE unchanged; DSTP not cleared; SMR GPR; SMODE incremented; SSTP not cleared; 
68:                DMAnCON1 = 0x02;
3984  0E02     MOVLW 0x2
3986  6FFD     MOVWF DMAnCON1, BANKED
69:                //Source Message Size : 1
70:                DMAnSSZ = 1;
3988  0E00     MOVLW 0x0
398A  6FF8     MOVWF DMAnSSZH, BANKED
398C  0E01     MOVLW 0x1
398E  6FF7     MOVWF DMAnSSZ, BANKED
71:                //Destination Message Size : 1
72:                DMAnDSZ = 1;
3990  0E00     MOVLW 0x0
3992  6FEF     MOVWF DMAnDSZH, BANKED
3994  0E01     MOVLW 0x1
3996  6FEE     MOVWF DMAnDSZ, BANKED
73:                //Start Trigger : SIRQ None; 
74:                DMAnSIRQ = 0x00;
3998  0E00     MOVLW 0x0
399A  6FFF     MOVWF DMAnSIRQ, BANKED
75:                //Abort Trigger : AIRQ None; 
76:                DMAnAIRQ = 0x00;
399C  0E00     MOVLW 0x0
399E  6FFE     MOVWF DMAnAIRQ, BANKED
77:            	
78:                // Clear Destination Count Interrupt Flag bit
79:                PIR13bits.DMA6DCNTIF = 0; 
39A0  9ABB     BCF 0xFBB, 5, ACCESS
80:                // Clear Source Count Interrupt Flag bit
81:                PIR13bits.DMA6SCNTIF = 0; 
39A2  98BB     BCF 0xFBB, 4, ACCESS
82:                // Clear Abort Interrupt Flag bit
83:                PIR13bits.DMA6AIF = 0; 
39A4  9EBB     BCF 0xFBB, 7, ACCESS
84:                // Clear Overrun Interrupt Flag bit
85:                PIR13bits.DMA6ORIF =0; 
39A6  9CBB     BCF 0xFBB, 6, ACCESS
86:                
87:                PIE13bits.DMA6DCNTIE = 0;
39A8  9AAB     BCF 0xFAB, 5, ACCESS
88:                PIE13bits.DMA6SCNTIE = 0;
39AA  98AB     BCF 0xFAB, 4, ACCESS
89:                PIE13bits.DMA6AIE = 0;
39AC  9EAB     BCF 0xFAB, 7, ACCESS
90:                PIE13bits.DMA6ORIE = 0;
39AE  9CAB     BCF 0xFAB, 6, ACCESS
91:            	
92:                //EN enabled; SIRQEN disabled; DGO not in progress; AIRQEN disabled; 
93:                DMAnCON0 = 0x80;
39B0  0E80     MOVLW 0x80
39B2  6FFC     MOVWF DMAnCON0, BANKED
94:            	
95:            }
39B4  0012     RETURN 0
96:            
97:            void DMA6_SelectSourceRegion(uint8_t region)
98:            {
99:                DMASELECT = 0x05;
100:           	DMAnCON1bits.SMR  = region;
101:           }
102:           
103:           void DMA6_SetSourceAddress(uint24_t address)
104:           {
105:               DMASELECT = 0x05;
106:           	DMAnSSA = address;
107:           }
108:           
109:           void DMA6_SetDestinationAddress(uint16_t address)
110:           {
111:               DMASELECT = 0x05;
112:           	DMAnDSA = address;
113:           }
114:           
115:           void DMA6_SetSourceSize(uint16_t size)
116:           {
117:               DMASELECT = 0x05;
118:           	DMAnSSZ= size;
119:           }
120:           
121:           void DMA6_SetDestinationSize(uint16_t size)
122:           {                     
123:               DMASELECT = 0x05;
124:           	DMAnDSZ= size;
125:           }
126:           
127:           uint24_t DMA6_GetSourcePointer(void)
128:           {
129:               DMASELECT = 0x05;
130:           	return DMAnSPTR;
131:           }
132:           
133:           uint16_t DMA6_GetDestinationPointer(void)
134:           {
135:               DMASELECT = 0x05;
136:           	return DMAnDPTR;
137:           }
138:           
139:           void DMA6_SetStartTrigger(uint8_t sirq)
140:           {
141:               DMASELECT = 0x05;
142:           	DMAnSIRQ = sirq;
143:           }
144:           
145:           void DMA6_SetAbortTrigger(uint8_t airq)
146:           {
147:               DMASELECT = 0x05;
148:           	DMAnAIRQ = airq;
149:           }
150:           
151:           void DMA6_StartTransfer(void)
152:           {
153:               DMASELECT = 0x05;
154:           	DMAnCON0bits.DGO = 1;
155:           }
156:           
157:           void DMA6_StartTransferWithTrigger(void)
158:           {
159:               DMASELECT = 0x05;
160:           	DMAnCON0bits.SIRQEN = 1;
161:           }
162:           
163:           void DMA6_StopTransfer(void)
164:           {
165:               DMASELECT = 0x05;
166:           	DMAnCON0bits.SIRQEN = 0; 
167:           	DMAnCON0bits.DGO = 0;
168:           }
169:           
170:           void DMA6_SetDMAPriority(uint8_t priority)
171:           {
172:               // This function is dependant on the PR1WAY CONFIG bit
173:           	PRLOCK = 0x55;
174:           	PRLOCK = 0xAA;
175:           	PRLOCKbits.PRLOCKED = 0;
176:           	DMA6PR = priority;
177:           	PRLOCK = 0x55;
178:           	PRLOCK = 0xAA;
179:           	PRLOCKbits.PRLOCKED = 1;
180:           }
181:           
182:           /**
183:            End of File
184:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/mcc_generated_files/dma5.c  --------------------
1:             /**
2:               DMA5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA5.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.30 and above
21:                    MPLAB 	          :  MPLAB X 5.40
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma5.h"
53:            
54:            void (*DMA5_DCNTI_InterruptHandler)(void);
55:            
56:            /**
57:              Section: DMA5 APIs
58:            */
59:            
60:            void DMA5_Initialize(void)
61:            {
62:                //DMA Instance Selection : 0x04
63:                DMASELECT = 0x04;
3770  0E04     MOVLW 0x4
3772  6FE8     MOVWF DMASELECT, BANKED
64:                //Source Address : vsync
65:                DMAnSSA = &vsync;
3774  0E00     MOVLW 0x0
3776  6FF9     MOVWF DMAnSSA, BANKED
3778  0E0C     MOVLW 0xC
377A  6FFA     MOVWF DMAnSSAH, BANKED
377C  0E00     MOVLW 0x0
377E  6FFB     MOVWF DMAnSSAU, BANKED
66:                //Destination Address : &PORTB
67:                DMAnDSA= &PORTB;
3780  0E04     MOVLW 0x4
3782  6FF1     MOVWF DMAnDSAH, BANKED
3784  0ECF     MOVLW 0xCF
3786  6FF0     MOVWF DMAnDSA, BANKED
68:                //DMODE unchanged; DSTP not cleared; SMR GPR; SMODE incremented; SSTP not cleared; 
69:                DMAnCON1 = 0x02;
3788  0E02     MOVLW 0x2
378A  6FFD     MOVWF DMAnCON1, BANKED
70:                //Source Message Size : 31
71:                DMAnSSZ = 243;
378C  0E00     MOVLW 0x0
378E  6FF8     MOVWF DMAnSSZH, BANKED
3790  0EF3     MOVLW 0xF3
3792  6FF7     MOVWF DMAnSSZ, BANKED
72:                //Destination Message Size : 13
73:                DMAnDSZ = 243;
3794  0E00     MOVLW 0x0
3796  6FEF     MOVWF DMAnDSZH, BANKED
3798  0EF3     MOVLW 0xF3
379A  6FEE     MOVWF DMAnDSZ, BANKED
74:                //Start Trigger : SIRQ None; 
75:                DMAnSIRQ = 0x00;
379C  0E00     MOVLW 0x0
379E  6FFF     MOVWF DMAnSIRQ, BANKED
76:                //Abort Trigger : AIRQ None; 
77:                DMAnAIRQ = 0x00;
37A0  0E00     MOVLW 0x0
37A2  6FFE     MOVWF DMAnAIRQ, BANKED
78:            	
79:                // Clear Destination Count Interrupt Flag bit
80:                PIR12bits.DMA5DCNTIF = 0; 
37A4  9ABA     BCF 0xFBA, 5, ACCESS
81:                // Clear Source Count Interrupt Flag bit
82:                PIR12bits.DMA5SCNTIF = 0; 
37A6  98BA     BCF 0xFBA, 4, ACCESS
83:                // Clear Abort Interrupt Flag bit
84:                PIR12bits.DMA5AIF = 0; 
37A8  9EBA     BCF 0xFBA, 7, ACCESS
85:                // Clear Overrun Interrupt Flag bit
86:                PIR12bits.DMA5ORIF =0; 
37AA  9CBA     BCF 0xFBA, 6, ACCESS
87:                
88:                PIE12bits.DMA5DCNTIE = 1;
37AC  8AAA     BSF 0xFAA, 5, ACCESS
89:            	DMA5_SetDCNTIInterruptHandler(DMA5_DefaultInterruptHandler);
37AE  0E72     MOVLW 0x72
37B0  6E0D     MOVWF 0xD, ACCESS
37B2  0E40     MOVLW 0x40
37B4  6E0E     MOVWF 0xE, ACCESS
37B6  0E00     MOVLW 0x0
37B8  6E0F     MOVWF 0xF, ACCESS
37BA  ECF0     CALL 0x3FE0, 0
37BC  F01F     NOP
90:                PIE12bits.DMA5SCNTIE = 0;
37BE  98AA     BCF 0xFAA, 4, ACCESS
91:                PIE12bits.DMA5AIE = 0;
37C0  9EAA     BCF 0xFAA, 7, ACCESS
92:                PIE12bits.DMA5ORIE = 0;
37C2  9CAA     BCF 0xFAA, 6, ACCESS
93:            	
94:                //EN enabled; SIRQEN disabled; DGO not in progress; AIRQEN disabled; 
95:                DMAnCON0 = 0x80;
37C4  0E80     MOVLW 0x80
37C6  6FFC     MOVWF DMAnCON0, BANKED
96:            	
97:            }
37C8  0012     RETURN 0
98:            
99:            void DMA5_SelectSourceRegion(uint8_t region)
100:           {
101:               DMASELECT = 0x04;
102:           	DMAnCON1bits.SMR  = region;
103:           }
104:           
105:           void DMA5_SetSourceAddress(uint24_t address)
106:           {
107:               DMASELECT = 0x04;
108:           	DMAnSSA = address;
109:           }
110:           
111:           void DMA5_SetDestinationAddress(uint16_t address)
112:           {
113:               DMASELECT = 0x04;
114:           	DMAnDSA = address;
115:           }
116:           
117:           void DMA5_SetSourceSize(uint16_t size)
118:           {
119:               DMASELECT = 0x04;
120:           	DMAnSSZ= size;
121:           }
122:           
123:           void DMA5_SetDestinationSize(uint16_t size)
124:           {                     
125:               DMASELECT = 0x04;
126:           	DMAnDSZ= size;
127:           }
128:           
129:           uint24_t DMA5_GetSourcePointer(void)
130:           {
131:               DMASELECT = 0x04;
132:           	return DMAnSPTR;
133:           }
134:           
135:           uint16_t DMA5_GetDestinationPointer(void)
136:           {
137:               DMASELECT = 0x04;
138:           	return DMAnDPTR;
139:           }
140:           
141:           void DMA5_SetStartTrigger(uint8_t sirq)
142:           {
143:               DMASELECT = 0x04;
144:           	DMAnSIRQ = sirq;
145:           }
146:           
147:           void DMA5_SetAbortTrigger(uint8_t airq)
148:           {
149:               DMASELECT = 0x04;
150:           	DMAnAIRQ = airq;
151:           }
152:           
153:           void DMA5_StartTransfer(void)
154:           {
155:               DMASELECT = 0x04;
4006  0E04     MOVLW 0x4
4008  0100     MOVLB 0x0
400A  6FE8     MOVWF DMASELECT, BANKED
4010  0E04     MOVLW 0x4
156:           	DMAnCON0bits.DGO = 1;
400C  8BFC     BSF DMAnCON0, 5, BANKED
4016  8BFC     BSF DMAnCON0, 5, BANKED
157:           }
400E  0012     RETURN 0
4018  0012     RETURN 0
158:           
159:           void DMA5_StartTransferWithTrigger(void)
160:           {
161:               DMASELECT = 0x04;
162:           	DMAnCON0bits.SIRQEN = 1;
163:           }
164:           
165:           void DMA5_StopTransfer(void)
166:           {
167:               DMASELECT = 0x04;
3FEE  0E04     MOVLW 0x4
3FF0  0100     MOVLB 0x0
3FF2  6FE8     MOVWF DMASELECT, BANKED
168:           	DMAnCON0bits.SIRQEN = 0; 
3FF4  9DFC     BCF DMAnCON0, 6, BANKED
169:           	DMAnCON0bits.DGO = 0;
3FF6  9BFC     BCF DMAnCON0, 5, BANKED
170:           }
3FF8  0012     RETURN 0
171:           
172:           void DMA5_SetDMAPriority(uint8_t priority)
3E84  6E0D     MOVWF 0xD, ACCESS
173:           {
174:               // This function is dependant on the PR1WAY CONFIG bit
175:           	PRLOCK = 0x55;
3E86  0E55     MOVLW 0x55
3E88  0100     MOVLB 0x0
3E8A  6FB4     MOVWF PRLOCK, BANKED
176:           	PRLOCK = 0xAA;
3E8C  0EAA     MOVLW 0xAA
3E8E  6FB4     MOVWF PRLOCK, BANKED
177:           	PRLOCKbits.PRLOCKED = 0;
3E90  91B4     BCF PRLOCK, 0, BANKED
178:           	DMA5PR = priority;
3E94  F434     NOP
3E96  F0BA     NOP
179:           	PRLOCK = 0x55;
3E98  0E55     MOVLW 0x55
3E9A  6FB4     MOVWF PRLOCK, BANKED
180:           	PRLOCK = 0xAA;
3E9C  0EAA     MOVLW 0xAA
3E9E  6FB4     MOVWF PRLOCK, BANKED
181:           	PRLOCKbits.PRLOCKED = 1;
3EA0  81B4     BSF PRLOCK, 0, BANKED
182:           }
3EA2  0012     RETURN 0
183:           
184:           void __interrupt(irq(IRQ_DMA5DCNT),base(8)) DMA5_DMADCNTI_ISR()
185:           {
186:               // Clear the source count interrupt flag
187:               PIR12bits.DMA5DCNTIF = 0;
3E18  9ABA     BCF 0xFBA, 5, ACCESS
188:           
189:               if (DMA5_DCNTI_InterruptHandler)
3E1A  0105     MOVLB 0x5
3E1C  51C5     MOVF 0xC5, W, BANKED
3E1E  11C6     IORWF 0xC6, W, BANKED
3E20  11C7     IORWF 0xC7, W, BANKED
3E22  B4D8     BTFSC 0xFD8, 2, ACCESS
3E24  0011     RETFIE 1
190:                       DMA5_DCNTI_InterruptHandler();
3E26  D801     RCALL 0x3E2A
3E28  0011     RETFIE 1
3E2A  0005     PUSH
3E2C  6EFA     MOVWF 0xFFA, ACCESS
3E2E  51C5     MOVF 0xC5, W, BANKED
3E30  6EFD     MOVWF 0xFFD, ACCESS
3E32  51C6     MOVF 0xC6, W, BANKED
3E34  6EFE     MOVWF 0xFFE, ACCESS
3E36  51C7     MOVF 0xC7, W, BANKED
3E38  6EFF     MOVWF 0xFFF, ACCESS
3E3A  50FA     MOVF 0xFFA, W, ACCESS
3E3C  0012     RETURN 0
191:           }
192:           
193:           void DMA5_SetDCNTIInterruptHandler(void (* InterruptHandler)(void))
194:           {
195:           	 DMA5_DCNTI_InterruptHandler = InterruptHandler;
3FE0  C50D     MOVFF d1, DMA5_DCNTI_InterruptHandler
3FE2  F5C5     NOP
3FE4  C50E     MOVFF 0x50E, 0x5C6
3FE6  F5C6     NOP
3FE8  C50F     MOVFF s1, 0x5C7
3FEA  F5C7     NOP
196:           }
3FEC  0012     RETURN 0
197:           
198:           void DMA5_DefaultInterruptHandler(void){
199:               // add your DMA5 interrupt custom code
200:               // or set custom function using DMA5_SetSCNTIInterruptHandler() /DMA5_SetDCNTIInterruptHandler() /DMA5_SetAIInterruptHandler() /DMA5_SetORIInterruptHandler()
201:           }
4072  0012     RETURN 0
202:           /**
203:            End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/main.c  ----------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.6
17:            	Device            :  PIC18F47Q43
18:            	Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:             */
43:            #pragma warning disable 520
44:            #pragma warning disable 1498
45:            
46:            #include <stdlib.h>
47:            #include <stdbool.h>
48:            #include "mcc_generated_files/mcc.h"
49:            #include "mcc_generated_files/tmr5.h"
50:            #include "mcc_generated_files/tmr4.h"
51:            #include "qconfig.h"
52:            #include "vtouch.h"
53:            #include "vtouch_build.h"
54:            #include "timers.h"
55:            #include "eadog.h"
56:            #include "ntsc.h"
57:            
58:            volatile uint16_t tickCount[TMR_COUNT];
59:            char buffer[256];
60:            
61:            void led_flash(void);
62:            
63:            /*
64:             *			 Main application
65:             */
66:            void main(void)
67:            {
68:            
69:            	// Initialize the device
70:            	SYSTEM_Initialize();
31AC  EC05     CALL 0x3C0A, 0
31AE  F01E     NOP
71:            	TMR4_Stop();
31B0  EC15     CALL 0x402A, 0
31B2  F020     NOP
72:            	TMR5_SetInterruptHandler(led_flash);
31B4  0EC8     MOVLW 0xC8
31B6  6E0D     MOVWF 0xD, ACCESS
31B8  0E3D     MOVLW 0x3D
31BA  6E0E     MOVWF 0xE, ACCESS
31BC  0E00     MOVLW 0x0
31BE  6E0F     MOVWF 0xF, ACCESS
31C0  ECE2     CALL 0x3FC4, 0
31C2  F01F     NOP
73:            
74:            	// Enable high priority global interrupts
75:            	INTERRUPT_GlobalInterruptHighEnable();
31C4  8ED6     BSF 0xFD6, 7, ACCESS
76:            
77:            	// Enable low priority global interrupts.
78:            	INTERRUPT_GlobalInterruptLowEnable();
31C6  8CD6     BSF 0xFD6, 6, ACCESS
79:            
80:            	SPI1CON0bits.EN = 1;
31C8  0100     MOVLB 0x0
31CA  8F84     BSF SPI1CON0, 7, BANKED
81:            	init_display();
31CC  EC08     CALL 0x3610, 0
31CE  F01B     NOP
82:            	sprintf(buffer, "%s ", build_version);
31D0  0E00     MOVLW 0x0
31D2  6FF8     MOVWF DMAnSSZH, BANKED
31D4  0E07     MOVLW 0x7
31D6  6FF9     MOVWF DMAnSSA, BANKED
31D8  0E2C     MOVLW 0x2C
31DA  6FFA     MOVWF DMAnSSAH, BANKED
31DC  0E06     MOVLW 0x6
31DE  6FFB     MOVWF DMAnSSAU, BANKED
31E0  51FB     MOVF DMAnSSAU, W, BANKED
31E2  A4D8     BTFSS 0xFD8, 2, ACCESS
31E4  0E26     MOVLW 0x26
31E6  6FFC     MOVWF DMAnCON0, BANKED
31E8  EC11     CALL 0x3822, 0
31EA  F01C     NOP
83:            	eaDogM_WriteStringAtPos(0, 0, buffer);
31EC  0E00     MOVLW 0x0
31EE  6E21     MOVWF 0x21, ACCESS
31F0  0E00     MOVLW 0x0
31F2  6E22     MOVWF 0x22, ACCESS
31F4  0E07     MOVLW 0x7
31F6  6E23     MOVWF 0x23, ACCESS
31F8  0E00     MOVLW 0x0
31FA  EC87     CALL 0x370E, 0
31FC  F01B     NOP
84:            	sprintf(buffer, "%s ", build_date);
31FE  0E00     MOVLW 0x0
3200  0105     MOVLB 0x5
3202  6FF8     MOVWF DMAnSSZH, BANKED
3204  0E07     MOVLW 0x7
3206  6FF9     MOVWF DMAnSSA, BANKED
3208  0E2C     MOVLW 0x2C
320A  6FFA     MOVWF DMAnSSAH, BANKED
320C  0E17     MOVLW 0x17
320E  6FFB     MOVWF DMAnSSAU, BANKED
3210  51FB     MOVF DMAnSSAU, W, BANKED
3212  A4D8     BTFSS 0xFD8, 2, ACCESS
3214  0E26     MOVLW 0x26
3216  6FFC     MOVWF DMAnCON0, BANKED
3218  EC11     CALL 0x3822, 0
321A  F01C     NOP
85:            	eaDogM_WriteStringAtPos(1, 0, buffer);
321C  0E00     MOVLW 0x0
321E  6E21     MOVWF 0x21, ACCESS
3220  0E00     MOVLW 0x0
3222  6E22     MOVWF 0x22, ACCESS
3224  0E07     MOVLW 0x7
3226  6E23     MOVWF 0x23, ACCESS
3228  0E01     MOVLW 0x1
322A  EC87     CALL 0x370E, 0
322C  F01B     NOP
86:            	sprintf(buffer, "%s ", build_time);
322E  0E00     MOVLW 0x0
3230  0105     MOVLB 0x5
3232  6FF8     MOVWF DMAnSSZH, BANKED
3234  0E07     MOVLW 0x7
3236  6FF9     MOVWF DMAnSSA, BANKED
3238  0E2C     MOVLW 0x2C
323A  6FFA     MOVWF DMAnSSAH, BANKED
323C  0E23     MOVLW 0x23
323E  6FFB     MOVWF DMAnSSAU, BANKED
3240  51FB     MOVF DMAnSSAU, W, BANKED
3242  A4D8     BTFSS 0xFD8, 2, ACCESS
3244  0E26     MOVLW 0x26
3246  6FFC     MOVWF DMAnCON0, BANKED
3248  EC11     CALL 0x3822, 0
324A  F01C     NOP
87:            	eaDogM_WriteStringAtPos(2, 0, buffer);
324C  0E00     MOVLW 0x0
324E  6E21     MOVWF 0x21, ACCESS
3250  0E00     MOVLW 0x0
3252  6E22     MOVWF 0x22, ACCESS
3254  0E07     MOVLW 0x7
3256  6E23     MOVWF 0x23, ACCESS
3258  0E02     MOVLW 0x2
325A  EC87     CALL 0x370E, 0
325C  F01B     NOP
88:            	BLED_SetLow();
325E  90C2     BCF 0xFC2, 0, ACCESS
89:            
90:            	StartTimer(TMR_DIS, 500);
3260  0E01     MOVLW 0x1
3262  6E0E     MOVWF 0xE, ACCESS
3264  0EF4     MOVLW 0xF4
3266  6E0D     MOVWF 0xD, ACCESS
3268  0E06     MOVLW 0x6
326A  ECB7     CALL 0x3D6E, 0
326C  F01E     NOP
91:            
92:            	TMR6_Stop(); // disable software timers to stop scan-line jitter
326E  EC21     CALL 0x4042, 0
3270  F020     NOP
93:            	ntsc_init();
3272  EC19     CALL 0x2A32, 0
3274  F015     NOP
94:            
95:            	while (true) {
96:            		// Add your application code
97:            		BLED_Toggle();
3276  A0C2     BTFSS 0xFC2, 0, ACCESS
3278  D002     BRA 0x327E
327A  0E01     MOVLW 0x1
327C  D001     BRA 0x3280
327E  0E00     MOVLW 0x0
3280  0AFF     XORLW 0xFF
3282  6E3C     MOVWF 0x3C, ACCESS
3284  50C2     MOVF 0xFC2, W, ACCESS
3286  183C     XORWF 0x3C, W, ACCESS
3288  0BFE     ANDLW 0xFE
328A  183C     XORWF 0x3C, W, ACCESS
328C  6EC2     MOVWF 0xFC2, ACCESS
98:            		task_hold = true;
328E  0E01     MOVLW 0x1
3290  6E50     MOVWF 0x50, ACCESS
99:            		while (task_hold) {
3292  5050     MOVF 0x50, W, ACCESS
3294  B4D8     BTFSC 0xFD8, 2, ACCESS
3296  D7EF     BRA 0x3276
3298  D7FC     BRA 0x3292
100:           		};
101:           	}
102:           }
103:           
104:           /*
105:            * This runs in the timer5 ISR
106:            */
107:           void led_flash(void)
108:           {
109:           	LED2_Toggle();
3DC8  A2C1     BTFSS 0xFC1, 1, ACCESS
3DCA  D002     BRA 0x3DD0
3DCC  0E01     MOVLW 0x1
3DCE  D001     BRA 0x3DD2
3DD0  0E00     MOVLW 0x0
3DD2  0AFF     XORLW 0xFF
3DD4  6E03     MOVWF 0x3, ACCESS
3DD6  4603     RLNCF 0x3, F, ACCESS
3DD8  50C1     MOVF 0xFC1, W, ACCESS
3DDA  1803     XORWF 0x3, W, ACCESS
3DDC  0BFD     ANDLW 0xFD
3DDE  1803     XORWF 0x3, W, ACCESS
3DE0  6EC1     MOVWF 0xFC1, ACCESS
110:           	ntsc_flip = !ntsc_flip;
3DE2  5044     MOVF NVMADRH, W, ACCESS
3DE4  A4D8     BTFSS 0xFD8, 2, ACCESS
3DE6  D002     BRA 0x3DEC
3DE8  0E01     MOVLW 0x1
3DEA  D001     BRA 0x3DEE
3DEC  0E00     MOVLW 0x0
3DEE  6E44     MOVWF NVMADRH, ACCESS
111:           	//	scan_line++;
112:           }
3DF0  0012     RETURN 0
113:           /**
114:            End of File
115:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_ntsc.X/eadog.c  ---------------------------------------
1:             #include <string.h>
2:             #include "qconfig.h"
3:             #include "eadog.h"
4:             #include "ringbufs.h"
5:             
6:             #define max_strlen	21
7:             #define max_port_data	1024
8:             
9:             volatile struct spi_link_type spi_link;
10:            struct ringBufS_t ring_buf1;
11:            static uint8_t port_data[max_port_data] = {255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0};
12:            
13:            static void send_lcd_cmd_long(uint8_t); // for display init only
14:            static void send_lcd_data(uint8_t);
15:            static void send_lcd_cmd(uint8_t);
16:            
17:            void wdtdelay(uint32_t delay)
18:            {
19:            	static uint32_t dcount;
20:            
21:            	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
3B58  0E00     MOVLW 0x0
3B5A  0105     MOVLB 0x5
3B5C  6FBE     MOVWF MAINPR, BANKED
3B5E  0E00     MOVLW 0x0
3B60  6FBF     MOVWF ISRPR, BANKED
3B62  0E00     MOVLW 0x0
3B64  6FC0     MOVWF 0xC0, BANKED
3B66  0E00     MOVLW 0x0
3B68  6FC1     MOVWF 0xC1, BANKED
3B6A  D009     BRA 0x3B7E
22:            		Nop();
3B6C  F000     NOP
23:            		ClrWdt(); // reset the WDT timer
3B6E  0004     CLRWDT
24:            	};
3B70  0E01     MOVLW 0x1
3B72  0105     MOVLB 0x5
3B74  27BE     ADDWF MAINPR, F, BANKED
3B76  0E00     MOVLW 0x0
3B78  23BF     ADDWFC ISRPR, F, BANKED
3B7A  23C0     ADDWFC 0xC0, F, BANKED
3B7C  23C1     ADDWFC 0xC1, F, BANKED
3B7E  51BE     MOVF MAINPR, W, BANKED
3B80  5C0D     SUBWF 0xD, W, ACCESS
3B82  51BF     MOVF ISRPR, W, BANKED
3B84  580E     SUBWFB 0xE, W, ACCESS
3B86  51C0     MOVF 0xC0, W, BANKED
3B88  580F     SUBWFB 0xF, W, ACCESS
3B8A  51C1     MOVF 0xC1, W, BANKED
3B8C  5810     SUBWFB 0x10, W, ACCESS
3B8E  A0D8     BTFSS 0xFD8, 0, ACCESS
3B90  0012     RETURN 0
3B92  D7EC     BRA 0x3B6C
25:            }
26:            
27:            /*
28:             * Init the NHD-0420D3Z-NSW-BBW-V3 in 8-bit serial mode
29:             * channel 1 DMA
30:             */
31:            void init_display(void)
32:            {
33:            	spi_link.tx1a = &ring_buf1;
3610  0EA0     MOVLW 0xA0
3612  0105     MOVLB 0x5
3614  6FB4     MOVWF PRLOCK, BANKED
3616  0E06     MOVLW 0x6
3618  6FB5     MOVWF SCANPR, BANKED
34:            	ringBufS_init(spi_link.tx1a);
361A  C5B4     MOVFF 0x5B4, _this
361C  F519     NOP
361E  C5B5     MOVFF 0x5B5, ptr
3620  F51A     NOP
3622  EC82     CALL 0x3F04, 0
3624  F01F     NOP
35:            
36:            #ifdef DEBUG_DISP2
37:            	DLED2 = true;
38:            #endif
39:            #ifdef NHD
40:            	wdtdelay(350000); // > 400ms power up delay
3626  0E30     MOVLW 0x30
3628  6E0D     MOVWF 0xD, ACCESS
362A  0E57     MOVLW 0x57
362C  6E0E     MOVWF 0xE, ACCESS
362E  0E05     MOVLW 0x5
3630  6E0F     MOVWF 0xF, ACCESS
3632  0E00     MOVLW 0x0
3634  6E10     MOVWF 0x10, ACCESS
3636  ECAC     CALL 0x3B58, 0
3638  F01D     NOP
41:            	send_lcd_cmd(0x46); // home cursor
363A  0E46     MOVLW 0x46
363C  ECE8     CALL 0x3BD0, 0
363E  F01D     NOP
42:            	wdtdelay(800);
3640  0E20     MOVLW 0x20
3642  6E0D     MOVWF 0xD, ACCESS
3644  0E03     MOVLW 0x3
3646  6E0E     MOVWF 0xE, ACCESS
3648  0E00     MOVLW 0x0
364A  6E0F     MOVWF 0xF, ACCESS
364C  0E00     MOVLW 0x0
364E  6E10     MOVWF 0x10, ACCESS
3650  ECAC     CALL 0x3B58, 0
3652  F01D     NOP
43:            	send_lcd_cmd(0x41); // display on
3654  0E41     MOVLW 0x41
3656  ECE8     CALL 0x3BD0, 0
3658  F01D     NOP
44:            	wdtdelay(80);
365A  0E50     MOVLW 0x50
365C  6E0D     MOVWF 0xD, ACCESS
365E  0E00     MOVLW 0x0
3660  6E0E     MOVWF 0xE, ACCESS
3662  0E00     MOVLW 0x0
3664  6E0F     MOVWF 0xF, ACCESS
3666  0E00     MOVLW 0x0
3668  6E10     MOVWF 0x10, ACCESS
366A  ECAC     CALL 0x3B58, 0
366C  F01D     NOP
45:            	send_lcd_cmd(0x53); // set back-light level
366E  0E53     MOVLW 0x53
3670  ECE8     CALL 0x3BD0, 0
3672  F01D     NOP
46:            	send_lcd_data(NHD_BL_LOW);
3674  0E02     MOVLW 0x2
3676  EC52     CALL 0x3EA4, 0
3678  F01F     NOP
47:            	wdtdelay(80);
367A  0E50     MOVLW 0x50
367C  6E0D     MOVWF 0xD, ACCESS
367E  0E00     MOVLW 0x0
3680  6E0E     MOVWF 0xE, ACCESS
3682  0E00     MOVLW 0x0
3684  6E0F     MOVWF 0xF, ACCESS
3686  0E00     MOVLW 0x0
3688  6E10     MOVWF 0x10, ACCESS
368A  ECAC     CALL 0x3B58, 0
368C  F01D     NOP
48:            	send_lcd_cmd(0x51); // clear screen
368E  0E51     MOVLW 0x51
3690  ECE8     CALL 0x3BD0, 0
3692  F01D     NOP
49:            	wdtdelay(800);
3694  0E20     MOVLW 0x20
3696  6E0D     MOVWF 0xD, ACCESS
3698  0E03     MOVLW 0x3
369A  6E0E     MOVWF 0xE, ACCESS
369C  0E00     MOVLW 0x0
369E  6E0F     MOVWF 0xF, ACCESS
36A0  0E00     MOVLW 0x0
36A2  6E10     MOVWF 0x10, ACCESS
36A4  ECAC     CALL 0x3B58, 0
36A6  F01D     NOP
50:            
51:            #else
52:            	CSB_SetHigh();
53:            	wdtdelay(350000); // > 400ms power up delay
54:            	send_lcd_cmd_dma(0x39);
55:            	send_lcd_cmd_dma(0x1d);
56:            	send_lcd_cmd_dma(0x50);
57:            	send_lcd_cmd_dma(0x6c);
58:            	send_lcd_cmd_dma(0x76); // contrast last 4 bits
59:            	send_lcd_cmd_dma(0x38); // follower control
60:            	wdtdelay(800);
61:            	send_lcd_cmd_dma(0x0f);
62:            	send_lcd_cmd_dma(0x01); // clear
63:            	wdtdelay(800);
64:            	send_lcd_cmd_dma(0x02);
65:            	send_lcd_cmd_dma(0x06);
66:            	wdtdelay(30);
67:            	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
68:            #endif
69:            	//	SPI1INTFbits.SPI1TXUIF = 0;
70:            	//	DMA1CON1bits.DMODE = 0;
71:            	//	DMA1CON1bits.DSTP = 0;
72:            	//	DMA1CON1bits.SMODE = 1;
73:            	//	DMA1CON1bits.SMR = 0;
74:            	//	DMA1CON1bits.SSTP = 1;
75:            	//	DMA1SSA = (uint32_t) & ring_buf1;
76:            	//	DMA1CON0bits.DGO = 0;
77:            	//	SPI1INTFbits.SPI1TXUIF = 1;
78:            #ifdef DEBUG_DISP2
79:            	DLED2 = false;
80:            #endif
81:            #ifdef USE_DMA
82:            	DMA1_SetSCNTIInterruptHandler(clear_lcd_done);
83:            	DMA2_SetDCNTIInterruptHandler(spi_rec_done);
84:            #endif
85:            }
36A8  0012     RETURN 0
86:            
87:            /*
88:             * channel DMA
89:             */
90:            void init_port_dma(void)
91:            {
92:            }
93:            
94:            #ifdef NHD
95:            
96:            /*
97:             * R2 short on LCD NHD-0420D3Z-NSW-BBW-V3 board
98:             */
99:            
100:           static void send_lcd_data(const uint8_t data)
3EA4  6E11     MOVWF 0x11, ACCESS
101:           {
102:           	CSB_SetLow();
3EA6  94C0     BCF 0xFC0, 2, ACCESS
103:           	SPI1_ExchangeByte(data);
3EA8  5011     MOVF 0x11, W, ACCESS
3EAA  ECAC     CALL 0x3F58, 0
3EAC  F01F     NOP
104:           	wdtdelay(8);
3EAE  0E08     MOVLW 0x8
3EB0  6E0D     MOVWF 0xD, ACCESS
3EB2  0E00     MOVLW 0x0
3EB4  6E0E     MOVWF 0xE, ACCESS
3EB6  0E00     MOVLW 0x0
3EB8  6E0F     MOVWF 0xF, ACCESS
3EBA  0E00     MOVLW 0x0
3EBC  6E10     MOVWF 0x10, ACCESS
3EBE  ECAC     CALL 0x3B58, 0
3EC0  F01D     NOP
105:           }
3EC2  0012     RETURN 0
106:           
107:           static void send_lcd_cmd(const uint8_t cmd)
3BD0  6E11     MOVWF 0x11, ACCESS
108:           {
109:           	CSB_SetLow();
3BD2  94C0     BCF 0xFC0, 2, ACCESS
110:           	SPI1_ExchangeByte(NHD_CMD);
3BD4  0EFE     MOVLW 0xFE
3BD6  ECAC     CALL 0x3F58, 0
3BD8  F01F     NOP
111:           	wdtdelay(8);
3BDA  0E08     MOVLW 0x8
3BDC  6E0D     MOVWF 0xD, ACCESS
3BDE  0E00     MOVLW 0x0
3BE0  6E0E     MOVWF 0xE, ACCESS
3BE2  0E00     MOVLW 0x0
3BE4  6E0F     MOVWF 0xF, ACCESS
3BE6  0E00     MOVLW 0x0
3BE8  6E10     MOVWF 0x10, ACCESS
3BEA  ECAC     CALL 0x3B58, 0
3BEC  F01D     NOP
112:           	SPI1_ExchangeByte(cmd);
3BEE  5011     MOVF 0x11, W, ACCESS
3BF0  ECAC     CALL 0x3F58, 0
3BF2  F01F     NOP
113:           	wdtdelay(8);
3BF4  0E08     MOVLW 0x8
3BF6  6E0D     MOVWF 0xD, ACCESS
3BF8  0E00     MOVLW 0x0
3BFA  6E0E     MOVWF 0xE, ACCESS
3BFC  0E00     MOVLW 0x0
3BFE  6E0F     MOVWF 0xF, ACCESS
3C00  0E00     MOVLW 0x0
3C02  6E10     MOVWF 0x10, ACCESS
3C04  ECAC     CALL 0x3B58, 0
3C06  F01D     NOP
114:           }
3C08  0012     RETURN 0
115:           
116:           static void send_lcd_cmd_long(const uint8_t cmd)
117:           {
118:           	CSB_SetLow();
119:           	SPI1_ExchangeByte(NHD_CMD);
120:           	wdtdelay(8);
121:           	SPI1_ExchangeByte(cmd);
122:           	wdtdelay(800);
123:           }
124:           
125:           /*
126:            * uses DMA channel 1 for transfers
127:            */
128:           void eaDogM_WriteString(char *strPtr)
129:           {
130:           	uint8_t len = (uint8_t) strlen(strPtr);
36AA  C51E     MOVFF strPtr, d1
36AC  F50D     NOP
36AE  C51F     MOVFF 0x51F, 0x50E
36B0  F50E     NOP
36B2  EC00     CALL 0x3A00, 0
36B4  F01D     NOP
36B6  500D     MOVF 0xD, W, ACCESS
36B8  6E20     MOVWF 0x20, ACCESS
131:           
132:           #ifdef DEBUG_DISP1
133:           	DLED1 = true;
134:           #endif
135:           	wait_lcd_done();
36BA  EC0D     CALL 0x401A, 0
36BC  F020     NOP
136:           	wait_lcd_set();
36BE  EC1E     CALL 0x403C, 0
36C0  F020     NOP
137:           	/* reset buffer for DMA */
138:           	ringBufS_flush(spi_link.tx1a, false);
36C2  C5B4     MOVFF 0x5B4, _this
36C4  F519     NOP
36C6  C5B5     MOVFF 0x5B5, ptr
36C8  F51A     NOP
36CA  0E00     MOVLW 0x0
36CC  6E1B     MOVWF 0x1B, ACCESS
36CE  EC3B     CALL 0x3876, 0
36D0  F01C     NOP
139:           	CSB_SetLow(); /* SPI select display */
36D2  94C0     BCF 0xFC0, 2, ACCESS
140:           	if (len > (uint8_t) max_strlen) {
36D4  0E15     MOVLW 0x15
36D6  6420     CPFSGT 0x20, ACCESS
36D8  D002     BRA 0x36DE
141:           		len = max_strlen;
36DA  0E15     MOVLW 0x15
36DC  6E20     MOVWF 0x20, ACCESS
142:           	}
143:           	ringBufS_put_dma_cpy(spi_link.tx1a, strPtr, len);
36DE  C5B4     MOVFF 0x5B4, _this
36E0  F518     NOP
36E2  C5B5     MOVFF 0x5B5, _this
36E4  F519     NOP
36E6  C51E     MOVFF strPtr, ptr
36E8  F51A     NOP
36EA  C51F     MOVFF 0x51F, clearBuffer
36EC  F51B     NOP
36EE  C520     MOVFF len, len
36F0  F51C     NOP
36F2  EC65     CALL 0x38CA, 0
36F4  F01C     NOP
144:           #ifdef USE_DMA
145:           	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
146:           	DMA1_SetSourceSize(len);
147:           	DMA1_SetDestinationSize(1);
148:           	DMA2_SetSourceSize(1);
149:           	DMA2_SetDestinationSize(len);
150:           #else
151:           	SPI1_ExchangeBlock(spi_link.tx1a, len);
36F6  C5B4     MOVFF 0x5B4, d1
36F8  F50D     NOP
36FA  C5B5     MOVFF 0x5B5, 0x50E
36FC  F50E     NOP
36FE  C520     MOVFF len, s1
3700  F50F     NOP
3702  6A10     CLRF 0x10, ACCESS
3704  ECDB     CALL 0x39B6, 0
3706  F01C     NOP
152:           #endif
153:           	start_lcd(); // start DMA transfer
3708  EC33     CALL 0x4066, 0
370A  F020     NOP
154:           #ifdef DISPLAY_SLOW
155:           	wdtdelay(9000);
156:           #endif
157:           #ifdef DEBUG_DISP1
158:           	DLED1 = false;
159:           #endif
160:           }
370C  0012     RETURN 0
161:           
162:           /*
163:            * uses DMA channel 1 for transfers
164:            */
165:           void send_lcd_cmd_dma(const uint8_t strPtr)
166:           {
167:           	wait_lcd_done();
168:           	send_lcd_data_dma(NHD_CMD); //prefix
169:           	wait_lcd_done();
170:           	send_lcd_data_dma(strPtr); // cmd code
171:           	wait_lcd_done();
172:           }
173:           
174:           /*
175:            * uses DMA channel 1 for transfers
176:            */
177:           void send_lcd_data_dma(const uint8_t strPtr)
178:           {
179:           #ifdef DEBUG_DISP2
180:           	DLED2 = true;
181:           #endif
182:           	wait_lcd_set();
183:           	/* reset buffer for DMA */
184:           	ringBufS_flush(spi_link.tx1a, false);
185:           	CSB_SetLow(); /* SPI select display */
186:           	ringBufS_put_dma(spi_link.tx1a, strPtr); // don't use printf to send zeros
187:           #ifdef USE_DMA
188:           	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
189:           	DMA1_SetSourceSize(1);
190:           	DMA1_SetDestinationSize(1);
191:           	DMA2_SetSourceSize(1);
192:           	DMA2_SetDestinationSize(1);
193:           #endif
194:           	start_lcd(); // start DMA transfer
195:           #ifdef DEBUG_DISP2
196:           	DLED2 = false;
197:           #endif
198:           }
199:           
200:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
370E  6E26     MOVWF 0x26, ACCESS
201:           {
202:           	uint8_t row;
203:           
204:           	switch (r) {
3710  D009     BRA 0x3724
205:           	case 0:
206:           		row = 0x40;
3712  0E40     MOVLW 0x40
3714  D005     BRA 0x3720
207:           		break;
208:           	case 1:
209:           		row = 0x14;
3716  0E14     MOVLW 0x14
3718  D003     BRA 0x3720
210:           		break;
211:           	case 2:
212:           		row = 0x54;
371A  0E54     MOVLW 0x54
371C  D001     BRA 0x3720
213:           		break;
214:           	case 3:
215:           		row = 0x00;
371E  0E00     MOVLW 0x0
3720  6E27     MOVWF 0x27, ACCESS
216:           		break;
3722  D015     BRA 0x374E
217:           	default:
218:           		row = 0x40;
219:           		break;
220:           	}
3724  5026     MOVF 0x26, W, ACCESS
3726  6E24     MOVWF 0x24, ACCESS
3728  6A25     CLRF 0x25, ACCESS
372A  5025     MOVF 0x25, W, ACCESS
372C  0A00     XORLW 0x0
372E  A4D8     BTFSS 0xFD8, 2, ACCESS
3730  D7F0     BRA 0x3712
3732  5024     MOVF 0x24, W, ACCESS
3734  0A00     XORLW 0x0
3736  B4D8     BTFSC 0xFD8, 2, ACCESS
3738  D7EC     BRA 0x3712
373A  0A01     XORLW 0x1
373C  B4D8     BTFSC 0xFD8, 2, ACCESS
373E  D7EB     BRA 0x3716
3740  0A03     XORLW 0x3
3742  B4D8     BTFSC 0xFD8, 2, ACCESS
3744  D7EA     BRA 0x371A
3746  0A01     XORLW 0x1
3748  B4D8     BTFSC 0xFD8, 2, ACCESS
374A  D7E9     BRA 0x371E
374C  D7E2     BRA 0x3712
221:           	send_lcd_cmd(0x45);
374E  0E45     MOVLW 0x45
3750  ECE8     CALL 0x3BD0, 0
3752  F01D     NOP
222:           	send_lcd_data(row + c);
3754  5027     MOVF 0x27, W, ACCESS
3756  2421     ADDWF 0x21, W, ACCESS
3758  EC52     CALL 0x3EA4, 0
375A  F01F     NOP
223:           	wait_lcd_done();
375C  EC0D     CALL 0x401A, 0
375E  F020     NOP
224:           	CSB_SetHigh(); /* SPI deselect display */
3760  84C0     BSF 0xFC0, 2, ACCESS
225:           	eaDogM_WriteString(strPtr);
3762  C522     MOVFF strPtr, strPtr
3764  F51E     NOP
3766  C523     MOVFF 0x523, 0x51F
3768  F51F     NOP
376A  EC55     CALL 0x36AA, 0
376C  F01B     NOP
226:           }
376E  0012     RETURN 0
227:           
228:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
229:           {
230:           
231:           }
232:           
233:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
234:           {
235:           
236:           }
237:           
238:           void eaDogM_ClearRow(const uint8_t r)
239:           {
240:           
241:           }
242:           
243:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
244:           {
245:           
246:           }
247:           
248:           #else
249:           
250:           /*
251:            * add short spi delay (default)
252:            */
253:           static void send_lcd_data(const uint8_t data)
254:           {
255:           	RS_SetHigh();
256:           	CSB_SetLow();
257:           	SPI1_Exchange8bit(data);
258:           	wdtdelay(8);
259:           }
260:           
261:           /*
262:            * add inst spi delay
263:            */
264:           static void send_lcd_cmd(const uint8_t cmd)
265:           {
266:           	RS_SetLow();
267:           	CSB_SetLow();
268:           	SPI1_Exchange8bit(cmd);
269:           	wdtdelay(30);
270:           	RS_SetHigh();
271:           }
272:           
273:           /*
274:            * add clear/home spi delay
275:            */
276:           static void send_lcd_cmd_long(const uint8_t cmd)
277:           {
278:           	RS_SetLow();
279:           	CSB_SetLow();
280:           	SPI1_Exchange8bit(cmd);
281:           	wdtdelay(800);
282:           	RS_SetHigh();
283:           }
284:           
285:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
286:           {
287:           	uint8_t cmdPos;
288:           	cmdPos = (uint8_t) EADOGM_CMD_DDRAM_ADDR + (uint8_t) ((uint8_t) r * (uint8_t) EADOGM_COLSPAN) + (uint8_t) c;
289:           	eaDogM_WriteCommand(cmdPos);
290:           }
291:           
292:           void eaDogM_ClearRow(const uint8_t r)
293:           {
294:           	uint8_t i;
295:           	eaDogM_SetPos(r, 0);
296:           	for (i = 0; i < EADOGM_COLSPAN; i++) {
297:           		eaDogM_WriteChr(' ');
298:           	}
299:           }
300:           
301:           /*
302:            * uses DMA channel 1 for transfers
303:            */
304:           void eaDogM_WriteString(char *strPtr)
305:           {
306:           	wait_lcd_set();
307:           	/* reset buffer for DMA */
308:           	ringBufS_flush(spi_link.tx1a, false);
309:           	CSB_SetLow(); /* SPI select display */
310:           	if (strlen(strPtr) > max_strlen) strPtr[max_strlen] = 0; // buffer overflow check
311:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
312:           	DMA1SSZ = strlen(strPtr);
313:           	DMA1CON0bits.EN = 1; /* enable DMA */
314:           	printf("%s", strPtr); // testing copy method using STDIO redirect to buffer
315:           	start_lcd();
316:           #ifdef DISPLAY_SLOW
317:           	wdtdelay(9000);
318:           #endif
319:           }
320:           
321:           /*
322:            * uses DMA channel 1 for transfers
323:            */
324:           void send_lcd_cmd_dma(uint8_t strPtr)
325:           {
326:           	wait_lcd_set();
327:           	/* reset buffer for DMA */
328:           	ringBufS_flush(spi_link.tx1a, false);
329:           	RS_SetLow();
330:           	CSB_SetLow(); /* SPI select display */
331:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
332:           	DMA1SSZ = 1;
333:           	DMA1CON0bits.EN = 1; /* enable DMA */
334:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
335:           	start_lcd();
336:           	wait_lcd_done();
337:           	RS_SetHigh();
338:           }
339:           
340:           /*
341:            * uses DMA channel 1 for transfers
342:            */
343:           void send_lcd_data_dma(uint8_t strPtr)
344:           {
345:           	wait_lcd_set();
346:           	/* reset buffer for DMA */
347:           	ringBufS_flush(spi_link.tx1a, false);
348:           	RS_SetHigh();
349:           	CSB_SetLow(); /* SPI select display */
350:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
351:           	DMA1SSZ = 1;
352:           	DMA1CON0bits.EN = 1; /* enable DMA */
353:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
354:           	start_lcd();
355:           }
356:           
357:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
358:           {
359:           	send_lcd_cmd_dma((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
360:           	eaDogM_WriteString(strPtr);
361:           }
362:           
363:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
364:           {
365:           	eaDogM_WriteCommand((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
366:           
367:           	eaDogM_WriteChr(i / 10 + '0');
368:           	eaDogM_WriteChr(i % 10 + '0');
369:           
370:           }
371:           
372:           // this writes a byte to the internal CGRAM (v2.02)
373:           // format for ndx: 00CCCRRR = CCC = character 0 to 7, RRR = row 0 to 7
374:           
375:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
376:           {
377:           	uint8_t cmd;
378:           
379:           	cmd = ndx & 0b00111111; // mask off upper to bits
380:           	cmd = cmd | EADOGM_CMD_CGRAM_ADDR; // set bit cmd bits
381:           
382:           	eaDogM_WriteCommand(cmd);
383:           	eaDogM_WriteChr(data);
384:           
385:           	// this is done to make sure we are back in data mode
386:           	eaDogM_SetPos(0, 0);
387:           }
388:           #endif
389:           
390:           void eaDogM_WriteCommand(const uint8_t cmd)
391:           {
392:           	send_lcd_cmd(cmd);
393:           }
394:           
395:           void eaDogM_WriteChr(const int8_t value)
396:           {
397:           	send_lcd_data((uint8_t) value);
398:           }
399:           
400:           /*
401:            * uses DMA channel 2 for transfers
402:            */
403:           void send_port_data_dma(uint16_t dsize)
404:           {
405:           	if (dsize > max_port_data)
406:           		dsize = max_port_data;
407:           }
408:           
409:           /*
410:            * return pointer to internal data buffer for DMA
411:            */
412:           uint8_t* port_data_dma_ptr(void)
413:           {
414:           	return port_data;
415:           }
416:           
417:           /*
418:            * Trigger the SPI DMA transfer to the LCD display
419:            */
420:           void start_lcd(void)
421:           {
422:           #ifdef USE_DMA
423:           	DMA2_StartTransferWithTrigger();
424:           	DMA1_StartTransfer();
425:           #endif
426:           }
4066  0012     RETURN 0
427:           
428:           void wait_lcd_set(void)
429:           {
430:           	spi_link.LCD_DATA = true;
403C  0105     MOVLB 0x5
403E  87AE     BSF OSCCON2, 3, BANKED
431:           }
4040  0012     RETURN 0
432:           
433:           bool wait_lcd_check(void)
434:           {
435:           	return spi_link.LCD_DATA;
436:           }
437:           
438:           void wait_lcd_done(void)
439:           {
440:           #ifdef USE_DMA
441:           	while (spi_link.LCD_DATA) {
442:           	};
443:           #endif
444:           	while (!SPI1STATUSbits.TXBE) {
401A  0100     MOVLB 0x0
401C  BB87     BTFSC SPI1STATUS, 5, BANKED
401E  0012     RETURN 0
4020  D7FC     BRA wait_lcd_done
445:           	};
446:           }
447:           
448:           void clear_lcd_done(void)
449:           {
450:           	spi_link.LCD_DATA = false;
451:           }
452:           
453:           
454:           void spi_rec_done(void)
455:           {
456:           }
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
3A00  C50D     MOVFF d1, s1
3A02  F50F     NOP
3A04  C50E     MOVFF 0x50E, 0x510
3A06  F510     NOP
8:             	while(*s) {
3A08  D002     BRA 0x3A0E
3A10  F434     NOP
3A12  F4F6     NOP
3A16  F438     NOP
3A18  F4F7     NOP
3A1A  0E00     MOVLW 0x0
3A1C  6EF8     MOVWF 0xFF8, ACCESS
3A1E  0E25     MOVLW 0x25
3A20  64F7     CPFSGT 0xFF7, ACCESS
3A22  D003     BRA 0x3A2A
3A24  0008     TBLRD*
3A26  50F5     MOVF 0xFF5, W, ACCESS
3A28  D005     BRA 0x3A34
3A2A  C4F6     MOVFF TBLPTR, FSR0
3A2C  F4E9     NOP
3A2E  C4F7     MOVFF TBLPTRH, FSR0H
3A30  F4EA     NOP
3A32  50EF     MOVF 0xFEF, W, ACCESS
3A34  0900     IORLW 0x0
3A36  A4D8     BTFSS 0xFD8, 2, ACCESS
3A38  D7E8     BRA 0x3A0A
9:             		s++;
3A0A  4A0D     INFSNZ 0xD, F, ACCESS
3A0C  2A0E     INCF 0xE, F, ACCESS
10:            	}
11:            	return (size_t)(s-a);
3A3A  500F     MOVF 0xF, W, ACCESS
3A3C  5C0D     SUBWF 0xD, W, ACCESS
3A3E  6E0D     MOVWF 0xD, ACCESS
3A40  5010     MOVF 0x10, W, ACCESS
3A42  580E     SUBWFB 0xE, W, ACCESS
3A44  6E0E     MOVWF 0xE, ACCESS
12:            }
3A46  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/putch.c  -------------------------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
4064  0012     RETURN 0
10:            
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_sprintf.c  --------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
3822  0EFB     MOVLW 0xFB
3824  0106     MOVLB 0x6
3826  6FE5     MOVWF 0xE5, BANKED
3828  0E05     MOVLW 0x5
382A  6FE6     MOVWF 0xE6, BANKED
16:            	f.buffer = s;
382C  C5F8     MOVFF __pcstackBANK5, f
382E  F6E7     NOP
3830  C5F9     MOVFF 0x5F9, 0x6E8
3832  F6E8     NOP
17:            	f.count = 0;
3834  0E00     MOVLW 0x0
3836  6FEA     MOVWF DMAnDCNT, BANKED
3838  0E00     MOVLW 0x0
383A  6FE9     MOVWF DMAnBUF, BANKED
18:            	f.limit = 0;
383C  0E00     MOVLW 0x0
383E  6FEC     MOVWF DMAnDPTR, BANKED
3840  0E00     MOVLW 0x0
3842  6FEB     MOVWF DMAnDCNTH, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
3844  0EE7     MOVLW 0xE7
3846  6E36     MOVWF 0x36, ACCESS
3848  0E06     MOVLW 0x6
384A  6E37     MOVWF 0x37, ACCESS
384C  C5FA     MOVFF fmt, fmt
384E  F538     NOP
3850  0EE5     MOVLW 0xE5
3852  6E39     MOVWF CLKRCON, ACCESS
3854  0E06     MOVLW 0x6
3856  6E3A     MOVWF CLKRCLK, ACCESS
3858  ECE5     CALL 0x37CA, 0
385A  F01B     NOP
20:            	s[f.count] = '\0';
385C  0106     MOVLB 0x6
385E  51E9     MOVF DMAnBUF, W, BANKED
3860  0105     MOVLB 0x5
3862  25F8     ADDWF DMAnSSZH, W, BANKED
3864  6ED9     MOVWF 0xFD9, ACCESS
3866  0106     MOVLB 0x6
3868  51EA     MOVF DMAnDCNT, W, BANKED
386A  0105     MOVLB 0x5
386C  21F9     ADDWFC DMAnSSA, W, BANKED
386E  6EDA     MOVWF 0xFDA, ACCESS
3870  0E00     MOVLW 0x0
3872  6EDF     MOVWF 0xFDF, ACCESS
21:            	va_end(ap);
22:            	return ret;
23:            }
3874  0012     RETURN 0
24:            
25:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
34C4  500F     MOVF 0xF, W, ACCESS
34C6  1010     IORWF 0x10, W, ACCESS
34C8  B4D8     BTFSC 0xFD8, 2, ACCESS
34CA  D004     BRA 0x34D4
34CC  500F     MOVF 0xF, W, ACCESS
34CE  1010     IORWF 0x10, W, ACCESS
34D0  A4D8     BTFSS 0xFD8, 2, ACCESS
34D2  D004     BRA 0x34DC
13:                    putch((char)c);
34D4  500D     MOVF 0xD, W, ACCESS
34D6  EC32     CALL 0x4064, 0
34D8  F020     NOP
14:                } else {
34DA  0012     RETURN 0
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
34DC  EE20     LFSR 2, 0x4
34DE  F004     NOP
34E0  500F     MOVF 0xF, W, ACCESS
34E2  26D9     ADDWF 0xFD9, F, ACCESS
34E4  5010     MOVF 0x10, W, ACCESS
34E6  22DA     ADDWFC 0xFDA, F, ACCESS
34E8  50DE     MOVF 0xFDE, W, ACCESS
34EA  10DE     IORWF 0xFDE, W, ACCESS
34EC  B4D8     BTFSC 0xFD8, 2, ACCESS
34EE  D016     BRA 0x351C
34F0  EE20     LFSR 2, 0x4
34F2  F004     NOP
34F4  500F     MOVF 0xF, W, ACCESS
34F6  26D9     ADDWF 0xFD9, F, ACCESS
34F8  5010     MOVF 0x10, W, ACCESS
34FA  22DA     ADDWFC 0xFDA, F, ACCESS
34FC  EE10     LFSR 1, 0x2
34FE  F002     NOP
3500  500F     MOVF 0xF, W, ACCESS
3502  26E1     ADDWF 0xFE1, F, ACCESS
3504  5010     MOVF 0x10, W, ACCESS
3506  22E2     ADDWFC 0xFE2, F, ACCESS
3508  50DE     MOVF 0xFDE, W, ACCESS
350A  5CE6     SUBWF 0xFE6, W, ACCESS
350C  50E6     MOVF 0xFE6, W, ACCESS
350E  0A80     XORLW 0x80
3510  6E15     MOVWF 0x15, ACCESS
3512  50DE     MOVF 0xFDE, W, ACCESS
3514  0A80     XORLW 0x80
3516  5815     SUBWFB 0x15, W, ACCESS
3518  B0D8     BTFSC 0xFD8, 0, ACCESS
351A  0012     RETURN 0
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
351C  EE20     LFSR 2, 0x2
351E  F002     NOP
3520  500F     MOVF 0xF, W, ACCESS
3522  26D9     ADDWF 0xFD9, F, ACCESS
3524  5010     MOVF 0x10, W, ACCESS
3526  22DA     ADDWFC 0xFDA, F, ACCESS
352A  F378     NOP
352C  F511     NOP
3530  F374     NOP
3532  F512     NOP
3536  F43C     NOP
3538  F4D9     NOP
353C  F440     NOP
353E  F4DA     NOP
3542  F378     NOP
3544  F513     NOP
3548  F374     NOP
354A  F514     NOP
354C  5011     MOVF 0x11, W, ACCESS
354E  2413     ADDWF 0x13, W, ACCESS
3550  6ED9     MOVWF 0xFD9, ACCESS
3552  5012     MOVF 0x12, W, ACCESS
3554  2014     ADDWFC 0x14, W, ACCESS
3556  6EDA     MOVWF 0xFDA, ACCESS
355A  F434     NOP
355C  F4DF     NOP
19:            #pragma warning pop
20:            			++fp->count;
355E  EE20     LFSR 2, 0x2
3560  F002     NOP
3562  500F     MOVF 0xF, W, ACCESS
3564  26D9     ADDWF 0xFD9, F, ACCESS
3566  5010     MOVF 0x10, W, ACCESS
3568  22DA     ADDWFC 0xFDA, F, ACCESS
356A  2ADE     INCF 0xFDE, F, ACCESS
356C  0E00     MOVLW 0x0
356E  22DD     ADDWFC 0xFDD, F, ACCESS
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
3570  0012     RETURN 0
25:            
26:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/memset.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
2F18  C50D     MOVFF d1, tmp
2F1A  F517     NOP
2F1C  C50E     MOVFF 0x50E, _this
2F1E  F518     NOP
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
2F20  5011     MOVF 0x11, W, ACCESS
2F22  1012     IORWF 0x12, W, ACCESS
2F24  B4D8     BTFSC 0xFD8, 2, ACCESS
2F26  0012     RETURN 0
14:            	s[0] = (unsigned char)c;
2F2A  F45C     NOP
2F2C  F4D9     NOP
2F30  F460     NOP
2F32  F4DA     NOP
2F36  F43C     NOP
2F38  F4DF     NOP
15:            	s[n-1] = (unsigned char)c;
2F3A  5011     MOVF 0x11, W, ACCESS
2F3C  2417     ADDWF 0x17, W, ACCESS
2F3E  6E13     MOVWF 0x13, ACCESS
2F40  5012     MOVF 0x12, W, ACCESS
2F42  2018     ADDWFC 0x18, W, ACCESS
2F44  6E14     MOVWF 0x14, ACCESS
2F46  0EFF     MOVLW 0xFF
2F48  2413     ADDWF 0x13, W, ACCESS
2F4A  6ED9     MOVWF 0xFD9, ACCESS
2F4C  0EFF     MOVLW 0xFF
2F4E  2014     ADDWFC 0x14, W, ACCESS
2F50  6EDA     MOVWF 0xFDA, ACCESS
2F54  F43C     NOP
2F56  F4DF     NOP
16:            	if (n <= 2) return dest;
2F58  5012     MOVF 0x12, W, ACCESS
2F5A  E104     BNZ 0x2F64
2F5C  0E03     MOVLW 0x3
2F5E  5C11     SUBWF 0x11, W, ACCESS
2F60  A0D8     BTFSS 0xFD8, 0, ACCESS
2F62  0012     RETURN 0
17:            	s[1] = (unsigned char)c;
2F64  EE20     LFSR 2, 0x1
2F66  F001     NOP
2F68  5017     MOVF 0x17, W, ACCESS
2F6A  26D9     ADDWF 0xFD9, F, ACCESS
2F6C  5018     MOVF 0x18, W, ACCESS
2F6E  22DA     ADDWFC 0xFDA, F, ACCESS
2F72  F43C     NOP
2F74  F4DF     NOP
18:            	s[2] = (unsigned char)c;
2F76  EE20     LFSR 2, 0x2
2F78  F002     NOP
2F7A  5017     MOVF 0x17, W, ACCESS
2F7C  26D9     ADDWF 0xFD9, F, ACCESS
2F7E  5018     MOVF 0x18, W, ACCESS
2F80  22DA     ADDWFC 0xFDA, F, ACCESS
2F84  F43C     NOP
2F86  F4DF     NOP
19:            	s[n-2] = (unsigned char)c;
2F88  5011     MOVF 0x11, W, ACCESS
2F8A  2417     ADDWF 0x17, W, ACCESS
2F8C  6E13     MOVWF 0x13, ACCESS
2F8E  5012     MOVF 0x12, W, ACCESS
2F90  2018     ADDWFC 0x18, W, ACCESS
2F92  6E14     MOVWF 0x14, ACCESS
2F94  0EFE     MOVLW 0xFE
2F96  2413     ADDWF 0x13, W, ACCESS
2F98  6ED9     MOVWF 0xFD9, ACCESS
2F9A  0EFF     MOVLW 0xFF
2F9C  2014     ADDWFC 0x14, W, ACCESS
2F9E  6EDA     MOVWF 0xFDA, ACCESS
2FA2  F43C     NOP
2FA4  F4DF     NOP
20:            	s[n-3] = (unsigned char)c;
2FA6  5011     MOVF 0x11, W, ACCESS
2FA8  2417     ADDWF 0x17, W, ACCESS
2FAA  6E13     MOVWF 0x13, ACCESS
2FAC  5012     MOVF 0x12, W, ACCESS
2FAE  2018     ADDWFC 0x18, W, ACCESS
2FB0  6E14     MOVWF 0x14, ACCESS
2FB2  0EFD     MOVLW 0xFD
2FB4  2413     ADDWF 0x13, W, ACCESS
2FB6  6ED9     MOVWF 0xFD9, ACCESS
2FB8  0EFF     MOVLW 0xFF
2FBA  2014     ADDWFC 0x14, W, ACCESS
2FBC  6EDA     MOVWF 0xFDA, ACCESS
2FC0  F43C     NOP
2FC2  F4DF     NOP
21:            	if (n <= 6) return dest;
2FC4  5012     MOVF 0x12, W, ACCESS
2FC6  E104     BNZ 0x2FD0
2FC8  0E07     MOVLW 0x7
2FCA  5C11     SUBWF 0x11, W, ACCESS
2FCC  A0D8     BTFSS 0xFD8, 0, ACCESS
2FCE  0012     RETURN 0
22:            	s[3] = (unsigned char)c;
2FD0  EE20     LFSR 2, 0x3
2FD2  F003     NOP
2FD4  5017     MOVF 0x17, W, ACCESS
2FD6  26D9     ADDWF 0xFD9, F, ACCESS
2FD8  5018     MOVF 0x18, W, ACCESS
2FDA  22DA     ADDWFC 0xFDA, F, ACCESS
2FDE  F43C     NOP
2FE0  F4DF     NOP
23:            	s[n-4] = (unsigned char)c;
2FE2  5011     MOVF 0x11, W, ACCESS
2FE4  2417     ADDWF 0x17, W, ACCESS
2FE6  6E13     MOVWF 0x13, ACCESS
2FE8  5012     MOVF 0x12, W, ACCESS
2FEA  2018     ADDWFC 0x18, W, ACCESS
2FEC  6E14     MOVWF 0x14, ACCESS
2FEE  0EFC     MOVLW 0xFC
2FF0  2413     ADDWF 0x13, W, ACCESS
2FF2  6ED9     MOVWF 0xFD9, ACCESS
2FF4  0EFF     MOVLW 0xFF
2FF6  2014     ADDWFC 0x14, W, ACCESS
2FF8  6EDA     MOVWF 0xFDA, ACCESS
2FFC  F43C     NOP
2FFE  F4DF     NOP
24:            	if (n <= 8) return dest;
3000  5012     MOVF 0x12, W, ACCESS
3002  E104     BNZ 0x300C
3004  0E09     MOVLW 0x9
3006  5C11     SUBWF 0x11, W, ACCESS
3008  A0D8     BTFSS 0xFD8, 0, ACCESS
300A  0012     RETURN 0
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
300C  C517     MOVFF tmp, d
300E  F513     NOP
3010  C518     MOVFF _this, 0x514
3012  F514     NOP
3014  1E13     COMF 0x13, F, ACCESS
3016  1E14     COMF 0x14, F, ACCESS
3018  4A13     INFSNZ 0x13, F, ACCESS
301A  2A14     INCF 0x14, F, ACCESS
301C  0E03     MOVLW 0x3
301E  1413     ANDWF 0x13, W, ACCESS
3020  6E15     MOVWF 0x15, ACCESS
3022  6A16     CLRF 0x16, ACCESS
32:            	s += k;
3024  5015     MOVF 0x15, W, ACCESS
3026  2617     ADDWF 0x17, F, ACCESS
3028  5016     MOVF 0x16, W, ACCESS
302A  2218     ADDWFC 0x18, F, ACCESS
33:            	n -= k;
302C  5015     MOVF 0x15, W, ACCESS
302E  5E11     SUBWF 0x11, F, ACCESS
3030  5016     MOVF 0x16, W, ACCESS
3032  5A12     SUBWFB 0x12, F, ACCESS
34:            	n &= (size_t)-4;
3034  0EFC     MOVLW 0xFC
3036  1611     ANDWF 0x11, F, ACCESS
3038  0EFF     MOVLW 0xFF
303A  1612     ANDWF 0x12, F, ACCESS
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
303C  D00E     BRA 0x305A
3040  F45C     NOP
3042  F4D9     NOP
3046  F460     NOP
3048  F4DA     NOP
304C  F43C     NOP
304E  F4DF     NOP
3050  0611     DECF 0x11, F, ACCESS
3052  A0D8     BTFSS 0xFD8, 0, ACCESS
3054  0612     DECF 0x12, F, ACCESS
3056  4A17     INFSNZ 0x17, F, ACCESS
3058  2A18     INCF 0x18, F, ACCESS
305A  5011     MOVF 0x11, W, ACCESS
305C  1012     IORWF 0x12, W, ACCESS
305E  B4D8     BTFSC 0xFD8, 2, ACCESS
3060  0012     RETURN 0
3062  D7ED     BRA 0x303E
87:            #endif
88:            
89:            	return dest;
90:            }
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/memcpy.c  ------------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
391C  C50F     MOVFF s1, s
391E  F515     NOP
3920  C510     MOVFF 0x510, fp
3922  F516     NOP
12:            	d = d1;
3924  C50D     MOVFF d1, d
3926  F513     NOP
3928  C50E     MOVFF 0x50E, 0x514
392A  F514     NOP
13:            	while(n--) {
392C  D015     BRA 0x3958
3958  0611     DECF 0x11, F, ACCESS
14:            		tmp = *s++;
3930  F454     NOP
3932  F4D9     NOP
3936  F458     NOP
3938  F4DA     NOP
393A  50DF     MOVF 0xFDF, W, ACCESS
393C  6E17     MOVWF 0x17, ACCESS
393E  4A15     INFSNZ 0x15, F, ACCESS
3940  2A16     INCF 0x16, F, ACCESS
15:            		*d++ = tmp;
3944  F44C     NOP
3946  F4D9     NOP
394A  F450     NOP
394C  F4DA     NOP
3950  F45C     NOP
3952  F4DF     NOP
3954  4A13     INFSNZ 0x13, F, ACCESS
3956  2A14     INCF 0x14, F, ACCESS
3958  0611     DECF 0x11, F, ACCESS
395A  A0D8     BTFSS 0xFD8, 0, ACCESS
395C  0612     DECF 0x12, F, ACCESS
395E  2811     INCF 0x11, W, ACCESS
3960  E1E6     BNZ 0x392E
3962  2812     INCF 0x12, W, ACCESS
3964  B4D8     BTFSC 0xFD8, 2, ACCESS
3966  0012     RETURN 0
3968  D7E2     BRA 0x392E
16:            	}
17:            	return d1;
18:            }
19:            
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
78:                    fputs((const char *)buf, fp);
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
83:                i = 0;
84:                while (i < w) {
85:                    fputc(' ', fp);
86:                    ++i;
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
91:                    fputs((const char *)buf, fp);
92:                }
93:            
94:                return (int)(strlen(buf) + (size_t)w);
95:            }
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = (char)d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Left justify ? Put out character */
267:               if (flags & MINUS_FLAG) {
268:                   fputc(c, fp);
269:               }
270:               /* Put out padding */
271:               w = (w < 0) ? 0 : w;
272:               l = 0;
273:               while (l < w) {
274:                   fputc(' ', fp);
275:                   ++l;
276:               }
277:               /* Right justify ? Put out string */
278:               if (!(flags & MINUS_FLAG)) {
279:                   fputc(c, fp);
280:               }
281:           
282:               return l+1;
283:           }
284:           #endif
285:           
286:           #ifdef _VFPF_D
287:           static _INLINE int dtoa(FILE *fp, long long d)
288:           {
289:               int i, p, s, w;
290:               long long n;
291:           
292:               /* Record sign, get absolute value */
293:               n = d;
294:               s = n < 0 ? 1 : 0;
295:               if (s) {
296:                   n = -n;
297:               }
298:           
299:               /* Adjust flags, precision, width */
300:               if (!(prec < 0)) {
301:                   flags &= ~ZERO_FLAG;
302:               }
303:               p = (0 < prec) ? prec : 1;
304:               w = width;
305:               if (s || (flags & PLUS_FLAG)) {
306:                   --w;
307:               }
308:           
309:               /* Convert to decimal, possibly filling on the left with zeroes */
310:               i = sizeof(dbuf) - 1;
311:               dbuf[i] = '\0';
312:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
313:                   --i;
314:                   dbuf[i] = (char)((int)'0' + abs(n % 10));
315:                   --p;
316:                   --w;
317:                   n = n / 10;
318:               }
319:           
320:               /* Display sign if required */
321:               if (s || (flags & PLUS_FLAG)) {
322:                   --i;
323:                   dbuf[i] = s ? '-' : '+';
324:               }
325:           
326:               /* Put out padded string */
327:               return pad(fp, &dbuf[i], w);
328:           }
329:           #endif
330:           
331:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
332:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
333:           {
334:               char mode, nmode;
335:               int d, e, i, m, n, ne, p, pp, sign, t, w;
336:               long double g, h, l, ou, u;
337:           
338:               /* Record sign, get absolute value */
339:               sign = 0;
340:               g = f;
341:               if (g < 0.0) {
342:                   sign = 1;
343:                   g = -g;
344:               }
345:           
346:               /* Print sign */
347:               n = 0;
348:               w = width;
349:               if (sign || (flags & PLUS_FLAG)) {
350:                   dbuf[n] = sign ? '-' : '+';
351:                   ++n;
352:                   --w;
353:               }
354:           
355:               /* Catch infinities, NaNs here */
356:               if (isinf(g)) {
357:                   if (isupper((int)c)) {
358:                       strcpy(&dbuf[n], "INF");
359:                   } else {
360:                       strcpy(&dbuf[n], "inf");
361:                   }
362:                   w -= CSTRLEN("inf");
363:                   return pad(fp, &dbuf[0], w);
364:               }
365:               if (isnan(g)) {
366:                   if (isupper((int)c)) {
367:                       strcpy(&dbuf[n], "NAN");
368:                   } else {
369:                       strcpy(&dbuf[n], "nan");
370:                   }
371:                   w -= CSTRLEN("inf");
372:                   return pad(fp, &dbuf[0], w);
373:               }
374:           
375:               /* First find the largest power of 10 not larger than number to print */
376:               u = 1.0;
377:               e = 0;
378:               if (!(g == 0.0)) {
379:                   while (!(g < (u*10.0))) {
380:                       u = u*10.0;
381:                       ++e;
382:                   }
383:                   while (g < u) {
384:                       u = u/10.0;
385:                       --e;
386:                   }
387:               }
388:           
389:               /* Get mode, precision */
390:               mode = (char)tolower((int)c);
391:               nmode = mode;
392:               if (mode == 'g') {
393:           		if (prec == 0) {
394:           			prec = 1;
395:           		}
396:                   p = (0 < prec) ? prec : 6;
397:               } else {
398:                   p = (prec < 0) ? 6 : prec;
399:               }
400:           
401:               /* Choose e or f mode from g mode */
402:               if (mode == 'g') {
403:                   if (!(e < -4) && !((p - 1) < e)) {
404:                       nmode = 'f';
405:                   } else {
406:                       nmode = 'e';
407:                   }
408:               }
409:           
410:               /* Decimal places or significant digits */
411:               m = p;
412:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
413:                   ++m;
414:               }
415:           
416:               /* Adjust starting exponent, string length for 'f' conversions */
417:               if (nmode == 'f') {
418:                   if (e < 0) {
419:                       u = 1.0;
420:                       e = 0;
421:                   }
422:                   if (!(mode == 'g')) {
423:                       m += e;
424:                   }
425:               }
426:           
427:               /* Go through the conversion once to get to the rounding step */
428:               i = 0;
429:               h = g;
430:               ou = u;
431:               while (i < m) {
432:                   l = floor(h/u);
433:                   d = (int)l;
434:                   h -= l*u;
435:                   u = u/10.0;
436:                   ++i;
437:               }
438:               
439:               /* Remainder >= halfway ? */
440:               l = u*5.0;
441:               if (h < l) {
442:                   l = 0.0;
443:               } else {
444:                   /* On tie choose even number */
445:                   if ((h == l) && !(d % 2)) {
446:                       l = 0.0;
447:                   }
448:               }
449:           
450:               /* Round */
451:               h = g + l;
452:               /* Has rounding increased the power above 10^0? */
453:           	if (h >= (ou*10.0)) {
454:           		e++;
455:           		ou *= 10.0;
456:           		if (nmode == 'f') {
457:           			// the increase in power will only affect the number of digits in 'f' mode
458:           			m++;
459:           		}
460:           	}
461:               
462:               /* Convert again, after rounding */
463:               u = ou;
464:               ne = (nmode == 'e') ? 0 : e;
465:               pp = 0;
466:               t = 0;
467:               i = 0;
468:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
469:                   l = floor(h/u);
470:                   d = (int)l;
471:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
472:                       ++t;
473:                   } else {
474:                       if (!pp && (ne < 0)) {
475:                           dbuf[n++] = '.';
476:                           --w;
477:                           pp = 1;
478:                       }
479:                       while (t) {
480:                           dbuf[n++] = '0';
481:                           --w;
482:                           --t;
483:                       }
484:                       dbuf[n++] = (char)((int)'0' + d);
485:                       --w;
486:                   }
487:                   h -= l*u;
488:                   u = u/10.0;
489:                   --ne;
490:                   ++i;
491:               }
492:               if (!pp && (flags & POUND_FLAG)) {
493:                   dbuf[n++] = '.';
494:               }
495:               dbuf[n] = '\0';
496:           
497:               /* Convert exponent */
498:               if (nmode == 'e') {
499:                   i = sizeof(dbuf) - 1;
500:                   dbuf[i] = '\0';
501:                   sign = 0;
502:                   if (e < 0) {
503:                       sign = 1;
504:                       e = -e;
505:                   }
506:                   p = 2;
507:                   while (e || (0 < p)) {
508:                       --i;
509:                       dbuf[i] = '0' + (e % 10);
510:                       e = e / 10;
511:                       --p;
512:                       --w;
513:                   }
514:                   --i;
515:                   dbuf[i] = sign ? '-' : '+';
516:                   --w;
517:                   --i;
518:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
519:                   --w;
520:                   strcpy(&dbuf[n], &dbuf[i]);
521:               }
522:           
523:               /* Put out padded string */
524:               return pad(fp, &dbuf[0], w);
525:           }
526:           #endif
527:           
528:           #ifdef _VFPF_O
529:           static _INLINE int otoa(FILE *fp, unsigned long long d)
530:           {
531:               int i, p, t, w;
532:               unsigned long long n;
533:           
534:               /* Adjust flags, precision, width */
535:               if (!(prec < 0)) {
536:                   flags &= ~ZERO_FLAG;
537:               }
538:               p = (0 < prec) ? prec : 1;
539:               w = width;
540:           
541:               /* Convert to octal, possibly filling on the left with zeroes */
542:               n = d;
543:               i = sizeof(dbuf) - 1;
544:               dbuf[i] = '\0';
545:               t = 0;
546:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
547:                   --i;
548:                   t = n & 07;
549:                   dbuf[i] = (char)((int)'0' + t);
550:                   --p;
551:                   --w;
552:                   n = n >> 3;
553:               }
554:           
555:               /* Display prefix if required */
556:               if ((flags & POUND_FLAG) && t) {
557:                   --i;
558:                   dbuf[i] = '0';
559:                   --w;
560:               }
561:           
562:               /* Put out padded string */
563:               return pad(fp, &dbuf[i], w);
564:           }
565:           #endif
566:           
567:           #ifdef _VFPF_S
568:           static _INLINE int stoa(FILE *fp, char *s)
569:           {
570:               char *cp, nuls[] = "(null)";
3064  EE21     LFSR 2, 0x5F1
3066  F1F1     NOP
3068  EE11     LFSR 1, 0x51B
306A  F11B     NOP
306C  0E06     MOVLW 0x6
306E  C4DB     MOVFF PLUSW2, PLUSW1
3070  F4E3     NOP
3072  06E8     DECF 0xFE8, F, ACCESS
3074  E2FC     BC 0x306E
571:               int i, l, p, w;
572:           
573:               /* Check for null string */
574:               cp = s;
3076  C518     MOVFF _this, r
3078  F526     NOP
307A  C519     MOVFF _this, row
307C  F527     NOP
575:               if (!cp) {
307E  5026     MOVF 0x26, W, ACCESS
3080  1027     IORWF 0x27, W, ACCESS
3082  A4D8     BTFSS 0xFD8, 2, ACCESS
3084  D004     BRA 0x308E
576:                   cp = nuls;
3086  0E1B     MOVLW 0x1B
3088  6E26     MOVWF 0x26, ACCESS
308A  0E05     MOVLW 0x5
308C  6E27     MOVWF 0x27, ACCESS
577:               }
578:           
579:               /* Get length, precision, width */
580:               l = (int)strlen(cp);
308E  C526     MOVFF r, d1
3090  F50D     NOP
3092  C527     MOVFF row, 0x50E
3094  F50E     NOP
3096  EC00     CALL 0x3A00, 0
3098  F01D     NOP
309A  C50D     MOVFF d1, l
309C  F52A     NOP
309E  C50E     MOVFF 0x50E, 0x52B
30A0  F52B     NOP
581:               p = prec;
30A2  C5E1     MOVFF prec, p
30A4  F528     NOP
30A6  C5E2     MOVFF 0x5E2, 0x529
30A8  F529     NOP
582:               l = (!(p < 0) && (p < l)) ? p : l;
30AA  BE29     BTFSC 0x29, 7, ACCESS
30AC  D00E     BRA 0x30CA
30AE  502A     MOVF 0x2A, W, ACCESS
30B0  5C28     SUBWF 0x28, W, ACCESS
30B2  5029     MOVF 0x29, W, ACCESS
30B4  0A80     XORLW 0x80
30B6  6E1A     MOVWF 0x1A, ACCESS
30B8  502B     MOVF 0x2B, W, ACCESS
30BA  0A80     XORLW 0x80
30BC  581A     SUBWFB 0x1A, W, ACCESS
30BE  B0D8     BTFSC 0xFD8, 0, ACCESS
30C0  D004     BRA 0x30CA
30C2  C528     MOVFF p, l
30C4  F52A     NOP
30C6  C529     MOVFF 0x529, 0x52B
30C8  F52B     NOP
583:               p = l;
30CA  C52A     MOVFF l, p
30CC  F528     NOP
30CE  C52B     MOVFF 0x52B, 0x529
30D0  F529     NOP
584:               w = width;
30D2  C5DF     MOVFF width, w
30D4  F524     NOP
30D6  C5E0     MOVFF 0x5E0, 0x525
30D8  F525     NOP
585:           
586:               /* Right justify, pad on left ? */
587:               if (!(flags & MINUS_FLAG)) {
30DA  0105     MOVLB 0x5
30DC  A1E3     BTFSS 0xE3, 0, BANKED
30DE  D00D     BRA 0x30FA
30E0  D016     BRA 0x310E
588:                   while (l < w) {
30FA  5024     MOVF 0x24, W, ACCESS
30FC  5C2A     SUBWF 0x2A, W, ACCESS
30FE  502B     MOVF 0x2B, W, ACCESS
3100  0A80     XORLW 0x80
3102  6E1A     MOVWF 0x1A, ACCESS
3104  5025     MOVF 0x25, W, ACCESS
3106  0A80     XORLW 0x80
3108  581A     SUBWFB 0x1A, W, ACCESS
310A  A0D8     BTFSS 0xFD8, 0, ACCESS
310C  D7EA     BRA 0x30E2
589:                       fputc(' ', fp);
30E2  0E00     MOVLW 0x0
30E4  6E0E     MOVWF 0xE, ACCESS
30E6  0E20     MOVLW 0x20
30E8  6E0D     MOVWF 0xD, ACCESS
30EA  C516     MOVFF fp, s1
30EC  F50F     NOP
30EE  C517     MOVFF tmp, 0x510
30F0  F510     NOP
30F2  EC62     CALL 0x34C4, 0
30F4  F01A     NOP
590:                       ++l;
30F6  4A2A     INFSNZ 0x2A, F, ACCESS
30F8  2A2B     INCF 0x2B, F, ACCESS
591:                   }
592:               }
593:           
594:               /* Put out string */
595:               i = 0;
310E  0E00     MOVLW 0x0
3110  6E23     MOVWF 0x23, ACCESS
3112  0E00     MOVLW 0x0
3114  6E22     MOVWF 0x22, ACCESS
596:               while (i < p) {
3116  D021     BRA 0x315A
315A  5028     MOVF 0x28, W, ACCESS
315C  5C22     SUBWF 0x22, W, ACCESS
315E  5023     MOVF 0x23, W, ACCESS
3160  0A80     XORLW 0x80
3162  6E1A     MOVWF 0x1A, ACCESS
3164  5029     MOVF 0x29, W, ACCESS
3166  0A80     XORLW 0x80
3168  581A     SUBWFB 0x1A, W, ACCESS
316A  A0D8     BTFSS 0xFD8, 0, ACCESS
316C  D7D5     BRA 0x3118
597:                   fputc(*cp, fp);
311A  F498     NOP
311C  F4F6     NOP
3120  F49C     NOP
3122  F4F7     NOP
3124  0E00     MOVLW 0x0
3126  6EF8     MOVWF 0xFF8, ACCESS
3128  0E25     MOVLW 0x25
312A  64F7     CPFSGT 0xFF7, ACCESS
312C  D003     BRA 0x3134
312E  0008     TBLRD*
3130  50F5     MOVF 0xFF5, W, ACCESS
3132  D005     BRA 0x313E
3134  C4F6     MOVFF TBLPTR, FSR0
3136  F4E9     NOP
3138  C4F7     MOVFF TBLPTRH, FSR0H
313A  F4EA     NOP
313C  50EF     MOVF 0xFEF, W, ACCESS
313E  6E1A     MOVWF 0x1A, ACCESS
3140  501A     MOVF 0x1A, W, ACCESS
3142  6E0D     MOVWF 0xD, ACCESS
3144  6A0E     CLRF 0xE, ACCESS
3146  C516     MOVFF fp, s1
3148  F50F     NOP
314A  C517     MOVFF tmp, 0x510
314C  F510     NOP
314E  EC62     CALL 0x34C4, 0
3150  F01A     NOP
598:                   ++cp;
3152  4A26     INFSNZ 0x26, F, ACCESS
3154  2A27     INCF 0x27, F, ACCESS
599:                   ++i;
3156  4A22     INFSNZ 0x22, F, ACCESS
3158  2A23     INCF 0x23, F, ACCESS
600:               }
601:           
602:               /* Left justify, pad on right ? */
603:               if (flags & MINUS_FLAG) {
316E  0105     MOVLB 0x5
3170  B1E3     BTFSC 0xE3, 0, BANKED
3172  D00D     BRA 0x318E
3174  D016     BRA 0x31A2
604:                   while (l < w) {
318E  5024     MOVF 0x24, W, ACCESS
3190  5C2A     SUBWF 0x2A, W, ACCESS
3192  502B     MOVF 0x2B, W, ACCESS
3194  0A80     XORLW 0x80
3196  6E1A     MOVWF 0x1A, ACCESS
3198  5025     MOVF 0x25, W, ACCESS
319A  0A80     XORLW 0x80
319C  581A     SUBWFB 0x1A, W, ACCESS
319E  A0D8     BTFSS 0xFD8, 0, ACCESS
31A0  D7EA     BRA 0x3176
605:                       fputc(' ', fp);
3176  0E00     MOVLW 0x0
3178  6E0E     MOVWF 0xE, ACCESS
317A  0E20     MOVLW 0x20
317C  6E0D     MOVWF 0xD, ACCESS
317E  C516     MOVFF fp, s1
3180  F50F     NOP
3182  C517     MOVFF tmp, 0x510
3184  F510     NOP
3186  EC62     CALL 0x34C4, 0
3188  F01A     NOP
606:                       ++l;
318A  4A2A     INFSNZ 0x2A, F, ACCESS
318C  2A2B     INCF 0x2B, F, ACCESS
607:                   }
608:               }
609:           
610:               return l;
31A2  C52A     MOVFF l, fp
31A4  F516     NOP
31A6  C52B     MOVFF 0x52B, tmp
31A8  F517     NOP
611:           }
31AA  0012     RETURN 0
612:           #endif
613:           
614:           #ifdef _VFPF_U
615:           static _INLINE int utoa(FILE *fp, unsigned long long d)
616:           {
617:               int i, p, w;
618:               unsigned long long n;
619:           
620:               /* Adjust flags, precision, width */
621:               if (!(prec < 0)) {
622:                   flags &= ~ZERO_FLAG;
623:               }
624:               p = (0 < prec) ? prec : 1;
625:               w = width;
626:           
627:               /* Convert to decimal, possibly filling on the left with zeroes */
628:               n = d;
629:               i = sizeof(dbuf) - 1;
630:               dbuf[i] = '\0';
631:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
632:                   --i;
633:                   dbuf[i] = '0' + (n % 10);
634:                   --p;
635:                   --w;
636:                   n = n / 10;
637:               }
638:           
639:               /* Put out padded string */
640:               return pad(fp, &dbuf[i], w);
641:           }
642:           #endif
643:           
644:           #if defined(_VFPF_X) || defined(_VFPF_P)
645:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
646:           {
647:               int c, i, p, w;
648:               unsigned long long n;
649:           
650:               /* Adjust, flags, precision, width */
651:               if (!(prec < 0)) {
652:                   flags &= ~ZERO_FLAG;
653:               }
654:               p = (0 < prec) ? prec : 1;
655:               w = width;
656:               if (flags & POUND_FLAG) {
657:                   w -= 2;
658:               }
659:           
660:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
661:               n = d;
662:               i = sizeof(dbuf) - 1;
663:               dbuf[i] = '\0';
664:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
665:                   --i;
666:                   c = n & 0x0f;
667:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
668:                   if (isupper((int)x) && isalpha(c)) {
669:                       c = toupper(c);
670:                   }
671:                   dbuf[i] = (char)c;
672:                   --p;
673:                   --w;
674:                   n = n >> 4;
675:               }
676:           
677:               /* Display prefix if required */
678:               if (flags & POUND_FLAG) {
679:                   --i;
680:                   dbuf[i] = x;
681:                   --i;
682:                   dbuf[i] = '0';
683:               }
684:           
685:               /* Put out padded string */
686:               return pad(fp, &dbuf[i], w);
687:           }
688:           #endif
689:           
690:           /* Consume and convert the next part of the format string */
691:           #ifdef _VFPF_CONVERT
692:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
693:           {
694:               char c, *cp, ct[3];
695:               int done, i;
696:               long long ll;
697:               unsigned long long llu;
698:               long double f;
699:               void *vp;
700:           
701:               /* Conversion ? */
702:               if ((*fmt)[0] == '%') {
2C58  F4B8     NOP
2C5A  F4D9     NOP
2C5E  F4BC     NOP
2C60  F4DA     NOP
2C62  C4DF     MOVFF INDF2, TBLPTR
2C64  F4F6     NOP
2C66  0E26     MOVLW 0x26
2C68  6EF7     MOVWF 0xFF7, ACCESS
2C6A  0E00     MOVLW 0x0
2C6C  6EF8     MOVWF 0xFF8, ACCESS
2C6E  0008     TBLRD*
2C70  50F5     MOVF 0xFF5, W, ACCESS
2C72  0A25     XORLW 0x25
2C74  A4D8     BTFSS 0xFD8, 2, ACCESS
2C76  D088     BRA 0x2D88
703:                   ++*fmt;
2C7A  F4B8     NOP
2C7C  F4D9     NOP
2C80  F4BC     NOP
2C82  F4DA     NOP
2C84  2ADF     INCF 0xFDF, F, ACCESS
704:           
705:                   flags = width = 0;
2C86  0E00     MOVLW 0x0
2C88  0105     MOVLB 0x5
2C8A  6FE0     MOVWF 0xE0, BANKED
2C8C  0E00     MOVLW 0x0
2C8E  6FDF     MOVWF CLCnGLS3, BANKED
2C90  C5DF     MOVFF width, flags
2C92  F5E3     NOP
2C94  C5E0     MOVFF 0x5E0, 0x5E4
2C96  F5E4     NOP
706:                   prec = -1;
2C98  69E1     SETF 0xE1, BANKED
2C9A  69E2     SETF 0xE2, BANKED
707:           
708:           #ifdef _VFPF_FLAGS
709:                   /* Get flags */
710:                   done = 0;
711:                   while (!done) {
712:                       switch ((*fmt)[0]) {
713:                           case '-' :
714:                               flags |= MINUS_FLAG;
715:                               ++*fmt;
716:                               break;
717:                           case '0' :
718:                               flags |= ZERO_FLAG;
719:                               ++*fmt;
720:                               break;
721:                           case '+' :
722:                               flags |= PLUS_FLAG;
723:                               ++*fmt;
724:                               break;
725:                           case ' ' :
726:                               flags |= SPACE_FLAG;
727:                               ++*fmt;
728:                               break;
729:                           case '#' :
730:                               flags |= POUND_FLAG;
731:                               ++*fmt;
732:                               break;
733:                           default:
734:                               done = 1;
735:                               break;
736:                       }
737:                   }
738:                   if (flags & MINUS_FLAG) {
739:                       flags &= ~ZERO_FLAG;
740:                   }
741:           #endif
742:           
743:           #ifdef _VFPF_WIDTH
744:                   /* Get field width */
745:                   if ((*fmt)[0] == '*') {
746:                       ++*fmt;
747:                       width = va_arg(ap, int);
748:                       if (width < 0) {
749:                           flags |= MINUS_FLAG;
750:                           width = -width;
751:                       }
752:                   } else {
753:                       width = atoi(*fmt);
754:                       while (isdigit((*fmt)[0])) {
755:                           ++*fmt;
756:                       }
757:                   }
758:           #endif
759:           
760:           #ifdef _VFPF_PRECISION
761:                   /* Get precision */
762:                   if ((*fmt)[0] == '.') {
763:                       prec = 0;
764:                       ++*fmt;
765:                       if ((*fmt)[0] == '*') {
766:                           ++*fmt;
767:                           prec = va_arg(ap, int);
768:                       } else {
769:                           prec = atoi(*fmt);
770:                           while (isdigit((*fmt)[0])) {
771:                               ++*fmt;
772:                           }
773:                       }
774:                   }
775:           #endif
776:           
777:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
778:                   /* Case-folded conversion types */
779:                   ct[0] = (char)tolower((int)(*fmt)[0]);
780:                   if (ct[0]) {
781:                       ct[1] = (char)tolower((int)(*fmt)[1]);
782:                       if (ct[1]) {
783:                           ct[2] = (char)tolower((int)(*fmt)[2]);
784:                       }
785:                   }
786:           #endif
787:           
788:           #ifdef _VFPF_A
789:                   /* 'a' style (hex) floating point */
790:                   if (ct[0] == 'a') {
791:           
792:                       c = (*fmt)[0];
793:                       ++*fmt;
794:                       f = (long double)va_arg(ap, double);
795:                                   
796:                       return atoa(fp, f, c);
797:                   }
798:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
799:           
800:                       c = (*fmt)[1];
801:                       if (isupper((int)(*fmt)[0])) {
802:                           f = va_arg(ap, long double);
803:                       } else {
804:                           f = (long double)va_arg(ap, double);
805:                       }
806:                       *fmt += CSTRLEN("la");
807:                                   
808:                       return atoa(fp, f, c);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_C
813:                   /* Character */
814:                   if (*fmt[0] == 'c') {
815:                       ++*fmt;
816:                       c = (unsigned char)va_arg(ap, int);
817:                       return ctoa(fp, c);
818:                   }
819:           #endif
820:           
821:           #ifdef _VFPF_D
822:           #ifdef _VFPF_HH
823:                   /* Character decimal integer */
824:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
825:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
826:           
827:                       *fmt += CSTRLEN("hhd");
828:                       ll = (long long)(signed char)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           #endif
833:           
834:           #ifdef _VFPF_H
835:                   /* Short decimal integer */
836:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
837:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
838:           
839:                       *fmt += CSTRLEN("hd");
840:                       ll = (long long)(short)va_arg(ap, int);
841:                                   
842:                       return dtoa(fp, ll);
843:                   }
844:           #endif
845:           
846:                   /* Decimal integer */
847:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
848:           
849:                       ++*fmt;
850:                       ll = (long long)va_arg(ap, int);
851:                                   
852:                       return dtoa(fp, ll);
853:                   }
854:           
855:           #ifdef _VFPF_L
856:                   /* Long decimal integer */
857:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
858:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
859:           
860:                       *fmt += CSTRLEN("ld");
861:                       ll = (long long)va_arg(ap, long);
862:                                   
863:                       return dtoa(fp, ll);
864:                   }
865:           #endif
866:           
867:           #ifdef _VFPF_LL
868:                   /* Long long decimal integer */
869:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
870:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
871:           
872:                       *fmt += CSTRLEN("lld");
873:                       ll = va_arg(ap, long long);
874:                                   
875:                       return dtoa(fp, ll);
876:                   }
877:           #endif
878:           
879:           #ifdef _VFPF_J
880:                   /* intmax_t decimal integer */
881:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
882:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
883:           
884:                       *fmt += CSTRLEN("jd");
885:                       ll = (long long)va_arg(ap, intmax_t);
886:                                   
887:                       return dtoa(fp, ll);
888:                   }
889:           #endif
890:           
891:           #ifdef _VFPF_T
892:                   /* ptrdiff_t decimal integer */
893:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
894:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
895:           
896:                       *fmt += CSTRLEN("td");
897:                       ll = (long long)va_arg(ap, ptrdiff_t);
898:                                   
899:                       return dtoa(fp, ll);
900:                   }
901:           #endif
902:           
903:           #ifdef _VFPF_Z
904:                   /* size_t decimal integer */
905:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
906:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
907:           
908:                       *fmt += CSTRLEN("zd");
909:                       ll = (long long)va_arg(ap, size_t);
910:                                   
911:                       return dtoa(fp, ll);
912:                   }
913:           #endif
914:           #endif
915:           
916:           #ifdef _VFPF_E
917:                   /* 'e' style floating point */
918:                   if (ct[0] == 'e') {
919:           
920:                       c = (*fmt)[0];
921:                       ++*fmt;
922:                       f = (long double)va_arg(ap, double);
923:                                   
924:                       return efgtoa(fp, f, c);
925:                   }
926:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
927:           
928:                       c = (*fmt)[1];
929:                       if (isupper((int)(*fmt)[0])) {
930:                           f = va_arg(ap, long double);
931:                       } else {
932:                           f = (long double)va_arg(ap, double);
933:                       }
934:                       *fmt += CSTRLEN("lf");
935:                                   
936:                       return efgtoa(fp, f, c);
937:                   }
938:           #endif
939:           
940:           #ifdef _VFPF_F
941:                   /* 'f' style floating point */
942:                   if (ct[0] == 'f') {
943:           
944:                       c = (*fmt)[0];
945:                       ++*fmt;
946:                       f = (long double)va_arg(ap, double);
947:                                   
948:                       return efgtoa(fp, f, c);
949:                   }
950:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
951:           
952:                       c = (*fmt)[1];
953:                       if (isupper((int)(*fmt)[0])) {
954:                           f = va_arg(ap, long double);
955:                       } else {
956:                           f = (long double)va_arg(ap, double);
957:                       }
958:                       *fmt += CSTRLEN("lf");
959:                                   
960:                       return efgtoa(fp, f, c);
961:                   }
962:           #endif
963:           
964:           #ifdef _VFPF_G
965:                   /* 'g' style floating point */
966:                   if (ct[0] == 'g') {
967:           
968:                       c = (*fmt)[0];
969:                       ++*fmt;
970:                       f = (long double)va_arg(ap, double);
971:                                   
972:                       return efgtoa(fp, f, c);
973:                   }
974:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
975:           
976:                       c = (*fmt)[1];
977:                       if (isupper((int)(*fmt)[0])) {
978:                           f = va_arg(ap, long double);
979:                       } else {
980:                           f = (long double)va_arg(ap, double);
981:                       }
982:                       *fmt += CSTRLEN("lg");
983:                                   
984:                       return efgtoa(fp, f, c);
985:                   }
986:           #endif
987:           
988:           #ifdef _VFPF_O
989:           #ifdef _VFPF_HH
990:                   /* Character octal integer */
991:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
992:           
993:                       *fmt += CSTRLEN("hho");
994:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
995:                                   
996:                       return otoa(fp, llu);
997:                   }
998:           #endif
999:           
1000:          #ifdef _VFPF_H
1001:                  /* Short octal integer */
1002:                  if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
1003:          
1004:                      *fmt += CSTRLEN("ho");
1005:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1006:                                  
1007:                      return otoa(fp, llu);
1008:                  }
1009:          #endif
1010:          
1011:                  /* Octal integer */
1012:                  if (*fmt[0] == 'o') {
1013:          
1014:                      ++*fmt;
1015:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1016:                                  
1017:                      return otoa(fp, llu);
1018:                  }
1019:          
1020:          #ifdef _VFPF_L
1021:                  /* Long octal integer */
1022:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1023:          
1024:                      *fmt += CSTRLEN("lo");
1025:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_LL
1032:                  /* Long long octal integer */
1033:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1034:          
1035:                      *fmt += CSTRLEN("llo");
1036:                      llu = va_arg(ap, unsigned long long);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_J
1043:                  /* uintmax_t octal integer */
1044:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1045:          
1046:                      *fmt += CSTRLEN("jo");
1047:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          
1053:          #ifdef _VFPF_T
1054:                  /* ptrdiff_t octal integer */
1055:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1056:          
1057:                      *fmt += CSTRLEN("to");
1058:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1059:                                  
1060:                      return otoa(fp, llu);
1061:                  }
1062:          #endif
1063:          
1064:          #ifdef _VFPF_Z
1065:                  /* size_t octal integer */
1066:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1067:          
1068:                      *fmt += CSTRLEN("zo");
1069:                      llu = (unsigned long long)va_arg(ap, size_t);
1070:                                  
1071:                      return otoa(fp, llu);
1072:                  }
1073:          #endif
1074:          #endif
1075:          
1076:                  /* Character count */
1077:          #ifdef _VFPF_N
1078:          
1079:          #ifdef _VFPF_HH
1080:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1081:          
1082:                      *fmt += CSTRLEN("hhn");
1083:                      vp = (void *)va_arg(ap, char *);
1084:                      *(char *)vp = (char)nout;
1085:                      return 0;
1086:                  }
1087:          #endif
1088:          
1089:          #ifdef _VFPF_H
1090:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1091:          
1092:                      *fmt += CSTRLEN("hn");
1093:                      vp = (void *)va_arg(ap, short *);
1094:                      *(short *)vp = (short)nout;
1095:                      return 0;
1096:                  }
1097:          #endif
1098:          
1099:                  if (*fmt[0] == 'n') {
1100:                      ++*fmt;
1101:                      vp = (void *)va_arg(ap, int *);
1102:                      *(int *)vp = nout;
1103:                      return 0;
1104:                  }
1105:          
1106:          #ifdef _VFPF_L
1107:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1108:          
1109:                      *fmt += CSTRLEN("ln");
1110:                      vp = (void *)va_arg(ap, long *);
1111:                      *(long *)vp = (long)nout;
1112:                      return 0;
1113:                  }
1114:          #endif
1115:          
1116:          #ifdef _VFPF_LL
1117:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1118:          
1119:                      *fmt += CSTRLEN("lln");
1120:                      vp = (void *)va_arg(ap, long long *);
1121:                      *(long long *)vp = (long long)nout;
1122:                      return 0;
1123:                  }
1124:          #endif
1125:          
1126:          #ifdef _VFPF_J
1127:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1128:          
1129:                      *fmt += CSTRLEN("jn");
1130:                      vp = (void *)va_arg(ap, uintmax_t *);
1131:                      *(uintmax_t *)vp = (uintmax_t)nout;
1132:                      return 0;
1133:                  }
1134:          #endif
1135:          
1136:          #ifdef _VFPF_T
1137:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1138:          
1139:                      *fmt += CSTRLEN("tn");
1140:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1141:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1142:                      return 0;
1143:                  }
1144:          #endif
1145:          
1146:          #ifdef _VFPF_Z
1147:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1148:          
1149:                      *fmt += CSTRLEN("zn");
1150:                      vp = (void *)va_arg(ap, size_t *);
1151:                      *(size_t *)vp = (size_t)nout;
1152:                      return 0;
1153:                  }
1154:          #endif
1155:          
1156:          #endif
1157:          
1158:          #ifdef _VFPF_P
1159:                  /* Pointer */
1160:                  if (*fmt[0] == 'p') {
1161:          
1162:                      ++*fmt;
1163:                      llu = (unsigned long long)(uintptr_t)va_arg(ap, void *);
1164:                                  
1165:                      return xtoa(fp, llu, 'x');
1166:                  }
1167:          #endif
1168:          
1169:          #ifdef _VFPF_S
1170:                  /* String */
1171:                  if (*fmt[0] == 's') {
2C9E  F4B8     NOP
2CA0  F4D9     NOP
2CA4  F4BC     NOP
2CA6  F4DA     NOP
2CA8  C4DF     MOVFF INDF2, TBLPTR
2CAA  F4F6     NOP
2CAC  0E26     MOVLW 0x26
2CAE  6EF7     MOVWF 0xFF7, ACCESS
2CB0  0E00     MOVLW 0x0
2CB2  6EF8     MOVWF 0xFF8, ACCESS
2CB4  0008     TBLRD*
2CB6  50F5     MOVF 0xFF5, W, ACCESS
2CB8  0A73     XORLW 0x73
2CBA  A4D8     BTFSS 0xFD8, 2, ACCESS
2CBC  D032     BRA 0x2D22
1172:          
1173:                      ++*fmt;
2CC0  F4B8     NOP
2CC2  F4D9     NOP
2CC6  F4BC     NOP
2CC8  F4DA     NOP
2CCA  2ADF     INCF 0xFDF, F, ACCESS
1174:                      cp = va_arg(ap, char *);
2CCE  F4C0     NOP
2CD0  F4D9     NOP
2CD4  F4C4     NOP
2CD6  F4DA     NOP
2CDA  F37C     NOP
2CDC  F532     NOP
2CDE  0E02     MOVLW 0x2
2CE0  26DE     ADDWF 0xFDE, F, ACCESS
2CE4  F37C     NOP
2CE6  F533     NOP
2CE8  0E00     MOVLW 0x0
2CEA  22DD     ADDWFC 0xFDD, F, ACCESS
2CEE  F4C8     NOP
2CF0  F4D9     NOP
2CF4  F4CC     NOP
2CF6  F4DA     NOP
2CFA  F378     NOP
2CFC  F534     NOP
2D00  F374     NOP
2D02  F535     NOP
1175:          
1176:                      return stoa(fp, cp);
2D04  C52C     MOVFF fp, fp
2D06  F516     NOP
2D08  C52D     MOVFF 0x52D, tmp
2D0A  F517     NOP
2D0C  C534     MOVFF cp, _this
2D0E  F518     NOP
2D10  C535     MOVFF 0x535, _this
2D12  F519     NOP
2D14  EC32     CALL 0x3064, 0
2D16  F018     NOP
2D18  C516     MOVFF fp, fp
2D1A  F52C     NOP
2D1C  C517     MOVFF tmp, 0x52D
2D1E  F52D     NOP
2D20  0012     RETURN 0
1177:                  }
1178:          #endif
1179:          
1180:          #ifdef _VFPF_U
1181:          #ifdef _VFPF_HH
1182:                  /* Unsigned character decimal integer */
1183:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1184:          
1185:                      *fmt += CSTRLEN("hhu");
1186:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1187:                                  
1188:                      return utoa(fp, llu);
1189:                  }
1190:          #endif
1191:          
1192:          #ifdef _VFPF_H
1193:                  /* Unsigned short decimal integer */
1194:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1195:          
1196:                      *fmt += CSTRLEN("hu");
1197:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1198:                                  
1199:                      return utoa(fp, llu);
1200:                  }
1201:          #endif
1202:          
1203:                  /* Unsigned decimal integer */
1204:                  if (*fmt[0] == 'u') {
1205:          
1206:                      ++*fmt;
1207:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1208:                                  
1209:                      return utoa(fp, llu);
1210:                  }
1211:          
1212:          #ifdef _VFPF_L
1213:                  /* Unsigned long decimal integer */
1214:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1215:          
1216:                      *fmt += CSTRLEN("lu");
1217:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_LL
1224:                  /* Unsigned long long decimal integer */
1225:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1226:          
1227:                      *fmt += CSTRLEN("llu");
1228:                      llu = va_arg(ap, unsigned long long);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_J
1235:                  /* uintmax_t decimal integer */
1236:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1237:          
1238:                      *fmt += CSTRLEN("ju");
1239:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          
1245:          #ifdef _VFPF_T
1246:                  /* ptrdiff_t decimal integer */
1247:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1248:          
1249:                      *fmt += CSTRLEN("tu");
1250:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1251:                                  
1252:                      return utoa(fp, llu);
1253:                  }
1254:          #endif
1255:          
1256:          #ifdef _VFPF_Z
1257:                  /* size_t decimal integer */
1258:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1259:          
1260:                      *fmt += CSTRLEN("zu");
1261:                      llu = (unsigned long long)va_arg(ap, size_t);
1262:                                  
1263:                      return utoa(fp, llu);
1264:                  }
1265:          #endif
1266:          #endif
1267:          
1268:          #ifdef _VFPF_X
1269:          #ifdef _VFPF_HH
1270:                  /* Character hexadecimal integer */
1271:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1272:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1273:          
1274:                      c = (*fmt)[2];
1275:                      *fmt += CSTRLEN("hhx");
1276:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1277:                                  
1278:                      return xtoa(fp, llu, c);
1279:                  }
1280:          #endif
1281:          
1282:          #ifdef _VFPF_H
1283:                  /* Short hexadecimal integer */
1284:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1285:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1286:          
1287:                      c = (*fmt)[1];
1288:                      *fmt += CSTRLEN("hx");
1289:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1290:                                  
1291:                      return xtoa(fp, llu, c);
1292:                  }
1293:          #endif
1294:          
1295:                  /* Hexadecimal integer */
1296:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1297:          
1298:                      c = (*fmt)[0];
1299:                      ++*fmt;
1300:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1301:                                  
1302:                      return xtoa(fp, llu, c);
1303:                  }
1304:          
1305:          #ifdef _VFPF_L
1306:                  /* Long hexadecimal integer */
1307:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1308:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1309:          
1310:                      c = (*fmt)[1];
1311:                      *fmt += CSTRLEN("lx");
1312:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1313:                                  
1314:                      return xtoa(fp, llu, c);
1315:                  }
1316:          #endif
1317:          
1318:          #ifdef _VFPF_LL
1319:                  /* Long long hexadecimal integer */
1320:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1321:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1322:          
1323:                      c = (*fmt)[2];
1324:                      *fmt += CSTRLEN("llx");
1325:                      llu = va_arg(ap, unsigned long long);
1326:                                  
1327:                      return xtoa(fp, llu, c);
1328:                  }
1329:          #endif
1330:          
1331:          #ifdef _VFPF_J
1332:                  /* uintmax_t hexadecimal integer */
1333:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1334:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1335:          
1336:                      c = (*fmt)[1];
1337:                      *fmt += CSTRLEN("jx");
1338:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1339:                                  
1340:                      return xtoa(fp, llu, c);
1341:                  }
1342:          #endif
1343:          
1344:          #ifdef _VFPF_T
1345:                  /* ptrdiff_t hexadecimal integer */
1346:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1347:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1348:          
1349:                      c = (*fmt)[1];
1350:                      *fmt += CSTRLEN("tx");
1351:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1352:                                  
1353:                      return xtoa(fp, llu, c);
1354:                  }
1355:          #endif
1356:          
1357:          #ifdef _VFPF_Z
1358:                  /* size_t hexadecimal integer */
1359:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1360:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1361:          
1362:                      c = (*fmt)[1];
1363:                      *fmt += CSTRLEN("zx");
1364:                      llu = (unsigned long long)va_arg(ap, size_t);
1365:                                  
1366:                      return xtoa(fp, llu, c);
1367:                  }
1368:          #endif
1369:          #endif
1370:          
1371:                  /* 'Escaped' '%' character */
1372:                  if ((*fmt)[0] == '%') {
2D24  F4B8     NOP
2D26  F4D9     NOP
2D2A  F4BC     NOP
2D2C  F4DA     NOP
2D2E  C4DF     MOVFF INDF2, TBLPTR
2D30  F4F6     NOP
2D32  0E26     MOVLW 0x26
2D34  6EF7     MOVWF 0xFF7, ACCESS
2D36  0E00     MOVLW 0x0
2D38  6EF8     MOVWF 0xFF8, ACCESS
2D3A  0008     TBLRD*
2D3C  50F5     MOVF 0xFF5, W, ACCESS
2D3E  0A25     XORLW 0x25
2D40  A4D8     BTFSS 0xFD8, 2, ACCESS
2D42  D016     BRA 0x2D70
1373:                      ++*fmt;
2D46  F4B8     NOP
2D48  F4D9     NOP
2D4C  F4BC     NOP
2D4E  F4DA     NOP
2D50  2ADF     INCF 0xFDF, F, ACCESS
1374:                      fputc((int)'%', fp);
2D52  0E00     MOVLW 0x0
2D54  6E0E     MOVWF 0xE, ACCESS
2D56  0E25     MOVLW 0x25
2D58  6E0D     MOVWF 0xD, ACCESS
2D5A  C52C     MOVFF fp, s1
2D5C  F50F     NOP
2D5E  C52D     MOVFF 0x52D, 0x510
2D60  F510     NOP
2D62  EC62     CALL 0x34C4, 0
2D64  F01A     NOP
1375:                      return 1;
2D66  0E00     MOVLW 0x0
2D68  6E2D     MOVWF 0x2D, ACCESS
2D6A  0E01     MOVLW 0x1
2D6C  6E2C     MOVWF 0x2C, ACCESS
2D6E  0012     RETURN 0
1376:                  }
1377:          
1378:                  /* Unrecognized conversion */
1379:                  ++*fmt;
2D72  F4B8     NOP
2D74  F4D9     NOP
2D78  F4BC     NOP
2D7A  F4DA     NOP
2D7C  2ADF     INCF 0xFDF, F, ACCESS
1380:                  return 0;
2D7E  0E00     MOVLW 0x0
2D80  6E2D     MOVWF 0x2D, ACCESS
2D82  0E00     MOVLW 0x0
2D84  6E2C     MOVWF 0x2C, ACCESS
2D86  0012     RETURN 0
1381:              }
1382:          
1383:              /* No conversion, just intervening text */
1384:              fputc((int)(*fmt)[0], fp);
2D8A  F4B8     NOP
2D8C  F4D9     NOP
2D90  F4BC     NOP
2D92  F4DA     NOP
2D94  C4DF     MOVFF INDF2, TBLPTR
2D96  F4F6     NOP
2D98  0E26     MOVLW 0x26
2D9A  6EF7     MOVWF 0xFF7, ACCESS
2D9C  0E00     MOVLW 0x0
2D9E  6EF8     MOVWF 0xFF8, ACCESS
2DA0  0008     TBLRD*
2DA2  50F5     MOVF 0xFF5, W, ACCESS
2DA4  6E0D     MOVWF 0xD, ACCESS
2DA6  6A0E     CLRF 0xE, ACCESS
2DA8  C52C     MOVFF fp, s1
2DAA  F50F     NOP
2DAC  C52D     MOVFF 0x52D, 0x510
2DAE  F510     NOP
2DB0  EC62     CALL 0x34C4, 0
2DB2  F01A     NOP
1385:              ++*fmt;
2DB6  F4B8     NOP
2DB8  F4D9     NOP
2DBC  F4BC     NOP
2DBE  F4DA     NOP
2DC0  2ADF     INCF 0xFDF, F, ACCESS
2DC2  D7D1     BRA 0x2D66
1386:              return 1;
1387:          }
1388:          #endif
1389:          
1390:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1391:          {
1392:          #ifdef _VFPF_CONVERT
1393:              char *cfmt;
1394:          
1395:              cfmt = (char *)fmt;
37CA  C538     MOVFF fmt, cfmt
37CC  F53B     NOP
1396:              nout = 0;
37CE  0E00     MOVLW 0x0
37D0  0105     MOVLB 0x5
37D2  6FDE     MOVWF CLCnGLS2, BANKED
37D4  0E00     MOVLW 0x0
37D6  6FDD     MOVWF CLCnGLS1, BANKED
1397:              while (*cfmt) {
37D8  D013     BRA 0x3800
3802  F4EC     NOP
3804  F4F6     NOP
3806  0E26     MOVLW 0x26
3808  6EF7     MOVWF 0xFF7, ACCESS
380A  0E00     MOVLW 0x0
380C  6EF8     MOVWF 0xFF8, ACCESS
380E  0008     TBLRD*
3810  50F5     MOVF 0xFF5, W, ACCESS
3812  0900     IORLW 0x0
3814  A4D8     BTFSS 0xFD8, 2, ACCESS
3816  D7E1     BRA 0x37DA
1398:                  nout += vfpfcnvrt(fp, &cfmt, ap);
37DA  C536     MOVFF fp, fp
37DC  F52C     NOP
37DE  C537     MOVFF 0x537, 0x52D
37E0  F52D     NOP
37E2  0E3B     MOVLW 0x3B
37E4  6E2E     MOVWF 0x2E, ACCESS
37E6  0E05     MOVLW 0x5
37E8  6E2F     MOVWF 0x2F, ACCESS
37EA  C539     MOVFF ap, ap
37EC  F530     NOP
37EE  C53A     MOVFF 0x53A, 0x531
37F0  F531     NOP
37F2  EC2B     CALL 0x2C56, 0
37F4  F016     NOP
37F6  502C     MOVF 0x2C, W, ACCESS
37F8  0105     MOVLB 0x5
37FA  27DD     ADDWF CLCnGLS1, F, BANKED
37FC  502D     MOVF 0x2D, W, ACCESS
37FE  23DE     ADDWFC CLCnGLS2, F, BANKED
1399:              }
1400:              return nout;
3818  C5DD     MOVFF nout, fp
381A  F536     NOP
381C  C5DE     MOVFF 0x5DE, 0x537
381E  F537     NOP
1401:          #else
1402:              return fputs(fmt, fp);
1403:          #endif
1404:          }
3820  0012     RETURN 0
