Disassembly Listing for q43_baseline
Generated From:
/root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/dist/default/production/q43_baseline.X.production.elf
Feb 20, 2021 1:32:04 PM

---  /tmp/xcXJhNnJg.s  ----------------------------------------------------------------------------------
11EF2  0EBA     MOVLW 0xBA
11EF4  6EF6     MOVWF 0xFF6, ACCESS
11EF6  0E0C     MOVLW 0xC
11EF8  6EF7     MOVWF 0xFF7, ACCESS
11EFA  0E01     MOVLW 0x1
11EFC  6EF8     MOVWF 0xFF8, ACCESS
11EFE  EE02     LFSR 0, 0xB00
11F02  EE11     LFSR 1, 0x400
11F06  0009     TBLRD*+
11F08  C4F5     MOVFF TABLAT, POSTINC0
11F0C  50E5     MOVF 0xFE5, W, ACCESS
11F0E  50E1     MOVF 0xFE1, W, ACCESS
11F10  E1FA     BNZ 0x1F06
11F12  50E2     MOVF 0xFE2, W, ACCESS
11F14  E1F8     BNZ 0x1F06
11F16  0E2C     MOVLW 0x2C
11F18  6EF6     MOVWF 0xFF6, ACCESS
11F1A  0E30     MOVLW 0x30
11F1C  6EF7     MOVWF 0xFF7, ACCESS
11F1E  0E01     MOVLW 0x1
11F20  6EF8     MOVWF 0xFF8, ACCESS
11F22  EE01     LFSR 0, 0x6B4
11F26  EE10     LFSR 1, 0x35
11F2A  0009     TBLRD*+
11F2C  C4F5     MOVFF TABLAT, POSTINC0
11F30  50E5     MOVF 0xFE5, W, ACCESS
11F32  50E1     MOVF 0xFE1, W, ACCESS
11F34  E1FA     BNZ 0x1F2A
11F36  0E7E     MOVLW 0x7E
11F38  6EF6     MOVWF 0xFF6, ACCESS
11F3A  0E35     MOVLW 0x35
11F3C  6EF7     MOVWF 0xFF7, ACCESS
11F3E  0E01     MOVLW 0x1
11F40  6EF8     MOVWF 0xFF8, ACCESS
11F42  0009     TBLRD*+
11F4A  0009     TBLRD*+
11F52  0009     TBLRD*+
11F5A  EE02     LFSR 0, 0xA00
11F5E  EE10     LFSR 1, 0x100
11F62  6AEE     CLRF 0xFEE, ACCESS
11F64  50E5     MOVF 0xFE5, W, ACCESS
11F66  50E1     MOVF 0xFE1, W, ACCESS
11F68  E1FC     BNZ 0x1F62
11F6A  50E2     MOVF 0xFE2, W, ACCESS
11F6C  E1FA     BNZ 0x1F62
11F6E  EE02     LFSR 0, 0x900
11F72  0EC3     MOVLW 0xC3
11F74  6AEE     CLRF 0xFEE, ACCESS
11F76  06E8     DECF 0xFE8, F, ACCESS
11F78  E1FD     BNZ 0x1F74
11F7A  EE02     LFSR 0, 0x800
11F7E  EE10     LFSR 1, 0x100
11F82  6AEE     CLRF 0xFEE, ACCESS
11F84  50E5     MOVF 0xFE5, W, ACCESS
11F86  50E1     MOVF 0xFE1, W, ACCESS
11F88  E1FC     BNZ 0x1F82
11F8A  50E2     MOVF 0xFE2, W, ACCESS
11F8C  E1FA     BNZ 0x1F82
11F8E  EE01     LFSR 0, 0x700
11F92  0EE0     MOVLW 0xE0
11F94  6AEE     CLRF 0xFEE, ACCESS
11F96  06E8     DECF 0xFE8, F, ACCESS
11F98  E1FD     BNZ 0x1F94
11F9A  EE01     LFSR 0, 0x600
11F9E  0EB4     MOVLW 0xB4
11FA0  6AEE     CLRF 0xFEE, ACCESS
11FA2  06E8     DECF 0xFE8, F, ACCESS
11FA4  E1FD     BNZ 0x1FA0
11FA6  EE01     LFSR 0, 0x5A8
11FAA  0E46     MOVLW 0x46
11FAC  6AEE     CLRF 0xFEE, ACCESS
11FAE  06E8     DECF 0xFE8, F, ACCESS
11FB0  E1FD     BNZ 0x1FAC
11FB2  6A58     CLRF 0x58, ACCESS
11FB4  6A57     CLRF 0x57, ACCESS
11FB6  6A56     CLRF 0x56, ACCESS
11FB8  6A55     CLRF 0x55, ACCESS
11FBA  6A54     CLRF 0x54, ACCESS
11FBC  6A53     CLRF 0x53, ACCESS
11FBE  0104     MOVLB 0x4
11FC0  0E08     MOVLW 0x8
11FC2  6F5D     MOVWF 0x5D, BANKED
11FC4  0E00     MOVLW 0x0
11FC6  6F5E     MOVWF 0x5E, BANKED
11FC8  0E00     MOVLW 0x0
11FCA  6F5F     MOVWF 0x5F, BANKED
11FCC  0100     MOVLB 0x0
11FCE  EF00     GOTO 0x10000
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/timers.c  ----------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "timers.h"
5:             
6:             extern volatile uint16_t tickCount[TMR_COUNT];
7:             
8:             //**********************************************************************************************************************
9:             // Start one of the software timers
10:            
11:            void StartTimer(const uint8_t timer, const uint16_t count)
130F4  6E0A     MOVWF 0xA, ACCESS
12:            {
13:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
130F6  C506     MOVFF InterruptHandler, blockSize
130F8  F508     NOP
130FA  C507     MOVFF c, td
130FC  F509     NOP
130FE  90D8     BCF 0xFD8, 0, ACCESS
13100  3608     RLCF 0x8, F, ACCESS
13102  3609     RLCF 0x9, F, ACCESS
13104  500A     MOVF 0xA, W, ACCESS
13106  0D02     MULLW 0x2
13108  0E7F     MOVLW 0x7F
1310A  24F3     ADDWF 0xFF3, W, ACCESS
1310C  6ED9     MOVWF 0xFD9, ACCESS
1310E  0E06     MOVLW 0x6
13110  20F4     ADDWFC 0xFF4, W, ACCESS
13112  6EDA     MOVWF 0xFDA, ACCESS
13116  F420     NOP
13118  F4DE     NOP
1311C  F424     NOP
1311E  F4DD     NOP
14:            }
13120  0012     RETURN 0
15:            
16:            //**********************************************************************************************************************
17:            // Check if one of the software software timers has timed out
18:            
19:            bool TimerDone(const uint8_t timer)
1317E  6E08     MOVWF 0x8, ACCESS
20:            {
21:            	bool td = false;
13180  0E00     MOVLW 0x0
13182  6E09     MOVWF 0x9, ACCESS
22:            
23:            	ClrWdt(); // reset the WDT timer
13184  0004     CLRWDT
24:            	if (tickCount[timer] == (uint16_t) 0) { //Check if counted down to zero
13186  5008     MOVF 0x8, W, ACCESS
13188  0D02     MULLW 0x2
1318A  0E7F     MOVLW 0x7F
1318C  24F3     ADDWF 0xFF3, W, ACCESS
1318E  6ED9     MOVWF 0xFD9, ACCESS
13190  0E06     MOVLW 0x6
13192  20F4     ADDWFC 0xFF4, W, ACCESS
13194  6EDA     MOVWF 0xFDA, ACCESS
13196  50DE     MOVF 0xFDE, W, ACCESS
13198  10DE     IORWF 0xFDE, W, ACCESS
1319A  A4D8     BTFSS 0xFD8, 2, ACCESS
1319C  D002     BRA 0x31A2
25:            		td = true; //then return true
1319E  0E01     MOVLW 0x1
131A0  6E09     MOVWF 0x9, ACCESS
26:            	}
27:            	return td;
131A2  5009     MOVF 0x9, W, ACCESS
28:            }
131A4  0012     RETURN 0
29:            
30:            //**********************************************************************************************************************
31:            // Simple delay for n milliseconds (blocking)
32:            
33:            void WaitMs(const uint16_t numMilliseconds)
34:            {
35:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
36:            	while (!TimerDone(TMR_INTERNAL)) {
37:            		Nop();
38:            		Nop();
39:            		Nop();
40:            		Nop();
41:            		ClrWdt(); // reset the WDT timer
42:            		//		Idle();
43:            	} //Enter idle mode to reduce power while waiting
44:            } //(timer interrupt will wake part from idle)
45:            
46:            
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/ringbufs.c  --------------------------------
1:             #include  <string.h>
2:             #include  "ringbufs.h"
3:             
4:             /*
5:              * general ring buffer fuctions from the internet
6:              */
7:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
8:             {
9:             	uint8_t my_value = value + 1;
10:            	if (my_value >= modulus) {
11:            		my_value = 0;
12:            	}
13:            	return my_value;
14:            }
15:            
16:            uint8_t modulo_dec(const uint8_t value, const uint8_t modulus)
17:            {
18:            	uint8_t my_value = (0 == value) ? (modulus - 1) : (value - 1);
19:            	return my_value;
20:            }
21:            
22:            void *ringBufS_init(volatile ringBufS_t *_this)
23:            {
24:            	/*****
25:            	  The following clears:
26:            	    -> buf
27:            	    -> head
28:            	    -> tail
29:            	    -> count
30:            	  and sets head = tail
31:            	 ***/
32:            	return memset((void*) _this, 0, sizeof(*_this));
1337C  C512     MOVFF sum, InterruptHandler
1337E  F506     NOP
13380  C513     MOVFF c, c
13382  F507     NOP
13384  0E00     MOVLW 0x0
13386  6E09     MOVWF 0x9, ACCESS
13388  0E00     MOVLW 0x0
1338A  6E08     MOVWF 0x8, ACCESS
1338C  0E00     MOVLW 0x0
1338E  6E0B     MOVWF 0xB, ACCESS
13390  0E43     MOVLW 0x43
13392  6E0A     MOVWF 0xA, ACCESS
13394  EC54     CALL 0x118A8, 0
13396  F08C     NOP
33:            }
13398  0012     RETURN 0
34:            
35:            int8_t ringBufS_empty(ringBufS_t *_this)
36:            {
37:            	return(0 == _this->count);
38:            }
39:            
40:            int8_t ringBufS_full(ringBufS_t *_this)
41:            {
42:            	return(_this->count >= RBUF_SIZE);
43:            }
44:            
45:            uint8_t ringBufS_get(ringBufS_t *_this)
46:            {
47:            	uint8_t c;
48:            	if (_this->count > 0) {
49:            		c = _this->buf[_this->tail];
50:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
51:            		--_this->count;
52:            	} else {
53:            		c = 0; // return null with empty buffer
54:            	}
55:            	return(c);
56:            }
57:            
58:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
59:            {
60:            	if (_this->count < RBUF_SIZE) {
61:            		_this->buf[_this->head] = c;
62:            		_this->head = modulo_inc(_this->head, RBUF_SIZE);
63:            		++_this->count;
64:            	}
65:            }
66:            
67:            void ringBufS_put_dma(ringBufS_t *_this, const uint8_t c)
68:            {
69:            	if (_this->count < RBUF_SIZE) {
70:            		_this->buf[_this->head] = c;
71:            		++_this->head;
72:            		++_this->count;
73:            	}
74:            }
75:            
76:            void ringBufS_put_dma_cpy(ringBufS_t *_this, const char *ptr, const uint8_t len)
77:            {
78:            	if (_this->count < RBUF_SIZE) {
12B80  EE20     LFSR 2, 0x42
12B82  F042     NOP
12B84  5011     MOVF 0x11, W, ACCESS
12B86  26D9     ADDWF 0xFD9, F, ACCESS
12B88  5012     MOVF 0x12, W, ACCESS
12B8A  22DA     ADDWFC 0xFDA, F, ACCESS
12B8C  0E40     MOVLW 0x40
12B8E  60DF     CPFSLT 0xFDF, ACCESS
12B90  0012     RETURN 0
79:            		memcpy(_this->buf, ptr, len);
12B92  C511     MOVFF fp, InterruptHandler
12B94  F506     NOP
12B96  C512     MOVFF sum, c
12B98  F507     NOP
12B9A  C513     MOVFF c, blockSize
12B9C  F508     NOP
12B9E  C514     MOVFF i, td
12BA0  F509     NOP
12BA2  C515     MOVFF len, data
12BA4  F50A     NOP
12BA6  6A0B     CLRF 0xB, ACCESS
12BA8  EC10     CALL 0x12C20, 0
12BAA  F096     NOP
80:            		_this->head = len;
12BAC  EE20     LFSR 2, 0x40
12BAE  F040     NOP
12BB0  5011     MOVF 0x11, W, ACCESS
12BB2  26D9     ADDWF 0xFD9, F, ACCESS
12BB4  5012     MOVF 0x12, W, ACCESS
12BB6  22DA     ADDWFC 0xFDA, F, ACCESS
12BBA  F454     NOP
12BBC  F4DF     NOP
81:            		_this->count = len;
12BBE  EE20     LFSR 2, 0x42
12BC0  F042     NOP
12BC2  5011     MOVF 0x11, W, ACCESS
12BC4  26D9     ADDWF 0xFD9, F, ACCESS
12BC6  5012     MOVF 0x12, W, ACCESS
12BC8  22DA     ADDWFC 0xFDA, F, ACCESS
12BCC  F454     NOP
12BCE  F4DF     NOP
82:            	}
83:            }
12BD0  0012     RETURN 0
84:            
85:            void *ringBufS_flush(ringBufS_t *_this, const bool clearBuffer)
86:            {
87:            	void *tmp = NULL;
88:            
89:            	_this->count = 0;
12B2C  EE20     LFSR 2, 0x42
12B2E  F042     NOP
12B30  5012     MOVF 0x12, W, ACCESS
12B32  26D9     ADDWF 0xFD9, F, ACCESS
12B34  5013     MOVF 0x13, W, ACCESS
12B36  22DA     ADDWFC 0xFDA, F, ACCESS
12B38  0E00     MOVLW 0x0
12B3A  6EDF     MOVWF 0xFDF, ACCESS
90:            	_this->head = 0;
12B3C  EE20     LFSR 2, 0x40
12B3E  F040     NOP
12B40  5012     MOVF 0x12, W, ACCESS
12B42  26D9     ADDWF 0xFD9, F, ACCESS
12B44  5013     MOVF 0x13, W, ACCESS
12B46  22DA     ADDWFC 0xFDA, F, ACCESS
12B48  0E00     MOVLW 0x0
12B4A  6EDF     MOVWF 0xFDF, ACCESS
91:            	_this->tail = 0;
12B4C  EE20     LFSR 2, 0x41
12B4E  F041     NOP
12B50  5012     MOVF 0x12, W, ACCESS
12B52  26D9     ADDWF 0xFD9, F, ACCESS
12B54  5013     MOVF 0x13, W, ACCESS
12B56  22DA     ADDWFC 0xFDA, F, ACCESS
12B58  0E00     MOVLW 0x0
12B5A  6EDF     MOVWF 0xFDF, ACCESS
92:            	if (clearBuffer) {
12B5C  5014     MOVF 0x14, W, ACCESS
12B5E  B4D8     BTFSC 0xFD8, 2, ACCESS
12B60  0012     RETURN 0
93:            		tmp = memset(_this->buf, 0, sizeof(_this->buf));
12B62  C512     MOVFF sum, InterruptHandler
12B64  F506     NOP
12B66  C513     MOVFF c, c
12B68  F507     NOP
12B6A  0E00     MOVLW 0x0
12B6C  6E09     MOVWF 0x9, ACCESS
12B6E  0E00     MOVLW 0x0
12B70  6E08     MOVWF 0x8, ACCESS
12B72  0E00     MOVLW 0x0
12B74  6E0B     MOVWF 0xB, ACCESS
12B76  0E40     MOVLW 0x40
12B78  6E0A     MOVWF 0xA, ACCESS
12B7A  EC54     CALL 0x118A8, 0
12B7C  F08C     NOP
94:            	}
95:            	return tmp;
96:            }
12B7E  0012     RETURN 0
97:            
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/uart2.c  ---------------
1:             /**
2:               UART2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:            	Device            :  PIC18F47Q43
18:                    Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            #include <xc.h>
51:            #include "uart2.h"
52:            #include "interrupt_manager.h"
53:            #include "pin_manager.h"
54:            
55:            /**
56:              Section: Macro Declarations
57:             */
58:            #define UART2_TX_BUFFER_SIZE 64
59:            #define UART2_RX_BUFFER_SIZE 64
60:            
61:            /**
62:              Section: Global Variables
63:             */
64:            
65:            static volatile uint8_t uart2TxHead = 0;
66:            static volatile uint8_t uart2TxTail = 0;
67:            static volatile uint8_t uart2TxBuffer[UART2_TX_BUFFER_SIZE];
68:            volatile uint8_t uart2TxBufferRemaining;
69:            
70:            static volatile uint8_t uart2RxHead = 0;
71:            static volatile uint8_t uart2RxTail = 0;
72:            static volatile uint8_t uart2RxBuffer[UART2_RX_BUFFER_SIZE];
73:            static volatile uart2_status_t uart2RxStatusBuffer[UART2_RX_BUFFER_SIZE];
74:            volatile uint8_t uart2RxCount;
75:            static volatile uart2_status_t uart2RxLastError;
76:            
77:            /**
78:              Section: UART2 APIs
79:             */
80:            void (*UART2_FramingErrorHandler)(void);
81:            void (*UART2_OverrunErrorHandler)(void);
82:            void (*UART2_ErrorHandler)(void);
83:            
84:            void UART2_DefaultFramingErrorHandler(void);
85:            void UART2_DefaultOverrunErrorHandler(void);
86:            void UART2_DefaultErrorHandler(void);
87:            
88:            void UART2_Initialize(void)
89:            {
90:            	// Disable interrupts before changing states
91:            	PIE8bits.U2RXIE = 0;
12368  90A6     BCF 0xFA6, 0, ACCESS
92:            	UART2_SetRxInterruptHandler(UART2_Receive_ISR);
1236A  0E10     MOVLW 0x10
1236C  6E06     MOVWF 0x6, ACCESS
1236E  0E24     MOVLW 0x24
12370  6E07     MOVWF 0x7, ACCESS
12372  0E01     MOVLW 0x1
12374  6E08     MOVWF 0x8, ACCESS
12376  EC46     CALL 0x1348C, 0
12378  F09A     NOP
93:            	PIE8bits.U2TXIE = 0;
1237A  92A6     BCF 0xFA6, 1, ACCESS
94:            	UART2_SetTxInterruptHandler(UART2_Transmit_ISR);
1237C  0E22     MOVLW 0x22
1237E  6E06     MOVWF 0x6, ACCESS
12380  0E31     MOVLW 0x31
12382  6E07     MOVWF 0x7, ACCESS
12384  0E01     MOVLW 0x1
12386  6E08     MOVWF 0x8, ACCESS
12388  EC3F     CALL 0x1347E, 0
1238A  F09A     NOP
95:            
96:            	// Set the UART2 module to the options selected in the user interface.
97:            
98:            	// P1L 0; 
99:            	U2P1L = 0x00;
1238C  0E00     MOVLW 0x0
1238E  0102     MOVLB 0x2
12390  6FB8     MOVWF DMA3PR, BANKED
100:           
101:           	// P2L 0; 
102:           	U2P2L = 0x00;
12392  0E00     MOVLW 0x0
12394  6FBA     MOVWF DMA5PR, BANKED
103:           
104:           	// P3L 0; 
105:           	U2P3L = 0x00;
12396  0E00     MOVLW 0x0
12398  6FBC     MOVWF 0xBC, BANKED
106:           
107:           	// BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
108:           	U2CON0 = 0xB0;
1239A  0EB0     MOVLW 0xB0
1239C  6FBE     MOVWF MAINPR, BANKED
109:           
110:           	// RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
111:           	U2CON1 = 0x80;
1239E  0E80     MOVLW 0x80
123A0  6FBF     MOVWF ISRPR, BANKED
112:           
113:           	// TXPOL not inverted; FLO off; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
114:           	U2CON2 = 0x00;
123A2  0E00     MOVLW 0x0
123A4  6FC0     MOVWF 0xC0, BANKED
115:           
116:           	// BRGL 130; 
117:           	U2BRGL = 0x82;
123A6  0E82     MOVLW 0x82
123A8  6FC1     MOVWF 0xC1, BANKED
118:           
119:           	// BRGH 6; 
120:           	U2BRGH = 0x06;
123AA  0E06     MOVLW 0x6
123AC  6FC2     MOVWF 0xC2, BANKED
121:           
122:           	// STPMD in middle of first Stop bit; TXWRE No error; 
123:           	U2FIFO = 0x00;
123AE  0E00     MOVLW 0x0
123B0  6FC3     MOVWF 0xC3, BANKED
124:           
125:           	// ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
126:           	U2UIR = 0x00;
123B2  0E00     MOVLW 0x0
123B4  6FC4     MOVWF 0xC4, BANKED
127:           
128:           	// ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
129:           	U2ERRIR = 0x00;
123B6  0E00     MOVLW 0x0
123B8  6FC5     MOVWF 0xC5, BANKED
130:           
131:           	// TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
132:           	U2ERRIE = 0x00;
123BA  0E00     MOVLW 0x0
123BC  6FC6     MOVWF 0xC6, BANKED
133:           
134:           
135:           	UART2_SetFramingErrorHandler(UART2_DefaultFramingErrorHandler);
123BE  0E8E     MOVLW 0x8E
123C0  6E06     MOVWF 0x6, ACCESS
123C2  0E35     MOVLW 0x35
123C4  6E07     MOVWF 0x7, ACCESS
123C6  0E01     MOVLW 0x1
123C8  6E08     MOVWF 0x8, ACCESS
123CA  EC54     CALL 0x134A8, 0
123CC  F09A     NOP
136:           	UART2_SetOverrunErrorHandler(UART2_DefaultOverrunErrorHandler);
123CE  0E8C     MOVLW 0x8C
123D0  6E06     MOVWF 0x6, ACCESS
123D2  0E35     MOVLW 0x35
123D4  6E07     MOVWF 0x7, ACCESS
123D6  0E01     MOVLW 0x1
123D8  6E08     MOVWF 0x8, ACCESS
123DA  EC4D     CALL 0x1349A, 0
123DC  F09A     NOP
137:           	UART2_SetErrorHandler(UART2_DefaultErrorHandler);
123DE  0E72     MOVLW 0x72
123E0  6E06     MOVWF 0x6, ACCESS
123E2  0E35     MOVLW 0x35
123E4  6E07     MOVWF 0x7, ACCESS
123E6  0E01     MOVLW 0x1
123E8  6E08     MOVWF 0x8, ACCESS
123EA  EC5B     CALL 0x134B6, 0
123EC  F09A     NOP
138:           
139:           	uart2RxLastError.status = 0;
123EE  0E00     MOVLW 0x0
123F0  0105     MOVLB 0x5
123F2  6FE9     MOVWF DMAnBUF, BANKED
140:           
141:           	// initializing the driver state
142:           	uart2TxHead = 0;
123F4  0E00     MOVLW 0x0
123F6  6FEC     MOVWF DMAnDPTR, BANKED
143:           	uart2TxTail = 0;
123F8  0E00     MOVLW 0x0
123FA  6FEB     MOVWF DMAnDCNTH, BANKED
144:           	uart2TxBufferRemaining = sizeof(uart2TxBuffer);
123FC  0E40     MOVLW 0x40
123FE  6E58     MOVWF 0x58, ACCESS
145:           	uart2RxHead = 0;
12400  0E00     MOVLW 0x0
12402  6E57     MOVWF 0x57, ACCESS
146:           	uart2RxTail = 0;
12404  0E00     MOVLW 0x0
12406  6E56     MOVWF 0x56, ACCESS
147:           	uart2RxCount = 0;
12408  0E00     MOVLW 0x0
1240A  6FEA     MOVWF DMAnDCNT, BANKED
148:           
149:           	// enable receive interrupt
150:           	PIE8bits.U2RXIE = 1;
1240C  80A6     BSF 0xFA6, 0, ACCESS
151:           }
1240E  0012     RETURN 0
152:           
153:           bool UART2_is_rx_ready(void)
154:           {
155:               return (uart2RxCount ? true : false);
13444  0105     MOVLB 0x5
13446  51EA     MOVF DMAnDCNT, W, BANKED
13448  B4D8     BTFSC 0xFD8, 2, ACCESS
1344A  D002     BRA 0x3450
1344C  0E01     MOVLW 0x1
1344E  0012     RETURN 0
13450  0E00     MOVLW 0x0
156:           }
13452  0012     RETURN 0
157:           
158:           bool UART2_is_tx_ready(void)
159:           {
160:               return (uart2TxBufferRemaining ? true : false);
13454  5058     MOVF 0x58, W, ACCESS
13456  B4D8     BTFSC 0xFD8, 2, ACCESS
13458  D002     BRA 0x345E
1345A  0E01     MOVLW 0x1
1345C  0012     RETURN 0
1345E  0E00     MOVLW 0x0
161:           }
13460  0012     RETURN 0
162:           
163:           bool UART2_is_tx_done(void)
164:           {
165:           	return U2ERRIRbits.TXMTIF;
166:           }
167:           
168:           uart2_status_t UART2_get_last_status(void){
169:           	return uart2RxLastError;
170:           }
171:           
172:           uint8_t UART2_Read(void)
173:           {
174:               uint8_t readValue  = 0;
175:           
176:               while(0 == uart2RxCount)
12D96  D001     BRA 0x2D9A
12D9A  0105     MOVLB 0x5
12D9C  51EA     MOVF DMAnDCNT, W, BANKED
12D9E  B4D8     BTFSC 0xFD8, 2, ACCESS
12DA0  D7FB     BRA 0x2D98
177:               {
178:                   CLRWDT();
12D98  0004     CLRWDT
179:           	}
180:           
181:           	uart2RxLastError = uart2RxStatusBuffer[uart2RxTail];
12DA2  0E80     MOVLW 0x80
12DA4  2456     ADDWF 0x56, W, ACCESS
12DA6  6ED9     MOVWF 0xFD9, ACCESS
12DA8  6ADA     CLRF 0xFDA, ACCESS
12DAA  0E07     MOVLW 0x7
12DAC  22DA     ADDWFC 0xFDA, F, ACCESS
12DAE  50DF     MOVF 0xFDF, W, ACCESS
12DB0  6FE9     MOVWF DMAnBUF, BANKED
182:           
183:           	readValue = uart2RxBuffer[uart2RxTail++];
12DB2  0E80     MOVLW 0x80
12DB4  2456     ADDWF 0x56, W, ACCESS
12DB6  6ED9     MOVWF 0xFD9, ACCESS
12DB8  6ADA     CLRF 0xFDA, ACCESS
12DBA  0E08     MOVLW 0x8
12DBC  22DA     ADDWFC 0xFDA, F, ACCESS
12DBE  50DF     MOVF 0xFDF, W, ACCESS
12DC0  6E06     MOVWF 0x6, ACCESS
12DC2  2A56     INCF 0x56, F, ACCESS
184:              	if(sizeof(uart2RxBuffer) <= uart2RxTail)
12DC4  0E3F     MOVLW 0x3F
12DC6  6456     CPFSGT 0x56, ACCESS
12DC8  D002     BRA 0x2DCE
185:               {
186:           		uart2RxTail = 0;
12DCA  0E00     MOVLW 0x0
12DCC  6E56     MOVWF 0x56, ACCESS
187:           	}
188:           	PIE8bits.U2RXIE = 0;
12DCE  90A6     BCF 0xFA6, 0, ACCESS
189:           	uart2RxCount--;
12DD0  07EA     DECF DMAnDCNT, F, BANKED
190:           	PIE8bits.U2RXIE = 1;
12DD2  80A6     BSF 0xFA6, 0, ACCESS
191:           
192:           	return readValue;
12DD4  5006     MOVF 0x6, W, ACCESS
193:           }
12DD6  0012     RETURN 0
194:           
195:           void UART2_Write(uint8_t txData)
12DD8  6E06     MOVWF 0x6, ACCESS
196:           {
197:               while(0 == uart2TxBufferRemaining)
12DDA  D001     BRA 0x2DDE
12DDE  5058     MOVF 0x58, W, ACCESS
12DE0  B4D8     BTFSC 0xFD8, 2, ACCESS
12DE2  D7FC     BRA 0x2DDC
198:               {
199:                   CLRWDT();
12DDC  0004     CLRWDT
200:           	}
201:           
202:               if(0 == PIE8bits.U2TXIE)
12DE4  B2A6     BTFSC 0xFA6, 1, ACCESS
12DE6  D004     BRA 0x2DF0
203:               {
204:           		U2TXB = txData;
12DEA  F418     NOP
12DEC  F2B6     NOP
205:               }
12DEE  D012     BRA 0x2E14
206:               else
207:               {
208:           		PIE8bits.U2TXIE = 0;
12DF0  92A6     BCF 0xFA6, 1, ACCESS
209:           		uart2TxBuffer[uart2TxHead++] = txData;
12DF2  0EC0     MOVLW 0xC0
12DF4  0105     MOVLB 0x5
12DF6  25EC     ADDWF DMAnDPTR, W, BANKED
12DF8  6ED9     MOVWF 0xFD9, ACCESS
12DFA  6ADA     CLRF 0xFDA, ACCESS
12DFC  0E08     MOVLW 0x8
12DFE  22DA     ADDWFC 0xFDA, F, ACCESS
12E02  F418     NOP
12E04  F4DF     NOP
12E06  2BEC     INCF DMAnDPTR, F, BANKED
210:                   if(sizeof(uart2TxBuffer) <= uart2TxHead)
12E08  0E3F     MOVLW 0x3F
12E0A  65EC     CPFSGT DMAnDPTR, BANKED
12E0C  D002     BRA 0x2E12
211:                   {
212:           			uart2TxHead = 0;
12E0E  0E00     MOVLW 0x0
12E10  6FEC     MOVWF DMAnDPTR, BANKED
213:           		}
214:           		uart2TxBufferRemaining--;
12E12  0658     DECF 0x58, F, ACCESS
215:           	}
216:           	PIE8bits.U2TXIE = 1;
12E14  82A6     BSF 0xFA6, 1, ACCESS
217:           }
12E16  0012     RETURN 0
218:           
219:           void __interrupt(irq(U2TX),base(8)) UART2_tx_vect_isr()
220:           {
221:               if(UART2_TxInterruptHandler)
13268  0105     MOVLB 0x5
222:               {
223:           		UART2_TxInterruptHandler();
13274  D801     RCALL 0x3278
13276  0011     RETFIE 1
13278  0005     PUSH
1327A  6EFA     MOVWF 0xFFA, ACCESS
1327C  51C7     MOVF 0xC7, W, BANKED
1327E  6EFD     MOVWF 0xFFD, ACCESS
13280  51C8     MOVF 0xC8, W, BANKED
13282  6EFE     MOVWF 0xFFE, ACCESS
13284  51C9     MOVF 0xC9, W, BANKED
13286  6EFF     MOVWF 0xFFF, ACCESS
13288  50FA     MOVF 0xFFA, W, ACCESS
1328A  0012     RETURN 0
224:           	}
225:           }
226:           
227:           void __interrupt(irq(U2RX),base(8)) UART2_rx_vect_isr()
228:           {
229:               if(UART2_RxInterruptHandler)
230:               {
231:           		UART2_RxInterruptHandler();
13298  D801     RCALL 0x329C
232:           	}
233:           }
234:           
235:           
236:           
237:           void UART2_Transmit_ISR(void)
238:           {
239:           	// use this default transmit interrupt handler code
240:               if(sizeof(uart2TxBuffer) > uart2TxBufferRemaining)
13122  0E40     MOVLW 0x40
13124  6058     CPFSLT 0x58, ACCESS
13126  D012     BRA 0x314C
241:               {
242:           		U2TXB = uart2TxBuffer[uart2TxTail++];
13128  0EC0     MOVLW 0xC0
1312A  25EB     ADDWF DMAnDCNTH, W, BANKED
1312C  6ED9     MOVWF 0xFD9, ACCESS
1312E  6ADA     CLRF 0xFDA, ACCESS
13130  0E08     MOVLW 0x8
13132  22DA     ADDWFC 0xFDA, F, ACCESS
13134  50DF     MOVF 0xFDF, W, ACCESS
13136  0102     MOVLB 0x2
13138  6FB6     MOVWF DMA1PR, BANKED
1313A  0105     MOVLB 0x5
1313C  2BEB     INCF DMAnDCNTH, F, BANKED
243:                  if(sizeof(uart2TxBuffer) <= uart2TxTail)
1313E  0E3F     MOVLW 0x3F
13140  65EB     CPFSGT DMAnDCNTH, BANKED
13142  D002     BRA 0x3148
244:                   {
245:           			uart2TxTail = 0;
13144  0E00     MOVLW 0x0
13146  6FEB     MOVWF DMAnDCNTH, BANKED
246:           		}
247:           		uart2TxBufferRemaining++;
13148  2A58     INCF 0x58, F, ACCESS
248:               }
1314A  0012     RETURN 0
249:               else
250:               {
251:           		PIE8bits.U2TXIE = 0;
1314C  92A6     BCF 0xFA6, 1, ACCESS
252:           	}
253:           
254:           	// or set custom function using UART2_SetTxInterruptHandler()
255:           }
1314E  0012     RETURN 0
1328C  0105     MOVLB 0x5
1328E  51CA     MOVF 0xCA, W, BANKED
13290  11CB     IORWF 0xCB, W, BANKED
13292  11CC     IORWF 0xCC, W, BANKED
13294  B4D8     BTFSC 0xFD8, 2, ACCESS
13296  0011     RETFIE 1
13298  D801     RCALL 0x329C
1329A  0011     RETFIE 1
1329C  0005     PUSH
1329E  6EFA     MOVWF 0xFFA, ACCESS
132A0  51CA     MOVF 0xCA, W, BANKED
132A2  6EFD     MOVWF 0xFFD, ACCESS
132A4  51CB     MOVF 0xCB, W, BANKED
132A6  6EFE     MOVWF 0xFFE, ACCESS
132A8  51CC     MOVF 0xCC, W, BANKED
132AA  6EFF     MOVWF 0xFFF, ACCESS
132AC  50FA     MOVF 0xFFA, W, ACCESS
132AE  0012     RETURN 0
256:           
257:           void UART2_Receive_ISR(void)
258:           {
259:           	// use this default receive interrupt handler code
260:           	uart2RxStatusBuffer[uart2RxHead].status = 0;
12410  0E80     MOVLW 0x80
12412  2457     ADDWF 0x57, W, ACCESS
12414  6ED9     MOVWF 0xFD9, ACCESS
12416  6ADA     CLRF 0xFDA, ACCESS
12418  0E07     MOVLW 0x7
1241A  22DA     ADDWFC 0xFDA, F, ACCESS
1241C  0E00     MOVLW 0x0
1241E  6EDF     MOVWF 0xFDF, ACCESS
261:           
262:               if(U2ERRIRbits.FERIF){
12420  0102     MOVLB 0x2
12422  A7C5     BTFSS 0xC5, 3, BANKED
12424  D015     BRA 0x2450
263:           		uart2RxStatusBuffer[uart2RxHead].ferr = 1;
12426  0E80     MOVLW 0x80
12428  2457     ADDWF 0x57, W, ACCESS
1242A  6ED9     MOVWF 0xFD9, ACCESS
1242C  6ADA     CLRF 0xFDA, ACCESS
1242E  0E07     MOVLW 0x7
12430  22DA     ADDWFC 0xFDA, F, ACCESS
12432  0107     MOVLB 0x7
12434  82DF     BSF 0xFDF, 1, ACCESS
264:           		UART2_FramingErrorHandler();
12436  D801     RCALL 0x243A
12438  D00B     BRA 0x2450
1243A  0005     PUSH
1243C  6EFA     MOVWF 0xFFA, ACCESS
1243E  0105     MOVLB 0x5
12440  51BB     MOVF DMA6PR, W, BANKED
12442  6EFD     MOVWF 0xFFD, ACCESS
12444  51BC     MOVF 0xBC, W, BANKED
12446  6EFE     MOVWF 0xFFE, ACCESS
12448  51BD     MOVF 0xBD, W, BANKED
1244A  6EFF     MOVWF 0xFFF, ACCESS
1244C  50FA     MOVF 0xFFA, W, ACCESS
1244E  0012     RETURN 0
265:           	}
266:           
267:               if(U2ERRIRbits.RXFOIF){
12450  0102     MOVLB 0x2
12452  A3C5     BTFSS 0xC5, 1, BANKED
12454  D015     BRA 0x2480
268:           		uart2RxStatusBuffer[uart2RxHead].oerr = 1;
12456  0E80     MOVLW 0x80
12458  2457     ADDWF 0x57, W, ACCESS
1245A  6ED9     MOVWF 0xFD9, ACCESS
1245C  6ADA     CLRF 0xFDA, ACCESS
1245E  0E07     MOVLW 0x7
12460  22DA     ADDWFC 0xFDA, F, ACCESS
12462  0107     MOVLB 0x7
12464  84DF     BSF 0xFDF, 2, ACCESS
269:           		UART2_OverrunErrorHandler();
12466  D801     RCALL 0x246A
12468  D00B     BRA 0x2480
1246A  0005     PUSH
1246C  6EFA     MOVWF 0xFFA, ACCESS
1246E  0105     MOVLB 0x5
12470  51B8     MOVF DMA3PR, W, BANKED
12472  6EFD     MOVWF 0xFFD, ACCESS
12474  51B9     MOVF DMA4PR, W, BANKED
12476  6EFE     MOVWF 0xFFE, ACCESS
12478  51BA     MOVF DMA5PR, W, BANKED
1247A  6EFF     MOVWF 0xFFF, ACCESS
1247C  50FA     MOVF 0xFFA, W, ACCESS
1247E  0012     RETURN 0
270:           	}
271:           
272:               if(uart2RxStatusBuffer[uart2RxHead].status){
12480  0E80     MOVLW 0x80
12482  2457     ADDWF 0x57, W, ACCESS
12484  6ED9     MOVWF 0xFD9, ACCESS
12486  6ADA     CLRF 0xFDA, ACCESS
12488  0E07     MOVLW 0x7
1248A  22DA     ADDWFC 0xFDA, F, ACCESS
1248C  50DF     MOVF 0xFDF, W, ACCESS
1248E  B4D8     BTFSC 0xFD8, 2, ACCESS
12490  D00D     BRA 0x24AC
273:           		UART2_ErrorHandler();
12492  D801     RCALL 0x2496
12494  0012     RETURN 0
12496  0005     PUSH
12498  6EFA     MOVWF 0xFFA, ACCESS
1249A  0105     MOVLB 0x5
1249C  51B5     MOVF SCANPR, W, BANKED
1249E  6EFD     MOVWF 0xFFD, ACCESS
124A0  51B6     MOVF DMA1PR, W, BANKED
124A2  6EFE     MOVWF 0xFFE, ACCESS
124A4  51B7     MOVF DMA2PR, W, BANKED
124A6  6EFF     MOVWF 0xFFF, ACCESS
124A8  50FA     MOVF 0xFFA, W, ACCESS
124AA  0012     RETURN 0
274:           	} else {
275:           		UART2_RxDataHandler();
124AC  EC2B     CALL 0x12E56, 0
124AE  F097     NOP
276:           	}
277:           
278:           	// or set custom function using UART2_SetRxInterruptHandler()
279:           }
124B0  0012     RETURN 0
280:           
281:           void UART2_RxDataHandler(void){
282:           	// use this default receive interrupt handler code							
283:           	DEBUG2_Toggle();
12E56  A4C2     BTFSS 0xFC2, 2, ACCESS
12E58  D002     BRA 0x2E5E
12E5A  0E01     MOVLW 0x1
12E5C  D001     BRA 0x2E60
12E5E  0E00     MOVLW 0x0
12E60  0AFF     XORLW 0xFF
12E62  6E03     MOVWF 0x3, ACCESS
12E64  4603     RLNCF 0x3, F, ACCESS
12E66  4603     RLNCF 0x3, F, ACCESS
12E68  50C2     MOVF 0xFC2, W, ACCESS
12E6A  1803     XORWF 0x3, W, ACCESS
12E6C  0BFB     ANDLW 0xFB
12E6E  1803     XORWF 0x3, W, ACCESS
12E70  6EC2     MOVWF 0xFC2, ACCESS
284:           	uart2RxBuffer[uart2RxHead++] = U2RXB;
12E72  0E80     MOVLW 0x80
12E74  2457     ADDWF 0x57, W, ACCESS
12E76  6ED9     MOVWF 0xFD9, ACCESS
12E78  6ADA     CLRF 0xFDA, ACCESS
12E7A  0E08     MOVLW 0x8
12E7C  22DA     ADDWFC 0xFDA, F, ACCESS
12E7E  C2B4     MOVFF U2RXB, INDF2
12E80  F4DF     NOP
12E82  2A57     INCF 0x57, F, ACCESS
285:               if(sizeof(uart2RxBuffer) <= uart2RxHead)
12E84  0E3F     MOVLW 0x3F
12E86  6457     CPFSGT 0x57, ACCESS
12E88  D002     BRA 0x2E8E
286:               {
287:           		uart2RxHead = 0;
12E8A  0E00     MOVLW 0x0
12E8C  6E57     MOVWF 0x57, ACCESS
288:           	}
289:           	uart2RxCount++;
12E8E  0105     MOVLB 0x5
12E90  2BEA     INCF DMAnDCNT, F, BANKED
290:           }
12E92  0012     RETURN 0
131CC  96BD     BCF 0xFBD, 3, ACCESS
291:           
292:           void UART2_DefaultFramingErrorHandler(void){}
1358E  0012     RETURN 0
293:           
294:           void UART2_DefaultOverrunErrorHandler(void){}
1358C  0012     RETURN 0
295:           
296:           void UART2_DefaultErrorHandler(void){
297:           	UART2_RxDataHandler();
13572  EC2B     CALL 0x12E56, 0
13574  F097     NOP
298:           }
13576  0012     RETURN 0
299:           
300:           void UART2_SetFramingErrorHandler(void (* interruptHandler)(void)){
301:           	UART2_FramingErrorHandler = interruptHandler;
134A8  C506     MOVFF InterruptHandler, UART2_FramingErrorHandler
134AA  F5BB     NOP
134AC  C507     MOVFF c, 0x5BC
134AE  F5BC     NOP
134B0  C508     MOVFF blockSize, 0x5BD
134B2  F5BD     NOP
302:           }
134B4  0012     RETURN 0
303:           
304:           void UART2_SetOverrunErrorHandler(void (* interruptHandler)(void)){
305:           	UART2_OverrunErrorHandler = interruptHandler;
1349A  C506     MOVFF InterruptHandler, UART2_OverrunErrorHandler
1349C  F5B8     NOP
1349E  C507     MOVFF c, 0x5B9
134A0  F5B9     NOP
134A2  C508     MOVFF blockSize, 0x5BA
134A4  F5BA     NOP
306:           }
134A6  0012     RETURN 0
307:           
308:           void UART2_SetErrorHandler(void (* interruptHandler)(void)){
309:           	UART2_ErrorHandler = interruptHandler;
134B6  C506     MOVFF InterruptHandler, UART2_ErrorHandler
134B8  F5B5     NOP
134BA  C507     MOVFF c, 0x5B6
134BC  F5B6     NOP
134BE  C508     MOVFF blockSize, 0x5B7
134C0  F5B7     NOP
310:           }
134C2  0012     RETURN 0
311:           
312:           
313:           
314:           void UART2_SetRxInterruptHandler(void (* InterruptHandler)(void)){
315:           	UART2_RxInterruptHandler = InterruptHandler;
1348C  C506     MOVFF InterruptHandler, UART2_RxInterruptHandler
1348E  F5CA     NOP
13490  C507     MOVFF c, 0x5CB
13492  F5CB     NOP
13494  C508     MOVFF blockSize, 0x5CC
13496  F5CC     NOP
316:           }
13498  0012     RETURN 0
317:           
318:           void UART2_SetTxInterruptHandler(void (* InterruptHandler)(void)){
319:           	UART2_TxInterruptHandler = InterruptHandler;
1347E  C506     MOVFF InterruptHandler, UART2_TxInterruptHandler
13480  F5C7     NOP
13482  C507     MOVFF c, 0x5C8
13484  F5C8     NOP
13486  C508     MOVFF blockSize, 0x5C9
13488  F5C9     NOP
320:           }
1348A  0012     RETURN 0
321:           
322:           
323:           /**
324:             End of File
325:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/uart1.c  ---------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.4.1
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            #include "interrupt_manager.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            #define UART1_TX_BUFFER_SIZE 64
58:            #define UART1_RX_BUFFER_SIZE 64
59:            
60:            /**
61:              Section: Global Variables
62:            */
63:            
64:            static volatile uint8_t uart1TxHead = 0;
65:            static volatile uint8_t uart1TxTail = 0;
66:            static volatile uint8_t uart1TxBuffer[UART1_TX_BUFFER_SIZE];
67:            volatile uint8_t uart1TxBufferRemaining;
68:            
69:            static volatile uint8_t uart1RxHead = 0;
70:            static volatile uint8_t uart1RxTail = 0;
71:            static volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
72:            static volatile uart1_status_t uart1RxStatusBuffer[UART1_RX_BUFFER_SIZE];
73:            volatile uint8_t uart1RxCount;
74:            static volatile uart1_status_t uart1RxLastError;
75:            
76:            /**
77:              Section: UART1 APIs
78:            */
79:            void (*UART1_FramingErrorHandler)(void);
80:            void (*UART1_OverrunErrorHandler)(void);
81:            void (*UART1_ErrorHandler)(void);
82:            
83:            void UART1_DefaultFramingErrorHandler(void);
84:            void UART1_DefaultOverrunErrorHandler(void);
85:            void UART1_DefaultErrorHandler(void);
86:            
87:            void UART1_Initialize(void)
88:            {
89:                // Disable interrupts before changing states
90:                PIE4bits.U1RXIE = 0;
12206  90A2     BCF 0xFA2, 0, ACCESS
91:                UART1_SetRxInterruptHandler(UART1_Receive_ISR);
12208  0EB2     MOVLW 0xB2
1220A  6E06     MOVWF 0x6, ACCESS
1220C  0E24     MOVLW 0x24
1220E  6E07     MOVWF 0x7, ACCESS
12210  0E01     MOVLW 0x1
12212  6E08     MOVWF 0x8, ACCESS
12214  EC69     CALL 0x134D2, 0
12216  F09A     NOP
92:                PIE4bits.U1TXIE = 0;
12218  92A2     BCF 0xFA2, 1, ACCESS
93:                UART1_SetTxInterruptHandler(UART1_Transmit_ISR);
1221A  0E50     MOVLW 0x50
1221C  6E06     MOVWF 0x6, ACCESS
1221E  0E31     MOVLW 0x31
12220  6E07     MOVWF 0x7, ACCESS
12222  0E01     MOVLW 0x1
12224  6E08     MOVWF 0x8, ACCESS
12226  EC62     CALL 0x134C4, 0
12228  F09A     NOP
94:            
95:                // Set the UART1 module to the options selected in the user interface.
96:            
97:                // P1L 0; 
98:                U1P1L = 0x00;
1222A  0E00     MOVLW 0x0
1222C  0102     MOVLB 0x2
1222E  6FA5     MOVWF 0xA5, BANKED
99:            
100:               // P1H 0; 
101:               U1P1H = 0x00;
12230  0E00     MOVLW 0x0
12232  6FA6     MOVWF 0xA6, BANKED
102:           
103:               // P2L 0; 
104:               U1P2L = 0x00;
12234  0E00     MOVLW 0x0
12236  6FA7     MOVWF 0xA7, BANKED
105:           
106:               // P2H 0; 
107:               U1P2H = 0x00;
12238  0E00     MOVLW 0x0
1223A  6FA8     MOVWF 0xA8, BANKED
108:           
109:               // P3L 0; 
110:               U1P3L = 0x00;
1223C  0E00     MOVLW 0x0
1223E  6FA9     MOVWF 0xA9, BANKED
111:           
112:               // P3H 0; 
113:               U1P3H = 0x00;
12240  0E00     MOVLW 0x0
12242  6FAA     MOVWF 0xAA, BANKED
114:           
115:               // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
116:               U1CON0 = 0xB0;
12244  0EB0     MOVLW 0xB0
12246  6FAB     MOVWF 0xAB, BANKED
117:           
118:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
119:               U1CON1 = 0x80;
12248  0E80     MOVLW 0x80
1224A  6FAC     MOVWF ACTCON, BANKED
120:           
121:               // TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
122:               U1CON2 = 0x00;
1224C  0E00     MOVLW 0x0
1224E  6FAD     MOVWF OSCCON1, BANKED
123:           
124:               // BRGL 130; 
125:               U1BRGL = 0x82;
12250  0E82     MOVLW 0x82
12252  6FAE     MOVWF OSCCON2, BANKED
126:           
127:               // BRGH 6; 
128:               U1BRGH = 0x06;
12254  0E06     MOVLW 0x6
12256  6FAF     MOVWF OSCCON3, BANKED
129:           
130:               // STPMD in middle of first Stop bit; TXWRE No error; 
131:               U1FIFO = 0x00;
12258  0E00     MOVLW 0x0
1225A  6FB0     MOVWF OSCTUNE, BANKED
132:           
133:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
134:               U1UIR = 0x00;
1225C  0E00     MOVLW 0x0
1225E  6FB1     MOVWF OSCFRQ, BANKED
135:           
136:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
137:               U1ERRIR = 0x00;
12260  0E00     MOVLW 0x0
12262  6FB2     MOVWF OSCSTAT, BANKED
138:           
139:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
140:               U1ERRIE = 0x00;
12264  0E00     MOVLW 0x0
12266  6FB3     MOVWF OSCEN, BANKED
141:           
142:           
143:               UART1_SetFramingErrorHandler(UART1_DefaultFramingErrorHandler);
12268  0E92     MOVLW 0x92
1226A  6E06     MOVWF 0x6, ACCESS
1226C  0E35     MOVLW 0x35
1226E  6E07     MOVWF 0x7, ACCESS
12270  0E01     MOVLW 0x1
12272  6E08     MOVWF 0x8, ACCESS
12274  EC77     CALL 0x134EE, 0
12276  F09A     NOP
144:               UART1_SetOverrunErrorHandler(UART1_DefaultOverrunErrorHandler);
12278  0E90     MOVLW 0x90
1227A  6E06     MOVWF 0x6, ACCESS
1227C  0E35     MOVLW 0x35
1227E  6E07     MOVWF 0x7, ACCESS
12280  0E01     MOVLW 0x1
12282  6E08     MOVWF 0x8, ACCESS
12284  EC70     CALL 0x134E0, 0
12286  F09A     NOP
145:               UART1_SetErrorHandler(UART1_DefaultErrorHandler);
12288  0E78     MOVLW 0x78
1228A  6E06     MOVWF 0x6, ACCESS
1228C  0E35     MOVLW 0x35
1228E  6E07     MOVWF 0x7, ACCESS
12290  0E01     MOVLW 0x1
12292  6E08     MOVWF 0x8, ACCESS
12294  EC7E     CALL 0x134FC, 0
12296  F09A     NOP
146:           
147:               uart1RxLastError.status = 0;
12298  0E00     MOVLW 0x0
1229A  0105     MOVLB 0x5
1229C  6FE4     MOVWF 0xE4, BANKED
148:           
149:               // initializing the driver state
150:               uart1TxHead = 0;
1229E  0E00     MOVLW 0x0
122A0  6FE7     MOVWF 0xE7, BANKED
151:               uart1TxTail = 0;
122A2  0E00     MOVLW 0x0
122A4  6FE6     MOVWF 0xE6, BANKED
152:               uart1TxBufferRemaining = sizeof(uart1TxBuffer);
122A6  0E40     MOVLW 0x40
122A8  6E55     MOVWF 0x55, ACCESS
153:               uart1RxHead = 0;
122AA  0E00     MOVLW 0x0
122AC  6E54     MOVWF 0x54, ACCESS
154:               uart1RxTail = 0;
122AE  0E00     MOVLW 0x0
122B0  6E53     MOVWF 0x53, ACCESS
155:               uart1RxCount = 0;
122B2  0E00     MOVLW 0x0
122B4  6FE5     MOVWF 0xE5, BANKED
156:           
157:               // enable receive interrupt
158:               PIE4bits.U1RXIE = 1;
122B6  80A2     BSF 0xFA2, 0, ACCESS
159:           }
122B8  0012     RETURN 0
160:           
161:           bool UART1_is_rx_ready(void)
162:           {
163:               return (uart1RxCount ? true : false);
13470  51E5     MOVF 0xE5, W, BANKED
13472  B4D8     BTFSC 0xFD8, 2, ACCESS
13474  D002     BRA 0x347A
13476  0E01     MOVLW 0x1
13478  0012     RETURN 0
1347A  0E00     MOVLW 0x0
164:           }
1347C  0012     RETURN 0
165:           
166:           bool UART1_is_tx_ready(void)
167:           {
168:               return (uart1TxBufferRemaining ? true : false);
13462  5055     MOVF 0x55, W, ACCESS
13464  B4D8     BTFSC 0xFD8, 2, ACCESS
13466  D002     BRA 0x346C
13468  0E01     MOVLW 0x1
1346A  0012     RETURN 0
1346C  0E00     MOVLW 0x0
169:           }
1346E  0012     RETURN 0
170:           
171:           bool UART1_is_tx_done(void)
172:           {
173:               return U1ERRIRbits.TXMTIF;
174:           }
175:           
176:           uart1_status_t UART1_get_last_status(void){
177:               return uart1RxLastError;
178:           }
179:           
180:           uint8_t UART1_Read(void)
181:           {
182:               uint8_t readValue  = 0;
183:               
184:               while(0 == uart1RxCount)
12E18  0105     MOVLB 0x5
12E1A  51E5     MOVF 0xE5, W, BANKED
12E1C  B4D8     BTFSC 0xFD8, 2, ACCESS
12E1E  D7FC     BRA 0x2E18
185:               {
186:               }
187:           
188:               uart1RxLastError = uart1RxStatusBuffer[uart1RxTail];
12E20  0E40     MOVLW 0x40
12E22  2453     ADDWF 0x53, W, ACCESS
12E24  6ED9     MOVWF 0xFD9, ACCESS
12E26  6ADA     CLRF 0xFDA, ACCESS
12E28  0E07     MOVLW 0x7
12E2A  22DA     ADDWFC 0xFDA, F, ACCESS
12E2C  50DF     MOVF 0xFDF, W, ACCESS
12E2E  6FE4     MOVWF 0xE4, BANKED
189:           
190:               readValue = uart1RxBuffer[uart1RxTail++];
12E30  0E00     MOVLW 0x0
12E32  2453     ADDWF 0x53, W, ACCESS
12E34  6ED9     MOVWF 0xFD9, ACCESS
12E36  6ADA     CLRF 0xFDA, ACCESS
12E38  0E08     MOVLW 0x8
12E3A  22DA     ADDWFC 0xFDA, F, ACCESS
12E3C  50DF     MOVF 0xFDF, W, ACCESS
12E3E  6E06     MOVWF 0x6, ACCESS
12E40  2A53     INCF 0x53, F, ACCESS
191:              	if(sizeof(uart1RxBuffer) <= uart1RxTail)
12E42  0E3F     MOVLW 0x3F
12E44  6453     CPFSGT 0x53, ACCESS
12E46  D002     BRA 0x2E4C
192:               {
193:                   uart1RxTail = 0;
12E48  0E00     MOVLW 0x0
12E4A  6E53     MOVWF 0x53, ACCESS
194:               }
195:               PIE4bits.U1RXIE = 0;
12E4C  90A2     BCF 0xFA2, 0, ACCESS
196:               uart1RxCount--;
12E4E  07E5     DECF 0xE5, F, BANKED
197:               PIE4bits.U1RXIE = 1;
12E50  80A2     BSF 0xFA2, 0, ACCESS
198:           
199:               return readValue;
12E52  5006     MOVF 0x6, W, ACCESS
200:           }
12E54  0012     RETURN 0
201:           
202:           void UART1_Write(uint8_t txData)
12ED2  6E06     MOVWF 0x6, ACCESS
203:           {
204:               while(0 == uart1TxBufferRemaining)
12ED4  5055     MOVF 0x55, W, ACCESS
12ED6  B4D8     BTFSC 0xFD8, 2, ACCESS
12ED8  D7FD     BRA 0x2ED4
205:               {
206:               }
207:           
208:               if(0 == PIE4bits.U1TXIE)
12EDA  B2A2     BTFSC 0xFA2, 1, ACCESS
12EDC  D004     BRA 0x2EE6
209:               {
210:                   U1TXB = txData;
12EE0  F418     NOP
12EE2  F2A3     NOP
211:               }
12EE4  D012     BRA 0x2F0A
212:               else
213:               {
214:                   PIE4bits.U1TXIE = 0;
12EE6  92A2     BCF 0xFA2, 1, ACCESS
215:                   uart1TxBuffer[uart1TxHead++] = txData;
12EE8  0E40     MOVLW 0x40
12EEA  0105     MOVLB 0x5
12EEC  25E7     ADDWF 0xE7, W, BANKED
12EEE  6ED9     MOVWF 0xFD9, ACCESS
12EF0  6ADA     CLRF 0xFDA, ACCESS
12EF2  0E08     MOVLW 0x8
12EF4  22DA     ADDWFC 0xFDA, F, ACCESS
12EF8  F418     NOP
12EFA  F4DF     NOP
12EFC  2BE7     INCF 0xE7, F, BANKED
216:                   if(sizeof(uart1TxBuffer) <= uart1TxHead)
12EFE  0E3F     MOVLW 0x3F
12F00  65E7     CPFSGT 0xE7, BANKED
12F02  D002     BRA 0x2F08
217:                   {
218:                       uart1TxHead = 0;
12F04  0E00     MOVLW 0x0
12F06  6FE7     MOVWF 0xE7, BANKED
219:                   }
220:                   uart1TxBufferRemaining--;
12F08  0655     DECF 0x55, F, ACCESS
221:               }
222:               PIE4bits.U1TXIE = 1;
12F0A  82A2     BSF 0xFA2, 1, ACCESS
223:           }
12F0C  0012     RETURN 0
224:           
225:           void __interrupt(irq(U1TX),base(8)) UART1_tx_vect_isr()
226:           {   
227:               if(UART1_TxInterruptHandler)
132B0  0105     MOVLB 0x5
132B2  51C1     MOVF 0xC1, W, BANKED
132B4  11C2     IORWF 0xC2, W, BANKED
132B6  11C3     IORWF 0xC3, W, BANKED
132B8  B4D8     BTFSC 0xFD8, 2, ACCESS
132BA  0011     RETFIE 1
228:               {
229:                   UART1_TxInterruptHandler();
132BC  D801     RCALL 0x32C0
132BE  0011     RETFIE 1
132C0  0005     PUSH
132C2  6EFA     MOVWF 0xFFA, ACCESS
132C4  51C1     MOVF 0xC1, W, BANKED
132C6  6EFD     MOVWF 0xFFD, ACCESS
132C8  51C2     MOVF 0xC2, W, BANKED
132CA  6EFE     MOVWF 0xFFE, ACCESS
132CC  51C3     MOVF 0xC3, W, BANKED
132CE  6EFF     MOVWF 0xFFF, ACCESS
132D0  50FA     MOVF 0xFFA, W, ACCESS
132D2  0012     RETURN 0
230:               }
231:           }
232:           
233:           void __interrupt(irq(U1RX),base(8)) UART1_rx_vect_isr()
234:           {
235:               if(UART1_RxInterruptHandler)
236:               {
237:                   UART1_RxInterruptHandler();
132E0  D801     RCALL 0x32E4
238:               }
239:           }
240:           
241:           
242:           
243:           void UART1_Transmit_ISR(void)
244:           {
245:               // use this default transmit interrupt handler code
246:               if(sizeof(uart1TxBuffer) > uart1TxBufferRemaining)
13150  0E40     MOVLW 0x40
13152  6055     CPFSLT 0x55, ACCESS
13154  D012     BRA 0x317A
247:               {
248:                   U1TXB = uart1TxBuffer[uart1TxTail++];
13156  0E40     MOVLW 0x40
13158  25E6     ADDWF 0xE6, W, BANKED
1315A  6ED9     MOVWF 0xFD9, ACCESS
1315C  6ADA     CLRF 0xFDA, ACCESS
1315E  0E08     MOVLW 0x8
13160  22DA     ADDWFC 0xFDA, F, ACCESS
13162  50DF     MOVF 0xFDF, W, ACCESS
13164  0102     MOVLB 0x2
13166  6FA3     MOVWF 0xA3, BANKED
13168  0105     MOVLB 0x5
1316A  2BE6     INCF 0xE6, F, BANKED
249:                  if(sizeof(uart1TxBuffer) <= uart1TxTail)
1316C  0E3F     MOVLW 0x3F
1316E  65E6     CPFSGT 0xE6, BANKED
13170  D002     BRA 0x3176
250:                   {
251:                       uart1TxTail = 0;
13172  0E00     MOVLW 0x0
13174  6FE6     MOVWF 0xE6, BANKED
252:                   }
253:                   uart1TxBufferRemaining++;
13176  2A55     INCF 0x55, F, ACCESS
254:               }
13178  0012     RETURN 0
255:               else
256:               {
257:                   PIE4bits.U1TXIE = 0;
1317A  92A2     BCF 0xFA2, 1, ACCESS
258:               }
259:               
260:               // or set custom function using UART1_SetTxInterruptHandler()
261:           }
1317C  0012     RETURN 0
132D4  0105     MOVLB 0x5
132D6  51C4     MOVF 0xC4, W, BANKED
132D8  11C5     IORWF 0xC5, W, BANKED
132DA  11C6     IORWF 0xC6, W, BANKED
132DC  B4D8     BTFSC 0xFD8, 2, ACCESS
132DE  0011     RETFIE 1
132E0  D801     RCALL 0x32E4
132E2  0011     RETFIE 1
132E4  0005     PUSH
132E6  6EFA     MOVWF 0xFFA, ACCESS
132E8  51C4     MOVF 0xC4, W, BANKED
132EA  6EFD     MOVWF 0xFFD, ACCESS
132EC  51C5     MOVF 0xC5, W, BANKED
132EE  6EFE     MOVWF 0xFFE, ACCESS
132F0  51C6     MOVF 0xC6, W, BANKED
132F2  6EFF     MOVWF 0xFFF, ACCESS
132F4  50FA     MOVF 0xFFA, W, ACCESS
132F6  0012     RETURN 0
262:           
263:           void UART1_Receive_ISR(void)
264:           {
265:               // use this default receive interrupt handler code
266:               uart1RxStatusBuffer[uart1RxHead].status = 0;
124B2  0E40     MOVLW 0x40
124B4  2454     ADDWF 0x54, W, ACCESS
124B6  6ED9     MOVWF 0xFD9, ACCESS
124B8  6ADA     CLRF 0xFDA, ACCESS
124BA  0E07     MOVLW 0x7
124BC  22DA     ADDWFC 0xFDA, F, ACCESS
124BE  0E00     MOVLW 0x0
124C0  6EDF     MOVWF 0xFDF, ACCESS
267:           
268:               if(U1ERRIRbits.FERIF){
124C2  0102     MOVLB 0x2
124C4  A7B2     BTFSS OSCSTAT, 3, BANKED
124C6  D015     BRA 0x24F2
269:                   uart1RxStatusBuffer[uart1RxHead].ferr = 1;
124C8  0E40     MOVLW 0x40
124CA  2454     ADDWF 0x54, W, ACCESS
124CC  6ED9     MOVWF 0xFD9, ACCESS
124CE  6ADA     CLRF 0xFDA, ACCESS
124D0  0E07     MOVLW 0x7
124D2  22DA     ADDWFC 0xFDA, F, ACCESS
124D4  0107     MOVLB 0x7
124D6  82DF     BSF 0xFDF, 1, ACCESS
270:                   UART1_FramingErrorHandler();
124D8  D801     RCALL 0x24DC
124DA  D00B     BRA 0x24F2
124DC  0005     PUSH
124DE  6EFA     MOVWF 0xFFA, ACCESS
124E0  0106     MOVLB 0x6
124E2  51B1     MOVF OSCFRQ, W, BANKED
124E4  6EFD     MOVWF 0xFFD, ACCESS
124E6  51B2     MOVF OSCSTAT, W, BANKED
124E8  6EFE     MOVWF 0xFFE, ACCESS
124EA  51B3     MOVF OSCEN, W, BANKED
124EC  6EFF     MOVWF 0xFFF, ACCESS
124EE  50FA     MOVF 0xFFA, W, ACCESS
124F0  0012     RETURN 0
271:               }
272:               
273:               if(U1ERRIRbits.RXFOIF){
124F2  0102     MOVLB 0x2
124F4  A3B2     BTFSS OSCSTAT, 1, BANKED
124F6  D015     BRA 0x2522
274:                   uart1RxStatusBuffer[uart1RxHead].oerr = 1;
124F8  0E40     MOVLW 0x40
124FA  2454     ADDWF 0x54, W, ACCESS
124FC  6ED9     MOVWF 0xFD9, ACCESS
124FE  6ADA     CLRF 0xFDA, ACCESS
12500  0E07     MOVLW 0x7
12502  22DA     ADDWFC 0xFDA, F, ACCESS
12504  0107     MOVLB 0x7
12506  84DF     BSF 0xFDF, 2, ACCESS
275:                   UART1_OverrunErrorHandler();
12508  D801     RCALL 0x250C
1250A  D00B     BRA 0x2522
1250C  0005     PUSH
1250E  6EFA     MOVWF 0xFFA, ACCESS
12510  0106     MOVLB 0x6
12512  51AE     MOVF OSCCON2, W, BANKED
12514  6EFD     MOVWF 0xFFD, ACCESS
12516  51AF     MOVF OSCCON3, W, BANKED
12518  6EFE     MOVWF 0xFFE, ACCESS
1251A  51B0     MOVF OSCTUNE, W, BANKED
1251C  6EFF     MOVWF 0xFFF, ACCESS
1251E  50FA     MOVF 0xFFA, W, ACCESS
12520  0012     RETURN 0
276:               }
277:               
278:               if(uart1RxStatusBuffer[uart1RxHead].status){
12522  0E40     MOVLW 0x40
12524  2454     ADDWF 0x54, W, ACCESS
12526  6ED9     MOVWF 0xFD9, ACCESS
12528  6ADA     CLRF 0xFDA, ACCESS
1252A  0E07     MOVLW 0x7
1252C  22DA     ADDWFC 0xFDA, F, ACCESS
1252E  50DF     MOVF 0xFDF, W, ACCESS
12530  B4D8     BTFSC 0xFD8, 2, ACCESS
12532  D00D     BRA 0x254E
279:                   UART1_ErrorHandler();
12534  D801     RCALL 0x2538
12536  0012     RETURN 0
12538  0005     PUSH
1253A  6EFA     MOVWF 0xFFA, ACCESS
1253C  0106     MOVLB 0x6
1253E  51AB     MOVF 0xAB, W, BANKED
12540  6EFD     MOVWF 0xFFD, ACCESS
12542  51AC     MOVF ACTCON, W, BANKED
12544  6EFE     MOVWF 0xFFE, ACCESS
12546  51AD     MOVF OSCCON1, W, BANKED
12548  6EFF     MOVWF 0xFFF, ACCESS
1254A  50FA     MOVF 0xFFA, W, ACCESS
1254C  0012     RETURN 0
280:               } else {
281:                   UART1_RxDataHandler();
1254E  EC8D     CALL 0x1331A, 0
12550  F099     NOP
282:               }
283:           
284:               // or set custom function using UART1_SetRxInterruptHandler()
285:           }
12552  0012     RETURN 0
286:           
287:           void UART1_RxDataHandler(void){
288:               // use this default receive interrupt handler code
289:               uart1RxBuffer[uart1RxHead++] = U1RXB;
1331A  0E00     MOVLW 0x0
1331C  2454     ADDWF 0x54, W, ACCESS
1331E  6ED9     MOVWF 0xFD9, ACCESS
13320  6ADA     CLRF 0xFDA, ACCESS
13322  0E08     MOVLW 0x8
13324  22DA     ADDWFC 0xFDA, F, ACCESS
13326  C2A1     MOVFF U1RXB, INDF2
13328  F4DF     NOP
1332A  2A54     INCF 0x54, F, ACCESS
290:               if(sizeof(uart1RxBuffer) <= uart1RxHead)
1332C  0E3F     MOVLW 0x3F
1332E  6454     CPFSGT 0x54, ACCESS
13330  D002     BRA 0x3336
291:               {
292:                   uart1RxHead = 0;
13332  0E00     MOVLW 0x0
13334  6E54     MOVWF 0x54, ACCESS
293:               }
294:               uart1RxCount++;
13336  0105     MOVLB 0x5
13338  2BE5     INCF 0xE5, F, BANKED
295:           }
131F4  98B0     BCF 0xFB0, 4, ACCESS
1333A  0012     RETURN 0
296:           
297:           void UART1_DefaultFramingErrorHandler(void){}
13592  0012     RETURN 0
298:           
299:           void UART1_DefaultOverrunErrorHandler(void){}
13590  0012     RETURN 0
300:           
301:           void UART1_DefaultErrorHandler(void){
302:               UART1_RxDataHandler();
13578  EC8D     CALL 0x1331A, 0
1357A  F099     NOP
303:           }
1357C  0012     RETURN 0
304:           
305:           void UART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
306:               UART1_FramingErrorHandler = interruptHandler;
134EE  C506     MOVFF InterruptHandler, UART1_FramingErrorHandler
134F0  F6B1     NOP
134F2  C507     MOVFF c, 0x6B2
134F4  F6B2     NOP
134F6  C508     MOVFF blockSize, 0x6B3
134F8  F6B3     NOP
307:           }
134FA  0012     RETURN 0
308:           
309:           void UART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
310:               UART1_OverrunErrorHandler = interruptHandler;
134E0  C506     MOVFF InterruptHandler, UART1_OverrunErrorHandler
134E2  F6AE     NOP
134E4  C507     MOVFF c, 0x6AF
134E6  F6AF     NOP
134E8  C508     MOVFF blockSize, 0x6B0
134EA  F6B0     NOP
311:           }
134EC  0012     RETURN 0
312:           
313:           void UART1_SetErrorHandler(void (* interruptHandler)(void)){
314:               UART1_ErrorHandler = interruptHandler;
134FC  C506     MOVFF InterruptHandler, UART1_ErrorHandler
134FE  F6AB     NOP
13500  C507     MOVFF c, 0x6AC
13502  F6AC     NOP
13504  C508     MOVFF blockSize, 0x6AD
13506  F6AD     NOP
315:           }
13508  0012     RETURN 0
316:           
317:           
318:           
319:           void UART1_SetRxInterruptHandler(void (* InterruptHandler)(void)){
320:               UART1_RxInterruptHandler = InterruptHandler;
134D2  C506     MOVFF InterruptHandler, UART1_RxInterruptHandler
134D4  F5C4     NOP
134D6  C507     MOVFF c, 0x5C5
134D8  F5C5     NOP
134DA  C508     MOVFF blockSize, 0x5C6
134DC  F5C6     NOP
321:           }
134DE  0012     RETURN 0
322:           
323:           void UART1_SetTxInterruptHandler(void (* InterruptHandler)(void)){
324:               UART1_TxInterruptHandler = InterruptHandler;
134C4  C506     MOVFF InterruptHandler, UART1_TxInterruptHandler
134C6  F5C1     NOP
134C8  C507     MOVFF c, 0x5C2
134CA  F5C2     NOP
134CC  C508     MOVFF blockSize, 0x5C3
134CE  F5C3     NOP
325:           }
134D0  0012     RETURN 0
326:           
327:           
328:           /**
329:             End of File
330:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/tmr6.c  ----------------
1:             /**
2:               TMR6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR6.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:            	Device            :  PIC18F47Q43
18:            	Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above 
21:                    MPLAB 	          :  MPLAB X 5.45
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "tmr6.h"
53:            #include "interrupt_manager.h"
54:            #include "../timers.h"
55:            
56:            /**
57:              Section: Global Variables Definitions
58:             */
59:            extern volatile uint16_t tickCount[TMR_COUNT];
60:            
61:            void (*TMR6_InterruptHandler)(void);
62:            
63:            /**
64:              Section: TMR6 APIs
65:             */
66:            
67:            void TMR6_Initialize(void)
68:            {
69:            	// Set TMR6 to the options selected in the User Interface
70:            
71:            	// T6CS FOSC/4; 
72:            	T6CLKCON = 0x01;
13094  0E01     MOVLW 0x1
13096  0103     MOVLB 0x3
13098  6F3E     MOVWF 0x3E, BANKED
73:            
74:            	// T6PSYNC Not Synchronized; T6MODE Software control; T6CKPOL Rising Edge; T6CKSYNC Synchronized; 
75:            	T6HLT = 0x20;
1309A  0E20     MOVLW 0x20
1309C  6F3D     MOVWF 0x3D, BANKED
76:            
77:            	// T6RSEL T6CKIPPS pin; 
78:            	T6RST = 0x00;
1309E  0E00     MOVLW 0x0
130A0  6F3F     MOVWF 0x3F, BANKED
79:            
80:            	// PR6 249; 
81:            	T6PR = 0xF9;
130A2  0EF9     MOVLW 0xF9
130A4  6F3B     MOVWF 0x3B, BANKED
82:            
83:            	// TMR6 0; 
84:            	T6TMR = 0x00;
130A6  0E00     MOVLW 0x0
130A8  6F3A     MOVWF CLKRCLK, BANKED
85:            
86:            	// Clearing IF flag before enabling the interrupt.
87:            	PIR15bits.TMR6IF = 0;
130AA  96BD     BCF 0xFBD, 3, ACCESS
88:            
89:            	// Enabling TMR6 interrupt.
90:            	PIE15bits.TMR6IE = 1;
130AC  86AD     BSF 0xFAD, 3, ACCESS
91:            
92:            	// Set Default Interrupt Handler
93:            	TMR6_SetInterruptHandler(TMR6_DefaultInterruptHandler);
130AE  0E94     MOVLW 0x94
130B0  6E06     MOVWF 0x6, ACCESS
130B2  0E2E     MOVLW 0x2E
130B4  6E07     MOVWF 0x7, ACCESS
130B6  0E01     MOVLW 0x1
130B8  6E08     MOVWF 0x8, ACCESS
130BA  EC85     CALL 0x1350A, 0
130BC  F09A     NOP
94:            
95:            	// T6CKPS 1:8; T6OUTPS 1:4; TMR6ON on; 
96:            	T6CON = 0xB3;
130BE  0EB3     MOVLW 0xB3
130C0  6F3C     MOVWF 0x3C, BANKED
97:            }
130C2  0012     RETURN 0
98:            
99:            void TMR6_ModeSet(TMR6_HLT_MODE mode)
100:           {
101:           	// Configure different types HLT mode
102:           	T6HLTbits.MODE = mode;
103:           }
104:           
105:           void TMR6_ExtResetSourceSet(TMR6_HLT_EXT_RESET_SOURCE reset)
106:           {
107:           	//Configure different types of HLT external reset source
108:           	T6RSTbits.RSEL = reset;
109:           }
110:           
111:           void TMR6_Start(void)
112:           {
113:           	// Start the Timer by writing to TMRxON bit
114:           	T6CONbits.TMR6ON = 1;
115:           }
116:           
117:           void TMR6_StartTimer(void)
118:           {
119:           	TMR6_Start();
120:           }
121:           
122:           void TMR6_Stop(void)
123:           {
124:           	// Stop the Timer by writing to TMRxON bit
125:           	T6CONbits.TMR6ON = 0;
126:           }
127:           
128:           void TMR6_StopTimer(void)
129:           {
130:           	TMR6_Stop();
131:           }
132:           
133:           uint8_t TMR6_Counter8BitGet(void)
134:           {
135:           	uint8_t readVal;
136:           
137:           	readVal = TMR6;
138:           
139:           	return readVal;
140:           }
141:           
142:           uint8_t TMR6_ReadTimer(void)
143:           {
144:           	return TMR6_Counter8BitGet();
145:           }
146:           
147:           void TMR6_Counter8BitSet(uint8_t timerVal)
148:           {
149:           	// Write to the Timer6 register
150:           	TMR6 = timerVal;
151:           }
152:           
153:           void TMR6_WriteTimer(uint8_t timerVal)
154:           {
155:           	TMR6_Counter8BitSet(timerVal);
156:           }
157:           
158:           void TMR6_Period8BitSet(uint8_t periodVal)
159:           {
160:           	PR6 = periodVal;
161:           }
162:           
163:           void TMR6_LoadPeriodRegister(uint8_t periodVal)
164:           {
165:           	TMR6_Period8BitSet(periodVal);
166:           }
167:           
168:           void __interrupt(irq(TMR6),base(8)) TMR6_ISR()
169:           {
170:           
171:           	// clear the TMR6 interrupt flag
172:           	PIR15bits.TMR6IF = 0;
131CC  96BD     BCF 0xFBD, 3, ACCESS
173:           
174:               if(TMR6_InterruptHandler)
131CE  0105     MOVLB 0x5
131D0  51B2     MOVF OSCSTAT, W, BANKED
131D2  11B3     IORWF OSCEN, W, BANKED
131D4  11B4     IORWF PRLOCK, W, BANKED
131D6  B4D8     BTFSC 0xFD8, 2, ACCESS
131D8  0011     RETFIE 1
175:               {
176:           		TMR6_InterruptHandler();
131DA  D801     RCALL 0x31DE
131DC  0011     RETFIE 1
131DE  0005     PUSH
131E0  6EFA     MOVWF 0xFFA, ACCESS
131E2  51B2     MOVF OSCSTAT, W, BANKED
131E4  6EFD     MOVWF 0xFFD, ACCESS
131E6  51B3     MOVF OSCEN, W, BANKED
131E8  6EFE     MOVWF 0xFFE, ACCESS
131EA  51B4     MOVF PRLOCK, W, BANKED
131EC  6EFF     MOVWF 0xFFF, ACCESS
131EE  50FA     MOVF 0xFFA, W, ACCESS
131F0  0012     RETURN 0
177:           	}
178:           }
179:           
180:           
181:           void TMR6_SetInterruptHandler(void (* InterruptHandler)(void)){
182:           	TMR6_InterruptHandler = InterruptHandler;
1350A  C506     MOVFF InterruptHandler, TMR6_InterruptHandler
1350C  F5B2     NOP
1350E  C507     MOVFF c, 0x5B3
13510  F5B3     NOP
13512  C508     MOVFF blockSize, 0x5B4
13514  F5B4     NOP
183:           }
13516  0012     RETURN 0
184:           
185:           void TMR6_DefaultInterruptHandler(void)
186:           {
187:           	static uint8_t i;
188:           	// add your TMR6 interrupt custom code
189:           	// or set custom function using TMR6_SetInterruptHandler()
190:           	//Decrement each software timer
191:           	for (i = 0; i < TMR_COUNT; i++) {
12E94  0E00     MOVLW 0x0
12E96  6FE8     MOVWF DMASELECT, BANKED
12E98  0E06     MOVLW 0x6
12E9A  65E8     CPFSGT DMASELECT, BANKED
12E9C  D001     BRA 0x2EA0
12E9E  0012     RETURN 0
192:           		if (tickCount[i] != 0) {
12EA0  51E8     MOVF DMASELECT, W, BANKED
12EA2  0D02     MULLW 0x2
12EA4  0E7F     MOVLW 0x7F
12EA6  24F3     ADDWF 0xFF3, W, ACCESS
12EA8  6ED9     MOVWF 0xFD9, ACCESS
12EAA  0E06     MOVLW 0x6
12EAC  20F4     ADDWFC 0xFF4, W, ACCESS
12EAE  6EDA     MOVWF 0xFDA, ACCESS
12EB0  50DE     MOVF 0xFDE, W, ACCESS
12EB2  10DE     IORWF 0xFDE, W, ACCESS
12EB4  B4D8     BTFSC 0xFD8, 2, ACCESS
12EB6  D00B     BRA 0x2ECE
193:           			tickCount[i]--;
12EB8  51E8     MOVF DMASELECT, W, BANKED
12EBA  0D02     MULLW 0x2
12EBC  0E7F     MOVLW 0x7F
12EBE  24F3     ADDWF 0xFF3, W, ACCESS
12EC0  6ED9     MOVWF 0xFD9, ACCESS
12EC2  0E06     MOVLW 0x6
12EC4  20F4     ADDWFC 0xFF4, W, ACCESS
12EC6  6EDA     MOVWF 0xFDA, ACCESS
12EC8  06DE     DECF 0xFDE, F, ACCESS
12ECA  0E00     MOVLW 0x0
12ECC  5ADD     SUBWFB 0xFDD, F, ACCESS
194:           		}
195:           	}
12ECE  2BE8     INCF DMASELECT, F, BANKED
12ED0  D7E3     BRA 0x2E98
196:           }
132B0  0105     MOVLB 0x5
197:           
198:           /**
199:             End of File
200:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/tmr5.c  ----------------
1:             /**
2:               TMR5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR5.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr5.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer5ReloadVal;
59:            void (*TMR5_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR5 APIs
63:            */
64:            
65:            void TMR5_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T5GE disabled; T5GTM disabled; T5GPOL low; T5GGO done; T5GSPM disabled; 
70:                T5GCON = 0x00;
12D04  0E00     MOVLW 0x0
12D06  6F37     MOVWF 0x37, BANKED
71:            
72:                //GSS T5G_pin; 
73:                T5GATE = 0x00;
12D08  0E00     MOVLW 0x0
12D0A  6F38     MOVWF 0x38, BANKED
74:            
75:                //CS FOSC/4; 
76:                T5CLK = 0x01;
12D0C  0E01     MOVLW 0x1
12D0E  6F39     MOVWF CLKRCON, BANKED
77:            
78:                //TMR5H 177; 
79:                TMR5H = 0xB1;
12D10  0EB1     MOVLW 0xB1
12D12  6F35     MOVWF 0x35, BANKED
80:            
81:                //TMR5L 224; 
82:                TMR5L = 0xE0;
12D14  0EE0     MOVLW 0xE0
12D16  6F34     MOVWF 0x34, BANKED
83:            
84:                // Clearing IF flag before enabling the interrupt.
85:                PIR8bits.TMR5IF = 0;
12D18  98B6     BCF 0xFB6, 4, ACCESS
86:            
87:                // Load the TMR value to reload variable
88:                timer5ReloadVal=(uint16_t)((TMR5H << 8) | TMR5L);
12D1A  5134     MOVF 0x34, W, BANKED
12D1E  FCD4     NOP
12D20  F509     NOP
12D22  6A0A     CLRF 0xA, ACCESS
12D24  C509     MOVFF td, data
12D26  F50A     NOP
12D28  6A09     CLRF 0x9, ACCESS
12D2A  1009     IORWF 0x9, W, ACCESS
12D2C  0105     MOVLB 0x5
12D2E  6FD9     MOVWF CLCnSEL1, BANKED
12D30  500A     MOVF 0xA, W, ACCESS
12D32  6FDA     MOVWF CLCnSEL2, BANKED
89:            
90:                // Enabling TMR5 interrupt.
91:                PIE8bits.TMR5IE = 1;
12D34  88A6     BSF 0xFA6, 4, ACCESS
92:            
93:                // Set Default Interrupt Handler
94:                TMR5_SetInterruptHandler(TMR5_DefaultInterruptHandler);
12D36  0E8A     MOVLW 0x8A
12D38  6E06     MOVWF 0x6, ACCESS
12D3A  0E35     MOVLW 0x35
12D3C  6E07     MOVWF 0x7, ACCESS
12D3E  0E01     MOVLW 0x1
12D40  6E08     MOVWF 0x8, ACCESS
12D42  EC8C     CALL 0x13518, 0
12D44  F09A     NOP
95:            
96:                // CKPS 1:8; NOT_SYNC synchronize; TMR5ON enabled; T5RD16 disabled; 
97:                T5CON = 0x31;
12D46  0E31     MOVLW 0x31
12D48  0103     MOVLB 0x3
12D4A  6F36     MOVWF 0x36, BANKED
98:            }
12D4C  0012     RETURN 0
99:            
100:           void TMR5_StartTimer(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T5CONbits.TMR5ON = 1;
104:           }
105:           
106:           void TMR5_StopTimer(void)
107:           {
108:               // Stop the Timer by writing to TMRxON bit
109:               T5CONbits.TMR5ON = 0;
110:           }
111:           
112:           uint16_t TMR5_ReadTimer(void)
113:           {
114:               uint16_t readVal;
115:               uint8_t readValHigh;
116:               uint8_t readValLow;
117:               
118:               T5CONbits.T5RD16 = 1;
119:           	
120:               readValLow = TMR5L;
121:               readValHigh = TMR5H;
122:               
123:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
124:           
125:               return readVal;
126:           }
127:           
128:           void TMR5_WriteTimer(uint16_t timerVal)
129:           {
130:               if (T5CONbits.NOT_SYNC == 1)
131A6  0103     MOVLB 0x3
131A8  A536     BTFSS 0x36, 2, BANKED
131AA  D009     BRA 0x31BE
131:               {
132:                   // Stop the Timer by writing to TMRxON bit
133:                   T5CONbits.TMR5ON = 0;
131AC  9136     BCF 0x36, 0, BANKED
134:           
135:                   // Write to the Timer5 register
136:                   TMR5H = (uint8_t)(timerVal >> 8);
131B0  F408     NOP
131B2  F335     NOP
137:                   TMR5L = (uint8_t)timerVal;
131B6  F404     NOP
131B8  F334     NOP
138:           
139:                   // Start the Timer after writing to the register
140:                   T5CONbits.TMR5ON =1;
131BA  8136     BSF 0x36, 0, BANKED
141:               }
131BC  0012     RETURN 0
142:               else
143:               {
144:                   // Write to the Timer5 register
145:                   TMR5H = (uint8_t)(timerVal >> 8);
131C0  F408     NOP
131C2  F335     NOP
146:                   TMR5L = (uint8_t)timerVal;
131C6  F404     NOP
131C8  F334     NOP
147:               }
148:           }
131CA  0012     RETURN 0
149:           
150:           void TMR5_Reload(void)
151:           {
152:               TMR5_WriteTimer(timer5ReloadVal);
153:           }
154:           
155:           void TMR5_StartSinglePulseAcquisition(void)
156:           {
157:               T5GCONbits.T5GGO = 1;
158:           }
159:           
160:           uint8_t TMR5_CheckGateValueStatus(void)
161:           {
162:               return (T5GCONbits.T5GVAL);
163:           }
164:           
165:           void __interrupt(irq(TMR5),base(8)) TMR5_ISR()
166:           {
167:               static volatile unsigned int CountCallBack = 0;
168:           
169:               // Clear the TMR5 interrupt flag
170:               PIR8bits.TMR5IF = 0;
130C4  98B6     BCF 0xFB6, 4, ACCESS
171:               TMR5_WriteTimer(timer5ReloadVal);
130C6  C5D9     MOVFF timer5ReloadVal, __pcstackCOMRAM
130C8  F501     NOP
130CA  C5DA     MOVFF 0x5DA, 0x502
130CC  F502     NOP
130CE  ECD3     CALL 0x131A6, 0
130D0  F098     NOP
172:           
173:               // callback function - called every 100th pass
174:               if (++CountCallBack >= TMR5_INTERRUPT_TICKER_FACTOR)
130D2  0105     MOVLB 0x5
130D4  4BD7     INFSNZ CLCnPOL, F, BANKED
130D6  2BD8     INCF CLCnSEL0, F, BANKED
130D8  51D8     MOVF CLCnSEL0, W, BANKED
130DA  E104     BNZ 0x30E4
130DC  0E64     MOVLW 0x64
130DE  5DD7     SUBWF CLCnPOL, W, BANKED
130E0  A0D8     BTFSS 0xFD8, 0, ACCESS
130E2  0011     RETFIE 1
175:               {
176:                   // ticker function call
177:                   TMR5_CallBack();
130E4  EC7C     CALL 0x132F8, 0
130E6  F099     NOP
178:           
179:                   // reset ticker counter
180:                   CountCallBack = 0;
130E8  0E00     MOVLW 0x0
130EA  0105     MOVLB 0x5
130EC  6FD8     MOVWF CLCnSEL0, BANKED
130EE  0E00     MOVLW 0x0
130F0  6FD7     MOVWF CLCnPOL, BANKED
181:               }
182:           }
130F2  0011     RETFIE 1
183:           
184:           void TMR5_CallBack(void)
185:           {
186:               // Add your custom callback code here
187:               if(TMR5_InterruptHandler)
132F8  51BE     MOVF MAINPR, W, BANKED
132FA  11BF     IORWF ISRPR, W, BANKED
132FC  11C0     IORWF 0xC0, W, BANKED
132FE  B4D8     BTFSC 0xFD8, 2, ACCESS
13300  0012     RETURN 0
188:               {
189:                   TMR5_InterruptHandler();
13302  D801     RCALL 0x3306
13304  0012     RETURN 0
13306  0005     PUSH
13308  6EFA     MOVWF 0xFFA, ACCESS
1330A  51BE     MOVF MAINPR, W, BANKED
1330C  6EFD     MOVWF 0xFFD, ACCESS
1330E  51BF     MOVF ISRPR, W, BANKED
13310  6EFE     MOVWF 0xFFE, ACCESS
13312  51C0     MOVF 0xC0, W, BANKED
13314  6EFF     MOVWF 0xFFF, ACCESS
13316  50FA     MOVF 0xFFA, W, ACCESS
13318  0012     RETURN 0
190:               }
191:           }
192:           
193:           void TMR5_SetInterruptHandler(void (* InterruptHandler)(void)){
194:               TMR5_InterruptHandler = InterruptHandler;
13518  C506     MOVFF InterruptHandler, TMR5_InterruptHandler
1351A  F5BE     NOP
1351C  C507     MOVFF c, 0x5BF
1351E  F5BF     NOP
13520  C508     MOVFF blockSize, 0x5C0
13522  F5C0     NOP
195:           }
13524  0012     RETURN 0
196:           
197:           void TMR5_DefaultInterruptHandler(void){
198:               // add your TMR5 interrupt custom code
199:               // or set custom function using TMR5_SetInterruptHandler()
200:           }
1358A  0012     RETURN 0
201:           
202:           /**
203:             End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/tmr2.c  ----------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above 
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
1339A  0E01     MOVLW 0x1
1339C  0103     MOVLB 0x3
1339E  6F26     MOVWF 0x26, BANKED
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
133A0  0E00     MOVLW 0x0
133A2  6F25     MOVWF 0x25, BANKED
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
133A4  0E00     MOVLW 0x0
133A6  6F27     MOVWF 0x27, BANKED
74:            
75:                // PR2 15; 
76:                T2PR = 0x0F;
133A8  0E0F     MOVLW 0xF
133AA  6F23     MOVWF 0x23, BANKED
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
133AC  0E00     MOVLW 0x0
133AE  6F22     MOVWF 0x22, BANKED
80:            
81:                // Clearing IF flag.
82:                PIR3bits.TMR2IF = 0;
133B0  96B1     BCF 0xFB1, 3, ACCESS
83:            
84:                // T2CKPS 1:1; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0x80;
133B2  0E80     MOVLW 0x80
133B4  6F24     MOVWF 0x24, BANKED
86:            }
133B6  0012     RETURN 0
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR3bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR3bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/spi1.c  ----------------
1:             /**
2:               SPI1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the SPI1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for SPI1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "spi1.h"
48:            #include <xc.h>
49:            
50:            typedef struct { 
51:                uint8_t con0; 
52:                uint8_t con1; 
53:                uint8_t con2; 
54:                uint8_t baud; 
55:                uint8_t operation;
56:            } spi1_configuration_t;
57:            
58:            
59:            //con0 == SPIxCON0, con1 == SPIxCON1, con2 == SPIxCON2, baud == SPIxBAUD, operation == Master/Slave
60:            static const spi1_configuration_t spi1_configuration[] = {   
61:                { 0x3, 0x24, 0x3, 0x4, 0 }
62:            };
63:            
64:            void SPI1_Initialize(void)
65:            {
66:                //EN disabled; LSBF MSb first; MST bus master; BMODE every byte; 
67:                SPI1CON0 = 0x03;
133D4  0E03     MOVLW 0x3
133D6  0100     MOVLB 0x0
133D8  6F84     MOVWF SPI1CON0, BANKED
68:                //SMP Middle; CKE Idle to active; CKP Idle:High, Active:Low; FST disabled; SSP active low; SDIP active high; SDOP active high; 
69:                SPI1CON1 = 0x24;
133DA  0E24     MOVLW 0x24
133DC  6F85     MOVWF SPI1CON1, BANKED
70:                //SSET disabled; TXR required for a transfer; RXR suspended if the RxFIFO is full; 
71:                SPI1CON2 = 0x03;
133DE  0E03     MOVLW 0x3
133E0  6F86     MOVWF SPI1CON2, BANKED
72:                //CLKSEL MFINTOSC; 
73:                SPI1CLK = 0x02;
133E2  0E02     MOVLW 0x2
133E4  6F8C     MOVWF SPI1CLK, BANKED
74:                //BAUD 4; 
75:                SPI1BAUD = 0x04;
133E6  0E04     MOVLW 0x4
133E8  6F89     MOVWF SPI1BAUD, BANKED
76:                TRISCbits.TRISC3 = 0;
133EA  96C8     BCF 0xFC8, 3, ACCESS
77:            }
133EC  0012     RETURN 0
78:            
79:            bool SPI1_Open(spi1_modes_t spi1UniqueConfiguration)
80:            {
81:                if(!SPI1CON0bits.EN)
82:                {
83:                    SPI1CON0 = spi1_configuration[spi1UniqueConfiguration].con0;
84:                    SPI1CON1 = spi1_configuration[spi1UniqueConfiguration].con1;
85:                    SPI1CON2 = spi1_configuration[spi1UniqueConfiguration].con2 | (_SPI1CON2_SPI1RXR_MASK | _SPI1CON2_SPI1TXR_MASK);
86:                    SPI1CLK  = 0x00;
87:                    SPI1BAUD = spi1_configuration[spi1UniqueConfiguration].baud;        
88:                    TRISCbits.TRISC3 = spi1_configuration[spi1UniqueConfiguration].operation;
89:                    SPI1CON0bits.EN = 1;
90:                    return true;
91:                }
92:                return false;
93:            }
94:            
95:            void SPI1_Close(void)
96:            {
97:                SPI1CON0bits.EN = 0;
98:            }
99:            
100:           uint8_t SPI1_ExchangeByte(uint8_t data)
133EE  6E06     MOVWF 0x6, ACCESS
101:           {
102:               SPI1TCNTL = 1;
133F0  0E01     MOVLW 0x1
133F2  0100     MOVLB 0x0
133F4  6F82     MOVWF SPI1TCNT, BANKED
103:               SPI1TXB = data;
133F8  F418     NOP
133FA  F081     NOP
104:               while(!PIR3bits.SPI1RXIF);
133FC  A0B1     BTFSS 0xFB1, 0, ACCESS
133FE  D7FE     BRA 0x33FC
105:               return SPI1RXB;
13400  0100     MOVLB 0x0
13402  5180     MOVF SPI1RXB, W, BANKED
106:           }
13404  0012     RETURN 0
107:           
108:           void SPI1_ExchangeBlock(void *block, size_t blockSize)
109:           {
110:               uint8_t *data = block;
12CBA  C506     MOVFF InterruptHandler, data
12CBC  F50A     NOP
12CBE  C507     MOVFF c, elostr
12CC0  F50B     NOP
111:               while(blockSize--)
12CC2  D017     BRA 0x2CF2
12CF2  0608     DECF 0x8, F, ACCESS
112:               {
113:                   SPI1TCNTL = 1;
12CC4  0E01     MOVLW 0x1
12CC6  0100     MOVLB 0x0
12CC8  6F82     MOVWF SPI1TCNT, BANKED
114:                   SPI1TXB = *data;
12CCC  F428     NOP
12CCE  F4D9     NOP
12CD2  F42C     NOP
12CD4  F4DA     NOP
12CD6  50DF     MOVF 0xFDF, W, ACCESS
12CD8  6F81     MOVWF SPI1TXB, BANKED
115:                   while(!PIR3bits.SPI1RXIF);
12CDA  A0B1     BTFSS 0xFB1, 0, ACCESS
12CDC  D7FE     BRA 0x2CDA
116:                   *data++ = SPI1RXB;
12CE0  F428     NOP
12CE2  F4D9     NOP
12CE6  F42C     NOP
12CE8  F4DA     NOP
12CEA  C080     MOVFF SPI1RXB, INDF2
12CEC  F4DF     NOP
12CEE  4A0A     INFSNZ 0xA, F, ACCESS
12CF0  2A0B     INCF 0xB, F, ACCESS
12CF2  0608     DECF 0x8, F, ACCESS
12CF4  A0D8     BTFSS 0xFD8, 0, ACCESS
12CF6  0609     DECF 0x9, F, ACCESS
12CF8  2808     INCF 0x8, W, ACCESS
12CFA  E1E4     BNZ 0x2CC4
12CFC  2809     INCF 0x9, W, ACCESS
12CFE  B4D8     BTFSC 0xFD8, 2, ACCESS
12D00  0012     RETURN 0
12D02  D7E0     BRA 0x2CC4
117:               }
118:           }
119:           
120:           // Half Duplex SPI Functions
121:           void SPI1_WriteBlock(void *block, size_t blockSize)
122:           {
123:               uint8_t *data = block;
124:               while(blockSize--)
125:               {
126:                   SPI1_ExchangeByte(*data++);
127:               }
128:           }
129:           
130:           void SPI1_ReadBlock(void *block, size_t blockSize)
131:           {
132:               uint8_t *data = block;
133:               while(blockSize--)
134:               {
135:                   *data++ = SPI1_ExchangeByte(0);
136:               }
137:           }
138:           
139:           void SPI1_WriteByte(uint8_t byte)
140:           {
141:               SPI1TXB = byte;
142:           }
143:           
144:           uint8_t SPI1_ReadByte(void)
145:           {
146:               return SPI1RXB;
147:           }
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/pin_manager.c  ---------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x07;
12090  0E07     MOVLW 0x7
12092  6EC2     MOVWF 0xFC2, ACCESS
61:                LATD = 0x00;
12094  0E00     MOVLW 0x0
12096  6EC1     MOVWF 0xFC1, ACCESS
62:                LATA = 0x00;
12098  0E00     MOVLW 0x0
1209A  6EBE     MOVWF 0xFBE, ACCESS
63:                LATB = 0x00;
1209C  0E00     MOVLW 0x0
1209E  6EBF     MOVWF 0xFBF, ACCESS
64:                LATC = 0x2E;
120A0  0E2E     MOVLW 0x2E
120A2  6EC0     MOVWF 0xFC0, ACCESS
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x00;
120A4  0E00     MOVLW 0x0
120A6  6ECA     MOVWF 0xFCA, ACCESS
70:                TRISA = 0xD5;
120A8  0ED5     MOVLW 0xD5
120AA  6EC6     MOVWF 0xFC6, ACCESS
71:                TRISB = 0xBF;
120AC  0EBF     MOVLW 0xBF
120AE  6EC7     MOVWF 0xFC7, ACCESS
72:                TRISC = 0x91;
120B0  0E91     MOVLW 0x91
120B2  6EC8     MOVWF 0xFC8, ACCESS
73:                TRISD = 0x3C;
120B4  0E3C     MOVLW 0x3C
120B6  6EC9     MOVWF 0xFC9, ACCESS
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0x3C;
120B8  0E3C     MOVLW 0x3C
120BA  0104     MOVLB 0x4
120BC  6F18     MOVWF 0x18, BANKED
79:                ANSELC = 0x01;
120BE  0E01     MOVLW 0x1
120C0  6F10     MOVWF 0x10, BANKED
80:                ANSELB = 0x3F;
120C2  0E3F     MOVLW 0x3F
120C4  6F08     MOVWF 0x8, BANKED
81:                ANSELE = 0x00;
120C6  0E00     MOVLW 0x0
120C8  6F20     MOVWF 0x20, BANKED
82:                ANSELA = 0xC0;
120CA  0EC0     MOVLW 0xC0
120CC  6F00     MOVWF data, BANKED
83:            
84:                /**
85:                WPUx registers
86:                */
87:                WPUD = 0x00;
120CE  0E00     MOVLW 0x0
120D0  6F19     MOVWF 0x19, BANKED
88:                WPUE = 0x06;
120D2  0E06     MOVLW 0x6
120D4  6F21     MOVWF 0x21, BANKED
89:                WPUB = 0x00;
120D6  0E00     MOVLW 0x0
120D8  6F09     MOVWF 0x9, BANKED
90:                WPUA = 0x15;
120DA  0E15     MOVLW 0x15
120DC  6F01     MOVWF 0x1, BANKED
91:                WPUC = 0x06;
120DE  0E06     MOVLW 0x6
120E0  6F11     MOVWF 0x11, BANKED
92:            
93:                /**
94:                RxyI2C registers
95:                */
96:                RB1I2C = 0x00;
120E2  0E00     MOVLW 0x0
120E4  0102     MOVLB 0x2
120E6  6F89     MOVWF SPI1BAUD, BANKED
97:                RB2I2C = 0x00;
120E8  0E00     MOVLW 0x0
120EA  6F88     MOVWF SPI1TWIDTH, BANKED
98:                RC3I2C = 0x00;
120EC  0E00     MOVLW 0x0
120EE  6F87     MOVWF SPI1STATUS, BANKED
99:                RC4I2C = 0x00;
120F0  0E00     MOVLW 0x0
120F2  6F86     MOVWF SPI1CON2, BANKED
100:           
101:               /**
102:               ODx registers
103:               */
104:               ODCONE = 0x00;
120F4  0E00     MOVLW 0x0
120F6  0104     MOVLB 0x4
120F8  6F22     MOVWF 0x22, BANKED
105:               ODCONA = 0x00;
120FA  0E00     MOVLW 0x0
120FC  6F02     MOVWF 0x2, BANKED
106:               ODCONB = 0x00;
120FE  0E00     MOVLW 0x0
12100  6F0A     MOVWF 0xA, BANKED
107:               ODCONC = 0x00;
12102  0E00     MOVLW 0x0
12104  6F12     MOVWF 0x12, BANKED
108:               ODCOND = 0x00;
12106  0E00     MOVLW 0x0
12108  6F1A     MOVWF 0x1A, BANKED
109:           
110:               /**
111:               SLRCONx registers
112:               */
113:               SLRCONA = 0x00;
1210A  0E00     MOVLW 0x0
1210C  6F03     MOVWF 0x3, BANKED
114:               SLRCONB = 0x00;
1210E  0E00     MOVLW 0x0
12110  6F0B     MOVWF 0xB, BANKED
115:               SLRCONC = 0xFF;
12112  6913     SETF 0x13, BANKED
116:               SLRCOND = 0x00;
12114  0E00     MOVLW 0x0
12116  6F1B     MOVWF 0x1B, BANKED
117:               SLRCONE = 0x00;
12118  0E00     MOVLW 0x0
1211A  6F23     MOVWF 0x23, BANKED
118:           
119:               /**
120:               INLVLx registers
121:               */
122:               INLVLA = 0xFF;
1211C  6904     SETF 0x4, BANKED
123:               INLVLB = 0xFF;
1211E  690C     SETF 0xC, BANKED
124:               INLVLC = 0xFF;
12120  6914     SETF 0x14, BANKED
125:               INLVLD = 0xFF;
12122  691C     SETF 0x1C, BANKED
126:               INLVLE = 0x0F;
12124  0E0F     MOVLW 0xF
12126  6F24     MOVWF 0x24, BANKED
127:           
128:           
129:           
130:           
131:           
132:              
133:               
134:           	
135:               U2RXPPS = 0x0F;   //RB7->UART2:RX2;    
12128  0E0F     MOVLW 0xF
1212A  0102     MOVLB 0x2
1212C  6F74     MOVWF CM2CON0, BANKED
136:               SPI1SCKPPS = 0x13;   //RC3->SPI1:SCK1;    
1212E  0E13     MOVLW 0x13
12130  6F6A     MOVWF MD1CON0, BANKED
137:               RB6PPS = 0x23;   //RB6->UART2:TX2;    
12132  0E23     MOVLW 0x23
12134  6F0F     MOVWF 0xF, BANKED
138:               RC3PPS = 0x31;   //RC3->SPI1:SCK1;    
12136  0E31     MOVLW 0x31
12138  6F14     MOVWF 0x14, BANKED
139:               RC5PPS = 0x32;   //RC5->SPI1:SDO1;    
1213A  0E32     MOVLW 0x32
1213C  6F16     MOVWF 0x16, BANKED
140:               RC6PPS = 0x20;   //RC6->UART1:TX1;    
1213E  0E20     MOVLW 0x20
12140  6F17     MOVWF 0x17, BANKED
141:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
12142  0E17     MOVLW 0x17
12144  6F72     MOVWF CM1NCH, BANKED
142:               SPI1SDIPPS = 0x14;   //RC4->SPI1:SDI1;    
12146  0E14     MOVLW 0x14
12148  6F6B     MOVWF MD1CON1, BANKED
143:           }
1214A  0012     RETURN 0
144:             
145:           void PIN_MANAGER_IOC(void)
146:           {   
147:           }
148:           
149:           /**
150:            End of File
151:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/mcc.c  -----------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
12F84  EC37     CALL 0x12C6E, 0
12F86  F096     NOP
53:                PMD_Initialize();
12F88  EC21     CALL 0x13242, 0
12F8A  F099     NOP
54:                PIN_MANAGER_Initialize();
12F8C  EC48     CALL 0x12090, 0
12F8E  F090     NOP
55:                OSCILLATOR_Initialize();
12F90  ECAE     CALL 0x1335C, 0
12F92  F099     NOP
56:                TMR6_Initialize();
12F94  EC4A     CALL 0x13094, 0
12F96  F098     NOP
57:                DMA2_Initialize();
12F98  EC3B     CALL 0x12A76, 0
12F9A  F095     NOP
58:                DMA1_Initialize();
12F9C  EC69     CALL 0x12AD2, 0
12F9E  F095     NOP
59:                TMR2_Initialize();
12FA0  ECCD     CALL 0x1339A, 0
12FA2  F099     NOP
60:                TMR5_Initialize();
12FA4  EC82     CALL 0x12D04, 0
12FA6  F096     NOP
61:                UART2_Initialize();
12FA8  ECB4     CALL 0x12368, 0
12FAA  F091     NOP
62:                UART1_Initialize();
12FAC  EC03     CALL 0x12206, 0
12FAE  F091     NOP
63:                SPI1_Initialize();
12FB0  ECEA     CALL 0x133D4, 0
12FB2  F099     NOP
64:                CLKREF_Initialize();
12FB4  ECAD     CALL 0x1355A, 0
12FB6  F09A     NOP
65:                SystemArbiter_Initialize();
12FB8  ECA1     CALL 0x13542, 0
12FBA  F09A     NOP
66:            }
12FBC  0012     RETURN 0
67:            
68:            void OSCILLATOR_Initialize(void)
69:            {
70:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
71:                OSCCON1 = 0x20;
1335C  0E20     MOVLW 0x20
1335E  0100     MOVLB 0x0
13360  6FAD     MOVWF OSCCON1, BANKED
72:                // CSWHOLD may proceed; SOSCPWR Low power; 
73:                OSCCON3 = 0x00;
13362  0E00     MOVLW 0x0
13364  6FAF     MOVWF OSCCON3, BANKED
74:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
75:                OSCEN = 0x00;
13366  0E00     MOVLW 0x0
13368  6FB3     MOVWF OSCEN, BANKED
76:                // HFFRQ 4_MHz; 
77:                OSCFRQ = 0x02;
1336A  0E02     MOVLW 0x2
1336C  6FB1     MOVWF OSCFRQ, BANKED
78:                // TUN 0; 
79:                OSCTUNE = 0x00;
1336E  0E00     MOVLW 0x0
13370  6FB0     MOVWF OSCTUNE, BANKED
80:                // ACTUD enabled; ACTEN disabled; 
81:                ACTCON = 0x00;
13372  0E00     MOVLW 0x0
13374  6FAC     MOVWF ACTCON, BANKED
82:                // Wait for PLL to stabilize
83:                while(PLLR == 0)
84:                {
85:                }
13376  B1B2     BTFSC OSCSTAT, 0, BANKED
13378  0012     RETURN 0
1337A  D7FD     BRA 0x3376
86:            }
87:            
88:            void PMD_Initialize(void)
89:            {
90:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; 
91:                PMD0 = 0x00;
13242  0E00     MOVLW 0x0
13244  0100     MOVLB 0x0
13246  6F60     MOVWF PMD0, BANKED
92:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; SMT1MD SMT1 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
93:                PMD1 = 0x00;
13248  0E00     MOVLW 0x0
1324A  6F61     MOVWF PMD1, BANKED
94:                // ZCDMD ZCD enabled; ADCMD ADC enabled; ACTMD ACT enabled; CM2MD CM2 enabled; CM1MD CM1 enabled; DAC1MD DAC1 enabled; 
95:                PMD3 = 0x00;
1324C  0E00     MOVLW 0x0
1324E  6F63     MOVWF PMD3, BANKED
96:                // NCO1MD NCO1 enabled; NCO2MD NCO2 enabled; DSM1MD DSM1 enabled; CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; NCO3MD NCO3 enabled; 
97:                PMD4 = 0x00;
13250  0E00     MOVLW 0x0
13252  6F64     MOVWF PMD4, BANKED
98:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM2MD PWM2 enabled; CCP3MD CCP3 enabled; PWM1MD PWM1 enabled; PWM3MD PWM3 enabled; 
99:                PMD5 = 0x00;
13254  0E00     MOVLW 0x0
13256  6F65     MOVWF PMD5, BANKED
100:               // U5MD UART5 enabled; U4MD UART4 enabled; U3MD UART3 enabled; U2MD UART2 enabled; U1MD UART1 enabled; SPI2MD SPI2 enabled; SPI1MD SPI1 enabled; I2C1MD I2C1 enabled; 
101:               PMD6 = 0x00;
13258  0E00     MOVLW 0x0
1325A  6F66     MOVWF PMD6, BANKED
102:               // CLC5MD CLC5 enabled; CLC6MD CLC6 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC7MD CLC7 enabled; CLC8MD CLC8 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
103:               PMD7 = 0x00;
1325C  0E00     MOVLW 0x0
1325E  6F67     MOVWF PMD7, BANKED
104:               // DMA5MD DMA5 enabled; DMA6MD DMA6 enabled; DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; DMA3MD DMA3 enabled; DMA4MD DMA4 enabled; 
105:               PMD8 = 0x00;
13260  0E00     MOVLW 0x0
13262  6F68     MOVWF PMD8, BANKED
106:           }
13264  0012     RETURN 0
107:           
108:           
109:           void SystemArbiter_Initialize(void)
110:           {
111:               // This function is dependant on the PR1WAY CONFIG bit
112:               PRLOCK = 0x55;
13542  0E55     MOVLW 0x55
13544  6FB4     MOVWF PRLOCK, BANKED
113:               PRLOCK = 0xAA;
13546  0EAA     MOVLW 0xAA
13548  6FB4     MOVWF PRLOCK, BANKED
114:               PRLOCKbits.PRLOCKED = 1;
1354A  81B4     BSF PRLOCK, 0, BANKED
115:           }
1354C  0012     RETURN 0
116:           /**
117:            End of File
118:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/interrupt_manager.c  ---
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
19:                    Device            :  PIC18F47Q43
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.31 and above or later
23:                    MPLAB 	          :  MPLAB X 5.45
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                INTCON0bits.IPEN = 1;
12C6E  8AD6     BSF 0xFD6, 5, ACCESS
55:            
56:                bool state = (unsigned char)GIE;
12C70  0E00     MOVLW 0x0
12C72  BED6     BTFSC 0xFD6, 7, ACCESS
12C74  0E01     MOVLW 0x1
12C76  6E06     MOVWF 0x6, ACCESS
57:                GIE = 0;
12C78  9ED6     BCF 0xFD6, 7, ACCESS
58:                IVTLOCK = 0x55;
12C7A  0E55     MOVLW 0x55
12C7C  0104     MOVLB 0x4
12C7E  6F59     MOVWF 0x59, BANKED
59:                IVTLOCK = 0xAA;
12C80  0EAA     MOVLW 0xAA
12C82  6F59     MOVWF 0x59, BANKED
60:                IVTLOCKbits.IVTLOCKED = 0x00; // unlock IVT
12C84  9159     BCF 0x59, 0, BANKED
61:            
62:                IVTBASEU = 0;
12C86  0E00     MOVLW 0x0
12C88  6F5F     MOVWF 0x5F, BANKED
63:                IVTBASEH = 0;
12C8A  0E00     MOVLW 0x0
12C8C  6F5E     MOVWF 0x5E, BANKED
64:                IVTBASEL = 8;
12C8E  0E08     MOVLW 0x8
12C90  6F5D     MOVWF 0x5D, BANKED
65:            
66:                IVTLOCK = 0x55;
12C92  0E55     MOVLW 0x55
12C94  6F59     MOVWF 0x59, BANKED
67:                IVTLOCK = 0xAA;
12C96  0EAA     MOVLW 0xAA
12C98  6F59     MOVWF 0x59, BANKED
68:                IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
12C9A  8159     BSF 0x59, 0, BANKED
69:            
70:                GIE = state;
12C9C  B006     BTFSC 0x6, 0, ACCESS
12C9E  D002     BRA 0x2CA4
12CA0  9ED6     BCF 0xFD6, 7, ACCESS
12CA2  D001     BRA 0x2CA6
12CA4  8ED6     BSF 0xFD6, 7, ACCESS
71:                // Assign peripheral interrupt priority vectors
72:                IPR6bits.DMA2DCNTIP = 1;
12CA6  0103     MOVLB 0x3
12CA8  8B68     BSF PMD8, 5, BANKED
73:                IPR2bits.DMA1SCNTIP = 1;
12CAA  8964     BSF PMD4, 4, BANKED
74:                IPR8bits.U2TXIP = 1;
12CAC  836A     BSF MD1CON0, 1, BANKED
75:                IPR8bits.U2RXIP = 1;
12CAE  816A     BSF MD1CON0, 0, BANKED
76:                IPR4bits.U1TXIP = 1;
12CB0  8366     BSF PMD6, 1, BANKED
77:                IPR4bits.U1RXIP = 1;
12CB2  8166     BSF PMD6, 0, BANKED
78:                IPR15bits.TMR6IP = 1;
12CB4  8771     BSF CM1CON1, 3, BANKED
79:                IPR8bits.TMR5IP = 1;
12CB6  896A     BSF MD1CON0, 4, BANKED
80:            }
12CB8  0012     RETURN 0
81:            
82:            void __interrupt(irq(default),base(8)) Default_ISR()
13588  0011     RETFIE 1
83:            {
84:            }
130C4  98B6     BCF 0xFB6, 4, ACCESS
85:            
86:            /**
87:             End of File
88:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/dma2.c  ----------------
1:             /**
2:               DMA2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma2.h"
53:            
54:            void (*DMA2_DCNTI_InterruptHandler)(void);
55:            
56:            /**
57:              Section: DMA2 APIs
58:            */
59:            
60:            void DMA2_Initialize(void)
61:            {
62:                //DMA Instance Selection : 0x01
63:                DMASELECT = 0x01;
12A76  0E01     MOVLW 0x1
12A78  0100     MOVLB 0x0
12A7A  6FE8     MOVWF DMASELECT, BANKED
64:                //Source Address : &SPI1RXB
65:                DMAnSSA = &SPI1RXB;
12A7C  0E80     MOVLW 0x80
12A7E  6FF9     MOVWF DMAnSSA, BANKED
12A80  0E00     MOVLW 0x0
12A82  6FFA     MOVWF DMAnSSAH, BANKED
12A84  0E00     MOVLW 0x0
12A86  6FFB     MOVWF DMAnSSAU, BANKED
66:                //Destination Address : &spidummy
67:                DMAnDSA= &spidummy;
12A88  0E05     MOVLW 0x5
12A8A  6FF1     MOVWF DMAnDSAH, BANKED
12A8C  0EED     MOVLW 0xED
12A8E  6FF0     MOVWF DMAnDSA, BANKED
68:                //DMODE unchanged; DSTP not cleared; SMR SFR; SMODE unchanged; SSTP not cleared; 
69:                DMAnCON1 = 0x00;
12A90  0E00     MOVLW 0x0
12A92  6FFD     MOVWF DMAnCON1, BANKED
70:                //Source Message Size : 1
71:                DMAnSSZ = 1;
12A94  0E00     MOVLW 0x0
12A96  6FF8     MOVWF DMAnSSZH, BANKED
12A98  0E01     MOVLW 0x1
12A9A  6FF7     MOVWF DMAnSSZ, BANKED
72:                //Destination Message Size : 1
73:                DMAnDSZ = 1;
12A9C  0E00     MOVLW 0x0
12A9E  6FEF     MOVWF DMAnDSZH, BANKED
12AA0  0E01     MOVLW 0x1
12AA2  6FEE     MOVWF DMAnDSZ, BANKED
74:                //Start Trigger : SIRQ SPI1RX; 
75:                DMAnSIRQ = 0x18;
12AA4  0E18     MOVLW 0x18
12AA6  6FFF     MOVWF DMAnSIRQ, BANKED
76:                //Abort Trigger : AIRQ None; 
77:                DMAnAIRQ = 0x00;
12AA8  0E00     MOVLW 0x0
12AAA  6FFE     MOVWF DMAnAIRQ, BANKED
78:            	
79:                // Clear Destination Count Interrupt Flag bit
80:                PIR6bits.DMA2DCNTIF = 0; 
12AAC  9AB4     BCF 0xFB4, 5, ACCESS
81:                // Clear Source Count Interrupt Flag bit
82:                PIR6bits.DMA2SCNTIF = 0; 
12AAE  98B4     BCF 0xFB4, 4, ACCESS
83:                // Clear Abort Interrupt Flag bit
84:                PIR6bits.DMA2AIF = 0; 
12AB0  9EB4     BCF 0xFB4, 7, ACCESS
85:                // Clear Overrun Interrupt Flag bit
86:                PIR6bits.DMA2ORIF =0; 
12AB2  9CB4     BCF 0xFB4, 6, ACCESS
87:                
88:                PIE6bits.DMA2DCNTIE = 1;
12AB4  8AA4     BSF 0xFA4, 5, ACCESS
89:            	DMA2_SetDCNTIInterruptHandler(DMA2_DefaultInterruptHandler);
12AB6  0E96     MOVLW 0x96
12AB8  6E06     MOVWF 0x6, ACCESS
12ABA  0E35     MOVLW 0x35
12ABC  6E07     MOVWF 0x7, ACCESS
12ABE  0E01     MOVLW 0x1
12AC0  6E08     MOVWF 0x8, ACCESS
12AC2  EC93     CALL 0x13526, 0
12AC4  F09A     NOP
90:                PIE6bits.DMA2SCNTIE = 0;
12AC6  98A4     BCF 0xFA4, 4, ACCESS
91:                PIE6bits.DMA2AIE = 0;
12AC8  9EA4     BCF 0xFA4, 7, ACCESS
92:                PIE6bits.DMA2ORIE = 0;
12ACA  9CA4     BCF 0xFA4, 6, ACCESS
93:            	
94:                //EN enabled; SIRQEN enabled; DGO not in progress; AIRQEN disabled; 
95:                DMAnCON0 = 0xC0;
12ACC  0EC0     MOVLW 0xC0
12ACE  6FFC     MOVWF DMAnCON0, BANKED
96:            	
97:            }
12AD0  0012     RETURN 0
98:            
99:            void DMA2_SelectSourceRegion(uint8_t region)
100:           {
101:               DMASELECT = 0x01;
102:           	DMAnCON1bits.SMR  = region;
103:           }
104:           
105:           void DMA2_SetSourceAddress(uint24_t address)
106:           {
107:               DMASELECT = 0x01;
108:           	DMAnSSA = address;
109:           }
110:           
111:           void DMA2_SetDestinationAddress(uint16_t address)
112:           {
113:               DMASELECT = 0x01;
114:           	DMAnDSA = address;
115:           }
116:           
117:           void DMA2_SetSourceSize(uint16_t size)
118:           {
119:               DMASELECT = 0x01;
120:           	DMAnSSZ= size;
121:           }
122:           
123:           void DMA2_SetDestinationSize(uint16_t size)
124:           {                     
125:               DMASELECT = 0x01;
126:           	DMAnDSZ= size;
127:           }
128:           
129:           uint24_t DMA2_GetSourcePointer(void)
130:           {
131:               DMASELECT = 0x01;
132:           	return DMAnSPTR;
133:           }
134:           
135:           uint16_t DMA2_GetDestinationPointer(void)
136:           {
137:               DMASELECT = 0x01;
138:           	return DMAnDPTR;
139:           }
140:           
141:           void DMA2_SetStartTrigger(uint8_t sirq)
142:           {
143:               DMASELECT = 0x01;
144:           	DMAnSIRQ = sirq;
145:           }
146:           
147:           void DMA2_SetAbortTrigger(uint8_t airq)
148:           {
149:               DMASELECT = 0x01;
150:           	DMAnAIRQ = airq;
151:           }
152:           
153:           void DMA2_StartTransfer(void)
154:           {
155:               DMASELECT = 0x01;
156:           	DMAnCON0bits.DGO = 1;
157:           }
158:           
159:           void DMA2_StartTransferWithTrigger(void)
160:           {
161:               DMASELECT = 0x01;
162:           	DMAnCON0bits.SIRQEN = 1;
163:           }
164:           
165:           void DMA2_StopTransfer(void)
166:           {
167:               DMASELECT = 0x01;
1354E  0E01     MOVLW 0x1
13550  0100     MOVLB 0x0
13552  6FE8     MOVWF DMASELECT, BANKED
168:           	DMAnCON0bits.SIRQEN = 0; 
13554  9DFC     BCF DMAnCON0, 6, BANKED
169:           	DMAnCON0bits.DGO = 0;
13556  9BFC     BCF DMAnCON0, 5, BANKED
170:           }
13558  0012     RETURN 0
13588  0011     RETFIE 1
171:           
172:           void DMA2_SetDMAPriority(uint8_t priority)
173:           {
174:               // This function is dependant on the PR1WAY CONFIG bit
175:           	PRLOCK = 0x55;
176:           	PRLOCK = 0xAA;
177:           	PRLOCKbits.PRLOCKED = 0;
178:           	DMA2PR = priority;
179:           	PRLOCK = 0x55;
180:           	PRLOCK = 0xAA;
181:           	PRLOCKbits.PRLOCKED = 1;
182:           }
183:           
184:           void __interrupt(irq(IRQ_DMA2DCNT),base(8)) DMA2_DMADCNTI_ISR()
185:           {
186:               // Clear the source count interrupt flag
187:               PIR6bits.DMA2DCNTIF = 0;
1321C  9AB4     BCF 0xFB4, 5, ACCESS
188:           
189:               if (DMA2_DCNTI_InterruptHandler)
1321E  0105     MOVLB 0x5
13220  51AC     MOVF ACTCON, W, BANKED
13222  11AD     IORWF OSCCON1, W, BANKED
13224  11AE     IORWF OSCCON2, W, BANKED
13226  B4D8     BTFSC 0xFD8, 2, ACCESS
13228  0011     RETFIE 1
190:                       DMA2_DCNTI_InterruptHandler();
1322A  D801     RCALL 0x322E
1322C  0011     RETFIE 1
1322E  0005     PUSH
13230  6EFA     MOVWF 0xFFA, ACCESS
13232  51AC     MOVF ACTCON, W, BANKED
13234  6EFD     MOVWF 0xFFD, ACCESS
13236  51AD     MOVF OSCCON1, W, BANKED
13238  6EFE     MOVWF 0xFFE, ACCESS
1323A  51AE     MOVF OSCCON2, W, BANKED
1323C  6EFF     MOVWF 0xFFF, ACCESS
1323E  50FA     MOVF 0xFFA, W, ACCESS
13240  0012     RETURN 0
191:           }
192:           
193:           void DMA2_SetDCNTIInterruptHandler(void (* InterruptHandler)(void))
194:           {
195:           	 DMA2_DCNTI_InterruptHandler = InterruptHandler;
13526  C506     MOVFF InterruptHandler, DMA2_DCNTI_InterruptHandler
13528  F5AC     NOP
1352A  C507     MOVFF c, 0x5AD
1352C  F5AD     NOP
1352E  C508     MOVFF blockSize, 0x5AE
13530  F5AE     NOP
196:           }
13532  0012     RETURN 0
197:           
198:           void DMA2_DefaultInterruptHandler(void){
199:               // add your DMA2 interrupt custom code
200:               // or set custom function using DMA2_SetSCNTIInterruptHandler() /DMA2_SetDCNTIInterruptHandler() /DMA2_SetAIInterruptHandler() /DMA2_SetORIInterruptHandler()
201:           }
13596  0012     RETURN 0
202:           /**
203:            End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/dma1.c  ----------------
1:             /**
2:               DMA1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for DMA1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma1.h"
53:            
54:            void (*DMA1_SCNTI_InterruptHandler)(void);
55:            
56:            /**
57:              Section: DMA1 APIs
58:            */
59:            
60:            void DMA1_Initialize(void)
61:            {
62:                //DMA Instance Selection : 0x00
63:                DMASELECT = 0x00;
12AD2  0E00     MOVLW 0x0
12AD4  6FE8     MOVWF DMASELECT, BANKED
64:                //Source Address : spibuffer
65:                DMAnSSA = &spibuffer;
12AD6  0E00     MOVLW 0x0
12AD8  6FF9     MOVWF DMAnSSA, BANKED
12ADA  0E09     MOVLW 0x9
12ADC  6FFA     MOVWF DMAnSSAH, BANKED
12ADE  0E00     MOVLW 0x0
12AE0  6FFB     MOVWF DMAnSSAU, BANKED
66:                //Destination Address : &SPI1TXB
67:                DMAnDSA = &SPI1TXB;
12AE2  0E00     MOVLW 0x0
12AE4  6FF1     MOVWF DMAnDSAH, BANKED
12AE6  0E81     MOVLW 0x81
12AE8  6FF0     MOVWF DMAnDSA, BANKED
68:                //DMODE unchanged; DSTP not cleared; SMR GPR; SMODE incremented; SSTP not cleared; 
69:                DMAnCON1 = 0x02;
12AEA  0E02     MOVLW 0x2
12AEC  6FFD     MOVWF DMAnCON1, BANKED
70:                //Source Message Size : 1
71:                DMAnSSZ = 1;
12AEE  0E00     MOVLW 0x0
12AF0  6FF8     MOVWF DMAnSSZH, BANKED
12AF2  0E01     MOVLW 0x1
12AF4  6FF7     MOVWF DMAnSSZ, BANKED
72:                //Destination Message Size : 1
73:                DMAnDSZ = 1;
12AF6  0E00     MOVLW 0x0
12AF8  6FEF     MOVWF DMAnDSZH, BANKED
12AFA  0E01     MOVLW 0x1
12AFC  6FEE     MOVWF DMAnDSZ, BANKED
74:                //Start Trigger : SIRQ None; 
75:                DMAnSIRQ = 0x00;
12AFE  0E00     MOVLW 0x0
12B00  6FFF     MOVWF DMAnSIRQ, BANKED
76:                //Abort Trigger : AIRQ None; 
77:                DMAnAIRQ = 0x00;
12B02  0E00     MOVLW 0x0
12B04  6FFE     MOVWF DMAnAIRQ, BANKED
78:            	
79:                // Clear Destination Count Interrupt Flag bit
80:                PIR2bits.DMA1DCNTIF = 0; 
12B06  9AB0     BCF 0xFB0, 5, ACCESS
81:                // Clear Source Count Interrupt Flag bit
82:                PIR2bits.DMA1SCNTIF = 0; 
12B08  98B0     BCF 0xFB0, 4, ACCESS
83:                // Clear Abort Interrupt Flag bit
84:                PIR2bits.DMA1AIF = 0; 
12B0A  9EB0     BCF 0xFB0, 7, ACCESS
85:                // Clear Overrun Interrupt Flag bit
86:                PIR2bits.DMA1ORIF =0; 
12B0C  9CB0     BCF 0xFB0, 6, ACCESS
87:                
88:                PIE2bits.DMA1DCNTIE = 0;
12B0E  9AA0     BCF 0xFA0, 5, ACCESS
89:                PIE2bits.DMA1SCNTIE = 1; 
12B10  88A0     BSF 0xFA0, 4, ACCESS
90:            	DMA1_SetSCNTIInterruptHandler(DMA1_DefaultInterruptHandler);
12B12  0E94     MOVLW 0x94
12B14  6E06     MOVWF 0x6, ACCESS
12B16  0E35     MOVLW 0x35
12B18  6E07     MOVWF 0x7, ACCESS
12B1A  0E01     MOVLW 0x1
12B1C  6E08     MOVWF 0x8, ACCESS
12B1E  EC9A     CALL 0x13534, 0
12B20  F09A     NOP
91:                PIE2bits.DMA1AIE = 0;
12B22  9EA0     BCF 0xFA0, 7, ACCESS
92:                PIE2bits.DMA1ORIE = 0;
12B24  9CA0     BCF 0xFA0, 6, ACCESS
93:            	
94:                //EN enabled; SIRQEN disabled; DGO not in progress; AIRQEN disabled; 
95:                DMAnCON0 = 0x80;
12B26  0E80     MOVLW 0x80
12B28  6FFC     MOVWF DMAnCON0, BANKED
96:            	
97:            }
12B2A  0012     RETURN 0
98:            
99:            void DMA1_SelectSourceRegion(uint8_t region)
100:           {
101:               DMASELECT = 0x00;
102:           	DMAnCON1bits.SMR  = region;
103:           }
104:           
105:           void DMA1_SetSourceAddress(uint24_t address)
106:           {
107:               DMASELECT = 0x00;
108:           	DMAnSSA = address;
109:           }
110:           
111:           void DMA1_SetDestinationAddress(uint16_t address)
112:           {
113:               DMASELECT = 0x00;
114:           	DMAnDSA = address;
115:           }
116:           
117:           void DMA1_SetSourceSize(uint16_t size)
118:           {
119:               DMASELECT = 0x00;
120:           	DMAnSSZ= size;
121:           }
122:           
123:           void DMA1_SetDestinationSize(uint16_t size)
124:           {                     
125:               DMASELECT = 0x00;
126:           	DMAnDSZ= size;
127:           }
128:           
129:           uint24_t DMA1_GetSourcePointer(void)
130:           {
131:               DMASELECT = 0x00;
132:           	return DMAnSPTR;
133:           }
134:           
135:           uint16_t DMA1_GetDestinationPointer(void)
136:           {
137:               DMASELECT = 0x00;
138:           	return DMAnDPTR;
139:           }
140:           
141:           void DMA1_SetStartTrigger(uint8_t sirq)
142:           {
143:               DMASELECT = 0x00;
144:           	DMAnSIRQ = sirq;
145:           }
146:           
147:           void DMA1_SetAbortTrigger(uint8_t airq)
148:           {
149:               DMASELECT = 0x00;
150:           	DMAnAIRQ = airq;
151:           }
152:           
153:           void DMA1_StartTransfer(void)
154:           {
155:               DMASELECT = 0x00;
156:           	DMAnCON0bits.DGO = 1;
157:           }
158:           
159:           void DMA1_StartTransferWithTrigger(void)
160:           {
161:               DMASELECT = 0x00;
162:           	DMAnCON0bits.SIRQEN = 1;
163:           }
164:           
165:           void DMA1_StopTransfer(void)
166:           {
167:               DMASELECT = 0x00;
168:           	DMAnCON0bits.SIRQEN = 0; 
169:           	DMAnCON0bits.DGO = 0;
170:           }
171:           
172:           void DMA1_SetDMAPriority(uint8_t priority)
173:           {
174:               // This function is dependant on the PR1WAY CONFIG bit
175:           	PRLOCK = 0x55;
176:           	PRLOCK = 0xAA;
177:           	PRLOCKbits.PRLOCKED = 0;
178:           	DMA1PR = priority;
179:           	PRLOCK = 0x55;
180:           	PRLOCK = 0xAA;
181:           	PRLOCKbits.PRLOCKED = 1;
182:           }
183:           
184:           void __interrupt(irq(IRQ_DMA1SCNT),base(8)) DMA1_DMASCNTI_ISR()
185:           {
186:               // Clear the source count interrupt flag
187:               PIR2bits.DMA1SCNTIF = 0;
131F4  98B0     BCF 0xFB0, 4, ACCESS
188:           
189:               if (DMA1_SCNTI_InterruptHandler)
131F6  0105     MOVLB 0x5
131F8  51AF     MOVF OSCCON3, W, BANKED
131FA  11B0     IORWF OSCTUNE, W, BANKED
131FC  11B1     IORWF OSCFRQ, W, BANKED
131FE  B4D8     BTFSC 0xFD8, 2, ACCESS
13200  0011     RETFIE 1
190:                       DMA1_SCNTI_InterruptHandler();
13202  D801     RCALL 0x3206
13204  0011     RETFIE 1
13206  0005     PUSH
13208  6EFA     MOVWF 0xFFA, ACCESS
1320A  51AF     MOVF OSCCON3, W, BANKED
1320C  6EFD     MOVWF 0xFFD, ACCESS
1320E  51B0     MOVF OSCTUNE, W, BANKED
13210  6EFE     MOVWF 0xFFE, ACCESS
13212  51B1     MOVF OSCFRQ, W, BANKED
13214  6EFF     MOVWF 0xFFF, ACCESS
13216  50FA     MOVF 0xFFA, W, ACCESS
13218  0012     RETURN 0
191:           }
192:           
193:           void DMA1_SetSCNTIInterruptHandler(void (* InterruptHandler)(void))
194:           {
195:           	 DMA1_SCNTI_InterruptHandler = InterruptHandler;
13534  C506     MOVFF InterruptHandler, DMA1_SCNTI_InterruptHandler
13536  F5AF     NOP
13538  C507     MOVFF c, 0x5B0
1353A  F5B0     NOP
1353C  C508     MOVFF blockSize, 0x5B1
1353E  F5B1     NOP
196:           }
13540  0012     RETURN 0
197:           
198:           void DMA1_DefaultInterruptHandler(void){
13594  0012     RETURN 0
199:               // add your DMA1 interrupt custom code
200:               // or set custom function using DMA1_SetSCNTIInterruptHandler() /DMA1_SetDCNTIInterruptHandler() /DMA1_SetAIInterruptHandler() /DMA1_SetORIInterruptHandler()
201:           }
1321C  9AB4     BCF 0xFB4, 5, ACCESS
202:           /**
203:            End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/mcc_generated_files/clkref.c  --------------
1:             /**
2:               CLKREF Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 clkref.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CLKREF driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for CLKREF.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC18F47Q43
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "clkref.h"
53:            
54:            /**
55:              Section: CLKREF APIs
56:            */
57:            
58:            void CLKREF_Initialize(void)
59:            {
60:                // CLK FOSC; 
61:                CLKRCLK = 0x00;
1355A  0E00     MOVLW 0x0
1355C  6F3A     MOVWF CLKRCLK, BANKED
62:                // DC 50% Duty Cycle; DIV BaseClock/64; CLKREN enabled; 
63:                CLKRCON = 0x96;
1355E  0E96     MOVLW 0x96
13560  6F39     MOVWF CLKRCON, BANKED
64:            }
13562  0012     RETURN 0
65:            /**
66:             End of File
67:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/main.c  ------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:            	Device            :  PIC18F47Q43
18:            	Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries.
23:            
24:                Subject to your compliance with these terms, you may use Microchip software and any
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party
26:                license terms applicable to your use of third party software (including open source software) that
27:                may accompany Microchip software.
28:            
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS
32:                FOR A PARTICULAR PURPOSE.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
41:                SOFTWARE.
42:             */
43:            #pragma warning disable 520
44:            #pragma warning disable 1498
45:            
46:            #include <stdlib.h>
47:            #include <stdbool.h>
48:            #include "mcc_generated_files/mcc.h"
49:            #include "mcc_generated_files/tmr5.h"
50:            #include "qconfig.h"
51:            #include "vtouch.h"
52:            #include "vtouch_build.h"
53:            #include "timers.h"
54:            #include "eadog.h"
55:            
56:            /*
57:             * Viision terminal code
58:             * This program converts the rs-232 output from a ELO controller type LCD monitor
59:             * to a format that can be used with the Varian Viision 80 Implanter with ADYIN CRT monitor
60:             * The LCD touchscreen will be  programmed to the correct touch response and configuration at program start
61:             *
62:             * USART1 is the host comm port
63:             * USART2 is the touch-screen comm port
64:             *
65:             * usart1	connected to implant host computer at 9600
66:             * usart2       connected to touchscreen  serial post at 9600
67:             *
68:             * V4.00+	convert to 47Q43 board and XC8
69:             *
70:             *
71:             *
72:             * HOST RS-232  5-1     uC port1
73:             * Female       2-2-tx
74:             *              3-3-rx
75:             * LCD  RS-232  5-1     uC port2
76:             * Male         2-3-rx
77:             *              3-2-tx
78:             *
79:             * HFBR-0501Z light link converter for front screen touch interface
80:             *
81:             */
82:            
83:            /* E220/E500 terminal code
84:             * This program converts the rs-232 output from a ELO touch-screen controller
85:             * to a format that can be used with the Varian E220/E500 Implanter
86:             * The touch controller must be first programmed
87:             * USART1 is the host comm port
88:             * USART2 is the touch-screen comm port
89:             *
90:             * PRORTA, PORTE Camera, aux switching with touch in target box
91:             * LED2			run flasher led onboard.
92:             * status LCD 4x20.
93:             *
94:             * Microchip Inc , Aug 2009,2018,2020
95:             * Gresham, Oregon
96:             *
97:             *
98:             * This application is designed for use with the
99:             * 47Q43 touch_board
100:            *
101:            * HOST RS-232  5-1     uC port1
102:            * Female       2-2-tx
103:            *              3-3-rx
104:            * LCD  RS-232  5-1     uC port2
105:            * Male         2-3-rx
106:            *              3-2-tx
107:            *
108:            * VGA converter box relay
109:            * Omron
110:            * G6k-2P bottom view
111:            * Pin		8 - gnd, wire tag 0/stripe,	RELAY output	pin 10 on connector SIG COMMON SV6
112:            * Pin		1 + 5vdc signal,		Power PIN	pin 7-8 connector for RD6 or RD7 PORT SIGNAL SV6
113:            */
114:           
115:           //#define DEBUG_CAM
116:           
117:           typedef struct reporttype {
118:           	uint8_t headder, status;
119:           	uint16_t x_cord, y_cord, z_cord;
120:           	uint8_t checksum;
121:           	uint8_t tohost;
122:           } reporttype;
123:           
124:           typedef struct statustype {
125:           	int32_t alive_led, touch_count, resync_count, rawint_count, status_count, lcd_count;
126:           	uint8_t host_write : 1;
127:           	uint8_t scrn_write : 1;
128:           	uint8_t do_cap : 1;
129:           	uint8_t comm_check, init_check, touch_good, cam_time;
130:           	uint16_t restart_delay;
131:           } statustype;
132:           
133:           typedef struct disp_state_t {
134:           	bool CATCH, TOUCH, UNTOUCH, LCD_OK,
135:           	SCREEN_INIT, SCREEN_COMM,
136:           	CATCH46, CATCH37, TSTATUS,
137:           	DATA1, DATA2, CAM;
138:           	uint16_t c_idx, ts_type;
139:           	int16_t speedup;
140:           } disp_state_t;
141:           
142:           /*
143:            * Old monitors
144:            * E779866	SecureTouch  use DELL_E215546 setting
145:            * E215546	IntelliTouch use DELL_E215546 setting
146:            * NEW REPLACEMENT MONITORS 1990L 1991L
147:            * E328700	Black with HDMI, IntelliTouch use DELL_E215546 setting
148:            * E328497	IntelliTouch use DELL_E215546 setting
149:            * E483757	new remote OSD
150:            * E005277	power brick
151:            *
152:            * TS_TYPE	0 Original CRT type screens
153:            *		1 OEM LCD screens
154:            *
155:            * SV4 jumpers
156:            * 1-2 off default: DELL_E215546
157:            * 3-4 off default: E220/E500
158:            * 5-6 off default: OEM CRT
159:            *
160:            */
161:           
162:           enum oem_type {
163:           	OEM_CRT = 0, OEM_LCD = 1
164:           };
165:           
166:           disp_state_t S = {
167:           	.ts_type = OEM_CRT,
168:           	.TSTATUS = true,
169:           	.SCREEN_COMM = false,
170:           	.SCREEN_INIT = false,
171:           };
172:           
173:           enum screen_type_t {
174:           	DELL_E215546, OTHER_SCREEN
175:           };
176:           
177:           enum emulat_type_t {
178:           	VIISION, E220, OTHER_MECH
179:           };
180:           
181:           enum screen_type_t screen_type;
182:           enum emulat_type_t emulat_type;
183:           
184:           int32_t j = 0;
185:           float xs = X_SCALE, ys = Y_SCALE, xs_ss = X_SCALE_SS, ys_ss = Y_SCALE_SS; // defaults
186:           
187:           uint8_t elobuf[BUF_SIZE], elobuf_out[BUF_SIZE_V80], elobuf_in[BUF_SIZE_V80], xl = X_LOGICAL, yl = Y_LOGICAL;
188:           uint8_t ssbuf[BUF_SIZE];
189:           
190:           struct reporttype ssreport;
191:           struct statustype status = {
192:           	.do_cap = false,
193:           };
194:           
195:           const uint8_t elocodes_s_v[] = {
196:           	0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x3c, 0x2b, 0x44, 0x25, 0x29, 0x44, 0x3d, 0x2a, 0x37
197:           }; // initial carrol-touch config codes, tracking, add end point modifier, get frame size report
198:           
199:           const uint8_t elocodes[ELO_SEQ_V80][ELO_SIZE_I_V80] = {// elo 2210/2216 program codes
200:           	'U', 'M', 0x00, 0x87, 0x40, '0', '0', '0', '0', '0', // initial touch,stream Point,untouch,Z-axis,no scaling, tracking
201:           	'U', 'S', 'X', 0x00, 0x0ff, 0x00, 0x01, '0', '0', '0', // scale x: X,Y,Z scaling Not Used
202:           	'U', 'S', 'Y', 0x00, 0x0ff, 0x00, 0x01, '0', '0', '0', // scale y
203:           	'U', 'S', 'Z', 0x00, 0x01, 0x00, 0x0f, '0', '0', '0', // scale z
204:           	'U', 'B', 5, 20, 0x00, 0x00, 0x0f, '0', '0', '0', // packet delays to match old terminal
205:           	'U', 'E', '1', '6', '0', '0', '0', '0', '0', '0', // emulation E281A-4002 Binary (Z=1-255 on touch, Z=0 on untouch)
206:           	'U', 'N', '1', '7', '0', '0', '0', '0', '0', '0', // nvram save
207:           	'U', 'R', '2', '0', '0', '0', '0', '0', '0', '0', // nvram reset
208:           }; // initial intelli-touch codes
209:           
210:           const uint8_t elocodes_m_e[] = {// 5 char, soft-reset,touch scanning off, report transfer on, (0x26) tracking mode, report transfer on, clear touch buffer, touch scanning on
211:           	0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x3c, 0x2b, 0x44, 0x26, 0x44, 0x3d, 0x2a
212:           }; // initial touch config codes, tracking
213:           const uint8_t elocodes_s_e[] = {// same as above ex (0x25) enter point mode
214:           	0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x3c, 0x2b, 0x44, 0x25, 0x44, 0x3d, 0x2a
215:           }; // initial touch config codes, single
216:           
217:           
218:           // SmartSet codes 0 command, 1 status, 2 low byte, 3 high byte, etc ...
219:           const uint8_t elocodes_e0[] = {
220:           	'U', 'B', 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // smartset timing and spacing setup
221:           };
222:           const uint8_t elocodes_e1[] = {
223:           	'U', 'E', '1', '4', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
224:           };
225:           const uint8_t elocodes_e2[] = {
226:           	'U', 'N', '1', '7', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
227:           };
228:           const uint8_t elocodes_e3[] = {
229:           	'U', 'R', '2', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // reset nvram and reboot
230:           };
231:           const uint8_t elocodes_e4[] = {
232:           	'U', 'S', 'Y', 0x01, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
233:           };
234:           const uint8_t elocodes_e5[] = {
235:           	'U', 'i', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
236:           };
237:           const uint8_t elocodes_e6[] = {
238:           	'U', 'M', 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
239:           };
240:           const uint8_t elocodes_e7[] = {// dummy packet
241:           	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
242:           };
243:           
244:           uint16_t touch_corner1 = 0;
245:           bool touch_corner_timed = false;
246:           
247:           uint8_t idx = 0, id_data[8] = {0xff, 0xff};
248:           volatile uint16_t tickCount[TMR_COUNT];
249:           char buffer[256];
250:           
251:           void putc1(uint8_t);
252:           void putc2(uint8_t);
253:           void rxtx_handler(void);
254:           void led_flash(void);
255:           bool check_id(uint8_t);
256:           void setup_lcd_smartset_other(void);
257:           void setup_lcd_smartset_e220(void);
258:           void setup_lcd_smartset_v80(void);
259:           
260:           void touch_cam(void)
261:           {
262:           	//	check for corner presses
263:           	if (S.CATCH) {
1288C  0106     MOVLB 0x6
1288E  51B4     MOVF PRLOCK, W, BANKED
12890  B4D8     BTFSC 0xFD8, 2, ACCESS
12892  D015     BRA 0x28BE
264:           		if ((elobuf[0] <= (uint8_t) 0x06) && (elobuf[1] >= (uint8_t) 0x5a)) { // check for left bottom corner
12894  0E07     MOVLW 0x7
12896  6100     CPFSLT data, BANKED
12898  D008     BRA 0x28AA
1289A  0E59     MOVLW 0x59
1289C  6501     CPFSGT 0x1, BANKED
1289E  D005     BRA 0x28AA
265:           			touch_corner1++;
128A0  0105     MOVLB 0x5
128A2  4BD5     INFSNZ CLCSELECT, F, BANKED
128A4  2BD6     INCF CLCnCON, F, BANKED
266:           			touch_corner_timed = true;
128A6  0E01     MOVLW 0x1
128A8  6FE1     MOVWF 0xE1, BANKED
267:           		};
268:           
269:           		if ((elobuf[0] >= (uint8_t) 0x72) && (elobuf[1] >= (uint8_t) 0x5a)) { // check for right bottom corner
128AA  0E71     MOVLW 0x71
128AC  0106     MOVLB 0x6
128AE  6500     CPFSGT data, BANKED
128B0  D006     BRA 0x28BE
128B2  0E59     MOVLW 0x59
128B4  6501     CPFSGT 0x1, BANKED
128B6  D003     BRA 0x28BE
270:           			touch_corner1++;
128B8  0105     MOVLB 0x5
128BA  4BD5     INFSNZ CLCSELECT, F, BANKED
128BC  2BD6     INCF CLCnCON, F, BANKED
271:           		};
272:           	};
273:           
274:           
275:           	if (touch_corner1 >= MAX_CAM_TOUCH) { // we have several corner presses
128BE  0105     MOVLB 0x5
128C0  51D6     MOVF CLCnCON, W, BANKED
128C2  E104     BNZ 0x28CC
128C4  0E05     MOVLW 0x5
128C6  5DD5     SUBWF CLCSELECT, W, BANKED
128C8  A0D8     BTFSS 0xFD8, 0, ACCESS
128CA  0012     RETURN 0
276:           		S.CAM = true;
128CC  0E01     MOVLW 0x1
128CE  0106     MOVLB 0x6
128D0  6FBF     MOVWF ISRPR, BANKED
277:           		status.cam_time = 0;
128D2  0E00     MOVLW 0x0
128D4  6F5C     MOVWF 0x5C, BANKED
278:           		touch_corner1 = 0;
128D6  0E00     MOVLW 0x0
128D8  0105     MOVLB 0x5
128DA  6FD6     MOVWF CLCnCON, BANKED
128DC  0E00     MOVLW 0x0
128DE  6FD5     MOVWF CLCSELECT, BANKED
279:           		CAM_RELAY_AUX = 1; // set secondary VGA/CAM switch
128E0  8CC1     BSF 0xFC1, 6, ACCESS
280:           		CAM_RELAY = 1; // set primary VGA/CAM switch
128E2  8EC1     BSF 0xFC1, 7, ACCESS
281:           		elobuf[0] = 1;
128E4  0E01     MOVLW 0x1
128E6  0106     MOVLB 0x6
128E8  6F00     MOVWF data, BANKED
282:           		elobuf[1] = 1;
128EA  0E01     MOVLW 0x1
128EC  6F01     MOVWF 0x1, BANKED
283:           	};
284:           }
128EE  0012     RETURN 0
285:           
286:           void elocmdout(uint8_t * elostr)
287:           {
288:           	putc2(elostr[0]);
289:           
290:           	BLED_Toggle(); // flash external led
291:           	wdtdelay(30000);
292:           }
293:           
294:           void eloSScmdout(uint8_t elostr)
12FF6  6E0B     MOVWF 0xB, ACCESS
295:           {
296:           	putc2(elostr);
12FF8  500B     MOVF 0xB, W, ACCESS
12FFA  EC0E     CALL 0x1341C, 0
12FFC  F09A     NOP
297:           
298:           	BLED_Toggle(); // flash external led
12FFE  A0C2     BTFSS 0xFC2, 0, ACCESS
13000  D002     BRA 0x3006
13002  0E01     MOVLW 0x1
13004  D001     BRA 0x3008
13006  0E00     MOVLW 0x0
13008  0AFF     XORLW 0xFF
1300A  6E0A     MOVWF 0xA, ACCESS
1300C  50C2     MOVF 0xFC2, W, ACCESS
1300E  180A     XORWF 0xA, W, ACCESS
13010  0BFE     ANDLW 0xFE
13012  180A     XORWF 0xA, W, ACCESS
13014  6EC2     MOVWF 0xFC2, ACCESS
299:           	wdtdelay(10000); // inter char delay
13016  0E10     MOVLW 0x10
13018  6E06     MOVWF 0x6, ACCESS
1301A  0E27     MOVLW 0x27
1301C  6E07     MOVWF 0x7, ACCESS
1301E  0E00     MOVLW 0x0
13020  6E08     MOVWF 0x8, ACCESS
13022  0E00     MOVLW 0x0
13024  6E09     MOVWF 0x9, ACCESS
13026  EC87     CALL 0x12F0E, 0
13028  F097     NOP
300:           }
1302A  0012     RETURN 0
301:           
302:           void elopacketout(const uint8_t *strptr, uint8_t strcount, bool slow)
303:           {
304:           	uint8_t i, c, sum = 0;
12688  0E00     MOVLW 0x0
1268A  6E12     MOVWF 0x12, ACCESS
305:           
306:           	for (i = 0; i < strcount; i++) {
1268C  0E00     MOVLW 0x0
1268E  6E14     MOVWF 0x14, ACCESS
12690  D02F     BRA 0x26F0
307:           		switch (i) {
308:           		case 0:
309:           			c = 'U';
12692  0E55     MOVLW 0x55
12694  6E13     MOVWF 0x13, ACCESS
310:           			sum = 0xAA + 'U';
12696  6812     SETF 0x12, ACCESS
311:           			break;
12698  D027     BRA 0x26E8
312:           		case 9:
313:           			c = sum;
1269A  C512     MOVFF sum, c
1269C  F513     NOP
314:           			break;
1269E  D024     BRA 0x26E8
315:           		default:
316:           			c = strptr[i];
126A0  5014     MOVF 0x14, W, ACCESS
126A2  240C     ADDWF 0xC, W, ACCESS
126A4  6E10     MOVWF 0x10, ACCESS
126A6  0E00     MOVLW 0x0
126A8  200D     ADDWFC 0xD, W, ACCESS
126AA  6E11     MOVWF 0x11, ACCESS
126AE  F440     NOP
126B0  F4F6     NOP
126B4  F444     NOP
126B6  F4F7     NOP
126B8  0E00     MOVLW 0x0
126BA  6EF8     MOVWF 0xFF8, ACCESS
126BC  0008     TBLRD*
126C0  F3D4     NOP
126C2  F513     NOP
317:           			sum += c;
126C4  5013     MOVF 0x13, W, ACCESS
126C6  2612     ADDWF 0x12, F, ACCESS
318:           			break;
126C8  D00F     BRA 0x26E8
319:           		}
126CA  5014     MOVF 0x14, W, ACCESS
126CC  6E10     MOVWF 0x10, ACCESS
126CE  6A11     CLRF 0x11, ACCESS
126D0  5011     MOVF 0x11, W, ACCESS
126D2  0A00     XORLW 0x0
126D4  A4D8     BTFSS 0xFD8, 2, ACCESS
126D6  D7E4     BRA 0x26A0
126D8  5010     MOVF 0x10, W, ACCESS
126DA  0A00     XORLW 0x0
126DC  B4D8     BTFSC 0xFD8, 2, ACCESS
126DE  D7D9     BRA 0x2692
126E0  0A09     XORLW 0x9
126E2  B4D8     BTFSC 0xFD8, 2, ACCESS
126E4  D7DA     BRA 0x269A
126E6  D7DC     BRA 0x26A0
320:           		eloSScmdout(c);
126E8  5013     MOVF 0x13, W, ACCESS
126EA  ECFB     CALL 0x12FF6, 0
126EC  F097     NOP
321:           	};
126EE  2A14     INCF 0x14, F, ACCESS
126F0  500E     MOVF 0xE, W, ACCESS
126F2  5C14     SUBWF 0x14, W, ACCESS
126F4  A0D8     BTFSS 0xFD8, 0, ACCESS
126F6  D7E9     BRA 0x26CA
322:           	if (slow) {
126F8  500F     MOVF 0xF, W, ACCESS
126FA  B4D8     BTFSC 0xFD8, 2, ACCESS
126FC  0012     RETURN 0
323:           		wdtdelay(30000);
126FE  0E30     MOVLW 0x30
12700  6E06     MOVWF 0x6, ACCESS
12702  0E75     MOVLW 0x75
12704  6E07     MOVWF 0x7, ACCESS
12706  0E00     MOVLW 0x0
12708  6E08     MOVWF 0x8, ACCESS
1270A  0E00     MOVLW 0x0
1270C  6E09     MOVWF 0x9, ACCESS
1270E  EC87     CALL 0x12F0E, 0
12710  F097     NOP
324:           	}
325:           }
12712  0012     RETURN 0
326:           
327:           void elocmdout_v80(const uint8_t * elostr)
328:           {
329:           	int16_t e;
330:           	uint8_t elo_char;
331:           	for (e = 0; e < ELO_SIZE_V80; e++) { // send buffered data
12714  0E00     MOVLW 0x0
12716  6E10     MOVWF 0x10, ACCESS
12718  0E00     MOVLW 0x0
1271A  6E0F     MOVWF 0xF, ACCESS
332:           		elo_char = elostr[e];
1271C  500F     MOVF 0xF, W, ACCESS
1271E  240A     ADDWF 0xA, W, ACCESS
12720  6E0C     MOVWF 0xC, ACCESS
12722  5010     MOVF 0x10, W, ACCESS
12724  200B     ADDWFC 0xB, W, ACCESS
12726  6E0D     MOVWF 0xD, ACCESS
1272A  F430     NOP
1272C  F4F6     NOP
12730  F434     NOP
12732  F4F7     NOP
12734  0E00     MOVLW 0x0
12736  6EF8     MOVWF 0xFF8, ACCESS
12738  0008     TBLRD*
1273C  F3D4     NOP
1273E  F50E     NOP
333:           		putc2(elo_char); // send to LCD touch
12740  500E     MOVF 0xE, W, ACCESS
12742  EC0E     CALL 0x1341C, 0
12744  F09A     NOP
334:           		BLED_Toggle(); // flash external led
12746  A0C2     BTFSS 0xFC2, 0, ACCESS
12748  D002     BRA 0x274E
1274A  0E01     MOVLW 0x1
1274C  D001     BRA 0x2750
1274E  0E00     MOVLW 0x0
12750  0AFF     XORLW 0xFF
12752  6E0C     MOVWF 0xC, ACCESS
12754  50C2     MOVF 0xFC2, W, ACCESS
12756  180C     XORWF 0xC, W, ACCESS
12758  0BFE     ANDLW 0xFE
1275A  180C     XORWF 0xC, W, ACCESS
1275C  6EC2     MOVWF 0xFC2, ACCESS
335:           		wdtdelay(10000); // inter char delay
1275E  0E10     MOVLW 0x10
12760  6E06     MOVWF 0x6, ACCESS
12762  0E27     MOVLW 0x27
12764  6E07     MOVWF 0x7, ACCESS
12766  0E00     MOVLW 0x0
12768  6E08     MOVWF 0x8, ACCESS
1276A  0E00     MOVLW 0x0
1276C  6E09     MOVWF 0x9, ACCESS
1276E  EC87     CALL 0x12F0E, 0
12770  F097     NOP
336:           	}
12772  4A0F     INFSNZ 0xF, F, ACCESS
12774  2A10     INCF 0x10, F, ACCESS
12776  BE10     BTFSC 0x10, 7, ACCESS
12778  D7D1     BRA 0x271C
1277A  5010     MOVF 0x10, W, ACCESS
1277C  E104     BNZ 0x2786
1277E  0E0E     MOVLW 0xE
12780  5C0F     SUBWF 0xF, W, ACCESS
12782  A0D8     BTFSS 0xFD8, 0, ACCESS
12784  D7CB     BRA 0x271C
337:           	wdtdelay(50000); // wait for LCD controller reset
12786  0E50     MOVLW 0x50
12788  6E06     MOVWF 0x6, ACCESS
1278A  0EC3     MOVLW 0xC3
1278C  6E07     MOVWF 0x7, ACCESS
1278E  0E00     MOVLW 0x0
12790  6E08     MOVWF 0x8, ACCESS
12792  0E00     MOVLW 0x0
12794  6E09     MOVWF 0x9, ACCESS
12796  EC87     CALL 0x12F0E, 0
12798  F097     NOP
338:           }
1279A  0012     RETURN 0
339:           
340:           bool check_id(uint8_t ts_type)
11FD2  6E51     MOVWF 0x51, ACCESS
341:           {
342:           	uint8_t i = 0;
11FD4  0E00     MOVLW 0x0
11FD6  6E52     MOVWF 0x52, ACCESS
343:           
344:           	while (UART2_DataReady) {
11FD8  D002     BRA 0x1FDE
11FDE  EC22     CALL 0x13444, 0
11FE0  F09A     NOP
11FE2  0900     IORLW 0x0
11FE4  A4D8     BTFSS 0xFD8, 2, ACCESS
11FE6  D7F9     BRA 0x1FDA
345:           		uint8_t dump;
346:           		dump = UART2_Read();
11FDA  ECCB     CALL 0x12D96, 0
11FDC  F096     NOP
347:           	} // dump data from screen COMM2
348:           
349:           	elopacketout(elocodes_e5, ELO_SEQ, 0); // query touch screen ID
11FE8  0E7F     MOVLW 0x7F
11FEA  6E0C     MOVWF 0xC, ACCESS
11FEC  0EFF     MOVLW 0xFF
11FEE  6E0D     MOVWF 0xD, ACCESS
11FF0  0E0A     MOVLW 0xA
11FF2  6E0E     MOVWF 0xE, ACCESS
11FF4  0E00     MOVLW 0x0
11FF6  6E0F     MOVWF 0xF, ACCESS
11FF8  EC44     CALL 0x12688, 0
11FFA  F093     NOP
350:           	wdtdelay(70000); // wait for LCD touch controller ID response
11FFC  0E70     MOVLW 0x70
11FFE  6E06     MOVWF 0x6, ACCESS
12000  0E11     MOVLW 0x11
12002  6E07     MOVWF 0x7, ACCESS
12004  0E01     MOVLW 0x1
12006  6E08     MOVWF 0x8, ACCESS
12008  0E00     MOVLW 0x0
1200A  6E09     MOVWF 0x9, ACCESS
1200C  EC87     CALL 0x12F0E, 0
1200E  F097     NOP
351:           	while (UART2_DataReady) { // is data from screen COMM2
12010  D036     BRA 0x207E
1207E  EC22     CALL 0x13444, 0
12080  F09A     NOP
12082  0900     IORLW 0x0
12084  A4D8     BTFSS 0xFD8, 2, ACCESS
12086  D7C5     BRA 0x2012
352:           		id_data[i] = UART2_Read();
12012  ECCB     CALL 0x12D96, 0
12014  F096     NOP
12016  6E4F     MOVWF 0x4F, ACCESS
12018  0EC6     MOVLW 0xC6
1201A  2452     ADDWF 0x52, W, ACCESS
1201C  6ED9     MOVWF 0xFD9, ACCESS
1201E  6ADA     CLRF 0xFDA, ACCESS
12020  0E06     MOVLW 0x6
12022  22DA     ADDWFC 0xFDA, F, ACCESS
12026  F53C     NOP
12028  F4DF     NOP
353:           		if (++i >= 8) {
1202A  2A52     INCF 0x52, F, ACCESS
1202C  0E07     MOVLW 0x7
1202E  6452     CPFSGT 0x52, ACCESS
12030  D026     BRA 0x207E
354:           			S.SCREEN_COMM = true;
12032  0E01     MOVLW 0x1
12034  0106     MOVLB 0x6
12036  6FB9     MOVWF DMA4PR, BANKED
355:           			if (id_data[1] == ts_type) { // code = 2 for IntelliTouch touchscreen type
12038  5051     MOVF 0x51, W, ACCESS
1203A  19C7     XORWF 0xC7, W, BANKED
1203C  A4D8     BTFSS 0xFD8, 2, ACCESS
1203E  D01D     BRA 0x207A
356:           				sprintf(buffer, "%s  ID %i", build_time, id_data[1]);
12040  0E00     MOVLW 0x0
12042  0105     MOVLB 0x5
12044  6F70     MOVWF CM1CON0, BANKED
12046  0E0A     MOVLW 0xA
12048  6F71     MOVWF CM1CON1, BANKED
1204A  0EE3     MOVLW 0xE3
1204C  6F72     MOVWF CM1NCH, BANKED
1204E  0EFF     MOVLW 0xFF
12050  6F73     MOVWF CM1PCH, BANKED
12052  0EED     MOVLW 0xED
12054  6F74     MOVWF CM2CON0, BANKED
12056  0EFF     MOVLW 0xFF
12058  6F75     MOVWF CM2CON1, BANKED
1205A  C6C7     MOVFF 0x6C7, 0x576
1205C  F576     NOP
1205E  6B77     CLRF CM2PCH, BANKED
12060  ECE9     CALL 0x12BD2, 0
12062  F095     NOP
357:           				eaDogM_WriteStringAtPos(2, 0, buffer);
12064  0E00     MOVLW 0x0
12066  6E1A     MOVWF 0x1A, ACCESS
12068  0E00     MOVLW 0x0
1206A  6E1B     MOVWF 0x1B, ACCESS
1206C  0E0A     MOVLW 0xA
1206E  6E1C     MOVWF 0x1C, ACCESS
12070  0E02     MOVLW 0x2
12072  ECDC     CALL 0x129B8, 0
12074  F094     NOP
358:           				return true;
12076  0E01     MOVLW 0x1
12078  0012     RETURN 0
359:           			} else {
360:           				return false;
1207A  0E00     MOVLW 0x0
1207C  0012     RETURN 0
361:           			}
362:           		}
363:           	}
364:           	S.SCREEN_COMM = false;
12088  0E00     MOVLW 0x0
1208A  0106     MOVLB 0x6
1208C  6FB9     MOVWF DMA4PR, BANKED
1208E  D7F5     BRA 0x207A
365:           	return false;
366:           }
367:           
368:           void setup_lcd_smartset_other(void)
369:           {
370:           	elopacketout(elocodes_e3, ELO_SEQ, 0); // reset to default smartset
1279C  0E8B     MOVLW 0x8B
1279E  6E0C     MOVWF 0xC, ACCESS
127A0  0EFF     MOVLW 0xFF
127A2  6E0D     MOVWF 0xD, ACCESS
127A4  0E0A     MOVLW 0xA
127A6  6E0E     MOVWF 0xE, ACCESS
127A8  0E00     MOVLW 0x0
127AA  6E0F     MOVWF 0xF, ACCESS
127AC  EC44     CALL 0x12688, 0
127AE  F093     NOP
371:           	wdtdelay(700000); // wait for LCD touch controller reset
127B0  0E60     MOVLW 0x60
127B2  6E06     MOVWF 0x6, ACCESS
127B4  0EAE     MOVLW 0xAE
127B6  6E07     MOVWF 0x7, ACCESS
127B8  0E0A     MOVLW 0xA
127BA  6E08     MOVWF 0x8, ACCESS
127BC  0E00     MOVLW 0x0
127BE  6E09     MOVWF 0x9, ACCESS
127C0  EC87     CALL 0x12F0E, 0
127C2  F097     NOP
372:           	if (check_id(ELO_TS_TYPE)) {
127C4  0E02     MOVLW 0x2
127C6  ECE9     CALL 0x11FD2, 0
127C8  F08F     NOP
127CA  0900     IORLW 0x0
127CC  B4D8     BTFSC 0xFD8, 2, ACCESS
127CE  D00D     BRA 0x27EA
373:           		elopacketout(elocodes_e6, ELO_SEQ, 0); // set touch modes
127D0  0E73     MOVLW 0x73
127D2  6E0C     MOVWF 0xC, ACCESS
127D4  0EFF     MOVLW 0xFF
127D6  6E0D     MOVWF 0xD, ACCESS
127D8  0E0A     MOVLW 0xA
127DA  6E0E     MOVWF 0xE, ACCESS
127DC  0E00     MOVLW 0x0
127DE  6E0F     MOVWF 0xF, ACCESS
127E0  EC44     CALL 0x12688, 0
127E2  F093     NOP
374:           		S.SCREEN_INIT = true;
127E4  0E01     MOVLW 0x1
127E6  0106     MOVLB 0x6
127E8  6FB8     MOVWF DMA3PR, BANKED
375:           	};
376:           	elopacketout(elocodes_e0, ELO_SEQ, 0); // set touch packet spacing and timing
127EA  0EA3     MOVLW 0xA3
127EC  6E0C     MOVWF 0xC, ACCESS
127EE  0EFF     MOVLW 0xFF
127F0  6E0D     MOVWF 0xD, ACCESS
127F2  0E0A     MOVLW 0xA
127F4  6E0E     MOVWF 0xE, ACCESS
127F6  0E00     MOVLW 0x0
127F8  6E0F     MOVWF 0xF, ACCESS
127FA  EC44     CALL 0x12688, 0
127FC  F093     NOP
377:           	elopacketout(elocodes_e2, ELO_SEQ, 0); // nvram save
127FE  0E97     MOVLW 0x97
12800  6E0C     MOVWF 0xC, ACCESS
12802  0EFF     MOVLW 0xFF
12804  6E0D     MOVWF 0xD, ACCESS
12806  0E0A     MOVLW 0xA
12808  6E0E     MOVWF 0xE, ACCESS
1280A  0E00     MOVLW 0x0
1280C  6E0F     MOVWF 0xF, ACCESS
1280E  EC44     CALL 0x12688, 0
12810  F093     NOP
378:           }
12812  0012     RETURN 0
379:           
380:           void setup_lcd_smartset_e220(void)
381:           {
382:           	elopacketout(elocodes_e3, ELO_SEQ, 0); // reset to default smartset
12814  0E8B     MOVLW 0x8B
12816  6E0C     MOVWF 0xC, ACCESS
12818  0EFF     MOVLW 0xFF
1281A  6E0D     MOVWF 0xD, ACCESS
1281C  0E0A     MOVLW 0xA
1281E  6E0E     MOVWF 0xE, ACCESS
12820  0E00     MOVLW 0x0
12822  6E0F     MOVWF 0xF, ACCESS
12824  EC44     CALL 0x12688, 0
12826  F093     NOP
383:           	wdtdelay(700000); // wait for LCD touch controller reset
12828  0E60     MOVLW 0x60
1282A  6E06     MOVWF 0x6, ACCESS
1282C  0EAE     MOVLW 0xAE
1282E  6E07     MOVWF 0x7, ACCESS
12830  0E0A     MOVLW 0xA
12832  6E08     MOVWF 0x8, ACCESS
12834  0E00     MOVLW 0x0
12836  6E09     MOVWF 0x9, ACCESS
12838  EC87     CALL 0x12F0E, 0
1283A  F097     NOP
384:           	if (check_id(ELO_TS_TYPE)) {
1283C  0E02     MOVLW 0x2
1283E  ECE9     CALL 0x11FD2, 0
12840  F08F     NOP
12842  0900     IORLW 0x0
12844  B4D8     BTFSC 0xFD8, 2, ACCESS
12846  D00D     BRA 0x2862
385:           		elopacketout(elocodes_e6, ELO_SEQ, 0); // set touch modes
12848  0E73     MOVLW 0x73
1284A  6E0C     MOVWF 0xC, ACCESS
1284C  0EFF     MOVLW 0xFF
1284E  6E0D     MOVWF 0xD, ACCESS
12850  0E0A     MOVLW 0xA
12852  6E0E     MOVWF 0xE, ACCESS
12854  0E00     MOVLW 0x0
12856  6E0F     MOVWF 0xF, ACCESS
12858  EC44     CALL 0x12688, 0
1285A  F093     NOP
386:           		S.SCREEN_INIT = true;
1285C  0E01     MOVLW 0x1
1285E  0106     MOVLB 0x6
12860  6FB8     MOVWF DMA3PR, BANKED
387:           	};
388:           	elopacketout(elocodes_e0, ELO_SEQ, 0); // set touch packet spacing and timing
12862  0EA3     MOVLW 0xA3
12864  6E0C     MOVWF 0xC, ACCESS
12866  0EFF     MOVLW 0xFF
12868  6E0D     MOVWF 0xD, ACCESS
1286A  0E0A     MOVLW 0xA
1286C  6E0E     MOVWF 0xE, ACCESS
1286E  0E00     MOVLW 0x0
12870  6E0F     MOVWF 0xF, ACCESS
12872  EC44     CALL 0x12688, 0
12874  F093     NOP
389:           	elopacketout(elocodes_e2, ELO_SEQ, 0); // nvram save
12876  0E97     MOVLW 0x97
12878  6E0C     MOVWF 0xC, ACCESS
1287A  0EFF     MOVLW 0xFF
1287C  6E0D     MOVWF 0xD, ACCESS
1287E  0E0A     MOVLW 0xA
12880  6E0E     MOVWF 0xE, ACCESS
12882  0E00     MOVLW 0x0
12884  6E0F     MOVWF 0xF, ACCESS
12886  EC44     CALL 0x12688, 0
12888  F093     NOP
390:           }
1288A  0012     RETURN 0
391:           
392:           void setup_lcd_smartset_v80(void)
393:           {
394:           	elocmdout_v80(&elocodes[7][0]); // reset;
128F0  0E42     MOVLW 0x42
128F2  6E0A     MOVWF 0xA, ACCESS
128F4  0EFF     MOVLW 0xFF
128F6  6E0B     MOVWF 0xB, ACCESS
128F8  EC8A     CALL 0x12714, 0
128FA  F093     NOP
395:           	wdtdelay(700000); // wait for LCD touch controller reset
128FC  0E60     MOVLW 0x60
128FE  6E06     MOVWF 0x6, ACCESS
12900  0EAE     MOVLW 0xAE
12902  6E07     MOVWF 0x7, ACCESS
12904  0E0A     MOVLW 0xA
12906  6E08     MOVWF 0x8, ACCESS
12908  0E00     MOVLW 0x0
1290A  6E09     MOVWF 0x9, ACCESS
1290C  EC87     CALL 0x12F0E, 0
1290E  F097     NOP
396:           	if (check_id(ELO_TS_TYPE)) {
12910  0E02     MOVLW 0x2
12912  ECE9     CALL 0x11FD2, 0
12914  F08F     NOP
12916  0900     IORLW 0x0
12918  B4D8     BTFSC 0xFD8, 2, ACCESS
1291A  D003     BRA 0x2922
397:           		S.SCREEN_INIT = true;
1291C  0E01     MOVLW 0x1
1291E  0106     MOVLB 0x6
12920  6FB8     MOVWF DMA3PR, BANKED
398:           	};
399:           	/* program the display */
400:           	elocmdout_v80(&elocodes[0][0]);
12922  0EFC     MOVLW 0xFC
12924  6E0A     MOVWF 0xA, ACCESS
12926  0EFE     MOVLW 0xFE
12928  6E0B     MOVWF 0xB, ACCESS
1292A  EC8A     CALL 0x12714, 0
1292C  F093     NOP
401:           	elocmdout_v80(&elocodes[4][0]);
1292E  0E24     MOVLW 0x24
12930  6E0A     MOVWF 0xA, ACCESS
12932  0EFF     MOVLW 0xFF
12934  6E0B     MOVWF 0xB, ACCESS
12936  EC8A     CALL 0x12714, 0
12938  F093     NOP
402:           	elocmdout_v80(&elocodes[5][0]);
1293A  0E2E     MOVLW 0x2E
1293C  6E0A     MOVWF 0xA, ACCESS
1293E  0EFF     MOVLW 0xFF
12940  6E0B     MOVWF 0xB, ACCESS
12942  EC8A     CALL 0x12714, 0
12944  F093     NOP
403:           	elocmdout_v80(&elocodes[6][0]);
12946  0E38     MOVLW 0x38
12948  6E0A     MOVWF 0xA, ACCESS
1294A  0EFF     MOVLW 0xFF
1294C  6E0B     MOVWF 0xB, ACCESS
1294E  EC8A     CALL 0x12714, 0
12950  F093     NOP
404:           }
12952  0012     RETURN 0
405:           
406:           void putc1(uint8_t c)
13430  6E07     MOVWF 0x7, ACCESS
407:           {
408:           	while (!UART1_is_tx_ready()) {
13432  EC31     CALL 0x13462, 0
13434  F09A     NOP
13436  0900     IORLW 0x0
13438  B4D8     BTFSC 0xFD8, 2, ACCESS
1343A  D7FB     BRA 0x3432
409:           	}; // wait until the usart is clear
410:           	UART1_Write(c);
1343C  5007     MOVF 0x7, W, ACCESS
1343E  EC69     CALL 0x12ED2, 0
13440  F097     NOP
411:           }
13442  0012     RETURN 0
412:           
413:           void putc2(uint8_t c)
1341C  6E07     MOVWF 0x7, ACCESS
414:           {
415:           	while (!UART2_is_tx_ready()) {
1341E  EC2A     CALL 0x13454, 0
13420  F09A     NOP
13422  0900     IORLW 0x0
13424  B4D8     BTFSC 0xFD8, 2, ACCESS
13426  D7FB     BRA 0x341E
416:           	}; // wait until the usart is clear
417:           	UART2_Write(c);
13428  5007     MOVF 0x7, W, ACCESS
1342A  ECEC     CALL 0x12DD8, 0
1342C  F096     NOP
418:           }
1342E  0012     RETURN 0
419:           
420:           void start_delay(void)
421:           {
422:           	wdtdelay(100000);
13406  0EA0     MOVLW 0xA0
13408  6E06     MOVWF 0x6, ACCESS
1340A  0E86     MOVLW 0x86
1340C  6E07     MOVWF 0x7, ACCESS
1340E  0E01     MOVLW 0x1
13410  6E08     MOVWF 0x8, ACCESS
13412  0E00     MOVLW 0x0
13414  6E09     MOVWF 0x9, ACCESS
13416  EC87     CALL 0x12F0E, 0
13418  F097     NOP
423:           }
1341A  0012     RETURN 0
424:           
425:           /*
426:            * main program loop processing
427:            */
428:           void rxtx_handler(void) // timer & serial data transform functions are handled here
429:           {
430:           	static uint8_t c = 0, i = 0, data_pos, uchar, tchar;
431:           	uint16_t x_tmp, y_tmp, uvalx, lvalx, uvaly, lvaly;
432:           	static uint8_t sum = 0xAA + 'U';
433:           	static uint32_t ticks = 0;
434:           
435:           	status.rawint_count++;
1066E  0E01     MOVLW 0x1
10670  0106     MOVLB 0x6
10672  274C     ADDWF ZCDCON, F, BANKED
10674  0E00     MOVLW 0x0
10676  234D     ADDWFC 0x4D, F, BANKED
10678  234E     ADDWFC 0x4E, F, BANKED
1067A  234F     ADDWFC 0x4F, F, BANKED
436:           	if (emulat_type != OTHER_MECH) {
1067C  0E02     MOVLW 0x2
1067E  0105     MOVLB 0x5
10680  19E2     XORWF 0xE2, W, BANKED
10682  B4D8     BTFSC 0xFD8, 2, ACCESS
10684  D026     BRA 0x6D2
437:           		if (UART1_DataReady) { // is data from host COMM1, only from E220/E500 machines
10686  EC38     CALL 0x13470, 0
10688  F09A     NOP
1068A  0900     IORLW 0x0
1068C  B4D8     BTFSC 0xFD8, 2, ACCESS
1068E  D021     BRA 0x6D2
438:           
439:           			if (status.do_cap) {
10690  0106     MOVLB 0x6
10692  B558     BTFSC 0x58, 2, BANKED
10694  D01E     BRA 0x6D2
440:           			} else {
441:           				tchar = UART1_Read(); // read from host
10696  EC0C     CALL 0x12E18, 0
10698  F097     NOP
1069A  6FDB     MOVWF CLCnSEL3, BANKED
442:           				S.DATA1 = true; // usart is connected to data
1069C  0E01     MOVLW 0x1
1069E  0106     MOVLB 0x6
106A0  6FBD     MOVWF 0xBD, BANKED
443:           				S.LCD_OK = true; // looks like a screen controller is connected
106A2  0E01     MOVLW 0x1
106A4  6FB7     MOVWF DMA2PR, BANKED
444:           				S.TSTATUS = true;
106A6  0E01     MOVLW 0x1
106A8  6FBC     MOVWF 0xBC, BANKED
445:           				if (tchar == 0x46) { // send one report to host
106AA  0E46     MOVLW 0x46
106AC  0105     MOVLB 0x5
106AE  19DB     XORWF CLCnSEL3, W, BANKED
106B0  A4D8     BTFSS 0xFD8, 2, ACCESS
106B2  D005     BRA 0x6BE
446:           					S.CATCH46 = true;
106B4  0E01     MOVLW 0x1
106B6  0106     MOVLB 0x6
106B8  6FBA     MOVWF DMA5PR, BANKED
447:           					status.touch_good = 0;
106BA  0E00     MOVLW 0x0
106BC  6F5B     MOVWF 0x5B, BANKED
448:           				}
449:           				if (tchar == 0x37) { // start of touch scan read
106BE  0E37     MOVLW 0x37
106C0  0105     MOVLB 0x5
106C2  19DB     XORWF CLCnSEL3, W, BANKED
106C4  A4D8     BTFSS 0xFD8, 2, ACCESS
106C6  D005     BRA 0x6D2
450:           					S.CATCH37 = true;
106C8  0E01     MOVLW 0x1
106CA  0106     MOVLB 0x6
106CC  6FBB     MOVWF DMA6PR, BANKED
451:           					status.touch_good = 0;
106CE  0E00     MOVLW 0x0
106D0  6F5B     MOVWF 0x5B, BANKED
452:           				}
453:           				if (tchar == 0x3C) { // touch reset from host
454:           					// a possible setup command
455:           				}
456:           			};
457:           		}
458:           	}
459:           
460:           	if (emulat_type == E220) {
106D2  0105     MOVLB 0x5
106D4  05E2     DECF 0xE2, W, BANKED
106D6  A4D8     BTFSS 0xFD8, 2, ACCESS
106D8  D0CE     BRA 0x876
461:           		if (UART2_DataReady) { // is data from touchscreen
106DA  EC22     CALL 0x13444, 0
106DC  F09A     NOP
106DE  0900     IORLW 0x0
106E0  B4D8     BTFSC 0xFD8, 2, ACCESS
106E2  D0C9     BRA 0x876
462:           			status.lcd_count++;
106E4  0E01     MOVLW 0x1
106E6  0106     MOVLB 0x6
106E8  2754     ADDWF 0x54, F, BANKED
106EA  0E00     MOVLW 0x0
106EC  2355     ADDWFC 0x55, F, BANKED
106EE  2356     ADDWFC 0x56, F, BANKED
106F0  2357     ADDWFC 0x57, F, BANKED
463:           			LED2_Toggle();
106F2  A2C1     BTFSS 0xFC1, 1, ACCESS
106F4  D002     BRA 0x6FA
106F6  0E01     MOVLW 0x1
106F8  D001     BRA 0x6FC
106FA  0E00     MOVLW 0x0
106FC  0AFF     XORLW 0xFF
106FE  0105     MOVLB 0x5
10700  6F8C     MOVWF SPI1CLK, BANKED
10702  478C     RLNCF SPI1CLK, F, BANKED
10704  50C1     MOVF 0xFC1, W, ACCESS
10706  198C     XORWF SPI1CLK, W, BANKED
10708  0BFD     ANDLW 0xFD
1070A  198C     XORWF SPI1CLK, W, BANKED
1070C  6EC1     MOVWF 0xFC1, ACCESS
464:           			DEBUG2_Toggle();
1070E  A4C2     BTFSS 0xFC2, 2, ACCESS
10710  D002     BRA 0x716
10712  0E01     MOVLW 0x1
10714  D001     BRA 0x718
10716  0E00     MOVLW 0x0
10718  0AFF     XORLW 0xFF
1071A  6F8C     MOVWF SPI1CLK, BANKED
1071C  478C     RLNCF SPI1CLK, F, BANKED
1071E  478C     RLNCF SPI1CLK, F, BANKED
10720  50C2     MOVF 0xFC2, W, ACCESS
10722  198C     XORWF SPI1CLK, W, BANKED
10724  0BFB     ANDLW 0xFB
10726  198C     XORWF SPI1CLK, W, BANKED
10728  6EC2     MOVWF 0xFC2, ACCESS
465:           			BLED_Toggle();
1072A  A0C2     BTFSS 0xFC2, 0, ACCESS
1072C  D002     BRA 0x732
1072E  0E01     MOVLW 0x1
10730  D001     BRA 0x734
10732  0E00     MOVLW 0x0
10734  0AFF     XORLW 0xFF
10736  6F8C     MOVWF SPI1CLK, BANKED
10738  50C2     MOVF 0xFC2, W, ACCESS
1073A  198C     XORWF SPI1CLK, W, BANKED
1073C  0BFE     ANDLW 0xFE
1073E  198C     XORWF SPI1CLK, W, BANKED
10740  6EC2     MOVWF 0xFC2, ACCESS
466:           			if (S.CAM && (status.cam_time > MAX_CAM_TIME)) {
10742  0106     MOVLB 0x6
10744  51BF     MOVF ISRPR, W, BANKED
10746  B4D8     BTFSC 0xFD8, 2, ACCESS
10748  D007     BRA 0x758
1074A  0E05     MOVLW 0x5
1074C  655C     CPFSGT 0x5C, BANKED
1074E  D004     BRA 0x758
467:           				CAM_RELAY_AUX = 0; // clear video switch
10750  9CC1     BCF 0xFC1, 6, ACCESS
468:           				CAM_RELAY = 0; // clear video switch
10752  9EC1     BCF 0xFC1, 7, ACCESS
469:           				S.CAM = false;
10754  0E00     MOVLW 0x0
10756  6FBF     MOVWF ISRPR, BANKED
470:           			}
471:           
472:           			c = UART2_Read(); // read data from touchscreen
10758  ECCB     CALL 0x12D96, 0
1075A  F096     NOP
1075C  6FDF     MOVWF CLCnGLS3, BANKED
473:           			ssbuf[idx] = c;
1075E  0E00     MOVLW 0x0
10760  25E0     ADDWF 0xE0, W, BANKED
10762  6ED9     MOVWF 0xFD9, ACCESS
10764  6ADA     CLRF 0xFDA, ACCESS
10766  0E07     MOVLW 0x7
10768  22DA     ADDWFC 0xFDA, F, ACCESS
1076C  F77C     NOP
1076E  F4DF     NOP
474:           			switch (idx++) {
10770  D06D     BRA 0x84C
475:           			case 0: // start of touch controller packet, save data and compute checksum
476:           				sum = 0xaa;
10772  0EAA     MOVLW 0xAA
10774  6FEE     MOVWF DMAnDSZ, BANKED
477:           				if (c != 'U') {
10776  0E55     MOVLW 0x55
10778  19DF     XORWF CLCnGLS3, W, BANKED
1077A  B4D8     BTFSC 0xFD8, 2, ACCESS
1077C  D076     BRA 0x86A
478:           					idx = 0;
1077E  0E00     MOVLW 0x0
10780  6FE0     MOVWF 0xE0, BANKED
10782  D073     BRA 0x86A
479:           				}
480:           				break;
481:           			case 9: // end of touch controller packet
482:           				idx = 0;
10784  0E00     MOVLW 0x0
10786  6FE0     MOVWF 0xE0, BANKED
483:           				if (c != sum) { // bad checksum
10788  51EE     MOVF DMAnDSZ, W, BANKED
1078A  19DF     XORWF CLCnGLS3, W, BANKED
1078C  A4D8     BTFSS 0xFD8, 2, ACCESS
1078E  D06D     BRA 0x86A
484:           					break;
485:           				}
486:           				if (ssbuf[1] == 'T') {
10790  0E54     MOVLW 0x54
10792  0107     MOVLB 0x7
10794  1901     XORWF 0x1, W, BANKED
10796  A4D8     BTFSS 0xFD8, 2, ACCESS
10798  D04A     BRA 0x82E
487:           					status.restart_delay = 0;
1079A  0E00     MOVLW 0x0
1079C  0106     MOVLB 0x6
1079E  6F5E     MOVWF 0x5E, BANKED
107A0  0E00     MOVLW 0x0
107A2  6F5D     MOVWF 0x5D, BANKED
488:           					S.CATCH = true;
107A4  0E01     MOVLW 0x1
107A6  6FB4     MOVWF PRLOCK, BANKED
489:           					if (!ssreport.tohost) {
107A8  51A2     MOVF 0xA2, W, BANKED
107AA  A4D8     BTFSS 0xFD8, 2, ACCESS
107AC  D05E     BRA 0x86A
490:           						ssreport.x_cord = (ELO_REV_H - (((uint16_t) ssbuf[3])+(((uint16_t) ssbuf[4]) << 8))) >> 4;
107AE  0E00     MOVLW 0x0
107B0  0105     MOVLB 0x5
107B2  6F8C     MOVWF SPI1CLK, BANKED
107B4  0E10     MOVLW 0x10
107B6  6F8D     MOVWF SPI2RXB, BANKED
107B8  0107     MOVLB 0x7
107BA  5104     MOVF 0x4, W, BANKED
107BC  0105     MOVLB 0x5
107BE  6F8F     MOVWF SPI2TCNT, BANKED
107C0  6B8E     CLRF SPI2TXB, BANKED
107C2  0107     MOVLB 0x7
107C4  5103     MOVF 0x3, W, BANKED
107C6  0105     MOVLB 0x5
107C8  6F90     MOVWF SPI2TCNTH, BANKED
107CA  6B91     CLRF SPI2CON0, BANKED
107CC  1F90     COMF SPI2TCNTH, F, BANKED
107CE  1F91     COMF SPI2CON0, F, BANKED
107D0  4B90     INFSNZ SPI2TCNTH, F, BANKED
107D2  2B91     INCF SPI2CON0, F, BANKED
107D4  518E     MOVF SPI2TXB, W, BANKED
107D6  5F90     SUBWF SPI2TCNTH, F, BANKED
107D8  518F     MOVF SPI2TCNT, W, BANKED
107DA  5B91     SUBWFB SPI2CON0, F, BANKED
107DC  518C     MOVF SPI1CLK, W, BANKED
107DE  2790     ADDWF SPI2TCNTH, F, BANKED
107E0  518D     MOVF SPI2RXB, W, BANKED
107E2  2391     ADDWFC SPI2CON0, F, BANKED
107E4  0E04     MOVLW 0x4
107E6  6F92     MOVWF SPI2CON1, BANKED
107E8  90D8     BCF 0xFD8, 0, ACCESS
107EA  3391     RRCF SPI2CON0, F, BANKED
107EC  3390     RRCF SPI2TCNTH, F, BANKED
107EE  2F92     DECFSZ SPI2CON1, F, BANKED
107F0  D7FB     BRA 0x7E8
107F2  C590     MOVFF 0x590, 0x69B
107F4  F69B     NOP
107F6  C591     MOVFF 0x591, 0x69C
107F8  F69C     NOP
491:           						ssreport.y_cord = (((uint16_t) ssbuf[5])+(((uint16_t) ssbuf[6]) << 8)) >> 4;
107FA  0107     MOVLB 0x7
107FC  5106     MOVF 0x6, W, BANKED
107FE  0105     MOVLB 0x5
10800  6F8D     MOVWF SPI2RXB, BANKED
10802  6B8C     CLRF SPI1CLK, BANKED
10804  0107     MOVLB 0x7
10806  5105     MOVF 0x5, W, BANKED
10808  0105     MOVLB 0x5
1080A  6F8E     MOVWF SPI2TXB, BANKED
1080C  6B8F     CLRF SPI2TCNT, BANKED
1080E  518C     MOVF SPI1CLK, W, BANKED
10810  278E     ADDWF SPI2TXB, F, BANKED
10812  518D     MOVF SPI2RXB, W, BANKED
10814  238F     ADDWFC SPI2TCNT, F, BANKED
10816  0E04     MOVLW 0x4
10818  6F90     MOVWF SPI2TCNTH, BANKED
1081A  90D8     BCF 0xFD8, 0, ACCESS
1081C  338F     RRCF SPI2TCNT, F, BANKED
1081E  338E     RRCF SPI2TXB, F, BANKED
10820  2F90     DECFSZ SPI2TCNTH, F, BANKED
10822  D7FB     BRA 0x81A
10824  C58E     MOVFF 0x58E, 0x69D
10826  F69D     NOP
10828  C58F     MOVFF 0x58F, 0x69E
1082A  F69E     NOP
1082C  D01E     BRA 0x86A
492:           					}
493:           				} else if (ssbuf[1] == 'A') {
1082E  0E41     MOVLW 0x41
10830  1901     XORWF 0x1, W, BANKED
10832  A4D8     BTFSS 0xFD8, 2, ACCESS
10834  D01A     BRA 0x86A
494:           					status.restart_delay = 0;
10836  0E00     MOVLW 0x0
10838  0106     MOVLB 0x6
1083A  6F5E     MOVWF 0x5E, BANKED
1083C  0E00     MOVLW 0x0
1083E  6F5D     MOVWF 0x5D, BANKED
495:           					BLED_LAT = 1; // connect  led ON
10840  80C2     BSF 0xFC2, 0, ACCESS
496:           					S.speedup = -10000;
10842  0ED8     MOVLW 0xD8
10844  6FC5     MOVWF 0xC5, BANKED
10846  0EF0     MOVLW 0xF0
10848  6FC4     MOVWF 0xC4, BANKED
497:           				} else {
1084A  D00F     BRA 0x86A
498:           				}
499:           				break;
500:           			default:
501:           				break;
502:           			}
1084C  2BE0     INCF 0xE0, F, BANKED
1084E  05E0     DECF 0xE0, W, BANKED
10850  6F8C     MOVWF SPI1CLK, BANKED
10852  6B8D     CLRF SPI2RXB, BANKED
10854  518D     MOVF SPI2RXB, W, BANKED
10856  0A00     XORLW 0x0
10858  A4D8     BTFSS 0xFD8, 2, ACCESS
1085A  D007     BRA 0x86A
1085C  518C     MOVF SPI1CLK, W, BANKED
1085E  0A00     XORLW 0x0
10860  B4D8     BTFSC 0xFD8, 2, ACCESS
10862  D787     BRA 0x772
10864  0A09     XORLW 0x9
10866  B4D8     BTFSC 0xFD8, 2, ACCESS
10868  D78D     BRA 0x784
503:           			sum += c;
1086A  0105     MOVLB 0x5
1086C  51DF     MOVF CLCnGLS3, W, BANKED
1086E  27EE     ADDWF DMAnDSZ, F, BANKED
504:           			S.DATA2 = true; // usart is connected to data
10870  0E01     MOVLW 0x1
10872  0106     MOVLB 0x6
10874  6FBE     MOVWF MAINPR, BANKED
505:           		}
506:           	}
507:           
508:           	if (emulat_type == VIISION) {
10876  0105     MOVLB 0x5
10878  51E2     MOVF 0xE2, W, BANKED
1087A  A4D8     BTFSS 0xFD8, 2, ACCESS
1087C  D1BD     BRA 0xBF8
509:           		if (UART2_DataReady) { // is data from screen COMM2
1087E  EC22     CALL 0x13444, 0
10880  F09A     NOP
10882  0900     IORLW 0x0
10884  B4D8     BTFSC 0xFD8, 2, ACCESS
10886  D177     BRA 0xB76
510:           			LED2_Toggle();
10888  A2C1     BTFSS 0xFC1, 1, ACCESS
1088A  D002     BRA 0x890
1088C  0E01     MOVLW 0x1
1088E  D001     BRA 0x892
10890  0E00     MOVLW 0x0
10892  0AFF     XORLW 0xFF
10894  6F8C     MOVWF SPI1CLK, BANKED
10896  478C     RLNCF SPI1CLK, F, BANKED
10898  50C1     MOVF 0xFC1, W, ACCESS
1089A  198C     XORWF SPI1CLK, W, BANKED
1089C  0BFD     ANDLW 0xFD
1089E  198C     XORWF SPI1CLK, W, BANKED
108A0  6EC1     MOVWF 0xFC1, ACCESS
511:           			/* Get the character received from the USART */
512:           			c = UART2_Read();
108A2  ECCB     CALL 0x12D96, 0
108A4  F096     NOP
108A6  6FDF     MOVWF CLCnGLS3, BANKED
513:           
514:           			if (((c & 0xc0) == 0xc0) || S.CATCH) { // start of touch sequence
108A8  51DF     MOVF CLCnGLS3, W, BANKED
108AA  0BC0     ANDLW 0xC0
108AC  0AC0     XORLW 0xC0
108AE  B4D8     BTFSC 0xFD8, 2, ACCESS
108B0  D004     BRA 0x8BA
108B2  0106     MOVLB 0x6
108B4  51B4     MOVF PRLOCK, W, BANKED
108B6  B4D8     BTFSC 0xFD8, 2, ACCESS
108B8  D016     BRA 0x8E6
515:           				S.CATCH = true; // found elo touch command start of sequence
108BA  0E01     MOVLW 0x1
108BC  0106     MOVLB 0x6
108BE  6FB4     MOVWF PRLOCK, BANKED
516:           				j = 0; // reset led timer
108C0  0E00     MOVLW 0x0
108C2  0105     MOVLB 0x5
108C4  6FA8     MOVWF 0xA8, BANKED
108C6  0E00     MOVLW 0x0
108C8  6FA9     MOVWF 0xA9, BANKED
108CA  0E00     MOVLW 0x0
108CC  6FAA     MOVWF 0xAA, BANKED
108CE  0E00     MOVLW 0x0
108D0  6FAB     MOVWF 0xAB, BANKED
517:           				elobuf[i++] = c; // start stuffing the command buffer
108D2  0E00     MOVLW 0x0
108D4  25DE     ADDWF CLCnGLS2, W, BANKED
108D6  6ED9     MOVWF 0xFD9, ACCESS
108D8  6ADA     CLRF 0xFDA, ACCESS
108DA  0E06     MOVLW 0x6
108DC  22DA     ADDWFC 0xFDA, F, ACCESS
108E0  F77C     NOP
108E2  F4DF     NOP
108E4  2BDE     INCF CLCnGLS2, F, BANKED
518:           			}
519:           			if (i == CMD_SIZE_SS_V80) { // see if we should send it
108E6  0E06     MOVLW 0x6
108E8  0105     MOVLB 0x5
108EA  19DE     XORWF CLCnGLS2, W, BANKED
108EC  A4D8     BTFSS 0xFD8, 2, ACCESS
108EE  D129     BRA 0xB42
520:           				i = 0; // reset i to start of cmd
108F0  0E00     MOVLW 0x0
108F2  6FDE     MOVWF CLCnGLS2, BANKED
521:           				uchar = 0; /* check for proper touch format */
108F4  0E00     MOVLW 0x0
108F6  6FDC     MOVWF CLCnGLS0, BANKED
522:           				if ((elobuf[0]& 0xc0) == 0xc0) /* binary start code? */ {
108F8  0106     MOVLB 0x6
108FA  5100     MOVF data, W, BANKED
108FC  0BC0     ANDLW 0xC0
108FE  0AC0     XORLW 0xC0
10900  A4D8     BTFSS 0xFD8, 2, ACCESS
10902  D003     BRA 0x90A
523:           					uchar = true;
10904  0E01     MOVLW 0x1
10906  0105     MOVLB 0x5
10908  6FDC     MOVWF CLCnGLS0, BANKED
524:           				}
525:           
526:           				S.CATCH = false; // reset buffering now
1090A  0E00     MOVLW 0x0
1090C  0106     MOVLB 0x6
1090E  6FB4     MOVWF PRLOCK, BANKED
527:           
528:           				/* munge the data for proper Varian format */
529:           				if ((bool) elobuf[5]) { // S.TOUCH
10910  5105     MOVF 0x5, W, BANKED
10912  B4D8     BTFSC 0xFD8, 2, ACCESS
10914  D0DC     BRA 0xACE
530:           					S.TOUCH = true; // first touch sequence has been sent
10916  0E01     MOVLW 0x1
10918  6FB5     MOVWF SCANPR, BANKED
531:           					uvalx = elobuf[0]&0x3f; // prune the data to 6-bits
1091A  C600     MOVFF elobuf, 0x58C
1091C  F58C     NOP
1091E  0E3F     MOVLW 0x3F
10920  0105     MOVLB 0x5
10922  178C     ANDWF SPI1CLK, F, BANKED
10924  518C     MOVF SPI1CLK, W, BANKED
10926  6F93     MOVWF SPI2CON2, BANKED
10928  6B94     CLRF SPI2STATUS, BANKED
532:           					lvalx = elobuf[1]&0x3f;
1092A  C601     MOVFF 0x601, 0x58C
1092C  F58C     NOP
1092E  0E3F     MOVLW 0x3F
10930  178C     ANDWF SPI1CLK, F, BANKED
10932  518C     MOVF SPI1CLK, W, BANKED
10934  6F95     MOVWF SPI2TWIDTH, BANKED
10936  6B96     CLRF SPI2BAUD, BANKED
533:           					uvaly = elobuf[2]&0x3f;
10938  C602     MOVFF 0x602, 0x58C
1093A  F58C     NOP
1093C  0E3F     MOVLW 0x3F
1093E  178C     ANDWF SPI1CLK, F, BANKED
10940  518C     MOVF SPI1CLK, W, BANKED
10942  6F97     MOVWF SPI2INTF, BANKED
10944  6B98     CLRF SPI2INTE, BANKED
534:           					lvaly = elobuf[3]&0x3f;
10946  C603     MOVFF 0x603, 0x58C
10948  F58C     NOP
1094A  0E3F     MOVLW 0x3F
1094C  178C     ANDWF SPI1CLK, F, BANKED
1094E  518C     MOVF SPI1CLK, W, BANKED
10950  6F99     MOVWF SPI2CLK, BANKED
10952  6B9A     CLRF 0x9A, BANKED
535:           					x_tmp = lvalx | (uvalx << 6); // 12-bit X value
10954  C593     MOVFF uvalx, 0x58C
10956  F58C     NOP
10958  C594     MOVFF 0x594, 0x58D
1095A  F58D     NOP
1095C  0E06     MOVLW 0x6
1095E  90D8     BCF 0xFD8, 0, ACCESS
10960  378C     RLCF SPI1CLK, F, BANKED
10962  378D     RLCF SPI2RXB, F, BANKED
10964  2EE8     DECFSZ 0xFE8, F, ACCESS
10966  D7FB     BRA 0x95E
10968  5195     MOVF SPI2TWIDTH, W, BANKED
1096A  118C     IORWF SPI1CLK, W, BANKED
1096C  6F9B     MOVWF 0x9B, BANKED
1096E  5196     MOVF SPI2BAUD, W, BANKED
10970  118D     IORWF SPI2RXB, W, BANKED
10972  6F9C     MOVWF 0x9C, BANKED
536:           					y_tmp = lvaly | (uvaly << 6); // 12-bit Y value
10974  C597     MOVFF uvaly, 0x58C
10976  F58C     NOP
10978  C598     MOVFF 0x598, 0x58D
1097A  F58D     NOP
1097C  0E06     MOVLW 0x6
1097E  90D8     BCF 0xFD8, 0, ACCESS
10980  378C     RLCF SPI1CLK, F, BANKED
10982  378D     RLCF SPI2RXB, F, BANKED
10984  2EE8     DECFSZ 0xFE8, F, ACCESS
10986  D7FB     BRA 0x97E
10988  5199     MOVF SPI2CLK, W, BANKED
1098A  118C     IORWF SPI1CLK, W, BANKED
1098C  6F9D     MOVWF 0x9D, BANKED
1098E  519A     MOVF 0x9A, W, BANKED
10990  118D     IORWF SPI2RXB, W, BANKED
10992  6F9E     MOVWF 0x9E, BANKED
537:           					x_tmp = 4095 - x_tmp; // FLIP X
10994  519B     MOVF 0x9B, W, BANKED
10996  08FF     SUBLW 0xFF
10998  6F9B     MOVWF 0x9B, BANKED
1099A  519C     MOVF 0x9C, W, BANKED
1099C  A0D8     BTFSS 0xFD8, 0, ACCESS
1099E  2AE8     INCF 0xFE8, F, ACCESS
109A0  080F     SUBLW 0xF
109A2  6F9C     MOVWF 0x9C, BANKED
538:           					y_tmp = 4095 - y_tmp; // FLIP Y
109A4  519D     MOVF 0x9D, W, BANKED
109A6  08FF     SUBLW 0xFF
109A8  6F9D     MOVWF 0x9D, BANKED
109AA  519E     MOVF 0x9E, W, BANKED
109AC  A0D8     BTFSS 0xFD8, 0, ACCESS
109AE  2AE8     INCF 0xFE8, F, ACCESS
109B0  080F     SUBLW 0xF
109B2  6F9E     MOVWF 0x9E, BANKED
539:           					x_tmp = (uint16_t) ((float) x_tmp * (float) xs_ss); // X rescale range
109B4  0E14     MOVLW 0x14
109B6  6E18     MOVWF 0x18, ACCESS
109B8  0EAE     MOVLW 0xAE
109BA  6E19     MOVWF 0x19, ACCESS
109BC  0E67     MOVLW 0x67
109BE  6E1A     MOVWF 0x1A, ACCESS
109C0  0E3F     MOVLW 0x3F
109C2  6E1B     MOVWF 0x1B, ACCESS
109C4  C59B     MOVFF x_tmp, InterruptHandler
109C6  F506     NOP
109C8  C59C     MOVFF 0x59C, c
109CA  F507     NOP
109CC  6A08     CLRF 0x8, ACCESS
109CE  6A09     CLRF 0x9, ACCESS
109D0  0E00     MOVLW 0x0
109D2  EC47     CALL 0x11C8E, 0
109D4  F08E     NOP
109D6  C506     MOVFF InterruptHandler, i
109D8  F514     NOP
109DA  C507     MOVFF c, len
109DC  F515     NOP
109DE  C508     MOVFF blockSize, counter
109E0  F516     NOP
109E2  C509     MOVFF td, sign
109E4  F517     NOP
109E6  EC5D     CALL 0x110BA, 0
109E8  F088     NOP
109EA  C514     MOVFF i, f1
109EC  F52D     NOP
109EE  C515     MOVFF len, 0x52E
109F0  F52E     NOP
109F2  C516     MOVFF counter, 0x52F
109F4  F52F     NOP
109F6  C517     MOVFF sign, 0x530
109F8  F530     NOP
109FA  ECA6     CALL 0x1214C, 0
109FC  F090     NOP
109FE  C52D     MOVFF f1, x_tmp
10A00  F59B     NOP
10A02  C52E     MOVFF 0x52E, 0x59C
10A04  F59C     NOP
540:           					y_tmp = (uint16_t) ((float) y_tmp * (float) ys_ss); // Y rescale
10A06  0E66     MOVLW 0x66
10A08  6E18     MOVWF 0x18, ACCESS
10A0A  0E66     MOVLW 0x66
10A0C  6E19     MOVWF 0x19, ACCESS
10A0E  0E26     MOVLW 0x26
10A10  6E1A     MOVWF 0x1A, ACCESS
10A12  0E3F     MOVLW 0x3F
10A14  6E1B     MOVWF 0x1B, ACCESS
10A16  C59D     MOVFF y_tmp, InterruptHandler
10A18  F506     NOP
10A1A  C59E     MOVFF 0x59E, c
10A1C  F507     NOP
10A1E  6A08     CLRF 0x8, ACCESS
10A20  6A09     CLRF 0x9, ACCESS
10A22  0E00     MOVLW 0x0
10A24  EC47     CALL 0x11C8E, 0
10A26  F08E     NOP
10A28  C506     MOVFF InterruptHandler, i
10A2A  F514     NOP
10A2C  C507     MOVFF c, len
10A2E  F515     NOP
10A30  C508     MOVFF blockSize, counter
10A32  F516     NOP
10A34  C509     MOVFF td, sign
10A36  F517     NOP
10A38  EC5D     CALL 0x110BA, 0
10A3A  F088     NOP
10A3C  C514     MOVFF i, f1
10A3E  F52D     NOP
10A40  C515     MOVFF len, 0x52E
10A42  F52E     NOP
10A44  C516     MOVFF counter, 0x52F
10A46  F52F     NOP
10A48  C517     MOVFF sign, 0x530
10A4A  F530     NOP
10A4C  ECA6     CALL 0x1214C, 0
10A4E  F090     NOP
10A50  C52D     MOVFF f1, y_tmp
10A52  F59D     NOP
10A54  C52E     MOVFF 0x52E, 0x59E
10A56  F59E     NOP
541:           					x_tmp = (x_tmp >> (uint16_t) 4); // rescale x to 8-bit value
10A58  C59B     MOVFF x_tmp, 0x58C
10A5A  F58C     NOP
10A5C  C59C     MOVFF 0x59C, 0x58D
10A5E  F58D     NOP
10A60  0E04     MOVLW 0x4
10A62  0105     MOVLB 0x5
10A64  6F8E     MOVWF SPI2TXB, BANKED
10A66  90D8     BCF 0xFD8, 0, ACCESS
10A68  338D     RRCF SPI2RXB, F, BANKED
10A6A  338C     RRCF SPI1CLK, F, BANKED
10A6C  2F8E     DECFSZ SPI2TXB, F, BANKED
10A6E  D7FB     BRA 0xA66
10A70  C58C     MOVFF 0x58C, x_tmp
10A72  F59B     NOP
10A74  C58D     MOVFF 0x58D, 0x59C
10A76  F59C     NOP
542:           					y_tmp = (y_tmp >> (uint16_t) 4); // rescale y
10A78  C59D     MOVFF y_tmp, 0x58C
10A7A  F58C     NOP
10A7C  C59E     MOVFF 0x59E, 0x58D
10A7E  F58D     NOP
10A80  0E04     MOVLW 0x4
10A82  6F8E     MOVWF SPI2TXB, BANKED
10A84  90D8     BCF 0xFD8, 0, ACCESS
10A86  338D     RRCF SPI2RXB, F, BANKED
10A88  338C     RRCF SPI1CLK, F, BANKED
10A8A  2F8E     DECFSZ SPI2TXB, F, BANKED
10A8C  D7FB     BRA 0xA84
10A8E  C58C     MOVFF 0x58C, y_tmp
10A90  F59D     NOP
10A92  C58D     MOVFF 0x58D, 0x59E
10A94  F59E     NOP
543:           					elobuf_in[1] = (uint8_t) x_tmp; // X to 8-bit var
10A96  C59B     MOVFF x_tmp, 0x660
10A98  F660     NOP
544:           					elobuf_in[2] = (uint8_t) y_tmp; // Y
10A9A  C59D     MOVFF y_tmp, 0x661
10A9C  F661     NOP
545:           					elobuf_out[0] = 0xc0 + ((elobuf_in[1]&0xc0) >> 6); // stuff into binary 4002 format
10A9E  0106     MOVLB 0x6
10AA0  4560     RLNCF PMD0, W, BANKED
10AA2  46E8     RLNCF 0xFE8, F, ACCESS
10AA4  0B03     ANDLW 0x3
10AA6  0B03     ANDLW 0x3
10AA8  0FC0     ADDLW 0xC0
10AAA  6F6F     MOVWF CMOUT, BANKED
546:           					elobuf_out[1] = 0x80 + (elobuf_in[1]&0x3f);
10AAC  5160     MOVF PMD0, W, BANKED
10AAE  0B3F     ANDLW 0x3F
10AB0  0F80     ADDLW 0x80
10AB2  6F70     MOVWF CM1CON0, BANKED
547:           					elobuf_out[2] = 0x40 + ((elobuf_in[2]&0xc0) >> 6);
10AB4  4561     RLNCF PMD1, W, BANKED
10AB6  46E8     RLNCF 0xFE8, F, ACCESS
10AB8  0B03     ANDLW 0x3
10ABA  0B03     ANDLW 0x3
10ABC  0F40     ADDLW 0x40
10ABE  6F71     MOVWF CM1CON1, BANKED
548:           					elobuf_out[3] = 0x00 + (elobuf_in[2]&0x3f);
10AC0  5161     MOVF PMD1, W, BANKED
10AC2  0B3F     ANDLW 0x3F
10AC4  6F72     MOVWF CM1NCH, BANKED
549:           					elobuf_out[4] = 0x00;
10AC6  0E00     MOVLW 0x0
10AC8  6F73     MOVWF CM1PCH, BANKED
550:           					elobuf_out[5] = 0x0f;
10ACA  0E0F     MOVLW 0xF
10ACC  6F74     MOVWF CM2CON0, BANKED
551:           				}
552:           
553:           				if (!elobuf[5]) { //S.UNTOUCH
10ACE  5105     MOVF 0x5, W, BANKED
10AD0  A4D8     BTFSS 0xFD8, 2, ACCESS
10AD2  D00E     BRA 0xAF0
554:           					S.UNTOUCH = true; // untouch sequence found
10AD4  0E01     MOVLW 0x1
10AD6  6FB6     MOVWF DMA1PR, BANKED
555:           					elobuf_out[0] = 0xc0; // restuff the buffer with needed varian untouch sequence
10AD8  0EC0     MOVLW 0xC0
10ADA  6F6F     MOVWF CMOUT, BANKED
556:           					elobuf_out[1] = 0x80;
10ADC  0E80     MOVLW 0x80
10ADE  6F70     MOVWF CM1CON0, BANKED
557:           					elobuf_out[2] = 0x40;
10AE0  0E40     MOVLW 0x40
10AE2  6F71     MOVWF CM1CON1, BANKED
558:           					elobuf_out[3] = 0x00;
10AE4  0E00     MOVLW 0x0
10AE6  6F72     MOVWF CM1NCH, BANKED
559:           					elobuf_out[4] = 0x00;
10AE8  0E00     MOVLW 0x0
10AEA  6F73     MOVWF CM1PCH, BANKED
560:           					elobuf_out[5] = 0x00;
10AEC  0E00     MOVLW 0x0
10AEE  6F74     MOVWF CM2CON0, BANKED
561:           				}
562:           
563:           				if (S.TOUCH || S.UNTOUCH) { // send both
10AF0  51B5     MOVF SCANPR, W, BANKED
10AF2  A4D8     BTFSS 0xFD8, 2, ACCESS
10AF4  D003     BRA 0xAFC
10AF6  51B6     MOVF DMA1PR, W, BANKED
10AF8  B4D8     BTFSC 0xFD8, 2, ACCESS
10AFA  D023     BRA 0xB42
564:           					if ((bool) uchar) { /* only send valid data */
10AFC  0105     MOVLB 0x5
10AFE  51DC     MOVF CLCnGLS0, W, BANKED
10B00  B4D8     BTFSC 0xFD8, 2, ACCESS
10B02  D010     BRA 0xB24
565:           						data_pos = 0;
10B04  0E00     MOVLW 0x0
10B06  6FDD     MOVWF CLCnGLS1, BANKED
566:           						do {
567:           							putc1(elobuf_out[data_pos]);
10B08  0E6F     MOVLW 0x6F
10B0A  25DD     ADDWF CLCnGLS1, W, BANKED
10B0C  6ED9     MOVWF 0xFD9, ACCESS
10B0E  6ADA     CLRF 0xFDA, ACCESS
10B10  0E06     MOVLW 0x6
10B12  22DA     ADDWFC 0xFDA, F, ACCESS
10B14  50DF     MOVF 0xFDF, W, ACCESS
10B16  EC18     CALL 0x13430, 0
10B18  F09A     NOP
568:           						} while (++data_pos < HOST_CMD_SIZE_V80);
10B1A  0105     MOVLB 0x5
10B1C  2BDD     INCF CLCnGLS1, F, BANKED
10B1E  0E05     MOVLW 0x5
10B20  65DD     CPFSGT CLCnGLS1, BANKED
10B22  D7F2     BRA 0xB08
569:           					}
570:           					S.LCD_OK = true; // looks like a screen controller is connected
10B24  0E01     MOVLW 0x1
10B26  0106     MOVLB 0x6
10B28  6FB7     MOVWF DMA2PR, BANKED
571:           					//					S.SCREEN_INIT = false; // command code has been received by lcd controller
572:           					status.init_check = 0; // reset init code timer
10B2A  0E00     MOVLW 0x0
10B2C  6F5A     MOVWF 0x5A, BANKED
573:           					BLED_LAT = 1; // connect  led ON
10B2E  80C2     BSF 0xFC2, 0, ACCESS
574:           
575:           					if (S.UNTOUCH) { // After untouch is sent dump buffer and clear all.
10B30  51B6     MOVF DMA1PR, W, BANKED
10B32  B4D8     BTFSC 0xFD8, 2, ACCESS
10B34  D006     BRA 0xB42
576:           						S.TOUCH = false;
10B36  0E00     MOVLW 0x0
10B38  6FB5     MOVWF SCANPR, BANKED
577:           						S.UNTOUCH = false;
10B3A  0E00     MOVLW 0x0
10B3C  6FB6     MOVWF DMA1PR, BANKED
578:           						S.CATCH = false;
10B3E  0E00     MOVLW 0x0
10B40  6FB4     MOVWF PRLOCK, BANKED
579:           					}
580:           				}
581:           			}
582:           
583:           			/* Clear the interrupt flag */
584:           			if (i > CMD_OVERFLOW_V80) {
10B42  0E0C     MOVLW 0xC
10B44  0105     MOVLB 0x5
10B46  65DE     CPFSGT CLCnGLS2, BANKED
10B48  D009     BRA 0xB5C
585:           				i = 0; // just incase i is greater than CMD_SIZE*2 somehow
10B4A  0E00     MOVLW 0x0
10B4C  6FDE     MOVWF CLCnGLS2, BANKED
586:           				S.CATCH = false;
10B4E  0E00     MOVLW 0x0
10B50  0106     MOVLB 0x6
10B52  6FB4     MOVWF PRLOCK, BANKED
587:           				S.TOUCH = false;
10B54  0E00     MOVLW 0x0
10B56  6FB5     MOVWF SCANPR, BANKED
588:           				S.UNTOUCH = false;
10B58  0E00     MOVLW 0x0
10B5A  6FB6     MOVWF DMA1PR, BANKED
589:           			}
590:           
591:           			BLED_Toggle(); // flash external led
10B5C  A0C2     BTFSS 0xFC2, 0, ACCESS
10B5E  D002     BRA 0xB64
10B60  0E01     MOVLW 0x1
10B62  D001     BRA 0xB66
10B64  0E00     MOVLW 0x0
10B66  0AFF     XORLW 0xFF
10B68  0105     MOVLB 0x5
10B6A  6F8C     MOVWF SPI1CLK, BANKED
10B6C  50C2     MOVF 0xFC2, W, ACCESS
10B6E  198C     XORWF SPI1CLK, W, BANKED
10B70  0BFE     ANDLW 0xFE
10B72  198C     XORWF SPI1CLK, W, BANKED
10B74  6EC2     MOVWF 0xFC2, ACCESS
592:           		}
593:           
594:           		if (emulat_type == OTHER_MECH) {
10B76  0E02     MOVLW 0x2
10B78  19E2     XORWF 0xE2, W, BANKED
10B7A  A4D8     BTFSS 0xFD8, 2, ACCESS
10B7C  D03D     BRA 0xBF8
595:           			if (UART2_DataReady) { // is data from touchscreen COMM2
10B7E  EC22     CALL 0x13444, 0
10B80  F09A     NOP
10B82  0900     IORLW 0x0
10B84  B4D8     BTFSC 0xFD8, 2, ACCESS
10B86  D020     BRA 0xBC8
596:           				/* Get the character received from the USART */
597:           				c = UART2_Read();
10B88  ECCB     CALL 0x12D96, 0
10B8A  F096     NOP
10B8C  6FDF     MOVWF CLCnGLS3, BANKED
598:           				putc1(c);
10B8E  51DF     MOVF CLCnGLS3, W, BANKED
10B90  EC18     CALL 0x13430, 0
10B92  F09A     NOP
599:           				BLED_Toggle();
10B94  A0C2     BTFSS 0xFC2, 0, ACCESS
10B96  D002     BRA 0xB9C
10B98  0E01     MOVLW 0x1
10B9A  D001     BRA 0xB9E
10B9C  0E00     MOVLW 0x0
10B9E  0AFF     XORLW 0xFF
10BA0  0105     MOVLB 0x5
10BA2  6F8C     MOVWF SPI1CLK, BANKED
10BA4  50C2     MOVF 0xFC2, W, ACCESS
10BA6  198C     XORWF SPI1CLK, W, BANKED
10BA8  0BFE     ANDLW 0xFE
10BAA  198C     XORWF SPI1CLK, W, BANKED
10BAC  6EC2     MOVWF 0xFC2, ACCESS
600:           				LED2_Toggle();
10BAE  A2C1     BTFSS 0xFC1, 1, ACCESS
10BB0  D002     BRA 0xBB6
10BB2  0E01     MOVLW 0x1
10BB4  D001     BRA 0xBB8
10BB6  0E00     MOVLW 0x0
10BB8  0AFF     XORLW 0xFF
10BBA  6F8C     MOVWF SPI1CLK, BANKED
10BBC  478C     RLNCF SPI1CLK, F, BANKED
10BBE  50C1     MOVF 0xFC1, W, ACCESS
10BC0  198C     XORWF SPI1CLK, W, BANKED
10BC2  0BFD     ANDLW 0xFD
10BC4  198C     XORWF SPI1CLK, W, BANKED
10BC6  6EC1     MOVWF 0xFC1, ACCESS
601:           			}
602:           			if (UART1_DataReady) { // is data from host COMM1
10BC8  EC38     CALL 0x13470, 0
10BCA  F09A     NOP
10BCC  0900     IORLW 0x0
10BCE  B4D8     BTFSC 0xFD8, 2, ACCESS
10BD0  D013     BRA 0xBF8
603:           				/* Get the character received from the USART */
604:           				c = UART1_Read();
10BD2  EC0C     CALL 0x12E18, 0
10BD4  F097     NOP
10BD6  6FDF     MOVWF CLCnGLS3, BANKED
605:           				putc2(c);
10BD8  51DF     MOVF CLCnGLS3, W, BANKED
10BDA  EC0E     CALL 0x1341C, 0
10BDC  F09A     NOP
606:           				BLED_Toggle();
10BDE  A0C2     BTFSS 0xFC2, 0, ACCESS
10BE0  D002     BRA 0xBE6
10BE2  0E01     MOVLW 0x1
10BE4  D001     BRA 0xBE8
10BE6  0E00     MOVLW 0x0
10BE8  0AFF     XORLW 0xFF
10BEA  0105     MOVLB 0x5
10BEC  6F8C     MOVWF SPI1CLK, BANKED
10BEE  50C2     MOVF 0xFC2, W, ACCESS
10BF0  198C     XORWF SPI1CLK, W, BANKED
10BF2  0BFE     ANDLW 0xFE
10BF4  198C     XORWF SPI1CLK, W, BANKED
10BF6  6EC2     MOVWF 0xFC2, ACCESS
607:           			}
608:           		}
609:           	}
610:           
611:           	if (TimerDone(TMR_DIS)) {
10BF8  0E06     MOVLW 0x6
10BFA  ECBF     CALL 0x1317E, 0
10BFC  F098     NOP
10BFE  0900     IORLW 0x0
10C00  B4D8     BTFSC 0xFD8, 2, ACCESS
10C02  0012     RETURN 0
612:           		sprintf(buffer, "%i,%i,%i,%i,%i", S.ts_type, screen_type, emulat_type, status.status_count, status.resync_count);
10C04  0E00     MOVLW 0x0
10C06  0105     MOVLB 0x5
10C08  6F70     MOVWF CM1CON0, BANKED
10C0A  0E0A     MOVLW 0xA
10C0C  6F71     MOVWF CM1CON1, BANKED
10C0E  0EAF     MOVLW 0xAF
10C10  6F72     MOVWF CM1NCH, BANKED
10C12  0EFF     MOVLW 0xFF
10C14  6F73     MOVWF CM1PCH, BANKED
10C16  C6C2     MOVFF 0x6C2, 0x574
10C18  F574     NOP
10C1A  C6C3     MOVFF 0x6C3, 0x575
10C1C  F575     NOP
10C1E  C5E3     MOVFF screen_type, 0x576
10C20  F576     NOP
10C22  6B77     CLRF CM2PCH, BANKED
10C24  C5E2     MOVFF emulat_type, 0x578
10C26  F578     NOP
10C28  6B79     CLRF WDTCON1, BANKED
10C2A  C650     MOVFF 0x650, 0x57A
10C2C  F57A     NOP
10C2E  C651     MOVFF 0x651, 0x57B
10C30  F57B     NOP
10C32  C652     MOVFF 0x652, 0x57C
10C34  F57C     NOP
10C36  C653     MOVFF 0x653, 0x57D
10C38  F57D     NOP
10C3A  C648     MOVFF 0x648, 0x57E
10C3C  F57E     NOP
10C3E  C649     MOVFF 0x649, 0x57F
10C40  F57F     NOP
10C42  C64A     MOVFF 0x64A, 0x580
10C44  F580     NOP
10C46  C64B     MOVFF 0x64B, 0x581
10C48  F581     NOP
10C4A  ECE9     CALL 0x12BD2, 0
10C4C  F095     NOP
613:           		eaDogM_WriteStringAtPos(3, 0, buffer);
10C4E  0E00     MOVLW 0x0
10C50  6E1A     MOVWF 0x1A, ACCESS
10C52  0E00     MOVLW 0x0
10C54  6E1B     MOVWF 0x1B, ACCESS
10C56  0E0A     MOVLW 0xA
10C58  6E1C     MOVWF 0x1C, ACCESS
10C5A  0E03     MOVLW 0x3
10C5C  ECDC     CALL 0x129B8, 0
10C5E  F094     NOP
614:           		sprintf(buffer, "%i,%i,%i %i ", idx, S.DATA1, S.DATA2, status.lcd_count);
10C60  0E00     MOVLW 0x0
10C62  0105     MOVLB 0x5
10C64  6F70     MOVWF CM1CON0, BANKED
10C66  0E0A     MOVLW 0xA
10C68  6F71     MOVWF CM1CON1, BANKED
10C6A  0EBE     MOVLW 0xBE
10C6C  6F72     MOVWF CM1NCH, BANKED
10C6E  0EFF     MOVLW 0xFF
10C70  6F73     MOVWF CM1PCH, BANKED
10C72  C5E0     MOVFF idx, 0x574
10C74  F574     NOP
10C76  6B75     CLRF CM2CON1, BANKED
10C78  C6BD     MOVFF 0x6BD, 0x576
10C7A  F576     NOP
10C7C  6B77     CLRF CM2PCH, BANKED
10C7E  C6BE     MOVFF 0x6BE, 0x578
10C80  F578     NOP
10C82  6B79     CLRF WDTCON1, BANKED
10C84  C654     MOVFF 0x654, 0x57A
10C86  F57A     NOP
10C88  C655     MOVFF 0x655, 0x57B
10C8A  F57B     NOP
10C8C  C656     MOVFF 0x656, 0x57C
10C8E  F57C     NOP
10C90  C657     MOVFF 0x657, 0x57D
10C92  F57D     NOP
10C94  ECE9     CALL 0x12BD2, 0
10C96  F095     NOP
615:           		eaDogM_WriteStringAtPos(0, 0, buffer);
10C98  0E00     MOVLW 0x0
10C9A  6E1A     MOVWF 0x1A, ACCESS
10C9C  0E00     MOVLW 0x0
10C9E  6E1B     MOVWF 0x1B, ACCESS
10CA0  0E0A     MOVLW 0xA
10CA2  6E1C     MOVWF 0x1C, ACCESS
10CA4  0E00     MOVLW 0x0
10CA6  ECDC     CALL 0x129B8, 0
10CA8  F094     NOP
616:           		StartTimer(TMR_DIS, 500);
10CAA  0E01     MOVLW 0x1
10CAC  6E07     MOVWF 0x7, ACCESS
10CAE  0EF4     MOVLW 0xF4
10CB0  6E06     MOVWF 0x6, ACCESS
10CB2  0E06     MOVLW 0x6
10CB4  EC7A     CALL 0x130F4, 0
10CB6  F098     NOP
617:           	}
618:           }
10CB8  0012     RETURN 0
619:           
620:           uint8_t Test_Screen(void)
621:           {
622:           	putc2(0x46);
623:           	wdtdelay(30000);
624:           	setup_lcd_smartset_e220(); // send lcd touch controller setup codes
625:           	return S.DATA2;
626:           }
627:           
628:           /*
629:           			 Main application
630:            */
631:           void main(void)
632:           {
633:           	uint8_t scaled_char;
634:           	float rez_scale_h = 1.0, rez_parm_h, rez_scale_v = 1.0, rez_parm_v;
10000  0E00     MOVLW 0x0
10002  0107     MOVLB 0x7
10004  6FE8     MOVWF DMASELECT, BANKED
10006  0E00     MOVLW 0x0
10008  6FE9     MOVWF DMAnBUF, BANKED
1000A  0E80     MOVLW 0x80
1000C  6FEA     MOVWF DMAnDCNT, BANKED
1000E  0E3F     MOVLW 0x3F
10010  6FEB     MOVWF DMAnDCNTH, BANKED
10012  0E00     MOVLW 0x0
10014  6FEC     MOVWF DMAnDPTR, BANKED
10016  0E00     MOVLW 0x0
10018  6FED     MOVWF DMAnDPTRH, BANKED
1001A  0E80     MOVLW 0x80
1001C  6FEE     MOVWF DMAnDSZ, BANKED
1001E  0E3F     MOVLW 0x3F
10020  6FEF     MOVWF DMAnDSZH, BANKED
635:           	float rez_scale_h_ss = ELO_SS_H_SCALE, rez_scale_v_ss = ELO_SS_V_SCALE;
10022  0EC7     MOVLW 0xC7
10024  6FE0     MOVWF 0xE0, BANKED
10026  0E4B     MOVLW 0x4B
10028  6FE1     MOVWF 0xE1, BANKED
1002A  0EF7     MOVLW 0xF7
1002C  6FE2     MOVWF 0xE2, BANKED
1002E  0E3E     MOVLW 0x3E
10030  6FE3     MOVWF 0xE3, BANKED
10032  0E5C     MOVLW 0x5C
10034  6FE4     MOVWF 0xE4, BANKED
10036  0E8F     MOVLW 0x8F
10038  6FE5     MOVWF 0xE5, BANKED
1003A  0EC2     MOVLW 0xC2
1003C  6FE6     MOVWF 0xE6, BANKED
1003E  0E3E     MOVLW 0x3E
10040  6FE7     MOVWF 0xE7, BANKED
636:           
637:           	// Initialize the device
638:           	SYSTEM_Initialize();
10042  ECC2     CALL 0x12F84, 0
10044  F097     NOP
639:           	TMR5_SetInterruptHandler(led_flash);
10046  0EB8     MOVLW 0xB8
10048  6E06     MOVWF 0x6, ACCESS
1004A  0E33     MOVLW 0x33
1004C  6E07     MOVWF 0x7, ACCESS
1004E  0E01     MOVLW 0x1
10050  6E08     MOVWF 0x8, ACCESS
10052  EC8C     CALL 0x13518, 0
10054  F09A     NOP
640:           
641:           	S.c_idx = 0;
10056  0E00     MOVLW 0x0
10058  0106     MOVLB 0x6
1005A  6FC1     MOVWF 0xC1, BANKED
1005C  0E00     MOVLW 0x0
1005E  6FC0     MOVWF 0xC0, BANKED
642:           	S.speedup = 0;
10060  0E00     MOVLW 0x0
10062  6FC5     MOVWF 0xC5, BANKED
10064  0E00     MOVLW 0x0
10066  6FC4     MOVWF 0xC4, BANKED
643:           
644:           	// default interfaces
645:           	/*
646:           	 * host expects
647:           	 */
648:           	if (S_TYPE_GetValue()) { // SV4 pin 5
10068  A8CE     BTFSS 0xFCE, 4, ACCESS
1006A  D004     BRA 0x74
649:           		S.ts_type = OEM_CRT;
1006C  0E00     MOVLW 0x0
1006E  6FC3     MOVWF 0xC3, BANKED
10070  0E00     MOVLW 0x0
10072  D003     BRA 0x7A
650:           	} else {
651:           		S.ts_type = OEM_LCD;
10074  0E00     MOVLW 0x0
10076  6FC3     MOVWF 0xC3, BANKED
10078  0E01     MOVLW 0x1
1007A  6FC2     MOVWF 0xC2, BANKED
652:           	}
653:           
654:           	/*
655:           	 * host is
656:           	 */
657:           	if (E_TYPE_GetValue()) { // SV4 pin 3
1007C  A4CE     BTFSS 0xFCE, 2, ACCESS
1007E  D002     BRA 0x84
658:           		emulat_type = E220;
10080  0E01     MOVLW 0x1
10082  D001     BRA 0x86
659:           	} else {
660:           		emulat_type = VIISION;
10084  0E00     MOVLW 0x0
10086  0105     MOVLB 0x5
10088  6FE2     MOVWF 0xE2, BANKED
661:           	}
662:           
663:           	/*
664:           	 * touch screen is
665:           	 */
666:           	if (D_TYPE_GetValue()) { // SV4 pin 1
1008A  A0CE     BTFSS 0xFCE, 0, ACCESS
1008C  D003     BRA 0x94
667:           		screen_type = DELL_E215546;
1008E  0E00     MOVLW 0x0
10090  6FE3     MOVWF 0xE3, BANKED
668:           	} else {
10092  D004     BRA 0x9C
669:           		screen_type = OTHER_SCREEN;
10094  0E01     MOVLW 0x1
10096  6FE3     MOVWF 0xE3, BANKED
670:           		emulat_type = OTHER_MECH;
10098  0E02     MOVLW 0x2
1009A  6FE2     MOVWF 0xE2, BANKED
671:           	}
672:           
673:           	CAM_RELAY = 0;
1009C  9EC1     BCF 0xFC1, 7, ACCESS
674:           	CAM_RELAY_AUX = 0;
1009E  9CC1     BCF 0xFC1, 6, ACCESS
675:           	status.touch_count = 0;
100A0  0E00     MOVLW 0x0
100A2  0106     MOVLB 0x6
100A4  6F44     MOVWF NVMADRH, BANKED
100A6  0E00     MOVLW 0x0
100A8  6F45     MOVWF NVMADRU, BANKED
100AA  0E00     MOVLW 0x0
100AC  6F46     MOVWF NVMDAT, BANKED
100AE  0E00     MOVLW 0x0
100B0  6F47     MOVWF NVMDATH, BANKED
676:           	S.CAM = false;
100B2  0E00     MOVLW 0x0
100B4  6FBF     MOVWF ISRPR, BANKED
677:           	ssreport.tohost = true;
100B6  0E01     MOVLW 0x1
100B8  6FA2     MOVWF 0xA2, BANKED
678:           
679:           	// Enable high priority global interrupts
680:           	INTERRUPT_GlobalInterruptHighEnable();
100BA  8ED6     BSF 0xFD6, 7, ACCESS
681:           
682:           	// Enable low priority global interrupts.
683:           	INTERRUPT_GlobalInterruptLowEnable();
100BC  8CD6     BSF 0xFD6, 6, ACCESS
684:           
685:           	DMA2_StopTransfer();
100BE  ECA7     CALL 0x1354E, 0
100C0  F09A     NOP
686:           	SPI1CON0bits.EN = 1;
100C2  8F84     BSF SPI1CON0, 7, BANKED
687:           	init_display();
100C4  ECF7     CALL 0x125EE, 0
100C6  F092     NOP
688:           	sprintf(buffer, "%s ", build_version);
100C8  0E00     MOVLW 0x0
100CA  0105     MOVLB 0x5
100CC  6F70     MOVWF CM1CON0, BANKED
100CE  0E0A     MOVLW 0xA
100D0  6F71     MOVWF CM1CON1, BANKED
100D2  0EFB     MOVLW 0xFB
100D4  6F72     MOVWF CM1NCH, BANKED
100D6  0EFF     MOVLW 0xFF
100D8  6F73     MOVWF CM1PCH, BANKED
100DA  0E60     MOVLW 0x60
100DC  6F74     MOVWF CM2CON0, BANKED
100DE  0EFF     MOVLW 0xFF
100E0  6F75     MOVWF CM2CON1, BANKED
100E2  ECE9     CALL 0x12BD2, 0
100E4  F095     NOP
689:           	eaDogM_WriteStringAtPos(0, 0, buffer);
100E6  0E00     MOVLW 0x0
100E8  6E1A     MOVWF 0x1A, ACCESS
100EA  0E00     MOVLW 0x0
100EC  6E1B     MOVWF 0x1B, ACCESS
100EE  0E0A     MOVLW 0xA
100F0  6E1C     MOVWF 0x1C, ACCESS
100F2  0E00     MOVLW 0x0
100F4  ECDC     CALL 0x129B8, 0
100F6  F094     NOP
690:           	sprintf(buffer, "%s ", build_date);
100F8  0E00     MOVLW 0x0
100FA  0105     MOVLB 0x5
100FC  6F70     MOVWF CM1CON0, BANKED
100FE  0E0A     MOVLW 0xA
10100  6F71     MOVWF CM1CON1, BANKED
10102  0EFB     MOVLW 0xFB
10104  6F72     MOVWF CM1NCH, BANKED
10106  0EFF     MOVLW 0xFF
10108  6F73     MOVWF CM1PCH, BANKED
1010A  0ECB     MOVLW 0xCB
1010C  6F74     MOVWF CM2CON0, BANKED
1010E  0EFF     MOVLW 0xFF
10110  6F75     MOVWF CM2CON1, BANKED
10112  ECE9     CALL 0x12BD2, 0
10114  F095     NOP
691:           	eaDogM_WriteStringAtPos(1, 0, buffer);
10116  0E00     MOVLW 0x0
10118  6E1A     MOVWF 0x1A, ACCESS
1011A  0E00     MOVLW 0x0
1011C  6E1B     MOVWF 0x1B, ACCESS
1011E  0E0A     MOVLW 0xA
10120  6E1C     MOVWF 0x1C, ACCESS
10122  0E01     MOVLW 0x1
10124  ECDC     CALL 0x129B8, 0
10126  F094     NOP
692:           	sprintf(buffer, "%s  ", build_time);
10128  0E00     MOVLW 0x0
1012A  0105     MOVLB 0x5
1012C  6F70     MOVWF CM1CON0, BANKED
1012E  0E0A     MOVLW 0xA
10130  6F71     MOVWF CM1CON1, BANKED
10132  0EF6     MOVLW 0xF6
10134  6F72     MOVWF CM1NCH, BANKED
10136  0EFF     MOVLW 0xFF
10138  6F73     MOVWF CM1PCH, BANKED
1013A  0EED     MOVLW 0xED
1013C  6F74     MOVWF CM2CON0, BANKED
1013E  0EFF     MOVLW 0xFF
10140  6F75     MOVWF CM2CON1, BANKED
10142  ECE9     CALL 0x12BD2, 0
10144  F095     NOP
693:           	eaDogM_WriteStringAtPos(2, 0, buffer);
10146  0E00     MOVLW 0x0
10148  6E1A     MOVWF 0x1A, ACCESS
1014A  0E00     MOVLW 0x0
1014C  6E1B     MOVWF 0x1B, ACCESS
1014E  0E0A     MOVLW 0xA
10150  6E1C     MOVWF 0x1C, ACCESS
10152  0E02     MOVLW 0x2
10154  ECDC     CALL 0x129B8, 0
10156  F094     NOP
694:           
695:           	StartTimer(TMR_DIS, 500);
10158  0E01     MOVLW 0x1
1015A  6E07     MOVWF 0x7, ACCESS
1015C  0EF4     MOVLW 0xF4
1015E  6E06     MOVWF 0x6, ACCESS
10160  0E06     MOVLW 0x6
10162  EC7A     CALL 0x130F4, 0
10164  F098     NOP
696:           
697:           	if (emulat_type == OTHER_MECH) {
10166  0E02     MOVLW 0x2
10168  0105     MOVLB 0x5
1016A  19E2     XORWF 0xE2, W, BANKED
1016C  B4D8     BTFSC 0xFD8, 2, ACCESS
698:           		setup_lcd_smartset_other();
1016E  ECCE     CALL 0x1279C, 0
10170  F093     NOP
699:           	}
700:           
701:           	if (emulat_type == VIISION) {
10172  0105     MOVLB 0x5
10174  51E2     MOVF 0xE2, W, BANKED
10176  B4D8     BTFSC 0xFD8, 2, ACCESS
702:           		setup_lcd_smartset_v80();
10178  EC78     CALL 0x128F0, 0
1017A  F094     NOP
703:           	}
704:           
705:           	if (emulat_type == E220) {
1017C  0105     MOVLB 0x5
1017E  05E2     DECF 0xE2, W, BANKED
10180  A4D8     BTFSS 0xFD8, 2, ACCESS
10182  D209     BRA 0x596
706:           		S.DATA1 = false; // reset COMM flags.
10184  0E00     MOVLW 0x0
10186  0106     MOVLB 0x6
10188  6FBD     MOVWF 0xBD, BANKED
707:           		S.DATA2 = false; // reset touch COMM flag
1018A  0E00     MOVLW 0x0
1018C  6FBE     MOVWF MAINPR, BANKED
708:           
709:           		setup_lcd_smartset_e220();
1018E  EC0A     CALL 0x12814, 0
10190  F094     NOP
710:           		/* Loop forever */
711:           		StartTimer(TMR_CAM, 1000);
10192  0E03     MOVLW 0x3
10194  6E07     MOVWF 0x7, ACCESS
10196  0EE8     MOVLW 0xE8
10198  6E06     MOVWF 0x6, ACCESS
1019A  0E05     MOVLW 0x5
1019C  EC7A     CALL 0x130F4, 0
1019E  F098     NOP
712:           		while (true) {
713:           			rxtx_handler();
101A0  EC37     CALL 0x1066E, 0
101A2  F083     NOP
714:           			if (j++ >= (BLINK_RATE_E220 + S.speedup)) { // delay a bit ok
101A4  0E20     MOVLW 0x20
101A6  0106     MOVLB 0x6
101A8  25C4     ADDWF 0xC4, W, BANKED
101AA  0105     MOVLB 0x5
101AC  6F9F     MOVWF 0x9F, BANKED
101AE  0E4E     MOVLW 0x4E
101B0  0106     MOVLB 0x6
101B2  21C5     ADDWFC 0xC5, W, BANKED
101B4  0105     MOVLB 0x5
101B6  6FA0     MOVWF 0xA0, BANKED
101B8  6BA1     CLRF 0xA1, BANKED
101BA  BFA0     BTFSC 0xA0, 7, BANKED
101BC  07A1     DECF 0xA1, F, BANKED
101BE  51A1     MOVF 0xA1, W, BANKED
101C0  6FA2     MOVWF 0xA2, BANKED
101C2  C5A8     MOVFF j, 0x5A3
101C4  F5A3     NOP
101C6  C5A9     MOVFF 0x5A9, 0x5A4
101C8  F5A4     NOP
101CA  C5AA     MOVFF 0x5AA, 0x5A5
101CC  F5A5     NOP
101CE  C5AB     MOVFF 0x5AB, 0x5A6
101D0  F5A6     NOP
101D2  2BA8     INCF 0xA8, F, BANKED
101D4  0E00     MOVLW 0x0
101D6  23A9     ADDWFC 0xA9, F, BANKED
101D8  23AA     ADDWFC 0xAA, F, BANKED
101DA  23AB     ADDWFC 0xAB, F, BANKED
101DC  519F     MOVF 0x9F, W, BANKED
101DE  5DA3     SUBWF 0xA3, W, BANKED
101E0  51A0     MOVF 0xA0, W, BANKED
101E2  59A4     SUBWFB 0xA4, W, BANKED
101E4  51A1     MOVF 0xA1, W, BANKED
101E6  59A5     SUBWFB 0xA5, W, BANKED
101E8  51A6     MOVF 0xA6, W, BANKED
101EA  0A80     XORLW 0x80
101EC  6FA7     MOVWF 0xA7, BANKED
101EE  51A2     MOVF 0xA2, W, BANKED
101F0  0A80     XORLW 0x80
101F2  59A7     SUBWFB 0xA7, W, BANKED
101F4  A0D8     BTFSS 0xFD8, 0, ACCESS
101F6  D076     BRA 0x2E4
715:           #ifdef	DEBUG_CAM
716:           				CAM_RELAY = !CAM_RELAY;
717:           #endif
718:           				BLED_Toggle(); // flash external led
101F8  A0C2     BTFSS 0xFC2, 0, ACCESS
101FA  D002     BRA 0x200
101FC  0E01     MOVLW 0x1
101FE  D001     BRA 0x202
10200  0E00     MOVLW 0x0
10202  0AFF     XORLW 0xFF
10204  6F9F     MOVWF 0x9F, BANKED
10206  50C2     MOVF 0xFC2, W, ACCESS
10208  199F     XORWF 0x9F, W, BANKED
1020A  0BFE     ANDLW 0xFE
1020C  199F     XORWF 0x9F, W, BANKED
1020E  6EC2     MOVWF 0xFC2, ACCESS
719:           				if (status.cam_time > MAX_CAM_TIMEOUT) {
10210  0E1E     MOVLW 0x1E
10212  0106     MOVLB 0x6
10214  655C     CPFSGT 0x5C, BANKED
10216  D00B     BRA 0x22E
720:           					if (touch_corner_timed) {
10218  0105     MOVLB 0x5
1021A  51E1     MOVF 0xE1, W, BANKED
1021C  B4D8     BTFSC 0xFD8, 2, ACCESS
1021E  D007     BRA 0x22E
721:           						touch_corner_timed = false;
10220  0E00     MOVLW 0x0
10222  6FE1     MOVWF 0xE1, BANKED
722:           						CAM_RELAY_AUX = 0; // clear video switch
10224  9CC1     BCF 0xFC1, 6, ACCESS
723:           						CAM_RELAY = 0; // clear video switch
10226  9EC1     BCF 0xFC1, 7, ACCESS
724:           						S.CAM = false;
10228  0E00     MOVLW 0x0
1022A  0106     MOVLB 0x6
1022C  6FBF     MOVWF ISRPR, BANKED
725:           					}
726:           				}
727:           				if (TimerDone(TMR_CAM)) {
1022E  0E05     MOVLW 0x5
10230  ECBF     CALL 0x1317E, 0
10232  F098     NOP
10234  0900     IORLW 0x0
10236  B4D8     BTFSC 0xFD8, 2, ACCESS
10238  D009     BRA 0x24C
728:           					status.cam_time++;
1023A  0106     MOVLB 0x6
1023C  2B5C     INCF 0x5C, F, BANKED
729:           					StartTimer(TMR_CAM, 1000);
1023E  0E03     MOVLW 0x3
10240  6E07     MOVWF 0x7, ACCESS
10242  0EE8     MOVLW 0xE8
10244  6E06     MOVWF 0x6, ACCESS
10246  0E05     MOVLW 0x5
10248  EC7A     CALL 0x130F4, 0
1024A  F098     NOP
730:           				}
731:           
732:           				/*		For the auto-restart switch						*/
733:           				//FIXME
734:           				if (AUTO_RESTART) { // enable auto-restarts
735:           					if ((status.restart_delay++ >= (uint16_t) 60) && (!S.TSTATUS)) { // try and reinit lcd after delay
1024C  0106     MOVLB 0x6
1024E  515D     MOVF 0x5D, W, BANKED
10250  0105     MOVLB 0x5
10252  6F9F     MOVWF 0x9F, BANKED
10254  0106     MOVLB 0x6
10256  515E     MOVF 0x5E, W, BANKED
10258  0105     MOVLB 0x5
1025A  6FA0     MOVWF 0xA0, BANKED
1025C  0106     MOVLB 0x6
1025E  4B5D     INFSNZ 0x5D, F, BANKED
10260  2B5E     INCF 0x5E, F, BANKED
10262  0105     MOVLB 0x5
10264  51A0     MOVF 0xA0, W, BANKED
10266  E104     BNZ 0x270
10268  0E3C     MOVLW 0x3C
1026A  5D9F     SUBWF 0x9F, W, BANKED
1026C  A0D8     BTFSS 0xFD8, 0, ACCESS
1026E  D021     BRA 0x2B2
10270  0106     MOVLB 0x6
10272  51BC     MOVF 0xBC, W, BANKED
10274  A4D8     BTFSS 0xFD8, 2, ACCESS
10276  D01D     BRA 0x2B2
736:           						start_delay();
10278  EC03     CALL 0x13406, 0
1027A  F09A     NOP
737:           						setup_lcd_smartset_e220(); // send lcd touch controller setup codes
1027C  EC0A     CALL 0x12814, 0
1027E  F094     NOP
738:           						sprintf(buffer, "%s  RESTART", build_time);
10280  0E00     MOVLW 0x0
10282  0105     MOVLB 0x5
10284  6F70     MOVWF CM1CON0, BANKED
10286  0E0A     MOVLW 0xA
10288  6F71     MOVWF CM1CON1, BANKED
1028A  0ED7     MOVLW 0xD7
1028C  6F72     MOVWF CM1NCH, BANKED
1028E  0EFF     MOVLW 0xFF
10290  6F73     MOVWF CM1PCH, BANKED
10292  0EED     MOVLW 0xED
10294  6F74     MOVWF CM2CON0, BANKED
10296  0EFF     MOVLW 0xFF
10298  6F75     MOVWF CM2CON1, BANKED
1029A  ECE9     CALL 0x12BD2, 0
1029C  F095     NOP
739:           						eaDogM_WriteStringAtPos(2, 0, buffer);
1029E  0E00     MOVLW 0x0
102A0  6E1A     MOVWF 0x1A, ACCESS
102A2  0E00     MOVLW 0x0
102A4  6E1B     MOVWF 0x1B, ACCESS
102A6  0E0A     MOVLW 0xA
102A8  6E1C     MOVWF 0x1C, ACCESS
102AA  0E02     MOVLW 0x2
102AC  ECDC     CALL 0x129B8, 0
102AE  F094     NOP
740:           						while (true) {
741:           						}; // lockup WDT counter to restart
102B0  D7FF     BRA 0x2B0
742:           					} else {
743:           						if ((status.restart_delay >= (uint16_t) 150) && (S.TSTATUS)) { // after delay restart TS status.
102B2  0106     MOVLB 0x6
102B4  515E     MOVF 0x5E, W, BANKED
102B6  E104     BNZ 0x2C0
102B8  0E96     MOVLW 0x96
102BA  5D5D     SUBWF 0x5D, W, BANKED
102BC  A0D8     BTFSS 0xFD8, 0, ACCESS
102BE  D009     BRA 0x2D2
102C0  51BC     MOVF 0xBC, W, BANKED
102C2  B4D8     BTFSC 0xFD8, 2, ACCESS
102C4  D006     BRA 0x2D2
744:           							S.TSTATUS = false; // lost comms while connected
102C6  0E00     MOVLW 0x0
102C8  6FBC     MOVWF 0xBC, BANKED
745:           							status.restart_delay = 0;
102CA  0E00     MOVLW 0x0
102CC  6F5E     MOVWF 0x5E, BANKED
102CE  0E00     MOVLW 0x0
102D0  6F5D     MOVWF 0x5D, BANKED
746:           						};
747:           					};
748:           				}
749:           				j = 0;
102D2  0E00     MOVLW 0x0
102D4  0105     MOVLB 0x5
102D6  6FA8     MOVWF 0xA8, BANKED
102D8  0E00     MOVLW 0x0
102DA  6FA9     MOVWF 0xA9, BANKED
102DC  0E00     MOVLW 0x0
102DE  6FAA     MOVWF 0xAA, BANKED
102E0  0E00     MOVLW 0x0
102E2  6FAB     MOVWF 0xAB, BANKED
750:           			}
751:           
752:           
753:           			touch_cam(); // always check the cam touch
102E4  EC46     CALL 0x1288C, 0
102E6  F094     NOP
754:           
755:           			if (S.CATCH46) { // flag to send report to host
102E8  0106     MOVLB 0x6
102EA  51BA     MOVF DMA5PR, W, BANKED
102EC  B4D8     BTFSC 0xFD8, 2, ACCESS
102EE  D111     BRA 0x512
756:           				if (S.CATCH) { // send the buffered touch report
102F0  51B4     MOVF PRLOCK, W, BANKED
102F2  B4D8     BTFSC 0xFD8, 2, ACCESS
102F4  D100     BRA 0x4F6
757:           					DEBUG1_Toggle();
102F6  A2C2     BTFSS 0xFC2, 1, ACCESS
102F8  D002     BRA 0x2FE
102FA  0E01     MOVLW 0x1
102FC  D001     BRA 0x300
102FE  0E00     MOVLW 0x0
10300  0AFF     XORLW 0xFF
10302  0105     MOVLB 0x5
10304  6F9F     MOVWF 0x9F, BANKED
10306  479F     RLNCF 0x9F, F, BANKED
10308  50C2     MOVF 0xFC2, W, ACCESS
1030A  199F     XORWF 0x9F, W, BANKED
1030C  0BFD     ANDLW 0xFD
1030E  199F     XORWF 0x9F, W, BANKED
10310  6EC2     MOVWF 0xFC2, ACCESS
758:           					putc1(0xFE); // send position report header to host
10312  0EFE     MOVLW 0xFE
10314  EC18     CALL 0x13430, 0
10316  F09A     NOP
759:           					if (screen_type == DELL_E215546) {
10318  0105     MOVLB 0x5
1031A  51E3     MOVF 0xE3, W, BANKED
1031C  A4D8     BTFSS 0xFD8, 2, ACCESS
1031E  D071     BRA 0x402
760:           						ssreport.tohost = true; // ISR flag
10320  0E01     MOVLW 0x1
10322  0106     MOVLB 0x6
10324  6FA2     MOVWF 0xA2, BANKED
761:           						rez_parm_h = ((float) (ssreport.x_cord)) * rez_scale_h_ss;
10326  C69B     MOVFF 0x69B, InterruptHandler
10328  F506     NOP
1032A  C69C     MOVFF 0x69C, c
1032C  F507     NOP
1032E  6A08     CLRF 0x8, ACCESS
10330  6A09     CLRF 0x9, ACCESS
10332  0E00     MOVLW 0x0
10334  EC47     CALL 0x11C8E, 0
10336  F08E     NOP
10338  C506     MOVFF InterruptHandler, i
1033A  F514     NOP
1033C  C507     MOVFF c, len
1033E  F515     NOP
10340  C508     MOVFF blockSize, counter
10342  F516     NOP
10344  C509     MOVFF td, sign
10346  F517     NOP
10348  C7E0     MOVFF __pcstackBANK7, a
1034A  F518     NOP
1034C  C7E1     MOVFF 0x7E1, len
1034E  F519     NOP
10350  C7E2     MOVFF 0x7E2, p
10352  F51A     NOP
10354  C7E3     MOVFF 0x7E3, i
10356  F51B     NOP
10358  EC5D     CALL 0x110BA, 0
1035A  F088     NOP
1035C  C514     MOVFF i, rez_parm_h
1035E  F7F0     NOP
10360  C515     MOVFF len, 0x7F1
10362  F7F1     NOP
10364  C516     MOVFF counter, 0x7F2
10366  F7F2     NOP
10368  C517     MOVFF sign, 0x7F3
1036A  F7F3     NOP
762:           						rez_parm_v = ((float) (ssreport.y_cord)) * rez_scale_v_ss;
1036C  C69D     MOVFF 0x69D, InterruptHandler
1036E  F506     NOP
10370  C69E     MOVFF 0x69E, c
10372  F507     NOP
10374  6A08     CLRF 0x8, ACCESS
10376  6A09     CLRF 0x9, ACCESS
10378  0E00     MOVLW 0x0
1037A  EC47     CALL 0x11C8E, 0
1037C  F08E     NOP
1037E  C506     MOVFF InterruptHandler, i
10380  F514     NOP
10382  C507     MOVFF c, len
10384  F515     NOP
10386  C508     MOVFF blockSize, counter
10388  F516     NOP
1038A  C509     MOVFF td, sign
1038C  F517     NOP
1038E  C7E4     MOVFF rez_scale_v_ss, a
10390  F518     NOP
10392  C7E5     MOVFF 0x7E5, len
10394  F519     NOP
10396  C7E6     MOVFF 0x7E6, p
10398  F51A     NOP
1039A  C7E7     MOVFF 0x7E7, i
1039C  F51B     NOP
1039E  EC5D     CALL 0x110BA, 0
103A0  F088     NOP
103A2  C514     MOVFF i, rez_parm_v
103A4  F7F4     NOP
103A6  C515     MOVFF len, 0x7F5
103A8  F7F5     NOP
103AA  C516     MOVFF counter, 0x7F6
103AC  F7F6     NOP
103AE  C517     MOVFF sign, 0x7F7
103B0  F7F7     NOP
763:           						ssreport.tohost = false;
103B2  0E00     MOVLW 0x0
103B4  0106     MOVLB 0x6
103B6  6FA2     MOVWF 0xA2, BANKED
764:           						scaled_char = ((uint8_t) (rez_parm_h));
103B8  C7F0     MOVFF rez_parm_h, f1
103BA  F52D     NOP
103BC  C7F1     MOVFF 0x7F1, 0x52E
103BE  F52E     NOP
103C0  C7F2     MOVFF 0x7F2, 0x52F
103C2  F52F     NOP
103C4  C7F3     MOVFF 0x7F3, 0x530
103C6  F530     NOP
103C8  ECA6     CALL 0x1214C, 0
103CA  F090     NOP
103CC  502D     MOVF 0x2D, W, ACCESS
103CE  0107     MOVLB 0x7
103D0  6FF8     MOVWF DMAnSSZH, BANKED
765:           						elobuf[0] = scaled_char;
103D2  C7F8     MOVFF scaled_char, elobuf
103D4  F600     NOP
766:           						putc1(scaled_char); // send h scaled touch coord
103D6  51F8     MOVF DMAnSSZH, W, BANKED
103D8  EC18     CALL 0x13430, 0
103DA  F09A     NOP
767:           						scaled_char = ((uint8_t) (rez_parm_v));
103DC  C7F4     MOVFF rez_parm_v, f1
103DE  F52D     NOP
103E0  C7F5     MOVFF 0x7F5, 0x52E
103E2  F52E     NOP
103E4  C7F6     MOVFF 0x7F6, 0x52F
103E6  F52F     NOP
103E8  C7F7     MOVFF 0x7F7, 0x530
103EA  F530     NOP
103EC  ECA6     CALL 0x1214C, 0
103EE  F090     NOP
103F0  502D     MOVF 0x2D, W, ACCESS
103F2  0107     MOVLB 0x7
103F4  6FF8     MOVWF DMAnSSZH, BANKED
768:           						elobuf[1] = scaled_char;
103F6  C7F8     MOVFF scaled_char, 0x601
103F8  F601     NOP
769:           						putc1(scaled_char); // send v scaled touch coord
103FA  51F8     MOVF DMAnSSZH, W, BANKED
103FC  EC18     CALL 0x13430, 0
103FE  F09A     NOP
770:           					} else {
10400  D06B     BRA 0x4D8
771:           						rez_parm_h = ((float) (elobuf[0])) * rez_scale_h;
10402  0106     MOVLB 0x6
10404  5100     MOVF data, W, BANKED
10406  6E06     MOVWF 0x6, ACCESS
10408  6A07     CLRF 0x7, ACCESS
1040A  6A08     CLRF 0x8, ACCESS
1040C  6A09     CLRF 0x9, ACCESS
1040E  0E00     MOVLW 0x0
10410  EC47     CALL 0x11C8E, 0
10412  F08E     NOP
10414  C506     MOVFF InterruptHandler, i
10416  F514     NOP
10418  C507     MOVFF c, len
1041A  F515     NOP
1041C  C508     MOVFF blockSize, counter
1041E  F516     NOP
10420  C509     MOVFF td, sign
10422  F517     NOP
10424  C7E8     MOVFF rez_scale_h, a
10426  F518     NOP
10428  C7E9     MOVFF 0x7E9, len
1042A  F519     NOP
1042C  C7EA     MOVFF 0x7EA, p
1042E  F51A     NOP
10430  C7EB     MOVFF 0x7EB, i
10432  F51B     NOP
10434  EC5D     CALL 0x110BA, 0
10436  F088     NOP
10438  C514     MOVFF i, rez_parm_h
1043A  F7F0     NOP
1043C  C515     MOVFF len, 0x7F1
1043E  F7F1     NOP
10440  C516     MOVFF counter, 0x7F2
10442  F7F2     NOP
10444  C517     MOVFF sign, 0x7F3
10446  F7F3     NOP
772:           						scaled_char = ((uint8_t) (rez_parm_h));
10448  C7F0     MOVFF rez_parm_h, f1
1044A  F52D     NOP
1044C  C7F1     MOVFF 0x7F1, 0x52E
1044E  F52E     NOP
10450  C7F2     MOVFF 0x7F2, 0x52F
10452  F52F     NOP
10454  C7F3     MOVFF 0x7F3, 0x530
10456  F530     NOP
10458  ECA6     CALL 0x1214C, 0
1045A  F090     NOP
1045C  502D     MOVF 0x2D, W, ACCESS
1045E  0107     MOVLB 0x7
10460  6FF8     MOVWF DMAnSSZH, BANKED
773:           						putc1(scaled_char); // send h scaled touch coord
10462  51F8     MOVF DMAnSSZH, W, BANKED
10464  EC18     CALL 0x13430, 0
10466  F09A     NOP
774:           						rez_parm_v = ((float) (elobuf[1])) * rez_scale_v;
10468  0106     MOVLB 0x6
1046A  5101     MOVF 0x1, W, BANKED
1046C  6E06     MOVWF 0x6, ACCESS
1046E  6A07     CLRF 0x7, ACCESS
10470  6A08     CLRF 0x8, ACCESS
10472  6A09     CLRF 0x9, ACCESS
10474  0E00     MOVLW 0x0
10476  EC47     CALL 0x11C8E, 0
10478  F08E     NOP
1047A  C506     MOVFF InterruptHandler, i
1047C  F514     NOP
1047E  C507     MOVFF c, len
10480  F515     NOP
10482  C508     MOVFF blockSize, counter
10484  F516     NOP
10486  C509     MOVFF td, sign
10488  F517     NOP
1048A  C7EC     MOVFF rez_scale_v, a
1048C  F518     NOP
1048E  C7ED     MOVFF 0x7ED, len
10490  F519     NOP
10492  C7EE     MOVFF 0x7EE, p
10494  F51A     NOP
10496  C7EF     MOVFF 0x7EF, i
10498  F51B     NOP
1049A  EC5D     CALL 0x110BA, 0
1049C  F088     NOP
1049E  C514     MOVFF i, rez_parm_v
104A0  F7F4     NOP
104A2  C515     MOVFF len, 0x7F5
104A4  F7F5     NOP
104A6  C516     MOVFF counter, 0x7F6
104A8  F7F6     NOP
104AA  C517     MOVFF sign, 0x7F7
104AC  F7F7     NOP
775:           						scaled_char = ((uint8_t) (rez_parm_v));
104AE  C7F4     MOVFF rez_parm_v, f1
104B0  F52D     NOP
104B2  C7F5     MOVFF 0x7F5, 0x52E
104B4  F52E     NOP
104B6  C7F6     MOVFF 0x7F6, 0x52F
104B8  F52F     NOP
104BA  C7F7     MOVFF 0x7F7, 0x530
104BC  F530     NOP
104BE  ECA6     CALL 0x1214C, 0
104C0  F090     NOP
104C2  502D     MOVF 0x2D, W, ACCESS
104C4  0107     MOVLB 0x7
104C6  6FF8     MOVWF DMAnSSZH, BANKED
776:           						putc1(scaled_char); // send v scaled touch coord
104C8  51F8     MOVF DMAnSSZH, W, BANKED
104CA  EC18     CALL 0x13430, 0
104CC  F09A     NOP
777:           						S.c_idx = 0;
104CE  0E00     MOVLW 0x0
104D0  0106     MOVLB 0x6
104D2  6FC1     MOVWF 0xC1, BANKED
104D4  0E00     MOVLW 0x0
104D6  6FC0     MOVWF 0xC0, BANKED
778:           					}
779:           					putc1(0xFF); // send end of report to host
104D8  0EFF     MOVLW 0xFF
104DA  EC18     CALL 0x13430, 0
104DC  F09A     NOP
780:           					status.touch_count++;
104DE  0E01     MOVLW 0x1
104E0  0106     MOVLB 0x6
104E2  2744     ADDWF NVMADRH, F, BANKED
104E4  0E00     MOVLW 0x0
104E6  2345     ADDWFC NVMADRU, F, BANKED
104E8  2346     ADDWFC NVMDAT, F, BANKED
104EA  2347     ADDWFC NVMDATH, F, BANKED
781:           					S.CATCH = false;
104EC  0E00     MOVLW 0x0
104EE  6FB4     MOVWF PRLOCK, BANKED
782:           					S.CATCH46 = false;
104F0  0E00     MOVLW 0x0
104F2  6FBA     MOVWF DMA5PR, BANKED
783:           				} else { // just send status
104F4  D00E     BRA 0x512
784:           					putc1(0xF5); // send status report
104F6  0EF5     MOVLW 0xF5
104F8  EC18     CALL 0x13430, 0
104FA  F09A     NOP
785:           					putc1(0xFF); // end of report
104FC  0EFF     MOVLW 0xFF
104FE  EC18     CALL 0x13430, 0
10500  F09A     NOP
786:           					status.status_count++;
10502  0E01     MOVLW 0x1
10504  0106     MOVLB 0x6
10506  2750     ADDWF 0x50, F, BANKED
10508  0E00     MOVLW 0x0
1050A  2351     ADDWFC 0x51, F, BANKED
1050C  2352     ADDWFC 0x52, F, BANKED
1050E  2353     ADDWFC 0x53, F, BANKED
10510  D7EF     BRA 0x4F0
787:           					S.CATCH46 = false;
788:           				};
789:           			};
790:           
791:           			if (S.CATCH37) { // send screen size codes
10512  51BB     MOVF DMA6PR, W, BANKED
10514  B4D8     BTFSC 0xFD8, 2, ACCESS
10516  D03D     BRA 0x592
792:           				rez_scale_h = 1.0; // LCD touch screen real H/V rez
10518  0E00     MOVLW 0x0
1051A  0107     MOVLB 0x7
1051C  6FE8     MOVWF DMASELECT, BANKED
1051E  0E00     MOVLW 0x0
10520  6FE9     MOVWF DMAnBUF, BANKED
10522  0E80     MOVLW 0x80
10524  6FEA     MOVWF DMAnDCNT, BANKED
10526  0E3F     MOVLW 0x3F
10528  6FEB     MOVWF DMAnDCNTH, BANKED
793:           				rez_scale_v = 1.0;
1052A  0E00     MOVLW 0x0
1052C  6FEC     MOVWF DMAnDPTR, BANKED
1052E  0E00     MOVLW 0x0
10530  6FED     MOVWF DMAnDPTRH, BANKED
10532  0E80     MOVLW 0x80
10534  6FEE     MOVWF DMAnDSZ, BANKED
10536  0E3F     MOVLW 0x3F
10538  6FEF     MOVWF DMAnDSZH, BANKED
794:           				if (!(screen_type == DELL_E215546)) {
1053A  0105     MOVLB 0x5
1053C  51E3     MOVF 0xE3, W, BANKED
1053E  B4D8     BTFSC 0xFD8, 2, ACCESS
10540  D003     BRA 0x548
795:           					putc2(0x3D); // send clear buffer to touch
10542  0E3D     MOVLW 0x3D
10544  EC0E     CALL 0x1341C, 0
10546  F09A     NOP
796:           				}
797:           
798:           				putc1(0xF4); // send status report
10548  0EF4     MOVLW 0xF4
1054A  EC18     CALL 0x13430, 0
1054C  F09A     NOP
799:           				if (S.ts_type == OEM_CRT) { // CRT type screens
1054E  0106     MOVLB 0x6
10550  51C2     MOVF 0xC2, W, BANKED
10552  11C3     IORWF 0xC3, W, BANKED
10554  A4D8     BTFSS 0xFD8, 2, ACCESS
10556  D006     BRA 0x564
800:           					putc1(0x77); // touch parm
10558  0E77     MOVLW 0x77
1055A  EC18     CALL 0x13430, 0
1055C  F09A     NOP
801:           					putc1(0x5f); // touch parm
1055E  0E5F     MOVLW 0x5F
10560  EC18     CALL 0x13430, 0
10562  F09A     NOP
802:           				}
803:           				if (S.ts_type == OEM_LCD) { // new LCD type screens
10564  0106     MOVLB 0x6
10566  05C2     DECF 0xC2, W, BANKED
10568  11C3     IORWF 0xC3, W, BANKED
1056A  A4D8     BTFSS 0xFD8, 2, ACCESS
1056C  D006     BRA 0x57A
804:           					putc1(0x71); // touch parm 113
1056E  0E71     MOVLW 0x71
10570  EC18     CALL 0x13430, 0
10572  F09A     NOP
805:           					putc1(0x59); // touch parm 89
10574  0E59     MOVLW 0x59
10576  EC18     CALL 0x13430, 0
10578  F09A     NOP
806:           				}
807:           				putc1(0xFF); // end of report
1057A  0EFF     MOVLW 0xFF
1057C  EC18     CALL 0x13430, 0
1057E  F09A     NOP
808:           				status.resync_count++;
10580  0E01     MOVLW 0x1
10582  0106     MOVLB 0x6
10584  2748     ADDWF VREGCON, F, BANKED
10586  0E00     MOVLW 0x0
10588  2349     ADDWFC BORCON, F, BANKED
1058A  234A     ADDWFC HLVDCON0, F, BANKED
1058C  234B     ADDWFC HLVDCON1, F, BANKED
809:           				S.CATCH37 = false;
1058E  0E00     MOVLW 0x0
10590  6FBB     MOVWF DMA6PR, BANKED
810:           			};
811:           
812:           			if (S.TOUCH) {
813:           				// do nothing now.
814:           			};
815:           
816:           			ClrWdt(); // reset the WDT timer
10592  0004     CLRWDT
10594  D605     BRA 0x1A0
817:           		}
818:           	}
819:           
820:           	if (emulat_type == VIISION) {
10596  51E2     MOVF 0xE2, W, BANKED
10598  A4D8     BTFSS 0xFD8, 2, ACCESS
1059A  D031     BRA 0x5FE
821:           		/* Loop forever */
822:           		while (true) { // busy loop
823:           			rxtx_handler();
1059C  EC37     CALL 0x1066E, 0
1059E  F083     NOP
824:           			if (j++ >= BLINK_RATE_V80) { // delay a bit ok
105A0  C5A8     MOVFF j, 0x59F
105A2  F59F     NOP
105A4  C5A9     MOVFF 0x5A9, 0x5A0
105A6  F5A0     NOP
105A8  C5AA     MOVFF 0x5AA, 0x5A1
105AA  F5A1     NOP
105AC  C5AB     MOVFF 0x5AB, 0x5A2
105AE  F5A2     NOP
105B0  0105     MOVLB 0x5
105B2  2BA8     INCF 0xA8, F, BANKED
105B4  0E00     MOVLW 0x0
105B6  23A9     ADDWFC 0xA9, F, BANKED
105B8  23AA     ADDWFC 0xAA, F, BANKED
105BA  23AB     ADDWFC 0xAB, F, BANKED
105BC  BFA2     BTFSC 0xA2, 7, BANKED
105BE  D01D     BRA 0x5FA
105C0  51A2     MOVF 0xA2, W, BANKED
105C2  11A1     IORWF 0xA1, W, BANKED
105C4  E106     BNZ 0x5D2
105C6  0EA8     MOVLW 0xA8
105C8  5D9F     SUBWF 0x9F, W, BANKED
105CA  0E61     MOVLW 0x61
105CC  59A0     SUBWFB 0xA0, W, BANKED
105CE  A0D8     BTFSS 0xFD8, 0, ACCESS
105D0  D014     BRA 0x5FA
825:           				BLED_Toggle(); // flash external led
105D2  A0C2     BTFSS 0xFC2, 0, ACCESS
105D4  D002     BRA 0x5DA
105D6  0E01     MOVLW 0x1
105D8  D001     BRA 0x5DC
105DA  0E00     MOVLW 0x0
105DC  0AFF     XORLW 0xFF
105DE  6F9F     MOVWF 0x9F, BANKED
105E0  50C2     MOVF 0xFC2, W, ACCESS
105E2  199F     XORWF 0x9F, W, BANKED
105E4  0BFE     ANDLW 0xFE
105E6  199F     XORWF 0x9F, W, BANKED
105E8  6EC2     MOVWF 0xFC2, ACCESS
826:           				if (S.LCD_OK) { // screen status feedback
827:           				} else {
828:           				}
829:           				j = 0;
105EA  0E00     MOVLW 0x0
105EC  6FA8     MOVWF 0xA8, BANKED
105EE  0E00     MOVLW 0x0
105F0  6FA9     MOVWF 0xA9, BANKED
105F2  0E00     MOVLW 0x0
105F4  6FAA     MOVWF 0xAA, BANKED
105F6  0E00     MOVLW 0x0
105F8  6FAB     MOVWF 0xAB, BANKED
830:           			}
831:           
832:           			ClrWdt(); // reset the WDT timer
105FA  0004     CLRWDT
105FC  D7CF     BRA 0x59C
833:           		}
834:           	}
835:           
836:           	if (emulat_type == OTHER_MECH) {
105FE  0E02     MOVLW 0x2
10600  19E2     XORWF 0xE2, W, BANKED
10602  A4D8     BTFSS 0xFD8, 2, ACCESS
10604  D031     BRA 0x668
837:           		/* Loop forever */
838:           		while (true) { // busy loop BSG style
839:           			rxtx_handler();
10606  EC37     CALL 0x1066E, 0
10608  F083     NOP
840:           			if (j++ >= BLINK_RATE_OTHER) { // delay a bit ok
1060A  C5A8     MOVFF j, 0x59F
1060C  F59F     NOP
1060E  C5A9     MOVFF 0x5A9, 0x5A0
10610  F5A0     NOP
10612  C5AA     MOVFF 0x5AA, 0x5A1
10614  F5A1     NOP
10616  C5AB     MOVFF 0x5AB, 0x5A2
10618  F5A2     NOP
1061A  0105     MOVLB 0x5
1061C  2BA8     INCF 0xA8, F, BANKED
1061E  0E00     MOVLW 0x0
10620  23A9     ADDWFC 0xA9, F, BANKED
10622  23AA     ADDWFC 0xAA, F, BANKED
10624  23AB     ADDWFC 0xAB, F, BANKED
10626  BFA2     BTFSC 0xA2, 7, BANKED
10628  D01D     BRA 0x664
1062A  51A2     MOVF 0xA2, W, BANKED
1062C  11A1     IORWF 0xA1, W, BANKED
1062E  E106     BNZ 0x63C
10630  0E98     MOVLW 0x98
10632  5D9F     SUBWF 0x9F, W, BANKED
10634  0E3A     MOVLW 0x3A
10636  59A0     SUBWFB 0xA0, W, BANKED
10638  A0D8     BTFSS 0xFD8, 0, ACCESS
1063A  D014     BRA 0x664
841:           				BLED_Toggle(); // flash external led
1063C  A0C2     BTFSS 0xFC2, 0, ACCESS
1063E  D002     BRA 0x644
10640  0E01     MOVLW 0x1
10642  D001     BRA 0x646
10644  0E00     MOVLW 0x0
10646  0AFF     XORLW 0xFF
10648  6F9F     MOVWF 0x9F, BANKED
1064A  50C2     MOVF 0xFC2, W, ACCESS
1064C  199F     XORWF 0x9F, W, BANKED
1064E  0BFE     ANDLW 0xFE
10650  199F     XORWF 0x9F, W, BANKED
10652  6EC2     MOVWF 0xFC2, ACCESS
842:           				j = 0;
10654  0E00     MOVLW 0x0
10656  6FA8     MOVWF 0xA8, BANKED
10658  0E00     MOVLW 0x0
1065A  6FA9     MOVWF 0xA9, BANKED
1065C  0E00     MOVLW 0x0
1065E  6FAA     MOVWF 0xAA, BANKED
10660  0E00     MOVLW 0x0
10662  6FAB     MOVWF 0xAB, BANKED
843:           			}
844:           			ClrWdt(); // reset the WDT timer
10664  0004     CLRWDT
10666  D7CF     BRA 0x606
845:           		}
846:           	}
847:           
848:           	while (true) {
849:           		// Add your application code
850:           		rxtx_handler();
10668  EC37     CALL 0x1066E, 0
1066A  F083     NOP
1066C  D7FD     BRA 0x668
851:           	}
852:           }
853:           
854:           /*
855:            * This runs in the timer5 ISR
856:            */
857:           void led_flash(void)
858:           {
859:           	LED2_Toggle();
133B8  A2C1     BTFSS 0xFC1, 1, ACCESS
133BA  D002     BRA 0x33C0
133BC  0E01     MOVLW 0x1
133BE  D001     BRA 0x33C2
133C0  0E00     MOVLW 0x0
133C2  0AFF     XORLW 0xFF
133C4  6E01     MOVWF 0x1, ACCESS
133C6  4601     RLNCF 0x1, F, ACCESS
133C8  50C1     MOVF 0xFC1, W, ACCESS
133CA  1801     XORWF 0x1, W, ACCESS
133CC  0BFD     ANDLW 0xFD
133CE  1801     XORWF 0x1, W, ACCESS
133D0  6EC1     MOVWF 0xFC1, ACCESS
860:           }
13268  0105     MOVLB 0x5
1326A  51C7     MOVF 0xC7, W, BANKED
1326C  11C8     IORWF 0xC8, W, BANKED
1326E  11C9     IORWF 0xC9, W, BANKED
13270  B4D8     BTFSC 0xFD8, 2, ACCESS
13272  0011     RETFIE 1
133D2  0012     RETURN 0
861:           /**
862:            End of File
863:            */
---  /root/MPLABXProjects/vtouch_v2/q43_board/q43_baseline.X/eadog.c  -----------------------------------
1:             #include <string.h>
2:             #include "qconfig.h"
3:             #include "eadog.h"
4:             #include "ringbufs.h"
5:             #include "mcc_generated_files/dma1.h"
6:             #include "mcc_generated_files/dma2.h"
7:             
8:             #define max_strlen	21
9:             #define max_port_data	1024
10:            
11:            volatile struct spi_link_type spi_link;
12:            struct ringBufS_t ring_buf1;
13:            static uint8_t port_data[max_port_data] = {255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0};
14:            
15:            static void send_lcd_cmd_long(uint8_t); // for display init only
16:            static void send_lcd_data(uint8_t);
17:            static void send_lcd_cmd(uint8_t);
18:            
19:            void wdtdelay(uint32_t delay)
20:            {
21:            	static uint32_t dcount;
22:            
23:            	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
12F0E  0E00     MOVLW 0x0
12F10  0106     MOVLB 0x6
12F12  6FA3     MOVWF 0xA3, BANKED
12F14  0E00     MOVLW 0x0
12F16  6FA4     MOVWF 0xA4, BANKED
12F18  0E00     MOVLW 0x0
12F1A  6FA5     MOVWF 0xA5, BANKED
12F1C  0E00     MOVLW 0x0
12F1E  6FA6     MOVWF 0xA6, BANKED
12F20  D009     BRA 0x2F34
24:            		Nop();
12F22  F000     NOP
25:            		ClrWdt(); // reset the WDT timer
12F24  0004     CLRWDT
26:            	};
12F26  0E01     MOVLW 0x1
12F28  0106     MOVLB 0x6
12F2A  27A3     ADDWF 0xA3, F, BANKED
12F2C  0E00     MOVLW 0x0
12F2E  23A4     ADDWFC 0xA4, F, BANKED
12F30  23A5     ADDWFC 0xA5, F, BANKED
12F32  23A6     ADDWFC 0xA6, F, BANKED
12F34  51A3     MOVF 0xA3, W, BANKED
12F36  5C06     SUBWF 0x6, W, ACCESS
12F38  51A4     MOVF 0xA4, W, BANKED
12F3A  5807     SUBWFB 0x7, W, ACCESS
12F3C  51A5     MOVF 0xA5, W, BANKED
12F3E  5808     SUBWFB 0x8, W, ACCESS
12F40  51A6     MOVF 0xA6, W, BANKED
12F42  5809     SUBWFB 0x9, W, ACCESS
12F44  A0D8     BTFSS 0xFD8, 0, ACCESS
12F46  0012     RETURN 0
12F48  D7EC     BRA 0x2F22
27:            }
28:            
29:            /*
30:             * Init the NHD-0420D3Z-NSW-BBW-V3 in 8-bit serial mode
31:             * channel 1 DMA
32:             */
33:            void init_display(void)
34:            {
35:            	spi_link.tx1a = &ring_buf1;
125EE  0E80     MOVLW 0x80
125F0  0106     MOVLB 0x6
125F2  6F93     MOVWF SPI2CON2, BANKED
125F4  0E09     MOVLW 0x9
125F6  6F94     MOVWF SPI2STATUS, BANKED
36:            	ringBufS_init(spi_link.tx1a);
125F8  C693     MOVFF 0x693, sum
125FA  F512     NOP
125FC  C694     MOVFF 0x694, c
125FE  F513     NOP
12600  ECBE     CALL 0x1337C, 0
12602  F099     NOP
37:            
38:            #ifdef DEBUG_DISP2
39:            	DLED2 = true;
40:            #endif
41:            #ifdef NHD
42:            	wdtdelay(350000); // > 400ms power up delay
12604  0E30     MOVLW 0x30
12606  6E06     MOVWF 0x6, ACCESS
12608  0E57     MOVLW 0x57
1260A  6E07     MOVWF 0x7, ACCESS
1260C  0E05     MOVLW 0x5
1260E  6E08     MOVWF 0x8, ACCESS
12610  0E00     MOVLW 0x0
12612  6E09     MOVWF 0x9, ACCESS
12614  EC87     CALL 0x12F0E, 0
12616  F097     NOP
43:            	send_lcd_cmd(0x46); // home cursor
12618  0E46     MOVLW 0x46
1261A  ECA5     CALL 0x12F4A, 0
1261C  F097     NOP
44:            	wdtdelay(800);
1261E  0E20     MOVLW 0x20
12620  6E06     MOVWF 0x6, ACCESS
12622  0E03     MOVLW 0x3
12624  6E07     MOVWF 0x7, ACCESS
12626  0E00     MOVLW 0x0
12628  6E08     MOVWF 0x8, ACCESS
1262A  0E00     MOVLW 0x0
1262C  6E09     MOVWF 0x9, ACCESS
1262E  EC87     CALL 0x12F0E, 0
12630  F097     NOP
45:            	send_lcd_cmd(0x41); // display on
12632  0E41     MOVLW 0x41
12634  ECA5     CALL 0x12F4A, 0
12636  F097     NOP
46:            	wdtdelay(80);
12638  0E50     MOVLW 0x50
1263A  6E06     MOVWF 0x6, ACCESS
1263C  0E00     MOVLW 0x0
1263E  6E07     MOVWF 0x7, ACCESS
12640  0E00     MOVLW 0x0
12642  6E08     MOVWF 0x8, ACCESS
12644  0E00     MOVLW 0x0
12646  6E09     MOVWF 0x9, ACCESS
12648  EC87     CALL 0x12F0E, 0
1264A  F097     NOP
47:            	send_lcd_cmd(0x53); // set back-light level
1264C  0E53     MOVLW 0x53
1264E  ECA5     CALL 0x12F4A, 0
12650  F097     NOP
48:            	send_lcd_data(NHD_BL_LOW);
12652  0E02     MOVLW 0x2
12654  EC9E     CALL 0x1333C, 0
12656  F099     NOP
49:            	wdtdelay(80);
12658  0E50     MOVLW 0x50
1265A  6E06     MOVWF 0x6, ACCESS
1265C  0E00     MOVLW 0x0
1265E  6E07     MOVWF 0x7, ACCESS
12660  0E00     MOVLW 0x0
12662  6E08     MOVWF 0x8, ACCESS
12664  0E00     MOVLW 0x0
12666  6E09     MOVWF 0x9, ACCESS
12668  EC87     CALL 0x12F0E, 0
1266A  F097     NOP
50:            	send_lcd_cmd(0x51); // clear screen
1266C  0E51     MOVLW 0x51
1266E  ECA5     CALL 0x12F4A, 0
12670  F097     NOP
51:            	wdtdelay(800);
12672  0E20     MOVLW 0x20
12674  6E06     MOVWF 0x6, ACCESS
12676  0E03     MOVLW 0x3
12678  6E07     MOVWF 0x7, ACCESS
1267A  0E00     MOVLW 0x0
1267C  6E08     MOVWF 0x8, ACCESS
1267E  0E00     MOVLW 0x0
12680  6E09     MOVWF 0x9, ACCESS
12682  EC87     CALL 0x12F0E, 0
12684  F097     NOP
52:            
53:            #else
54:            	CSB_SetHigh();
55:            	wdtdelay(350000); // > 400ms power up delay
56:            	send_lcd_cmd_dma(0x39);
57:            	send_lcd_cmd_dma(0x1d);
58:            	send_lcd_cmd_dma(0x50);
59:            	send_lcd_cmd_dma(0x6c);
60:            	send_lcd_cmd_dma(0x76); // contrast last 4 bits
61:            	send_lcd_cmd_dma(0x38); // follower control
62:            	wdtdelay(800);
63:            	send_lcd_cmd_dma(0x0f);
64:            	send_lcd_cmd_dma(0x01); // clear
65:            	wdtdelay(800);
66:            	send_lcd_cmd_dma(0x02);
67:            	send_lcd_cmd_dma(0x06);
68:            	wdtdelay(30);
69:            	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
70:            #endif
71:            	//	SPI1INTFbits.SPI1TXUIF = 0;
72:            	//	DMA1CON1bits.DMODE = 0;
73:            	//	DMA1CON1bits.DSTP = 0;
74:            	//	DMA1CON1bits.SMODE = 1;
75:            	//	DMA1CON1bits.SMR = 0;
76:            	//	DMA1CON1bits.SSTP = 1;
77:            	//	DMA1SSA = (uint32_t) & ring_buf1;
78:            	//	DMA1CON0bits.DGO = 0;
79:            	//	SPI1INTFbits.SPI1TXUIF = 1;
80:            #ifdef DEBUG_DISP2
81:            	DLED2 = false;
82:            #endif
83:            #ifdef USE_DMA
84:            	DMA1_SetSCNTIInterruptHandler(clear_lcd_done);
85:            	DMA2_SetDCNTIInterruptHandler(spi_rec_done);
86:            #endif
87:            }
12686  0012     RETURN 0
88:            
89:            /*
90:             * channel DMA
91:             */
92:            void init_port_dma(void)
93:            {
94:            }
95:            
96:            #ifdef NHD
97:            
98:            /*
99:             * R2 short on LCD NHD-0420D3Z-NSW-BBW-V3 board
100:            */
101:           
102:           static void send_lcd_data(const uint8_t data)
1333C  6E0A     MOVWF 0xA, ACCESS
103:           {
104:           	CSB_SetLow();
1333E  94C0     BCF 0xFC0, 2, ACCESS
105:           	SPI1_ExchangeByte(data);
13340  500A     MOVF 0xA, W, ACCESS
13342  ECF7     CALL 0x133EE, 0
13344  F099     NOP
106:           	wdtdelay(8);
13346  0E08     MOVLW 0x8
13348  6E06     MOVWF 0x6, ACCESS
1334A  0E00     MOVLW 0x0
1334C  6E07     MOVWF 0x7, ACCESS
1334E  0E00     MOVLW 0x0
13350  6E08     MOVWF 0x8, ACCESS
13352  0E00     MOVLW 0x0
13354  6E09     MOVWF 0x9, ACCESS
13356  EC87     CALL 0x12F0E, 0
13358  F097     NOP
107:           }
1335A  0012     RETURN 0
108:           
109:           static void send_lcd_cmd(const uint8_t cmd)
12F4A  6E0A     MOVWF 0xA, ACCESS
110:           {
111:           	CSB_SetLow();
12F4C  94C0     BCF 0xFC0, 2, ACCESS
112:           	SPI1_ExchangeByte(NHD_CMD);
12F4E  0EFE     MOVLW 0xFE
12F50  ECF7     CALL 0x133EE, 0
12F52  F099     NOP
113:           	wdtdelay(8);
12F54  0E08     MOVLW 0x8
12F56  6E06     MOVWF 0x6, ACCESS
12F58  0E00     MOVLW 0x0
12F5A  6E07     MOVWF 0x7, ACCESS
12F5C  0E00     MOVLW 0x0
12F5E  6E08     MOVWF 0x8, ACCESS
12F60  0E00     MOVLW 0x0
12F62  6E09     MOVWF 0x9, ACCESS
12F64  EC87     CALL 0x12F0E, 0
12F66  F097     NOP
114:           	SPI1_ExchangeByte(cmd);
12F68  500A     MOVF 0xA, W, ACCESS
12F6A  ECF7     CALL 0x133EE, 0
12F6C  F099     NOP
115:           	wdtdelay(8);
12F6E  0E08     MOVLW 0x8
12F70  6E06     MOVWF 0x6, ACCESS
12F72  0E00     MOVLW 0x0
12F74  6E07     MOVWF 0x7, ACCESS
12F76  0E00     MOVLW 0x0
12F78  6E08     MOVWF 0x8, ACCESS
12F7A  0E00     MOVLW 0x0
12F7C  6E09     MOVWF 0x9, ACCESS
12F7E  EC87     CALL 0x12F0E, 0
12F80  F097     NOP
116:           }
12F82  0012     RETURN 0
117:           
118:           static void send_lcd_cmd_long(const uint8_t cmd)
119:           {
120:           	CSB_SetLow();
121:           	SPI1_ExchangeByte(NHD_CMD);
122:           	wdtdelay(8);
123:           	SPI1_ExchangeByte(cmd);
124:           	wdtdelay(800);
125:           }
126:           
127:           /*
128:            * uses DMA channel 1 for transfers
129:            */
130:           void eaDogM_WriteString(char *strPtr)
131:           {
132:           	uint8_t len = (uint8_t) strlen(strPtr);
12954  C517     MOVFF sign, InterruptHandler
12956  F506     NOP
12958  C518     MOVFF a, c
1295A  F507     NOP
1295C  ECA7     CALL 0x12D4E, 0
1295E  F096     NOP
12960  5006     MOVF 0x6, W, ACCESS
12962  6E19     MOVWF 0x19, ACCESS
133:           
134:           #ifdef DEBUG_DISP1
135:           	DLED1 = true;
136:           #endif
137:           	wait_lcd_done();
12964  ECB2     CALL 0x13564, 0
12966  F09A     NOP
138:           	wait_lcd_set();
12968  ECB6     CALL 0x1356C, 0
1296A  F09A     NOP
139:           	/* reset buffer for DMA */
140:           	ringBufS_flush(spi_link.tx1a, false);
1296C  C693     MOVFF 0x693, sum
1296E  F512     NOP
12970  C694     MOVFF 0x694, c
12972  F513     NOP
12974  0E00     MOVLW 0x0
12976  6E14     MOVWF 0x14, ACCESS
12978  EC96     CALL 0x12B2C, 0
1297A  F095     NOP
141:           	CSB_SetLow(); /* SPI select display */
1297C  94C0     BCF 0xFC0, 2, ACCESS
142:           	if (len > (uint8_t) max_strlen) {
1297E  0E15     MOVLW 0x15
12980  6419     CPFSGT 0x19, ACCESS
12982  D002     BRA 0x2988
143:           		len = max_strlen;
12984  0E15     MOVLW 0x15
12986  6E19     MOVWF 0x19, ACCESS
144:           	}
145:           	ringBufS_put_dma_cpy(spi_link.tx1a, strPtr, len);
12988  C693     MOVFF 0x693, fp
1298A  F511     NOP
1298C  C694     MOVFF 0x694, sum
1298E  F512     NOP
12990  C517     MOVFF sign, c
12992  F513     NOP
12994  C518     MOVFF a, i
12996  F514     NOP
12998  C519     MOVFF len, len
1299A  F515     NOP
1299C  ECC0     CALL 0x12B80, 0
1299E  F095     NOP
146:           #ifdef USE_DMA
147:           	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
148:           	DMA1_SetSourceSize(len);
149:           	DMA1_SetDestinationSize(1);
150:           	DMA2_SetSourceSize(1);
151:           	DMA2_SetDestinationSize(len);
152:           #else
153:           	SPI1_ExchangeBlock(spi_link.tx1a, len);
129A0  C693     MOVFF 0x693, InterruptHandler
129A2  F506     NOP
129A4  C694     MOVFF 0x694, c
129A6  F507     NOP
129A8  C519     MOVFF len, blockSize
129AA  F508     NOP
129AC  6A09     CLRF 0x9, ACCESS
129AE  EC5D     CALL 0x12CBA, 0
129B0  F096     NOP
154:           #endif
155:           	start_lcd(); // start DMA transfer
129B2  ECC2     CALL 0x13584, 0
129B4  F09A     NOP
156:           #ifdef DISPLAY_SLOW
157:           	wdtdelay(9000);
158:           #endif
159:           #ifdef DEBUG_DISP1
160:           	DLED1 = false;
161:           #endif
162:           }
129B6  0012     RETURN 0
163:           
164:           /*
165:            * uses DMA channel 1 for transfers
166:            */
167:           void send_lcd_cmd_dma(const uint8_t strPtr)
168:           {
169:           	wait_lcd_done();
170:           	send_lcd_data_dma(NHD_CMD); //prefix
171:           	wait_lcd_done();
172:           	send_lcd_data_dma(strPtr); // cmd code
173:           	wait_lcd_done();
174:           }
175:           
176:           /*
177:            * uses DMA channel 1 for transfers
178:            */
179:           void send_lcd_data_dma(const uint8_t strPtr)
180:           {
181:           #ifdef DEBUG_DISP2
182:           	DLED2 = true;
183:           #endif
184:           	wait_lcd_set();
185:           	/* reset buffer for DMA */
186:           	ringBufS_flush(spi_link.tx1a, false);
187:           	CSB_SetLow(); /* SPI select display */
188:           	ringBufS_put_dma(spi_link.tx1a, strPtr); // don't use printf to send zeros
189:           #ifdef USE_DMA
190:           	DMA1_SetSourceAddress((uint24_t) spi_link.tx1a);
191:           	DMA1_SetSourceSize(1);
192:           	DMA1_SetDestinationSize(1);
193:           	DMA2_SetSourceSize(1);
194:           	DMA2_SetDestinationSize(1);
195:           #endif
196:           	start_lcd(); // start DMA transfer
197:           #ifdef DEBUG_DISP2
198:           	DLED2 = false;
199:           #endif
200:           }
201:           
202:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
129B8  6E1F     MOVWF 0x1F, ACCESS
203:           {
204:           	uint8_t row;
205:           
206:           	switch (r) {
129BA  D009     BRA 0x29CE
207:           	case 0:
208:           		row = 0x40;
129BC  0E40     MOVLW 0x40
129BE  D005     BRA 0x29CA
209:           		break;
210:           	case 1:
211:           		row = 0x14;
129C0  0E14     MOVLW 0x14
129C2  D003     BRA 0x29CA
212:           		break;
213:           	case 2:
214:           		row = 0x54;
129C4  0E54     MOVLW 0x54
129C6  D001     BRA 0x29CA
215:           		break;
216:           	case 3:
217:           		row = 0x00;
129C8  0E00     MOVLW 0x0
129CA  6E20     MOVWF 0x20, ACCESS
218:           		break;
129CC  D015     BRA 0x29F8
219:           	default:
220:           		row = 0x40;
221:           		break;
222:           	}
129CE  501F     MOVF 0x1F, W, ACCESS
129D0  6E1D     MOVWF 0x1D, ACCESS
129D2  6A1E     CLRF 0x1E, ACCESS
129D4  501E     MOVF 0x1E, W, ACCESS
129D6  0A00     XORLW 0x0
129D8  A4D8     BTFSS 0xFD8, 2, ACCESS
129DA  D7F0     BRA 0x29BC
129DC  501D     MOVF 0x1D, W, ACCESS
129DE  0A00     XORLW 0x0
129E0  B4D8     BTFSC 0xFD8, 2, ACCESS
129E2  D7EC     BRA 0x29BC
129E4  0A01     XORLW 0x1
129E6  B4D8     BTFSC 0xFD8, 2, ACCESS
129E8  D7EB     BRA 0x29C0
129EA  0A03     XORLW 0x3
129EC  B4D8     BTFSC 0xFD8, 2, ACCESS
129EE  D7EA     BRA 0x29C4
129F0  0A01     XORLW 0x1
129F2  B4D8     BTFSC 0xFD8, 2, ACCESS
129F4  D7E9     BRA 0x29C8
129F6  D7E2     BRA 0x29BC
223:           	send_lcd_cmd(0x45);
129F8  0E45     MOVLW 0x45
129FA  ECA5     CALL 0x12F4A, 0
129FC  F097     NOP
224:           	send_lcd_data(row + c);
129FE  5020     MOVF 0x20, W, ACCESS
12A00  241A     ADDWF 0x1A, W, ACCESS
12A02  EC9E     CALL 0x1333C, 0
12A04  F099     NOP
225:           	wait_lcd_done();
12A06  ECB2     CALL 0x13564, 0
12A08  F09A     NOP
226:           	CSB_SetHigh(); /* SPI deselect display */
12A0A  84C0     BSF 0xFC0, 2, ACCESS
227:           	eaDogM_WriteString(strPtr);
12A0C  C51B     MOVFF i, sign
12A0E  F517     NOP
12A10  C51C     MOVFF 0x51C, a
12A12  F518     NOP
12A14  ECAA     CALL 0x12954, 0
12A16  F094     NOP
228:           }
12A18  0012     RETURN 0
229:           
230:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
231:           {
232:           
233:           }
234:           
235:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
236:           {
237:           
238:           }
239:           
240:           void eaDogM_ClearRow(const uint8_t r)
241:           {
242:           
243:           }
244:           
245:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
246:           {
247:           
248:           }
249:           
250:           #else
251:           
252:           /*
253:            * add short spi delay (default)
254:            */
255:           static void send_lcd_data(const uint8_t data)
256:           {
257:           	RS_SetHigh();
258:           	CSB_SetLow();
259:           	SPI1_Exchange8bit(data);
260:           	wdtdelay(8);
261:           }
262:           
263:           /*
264:            * add inst spi delay
265:            */
266:           static void send_lcd_cmd(const uint8_t cmd)
267:           {
268:           	RS_SetLow();
269:           	CSB_SetLow();
270:           	SPI1_Exchange8bit(cmd);
271:           	wdtdelay(30);
272:           	RS_SetHigh();
273:           }
274:           
275:           /*
276:            * add clear/home spi delay
277:            */
278:           static void send_lcd_cmd_long(const uint8_t cmd)
279:           {
280:           	RS_SetLow();
281:           	CSB_SetLow();
282:           	SPI1_Exchange8bit(cmd);
283:           	wdtdelay(800);
284:           	RS_SetHigh();
285:           }
286:           
287:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
288:           {
289:           	uint8_t cmdPos;
290:           	cmdPos = (uint8_t) EADOGM_CMD_DDRAM_ADDR + (uint8_t) ((uint8_t) r * (uint8_t) EADOGM_COLSPAN) + (uint8_t) c;
291:           	eaDogM_WriteCommand(cmdPos);
292:           }
293:           
294:           void eaDogM_ClearRow(const uint8_t r)
295:           {
296:           	uint8_t i;
297:           	eaDogM_SetPos(r, 0);
298:           	for (i = 0; i < EADOGM_COLSPAN; i++) {
299:           		eaDogM_WriteChr(' ');
300:           	}
301:           }
302:           
303:           /*
304:            * uses DMA channel 1 for transfers
305:            */
306:           void eaDogM_WriteString(char *strPtr)
307:           {
308:           	wait_lcd_set();
309:           	/* reset buffer for DMA */
310:           	ringBufS_flush(spi_link.tx1a, false);
311:           	CSB_SetLow(); /* SPI select display */
312:           	if (strlen(strPtr) > max_strlen) {
313:           		strPtr[max_strlen] = 0; // buffer overflow check
314:           	}
315:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
316:           	DMA1SSZ = strlen(strPtr);
317:           	DMA1CON0bits.EN = 1; /* enable DMA */
318:           	printf("%s", strPtr); // testing copy method using STDIO redirect to buffer
319:           	start_lcd();
320:           #ifdef DISPLAY_SLOW
321:           	wdtdelay(9000);
322:           #endif
323:           }
324:           
325:           /*
326:            * uses DMA channel 1 for transfers
327:            */
328:           void send_lcd_cmd_dma(uint8_t strPtr)
329:           {
330:           	wait_lcd_set();
331:           	/* reset buffer for DMA */
332:           	ringBufS_flush(spi_link.tx1a, false);
333:           	RS_SetLow();
334:           	CSB_SetLow(); /* SPI select display */
335:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
336:           	DMA1SSZ = 1;
337:           	DMA1CON0bits.EN = 1; /* enable DMA */
338:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
339:           	start_lcd();
340:           	wait_lcd_done();
341:           	RS_SetHigh();
342:           }
343:           
344:           /*
345:            * uses DMA channel 1 for transfers
346:            */
347:           void send_lcd_data_dma(uint8_t strPtr)
348:           {
349:           	wait_lcd_set();
350:           	/* reset buffer for DMA */
351:           	ringBufS_flush(spi_link.tx1a, false);
352:           	RS_SetHigh();
353:           	CSB_SetLow(); /* SPI select display */
354:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
355:           	DMA1SSZ = 1;
356:           	DMA1CON0bits.EN = 1; /* enable DMA */
357:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
358:           	start_lcd();
359:           }
360:           
361:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
362:           {
363:           	send_lcd_cmd_dma((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
364:           	eaDogM_WriteString(strPtr);
365:           }
366:           
367:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
368:           {
369:           	eaDogM_WriteCommand((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
370:           
371:           	eaDogM_WriteChr(i / 10 + '0');
372:           	eaDogM_WriteChr(i % 10 + '0');
373:           
374:           }
375:           
376:           // this writes a byte to the internal CGRAM (v2.02)
377:           // format for ndx: 00CCCRRR = CCC = character 0 to 7, RRR = row 0 to 7
378:           
379:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
380:           {
381:           	uint8_t cmd;
382:           
383:           	cmd = ndx & 0b00111111; // mask off upper to bits
384:           	cmd = cmd | EADOGM_CMD_CGRAM_ADDR; // set bit cmd bits
385:           
386:           	eaDogM_WriteCommand(cmd);
387:           	eaDogM_WriteChr(data);
388:           
389:           	// this is done to make sure we are back in data mode
390:           	eaDogM_SetPos(0, 0);
391:           }
392:           #endif
393:           
394:           void eaDogM_WriteCommand(const uint8_t cmd)
395:           {
396:           	send_lcd_cmd(cmd);
397:           }
398:           
399:           void eaDogM_WriteChr(const int8_t value)
400:           {
401:           	send_lcd_data((uint8_t) value);
402:           }
403:           
404:           /*
405:            * uses DMA channel 2 for transfers
406:            */
407:           void send_port_data_dma(uint16_t dsize)
408:           {
409:           	if (dsize > max_port_data) {
410:           		dsize = max_port_data;
411:           	}
412:           }
413:           
414:           /*
415:            * return pointer to internal data buffer for DMA
416:            */
417:           uint8_t* port_data_dma_ptr(void)
418:           {
419:           	return port_data;
420:           }
421:           
422:           /*
423:            * Trigger the SPI DMA transfer to the LCD display
424:            */
425:           void start_lcd(void)
426:           {
427:           #ifdef USE_DMA
428:           	DMA2_StartTransferWithTrigger();
429:           	DMA1_StartTransfer();
430:           #endif
431:           }
13584  0012     RETURN 0
432:           
433:           void wait_lcd_set(void)
434:           {
435:           	spi_link.LCD_DATA = true;
1356C  0106     MOVLB 0x6
1356E  878D     BSF SPI2RXB, 3, BANKED
436:           }
13570  0012     RETURN 0
437:           
438:           bool wait_lcd_check(void)
439:           {
440:           	return spi_link.LCD_DATA;
441:           }
442:           
443:           void wait_lcd_done(void)
444:           {
445:           #ifdef USE_DMA
446:           	while (spi_link.LCD_DATA) {
447:           	};
448:           #endif
449:           	while (!SPI1STATUSbits.TXBE) {
13564  0100     MOVLB 0x0
13566  BB87     BTFSC SPI1STATUS, 5, BANKED
13568  0012     RETURN 0
1356A  D7FC     BRA 0x3564
450:           	};
451:           }
452:           
453:           void clear_lcd_done(void)
454:           {
455:           	spi_link.LCD_DATA = false;
456:           }
457:           
458:           void spi_rec_done(void)
459:           {
460:           	DMA2_StopTransfer();
461:           }
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/xxtofl.c  ------------------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
11C8E  6E0E     MOVWF 0xE, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
11C90  500E     MOVF 0xE, W, ACCESS
11C92  A4D8     BTFSS 0xFD8, 2, ACCESS
11C94  AE09     BTFSS 0x9, 7, ACCESS
11C96  D01A     BRA 0x1CCC
16:            		arg = (unsigned long) -val;
11C98  C506     MOVFF InterruptHandler, data
11C9A  F50A     NOP
11C9C  C507     MOVFF c, elostr
11C9E  F50B     NOP
11CA0  C508     MOVFF blockSize, strptr
11CA2  F50C     NOP
11CA4  C509     MOVFF td, d
11CA6  F50D     NOP
11CA8  1E0A     COMF 0xA, F, ACCESS
11CAA  1E0B     COMF 0xB, F, ACCESS
11CAC  1E0C     COMF 0xC, F, ACCESS
11CAE  1E0D     COMF 0xD, F, ACCESS
11CB0  2A0A     INCF 0xA, F, ACCESS
11CB2  0E00     MOVLW 0x0
11CB4  220B     ADDWFC 0xB, F, ACCESS
11CB6  220C     ADDWFC 0xC, F, ACCESS
11CB8  220D     ADDWFC 0xD, F, ACCESS
11CBA  C50A     MOVFF data, arg
11CBC  F510     NOP
11CBE  C50B     MOVFF elostr, fp
11CC0  F511     NOP
11CC2  C50C     MOVFF strptr, sum
11CC4  F512     NOP
11CC6  C50D     MOVFF d, c
11CC8  F513     NOP
17:            	}
11CCA  D008     BRA 0x1CDC
18:            	else {
19:            		arg = (unsigned long) val;
11CCC  C506     MOVFF InterruptHandler, arg
11CCE  F510     NOP
11CD0  C507     MOVFF c, fp
11CD2  F511     NOP
11CD4  C508     MOVFF blockSize, sum
11CD6  F512     NOP
11CD8  C509     MOVFF td, c
11CDA  F513     NOP
20:            	}
21:            	if(val == 0)
11CDC  5006     MOVF 0x6, W, ACCESS
11CDE  1007     IORWF 0x7, W, ACCESS
11CE0  1008     IORWF 0x8, W, ACCESS
11CE2  1009     IORWF 0x9, W, ACCESS
11CE4  A4D8     BTFSS 0xFD8, 2, ACCESS
11CE6  D009     BRA 0x1CFA
22:            		return 0.0;
11CE8  0E00     MOVLW 0x0
11CEA  6E06     MOVWF 0x6, ACCESS
11CEC  0E00     MOVLW 0x0
11CEE  6E07     MOVWF 0x7, ACCESS
11CF0  0E00     MOVLW 0x0
11CF2  6E08     MOVWF 0x8, ACCESS
11CF4  0E00     MOVLW 0x0
11CF6  6E09     MOVWF 0x9, ACCESS
11CF8  0012     RETURN 0
23:            	exp = (127 + 23);
11CFA  0E96     MOVLW 0x96
11CFC  6E0F     MOVWF 0xF, ACCESS
24:            	while(arg & ~0x1FFFFFFUL) {
11CFE  D006     BRA 0x1D0C
11D0C  0E00     MOVLW 0x0
11D0E  1410     ANDWF 0x10, W, ACCESS
11D10  6E0A     MOVWF 0xA, ACCESS
11D12  0E00     MOVLW 0x0
11D14  1411     ANDWF 0x11, W, ACCESS
11D16  6E0B     MOVWF 0xB, ACCESS
11D18  0E00     MOVLW 0x0
11D1A  1412     ANDWF 0x12, W, ACCESS
11D1C  6E0C     MOVWF 0xC, ACCESS
11D1E  0EFE     MOVLW 0xFE
11D20  1413     ANDWF 0x13, W, ACCESS
11D22  6E0D     MOVWF 0xD, ACCESS
11D24  500A     MOVF 0xA, W, ACCESS
11D26  100B     IORWF 0xB, W, ACCESS
11D28  100C     IORWF 0xC, W, ACCESS
11D2A  100D     IORWF 0xD, W, ACCESS
11D2C  B4D8     BTFSC 0xFD8, 2, ACCESS
11D2E  D00D     BRA 0x1D4A
11D30  D7E7     BRA 0x1D00
25:            		++exp;
11D00  2A0F     INCF 0xF, F, ACCESS
26:            		arg >>= 1;
11D02  90D8     BCF 0xFD8, 0, ACCESS
11D04  3213     RRCF 0x13, F, ACCESS
11D06  3212     RRCF 0x12, F, ACCESS
11D08  3211     RRCF 0x11, F, ACCESS
11D0A  3210     RRCF 0x10, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
29:            		++exp;
11D32  2A0F     INCF 0xF, F, ACCESS
30:            		++arg;
11D34  0E01     MOVLW 0x1
11D36  2610     ADDWF 0x10, F, ACCESS
11D38  0E00     MOVLW 0x0
11D3A  2211     ADDWFC 0x11, F, ACCESS
11D3C  2212     ADDWFC 0x12, F, ACCESS
11D3E  2213     ADDWFC 0x13, F, ACCESS
31:            		arg >>= 1;
11D40  90D8     BCF 0xFD8, 0, ACCESS
11D42  3213     RRCF 0x13, F, ACCESS
11D44  3212     RRCF 0x12, F, ACCESS
11D46  3211     RRCF 0x11, F, ACCESS
11D48  3210     RRCF 0x10, F, ACCESS
32:            	}
11D4A  0E00     MOVLW 0x0
11D4C  1410     ANDWF 0x10, W, ACCESS
11D4E  6E0A     MOVWF 0xA, ACCESS
11D50  0E00     MOVLW 0x0
11D52  1411     ANDWF 0x11, W, ACCESS
11D54  6E0B     MOVWF 0xB, ACCESS
11D56  0E00     MOVLW 0x0
11D58  1412     ANDWF 0x12, W, ACCESS
11D5A  6E0C     MOVWF 0xC, ACCESS
11D5C  0EFF     MOVLW 0xFF
11D5E  1413     ANDWF 0x13, W, ACCESS
11D60  6E0D     MOVWF 0xD, ACCESS
11D62  500A     MOVF 0xA, W, ACCESS
11D64  100B     IORWF 0xB, W, ACCESS
11D66  100C     IORWF 0xC, W, ACCESS
11D68  100D     IORWF 0xD, W, ACCESS
11D6A  B4D8     BTFSC 0xFD8, 2, ACCESS
11D6C  D007     BRA 0x1D7C
11D6E  D7E1     BRA 0x1D32
33:            	while(!(arg & 0x800000UL) && exp > 1) {
11D7C  BE12     BTFSC 0x12, 7, ACCESS
11D7E  D003     BRA 0x1D86
11D80  0E02     MOVLW 0x2
11D82  600F     CPFSLT 0xF, ACCESS
11D84  D7F5     BRA 0x1D70
34:            		--exp;
11D70  060F     DECF 0xF, F, ACCESS
35:            		arg <<= 1;
11D72  90D8     BCF 0xFD8, 0, ACCESS
11D74  3610     RLCF 0x10, F, ACCESS
11D76  3611     RLCF 0x11, F, ACCESS
11D78  3612     RLCF 0x12, F, ACCESS
11D7A  3613     RLCF 0x13, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
11D86  A00F     BTFSS 0xF, 0, ACCESS
38:            		arg &= ~0x800000UL;
11D88  9E12     BCF 0x12, 7, ACCESS
39:            	exp >>= 1;
11D8A  90D8     BCF 0xFD8, 0, ACCESS
11D8C  320F     RRCF 0xF, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
11D8E  C50F     MOVFF s, data
11D90  F50A     NOP
11D92  6A0B     CLRF 0xB, ACCESS
11D94  6A0C     CLRF 0xC, ACCESS
11D96  6A0D     CLRF 0xD, ACCESS
11D98  C50A     MOVFF data, d
11D9A  F50D     NOP
11D9C  6A0C     CLRF 0xC, ACCESS
11D9E  6A0B     CLRF 0xB, ACCESS
11DA0  6A0A     CLRF 0xA, ACCESS
11DA2  500A     MOVF 0xA, W, ACCESS
11DA4  1210     IORWF 0x10, F, ACCESS
11DA6  500B     MOVF 0xB, W, ACCESS
11DA8  1211     IORWF 0x11, F, ACCESS
11DAA  500C     MOVF 0xC, W, ACCESS
11DAC  1212     IORWF 0x12, F, ACCESS
11DAE  500D     MOVF 0xD, W, ACCESS
11DB0  1213     IORWF 0x13, F, ACCESS
41:            	if(sign && val < 0)
11DB2  500E     MOVF 0xE, W, ACCESS
11DB4  A4D8     BTFSS 0xFD8, 2, ACCESS
11DB6  AE09     BTFSS 0x9, 7, ACCESS
11DB8  D001     BRA 0x1DBC
42:            		arg |= 0x80000000UL;
11DBA  8E13     BSF 0x13, 7, ACCESS
43:            	return *(double *)&arg;
11DBC  C510     MOVFF arg, InterruptHandler
11DBE  F506     NOP
11DC0  C511     MOVFF fp, c
11DC2  F507     NOP
11DC4  C512     MOVFF sum, blockSize
11DC6  F508     NOP
11DC8  C513     MOVFF c, td
11DCA  F509     NOP
44:            }
11DCC  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
12D4E  C506     MOVFF InterruptHandler, blockSize
12D50  F508     NOP
12D52  C507     MOVFF c, td
12D54  F509     NOP
8:             	while(*s) {
12D56  D002     BRA 0x2D5C
12D5E  F418     NOP
12D60  F4F6     NOP
12D64  F41C     NOP
12D66  F4F7     NOP
12D68  0E00     MOVLW 0x0
12D6A  6EF8     MOVWF 0xFF8, ACCESS
12D6C  0E25     MOVLW 0x25
12D6E  64F7     CPFSGT 0xFF7, ACCESS
12D70  D003     BRA 0x2D78
12D72  0008     TBLRD*
12D74  50F5     MOVF 0xFF5, W, ACCESS
12D76  D005     BRA 0x2D82
12D78  C4F6     MOVFF TBLPTR, FSR1
12D7A  F4E1     NOP
12D7C  C4F7     MOVFF TBLPTRH, FSR1H
12D7E  F4E2     NOP
12D80  50E7     MOVF 0xFE7, W, ACCESS
12D82  0900     IORLW 0x0
12D84  A4D8     BTFSS 0xFD8, 2, ACCESS
12D86  D7E8     BRA 0x2D58
9:             		s++;
12D58  4A06     INFSNZ 0x6, F, ACCESS
12D5A  2A07     INCF 0x7, F, ACCESS
10:            	}
11:            	return (size_t)(s-a);
12D88  5008     MOVF 0x8, W, ACCESS
12D8A  5C06     SUBWF 0x6, W, ACCESS
12D8C  6E06     MOVWF 0x6, ACCESS
12D8E  5009     MOVF 0x9, W, ACCESS
12D90  5807     SUBWFB 0x7, W, ACCESS
12D92  6E07     MOVWF 0x7, ACCESS
12:            }
12D94  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/sprcmul.c  -----------------------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
110BA  5017     MOVF 0x17, W, ACCESS
110BC  0B80     ANDLW 0x80
110BE  6E20     MOVWF 0x20, ACCESS
18:            	bexp = (unsigned char)(((*(SFP *) & b).fAsBytes.d) << 1);
110C0  5017     MOVF 0x17, W, ACCESS
110C2  2417     ADDWF 0x17, W, ACCESS
110C4  6E22     MOVWF 0x22, ACCESS
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
110C6  BE16     BTFSC 0x16, 7, ACCESS
20:            		bexp |= 0x1;
110C8  8022     BSF 0x22, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
110CA  5022     MOVF 0x22, W, ACCESS
110CC  B4D8     BTFSC 0xFD8, 2, ACCESS
110CE  D00D     BRA 0x10EA
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
110D0  2822     INCF 0x22, W, ACCESS
110D2  A4D8     BTFSS 0xFD8, 2, ACCESS
110D4  D008     BRA 0x10E6
27:            			/* Make it inf */
28:            			b = 0;
110D6  0E00     MOVLW 0x0
110D8  6E14     MOVWF 0x14, ACCESS
110DA  0E00     MOVLW 0x0
110DC  6E15     MOVWF 0x15, ACCESS
110DE  0E00     MOVLW 0x0
110E0  6E16     MOVWF 0x16, ACCESS
110E2  0E00     MOVLW 0x0
110E4  6E17     MOVWF 0x17, ACCESS
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
110E6  8E16     BSF 0x16, 7, ACCESS
32:            
33:            	}
110E8  D008     BRA 0x10FA
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
110EA  0E00     MOVLW 0x0
110EC  6E14     MOVWF 0x14, ACCESS
110EE  0E00     MOVLW 0x0
110F0  6E15     MOVWF 0x15, ACCESS
110F2  0E00     MOVLW 0x0
110F4  6E16     MOVWF 0x16, ACCESS
110F6  0E00     MOVLW 0x0
110F8  6E17     MOVWF 0x17, ACCESS
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
110FA  501B     MOVF 0x1B, W, ACCESS
110FC  0B80     ANDLW 0x80
110FE  1A20     XORWF 0x20, F, ACCESS
40:            	aexp = (unsigned char)(((*(SFP *) & a).fAsBytes.d) << 1);
11100  501B     MOVF 0x1B, W, ACCESS
11102  241B     ADDWF 0x1B, W, ACCESS
11104  6E21     MOVWF 0x21, ACCESS
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
11106  BE1A     BTFSC 0x1A, 7, ACCESS
42:            		aexp |= 0x1;
11108  8021     BSF 0x21, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
1110A  5021     MOVF 0x21, W, ACCESS
1110C  B4D8     BTFSC 0xFD8, 2, ACCESS
1110E  D00D     BRA 0x112A
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
11110  2821     INCF 0x21, W, ACCESS
11112  A4D8     BTFSS 0xFD8, 2, ACCESS
11114  D008     BRA 0x1126
49:            			/* Make it inf */
50:            			a = 0;
11116  0E00     MOVLW 0x0
11118  6E18     MOVWF 0x18, ACCESS
1111A  0E00     MOVLW 0x0
1111C  6E19     MOVWF 0x19, ACCESS
1111E  0E00     MOVLW 0x0
11120  6E1A     MOVWF 0x1A, ACCESS
11122  0E00     MOVLW 0x0
11124  6E1B     MOVWF 0x1B, ACCESS
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
11126  8E1A     BSF 0x1A, 7, ACCESS
54:            	}
11128  D008     BRA 0x113A
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
1112A  0E00     MOVLW 0x0
1112C  6E18     MOVWF 0x18, ACCESS
1112E  0E00     MOVLW 0x0
11130  6E19     MOVWF 0x19, ACCESS
11132  0E00     MOVLW 0x0
11134  6E1A     MOVWF 0x1A, ACCESS
11136  0E00     MOVLW 0x0
11138  6E1B     MOVWF 0x1B, ACCESS
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
1113A  5021     MOVF 0x21, W, ACCESS
1113C  B4D8     BTFSC 0xFD8, 2, ACCESS
1113E  D003     BRA 0x1146
11140  5022     MOVF 0x22, W, ACCESS
11142  A4D8     BTFSS 0xFD8, 2, ACCESS
11144  D009     BRA 0x1158
66:            		return 0.0;
11146  0E00     MOVLW 0x0
11148  6E14     MOVWF 0x14, ACCESS
1114A  0E00     MOVLW 0x0
1114C  6E15     MOVWF 0x15, ACCESS
1114E  0E00     MOVLW 0x0
11150  6E16     MOVWF 0x16, ACCESS
11152  0E00     MOVLW 0x0
11154  6E17     MOVWF 0x17, ACCESS
11156  0012     RETURN 0
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
11158  501A     MOVF 0x1A, W, ACCESS
1115A  0214     MULWF 0x14, ACCESS
1115E  F3CC     NOP
11160  F52B     NOP
11164  F3D0     NOP
11166  F52C     NOP
96:            	grs = temp.nAsBytes.a;
11168  502B     MOVF 0x2B, W, ACCESS
1116A  6E23     MOVWF 0x23, ACCESS
1116C  6A24     CLRF 0x24, ACCESS
1116E  6A25     CLRF 0x25, ACCESS
11170  6A26     CLRF 0x26, ACCESS
97:            	prod.i = temp.nAsBytes.b;
11172  502C     MOVF 0x2C, W, ACCESS
11174  6E27     MOVWF 0x27, ACCESS
11176  6A28     CLRF 0x28, ACCESS
11178  6A29     CLRF 0x29, ACCESS
1117A  6A2A     CLRF 0x2A, ACCESS
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
1117C  5019     MOVF 0x19, W, ACCESS
1117E  0215     MULWF 0x15, ACCESS
11182  F3CC     NOP
11184  F52B     NOP
11188  F3D0     NOP
1118A  F52C     NOP
99:            	grs += temp.nAsBytes.a;
1118C  502B     MOVF 0x2B, W, ACCESS
1118E  2623     ADDWF 0x23, F, ACCESS
11190  0E00     MOVLW 0x0
11192  2224     ADDWFC 0x24, F, ACCESS
11194  2225     ADDWFC 0x25, F, ACCESS
11196  2226     ADDWFC 0x26, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
11198  502C     MOVF 0x2C, W, ACCESS
1119A  2627     ADDWF 0x27, F, ACCESS
1119C  0E00     MOVLW 0x0
1119E  2228     ADDWFC 0x28, F, ACCESS
111A0  2229     ADDWFC 0x29, F, ACCESS
111A2  222A     ADDWFC 0x2A, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
111A4  5018     MOVF 0x18, W, ACCESS
111A6  0216     MULWF 0x16, ACCESS
111AA  F3CC     NOP
111AC  F52B     NOP
111B0  F3D0     NOP
111B2  F52C     NOP
102:           	grs += temp.nAsBytes.a;
111B4  502B     MOVF 0x2B, W, ACCESS
111B6  2623     ADDWF 0x23, F, ACCESS
111B8  0E00     MOVLW 0x0
111BA  2224     ADDWFC 0x24, F, ACCESS
111BC  2225     ADDWFC 0x25, F, ACCESS
111BE  2226     ADDWFC 0x26, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
111C0  502C     MOVF 0x2C, W, ACCESS
111C2  2627     ADDWF 0x27, F, ACCESS
111C4  0E00     MOVLW 0x0
111C6  2228     ADDWFC 0x28, F, ACCESS
111C8  2229     ADDWFC 0x29, F, ACCESS
111CA  222A     ADDWFC 0x2A, F, ACCESS
104:           	grs <<= 8;
111CC  C525     MOVFF 0x525, 0x526
111CE  F526     NOP
111D0  C524     MOVFF 0x524, 0x525
111D2  F525     NOP
111D4  C523     MOVFF grs, 0x524
111D6  F524     NOP
111D8  6A23     CLRF 0x23, ACCESS
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
111DA  5018     MOVF 0x18, W, ACCESS
111DC  0215     MULWF 0x15, ACCESS
111E0  F3CC     NOP
111E2  F52B     NOP
111E6  F3D0     NOP
111E8  F52C     NOP
106:           	grs += (unsigned long)temp.n;
111EA  502B     MOVF 0x2B, W, ACCESS
111EC  2623     ADDWF 0x23, F, ACCESS
111EE  502C     MOVF 0x2C, W, ACCESS
111F0  2224     ADDWFC 0x24, F, ACCESS
111F2  0E00     MOVLW 0x0
111F4  2225     ADDWFC 0x25, F, ACCESS
111F6  0E00     MOVLW 0x0
111F8  2226     ADDWFC 0x26, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
111FA  5019     MOVF 0x19, W, ACCESS
111FC  0214     MULWF 0x14, ACCESS
11200  F3CC     NOP
11202  F52B     NOP
11206  F3D0     NOP
11208  F52C     NOP
108:           	grs += (unsigned long)temp.n;
1120A  502B     MOVF 0x2B, W, ACCESS
1120C  2623     ADDWF 0x23, F, ACCESS
1120E  502C     MOVF 0x2C, W, ACCESS
11210  2224     ADDWFC 0x24, F, ACCESS
11212  0E00     MOVLW 0x0
11214  2225     ADDWFC 0x25, F, ACCESS
11216  0E00     MOVLW 0x0
11218  2226     ADDWFC 0x26, F, ACCESS
109:           	grs <<= 8;
1121A  C525     MOVFF 0x525, 0x526
1121C  F526     NOP
1121E  C524     MOVFF 0x524, 0x525
11220  F525     NOP
11222  C523     MOVFF grs, 0x524
11224  F524     NOP
11226  6A23     CLRF 0x23, ACCESS
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
11228  5018     MOVF 0x18, W, ACCESS
1122A  0214     MULWF 0x14, ACCESS
1122E  F3CC     NOP
11230  F52B     NOP
11234  F3D0     NOP
11236  F52C     NOP
111:           	grs += (unsigned long)temp.n;
11238  502B     MOVF 0x2B, W, ACCESS
1123A  2623     ADDWF 0x23, F, ACCESS
1123C  502C     MOVF 0x2C, W, ACCESS
1123E  2224     ADDWFC 0x24, F, ACCESS
11240  0E00     MOVLW 0x0
11242  2225     ADDWFC 0x25, F, ACCESS
11244  0E00     MOVLW 0x0
11246  2226     ADDWFC 0x26, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
11248  501A     MOVF 0x1A, W, ACCESS
1124A  0215     MULWF 0x15, ACCESS
1124E  F3CC     NOP
11250  F52B     NOP
11254  F3D0     NOP
11256  F52C     NOP
113:           	prod.i += (unsigned long)temp.n;
11258  502B     MOVF 0x2B, W, ACCESS
1125A  2627     ADDWF 0x27, F, ACCESS
1125C  502C     MOVF 0x2C, W, ACCESS
1125E  2228     ADDWFC 0x28, F, ACCESS
11260  0E00     MOVLW 0x0
11262  2229     ADDWFC 0x29, F, ACCESS
11264  0E00     MOVLW 0x0
11266  222A     ADDWFC 0x2A, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
11268  5019     MOVF 0x19, W, ACCESS
1126A  0216     MULWF 0x16, ACCESS
1126E  F3CC     NOP
11270  F52B     NOP
11274  F3D0     NOP
11276  F52C     NOP
115:           	prod.i += (unsigned long)temp.n;
11278  502B     MOVF 0x2B, W, ACCESS
1127A  2627     ADDWF 0x27, F, ACCESS
1127C  502C     MOVF 0x2C, W, ACCESS
1127E  2228     ADDWFC 0x28, F, ACCESS
11280  0E00     MOVLW 0x0
11282  2229     ADDWFC 0x29, F, ACCESS
11284  0E00     MOVLW 0x0
11286  222A     ADDWFC 0x2A, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
11288  501A     MOVF 0x1A, W, ACCESS
1128A  0216     MULWF 0x16, ACCESS
1128E  F3CC     NOP
11290  F52B     NOP
11294  F3D0     NOP
11296  F52C     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
11298  502B     MOVF 0x2B, W, ACCESS
1129A  6E1C     MOVWF 0x1C, ACCESS
1129C  502C     MOVF 0x2C, W, ACCESS
1129E  6E1D     MOVWF 0x1D, ACCESS
112A0  6A1E     CLRF 0x1E, ACCESS
112A2  6A1F     CLRF 0x1F, ACCESS
112A4  C51E     MOVFF 0x51E, cp
112A6  F51F     NOP
112A8  C51D     MOVFF w, 0x51E
112AA  F51E     NOP
112AC  C51C     MOVFF 0x51C, w
112AE  F51D     NOP
112B0  6A1C     CLRF 0x1C, ACCESS
112B2  501C     MOVF 0x1C, W, ACCESS
112B4  2627     ADDWF 0x27, F, ACCESS
112B6  501D     MOVF 0x1D, W, ACCESS
112B8  2228     ADDWFC 0x28, F, ACCESS
112BA  501E     MOVF 0x1E, W, ACCESS
112BC  2229     ADDWFC 0x29, F, ACCESS
112BE  501F     MOVF 0x1F, W, ACCESS
112C0  222A     ADDWFC 0x2A, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
112C2  5026     MOVF 0x26, W, ACCESS
112C4  2627     ADDWF 0x27, F, ACCESS
112C6  0E00     MOVLW 0x0
112C8  2228     ADDWFC 0x28, F, ACCESS
112CA  2229     ADDWFC 0x29, F, ACCESS
112CC  222A     ADDWFC 0x2A, F, ACCESS
146:           	grs <<= 8;
112CE  C525     MOVFF 0x525, 0x526
112D0  F526     NOP
112D2  C524     MOVFF 0x524, 0x525
112D4  F525     NOP
112D6  C523     MOVFF grs, 0x524
112D8  F524     NOP
112DA  6A23     CLRF 0x23, ACCESS
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
112DC  5021     MOVF 0x21, W, ACCESS
112DE  C522     MOVFF bexp, 0x51C
112E0  F51C     NOP
112E2  6A1D     CLRF 0x1D, ACCESS
112E4  261C     ADDWF 0x1C, F, ACCESS
112E6  0E00     MOVLW 0x0
112E8  221D     ADDWFC 0x1D, F, ACCESS
112EA  0E82     MOVLW 0x82
112EC  241C     ADDWF 0x1C, W, ACCESS
112EE  6E2B     MOVWF 0x2B, ACCESS
112F0  0EFF     MOVLW 0xFF
112F2  201D     ADDWFC 0x1D, W, ACCESS
112F4  6E2C     MOVWF 0x2C, ACCESS
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
112F6  D00F     BRA 0x1316
11316  AE29     BTFSS 0x29, 7, ACCESS
11318  D7EF     BRA 0x12F8
153:           		prod.i <<= 1;
112F8  90D8     BCF 0xFD8, 0, ACCESS
112FA  3627     RLCF 0x27, F, ACCESS
112FC  3628     RLCF 0x28, F, ACCESS
112FE  3629     RLCF 0x29, F, ACCESS
11300  362A     RLCF 0x2A, F, ACCESS
154:           		if (grs & 0x80000000) {
11302  BE26     BTFSC 0x26, 7, ACCESS
155:           			prod.i |= 0x1;
11304  8027     BSF 0x27, 0, ACCESS
156:           		}
157:           		grs <<= 1;
11306  90D8     BCF 0xFD8, 0, ACCESS
11308  3623     RLCF 0x23, F, ACCESS
1130A  3624     RLCF 0x24, F, ACCESS
1130C  3625     RLCF 0x25, F, ACCESS
1130E  3626     RLCF 0x26, F, ACCESS
158:           		--temp.i;
11310  062B     DECF 0x2B, F, ACCESS
11312  A0D8     BTFSS 0xFD8, 0, ACCESS
11314  062C     DECF 0x2C, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
1131A  0E00     MOVLW 0x0
1131C  6E21     MOVWF 0x21, ACCESS
164:           	if (grs & 0x80000000) {
1131E  AE26     BTFSS 0x26, 7, ACCESS
11320  D017     BRA 0x1350
165:           		if (grs & 0x7FFFFFFF) {
11322  0EFF     MOVLW 0xFF
11324  1423     ANDWF 0x23, W, ACCESS
11326  6E1C     MOVWF 0x1C, ACCESS
11328  0EFF     MOVLW 0xFF
1132A  1424     ANDWF 0x24, W, ACCESS
1132C  6E1D     MOVWF 0x1D, ACCESS
1132E  0EFF     MOVLW 0xFF
11330  1425     ANDWF 0x25, W, ACCESS
11332  6E1E     MOVWF 0x1E, ACCESS
11334  0E7F     MOVLW 0x7F
11336  1426     ANDWF 0x26, W, ACCESS
11338  6E1F     MOVWF 0x1F, ACCESS
1133A  501C     MOVF 0x1C, W, ACCESS
1133C  101D     IORWF 0x1D, W, ACCESS
1133E  101E     IORWF 0x1E, W, ACCESS
11340  101F     IORWF 0x1F, W, ACCESS
11342  B4D8     BTFSC 0xFD8, 2, ACCESS
11344  D003     BRA 0x134C
166:           			aexp = 1;
11346  0E01     MOVLW 0x1
11348  6E21     MOVWF 0x21, ACCESS
167:           		}
1134A  D002     BRA 0x1350
168:           		else {
169:           			if (prod.i & 1) {
1134C  B027     BTFSC 0x27, 0, ACCESS
1134E  D7FB     BRA 0x1346
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
11350  5021     MOVF 0x21, W, ACCESS
11352  B4D8     BTFSC 0xFD8, 2, ACCESS
11354  D01F     BRA 0x1394
175:           		++prod.i;
11356  0E01     MOVLW 0x1
11358  2627     ADDWF 0x27, F, ACCESS
1135A  0E00     MOVLW 0x0
1135C  2228     ADDWFC 0x28, F, ACCESS
1135E  2229     ADDWFC 0x29, F, ACCESS
11360  222A     ADDWFC 0x2A, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
11362  A02A     BTFSS 0x2A, 0, ACCESS
11364  D017     BRA 0x1394
177:           			prod.i = prod.i >> 1;
11366  C527     MOVFF prod, 0x51C
11368  F51C     NOP
1136A  C528     MOVFF 0x528, w
1136C  F51D     NOP
1136E  C529     MOVFF 0x529, 0x51E
11370  F51E     NOP
11372  C52A     MOVFF 0x52A, cp
11374  F51F     NOP
11376  341F     RLCF 0x1F, W, ACCESS
11378  321F     RRCF 0x1F, F, ACCESS
1137A  321E     RRCF 0x1E, F, ACCESS
1137C  321D     RRCF 0x1D, F, ACCESS
1137E  321C     RRCF 0x1C, F, ACCESS
11380  C51C     MOVFF 0x51C, prod
11382  F527     NOP
11384  C51D     MOVFF w, 0x528
11386  F528     NOP
11388  C51E     MOVFF 0x51E, 0x529
1138A  F529     NOP
1138C  C51F     MOVFF cp, 0x52A
1138E  F52A     NOP
178:           			++temp.i;
11390  4A2B     INFSNZ 0x2B, F, ACCESS
11392  2A2C     INCF 0x2C, F, ACCESS
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
11394  BE2C     BTFSC 0x2C, 7, ACCESS
11396  D00D     BRA 0x13B2
11398  502C     MOVF 0x2C, W, ACCESS
1139A  E103     BNZ 0x13A2
1139C  282B     INCF 0x2B, W, ACCESS
1139E  A0D8     BTFSS 0xFD8, 0, ACCESS
113A0  D008     BRA 0x13B2
184:           		prod.i = 0x7F800000;
113A2  0E00     MOVLW 0x0
113A4  6E27     MOVWF 0x27, ACCESS
113A6  0E00     MOVLW 0x0
113A8  6E28     MOVWF 0x28, ACCESS
113AA  0E80     MOVLW 0x80
113AC  6E29     MOVWF 0x29, ACCESS
113AE  0E7F     MOVLW 0x7F
113B0  D020     BRA 0x13F2
185:           	}
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
113B2  BE2C     BTFSC 0x2C, 7, ACCESS
113B4  D005     BRA 0x13C0
113B6  502C     MOVF 0x2C, W, ACCESS
113B8  E10E     BNZ 0x13D6
113BA  042B     DECF 0x2B, W, ACCESS
113BC  B0D8     BTFSC 0xFD8, 0, ACCESS
113BE  D00B     BRA 0x13D6
188:           		prod.i = 0;
113C0  0E00     MOVLW 0x0
113C2  6E27     MOVWF 0x27, ACCESS
113C4  0E00     MOVLW 0x0
113C6  6E28     MOVWF 0x28, ACCESS
113C8  0E00     MOVLW 0x0
113CA  6E29     MOVWF 0x29, ACCESS
113CC  0E00     MOVLW 0x0
113CE  6E2A     MOVWF 0x2A, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
113D0  0E00     MOVLW 0x0
113D2  6E20     MOVWF 0x20, ACCESS
191:           	}
113D4  D00F     BRA 0x13F4
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = (unsigned char)temp.i;	// it fits in 8 bits !
113D6  C52B     MOVFF temp, bexp
113D8  F522     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
113DA  0EFF     MOVLW 0xFF
113DC  1627     ANDWF 0x27, F, ACCESS
113DE  0EFF     MOVLW 0xFF
113E0  1628     ANDWF 0x28, F, ACCESS
113E2  0E7F     MOVLW 0x7F
113E4  1629     ANDWF 0x29, F, ACCESS
113E6  0E00     MOVLW 0x0
113E8  162A     ANDWF 0x2A, F, ACCESS
196:           		if (bexp & 0x1) {
113EA  B022     BTFSC 0x22, 0, ACCESS
197:           			prod.fAsBytes.c |= 0x80;
113EC  8E29     BSF 0x29, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
113EE  90D8     BCF 0xFD8, 0, ACCESS
113F0  3022     RRCF 0x22, W, ACCESS
113F2  6E2A     MOVWF 0x2A, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
113F4  5020     MOVF 0x20, W, ACCESS
113F6  122A     IORWF 0x2A, F, ACCESS
202:           
203:           	return prod.f;
113F8  C527     MOVFF prod, i
113FA  F514     NOP
113FC  C528     MOVFF 0x528, len
113FE  F515     NOP
11400  C529     MOVFF 0x529, counter
11402  F516     NOP
11404  C52A     MOVFF 0x52A, sign
11406  F517     NOP
204:           
205:           }
11408  0012     RETURN 0
206:           
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/putch.c  -------------------------------------------
1:             /*
2:              * Function: putch
3:              * Weak implementation.  User implementation may be required
4:              */
5:             
6:             void 
7:             putch(char c)
8:             {
9:             }
13582  0012     RETURN 0
10:            
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_sprintf.c  --------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
12BD2  0E74     MOVLW 0x74
12BD4  6F84     MOVWF SPI1CON0, BANKED
12BD6  0E05     MOVLW 0x5
12BD8  6F85     MOVWF SPI1CON1, BANKED
16:            	f.buffer = s;
12BDA  C570     MOVFF s, f
12BDC  F586     NOP
12BDE  C571     MOVFF 0x571, 0x587
12BE0  F587     NOP
17:            	f.count = 0;
12BE2  0E00     MOVLW 0x0
12BE4  6F89     MOVWF SPI1BAUD, BANKED
12BE6  0E00     MOVLW 0x0
12BE8  6F88     MOVWF SPI1TWIDTH, BANKED
18:            	f.limit = 0;
12BEA  0E00     MOVLW 0x0
12BEC  6F8B     MOVWF SPI1INTE, BANKED
12BEE  0E00     MOVLW 0x0
12BF0  6F8A     MOVWF SPI1INTF, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
12BF2  0E86     MOVLW 0x86
12BF4  6F6A     MOVWF MD1CON0, BANKED
12BF6  0E05     MOVLW 0x5
12BF8  6F6B     MOVWF MD1CON1, BANKED
12BFA  C572     MOVFF fmt, fmt
12BFC  F56C     NOP
12BFE  C573     MOVFF 0x573, 0x56D
12C00  F56D     NOP
12C02  0E84     MOVLW 0x84
12C04  6F6E     MOVWF MD1CARH, BANKED
12C06  0E05     MOVLW 0x5
12C08  6F6F     MOVWF CMOUT, BANKED
12C0A  EC0D     CALL 0x12A1A, 0
12C0C  F095     NOP
20:            	s[f.count] = '\0';
12C0E  5188     MOVF SPI1TWIDTH, W, BANKED
12C10  2570     ADDWF CM1CON0, W, BANKED
12C12  6ED9     MOVWF 0xFD9, ACCESS
12C14  5189     MOVF SPI1BAUD, W, BANKED
12C16  2171     ADDWFC CM1CON1, W, BANKED
12C18  6EDA     MOVWF 0xFDA, ACCESS
12C1A  0E00     MOVLW 0x0
12C1C  6EDF     MOVWF 0xFDF, ACCESS
21:            	va_end(ap);
22:            	return ret;
23:            }
12C1E  0012     RETURN 0
24:            
25:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_fputs.c  ----------------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
12FBE  0E00     MOVLW 0x0
12FC0  6E15     MOVWF 0x15, ACCESS
12FC2  0E00     MOVLW 0x0
12FC4  6E14     MOVWF 0x14, ACCESS
14:                while ((c = *(s + i))) {
12FC6  D00B     BRA 0x2FDE
12FDE  5014     MOVF 0x14, W, ACCESS
15:            	fputc(c,fp);
12FC8  C513     MOVFF c, InterruptHandler
12FCA  F506     NOP
12FCC  6A07     CLRF 0x7, ACCESS
12FCE  C511     MOVFF fp, blockSize
12FD0  F508     NOP
12FD2  C512     MOVFF sum, td
12FD4  F509     NOP
12FD6  EC5D     CALL 0x122BA, 0
12FD8  F091     NOP
16:                    ++i;
12FDA  4A14     INFSNZ 0x14, F, ACCESS
12FDC  2A15     INCF 0x15, F, ACCESS
12FDE  5014     MOVF 0x14, W, ACCESS
12FE0  240F     ADDWF 0xF, W, ACCESS
12FE2  6ED9     MOVWF 0xFD9, ACCESS
12FE4  5015     MOVF 0x15, W, ACCESS
12FE6  2010     ADDWFC 0x10, W, ACCESS
12FE8  6EDA     MOVWF 0xFDA, ACCESS
12FEA  50DF     MOVF 0xFDF, W, ACCESS
12FEC  6E13     MOVWF 0x13, ACCESS
12FEE  5013     MOVF 0x13, W, ACCESS
12FF0  B4D8     BTFSC 0xFD8, 2, ACCESS
12FF2  0012     RETURN 0
12FF4  D7E9     BRA 0x2FC8
17:                }
18:                return i;
19:            }
20:            
21:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
122BA  5008     MOVF 0x8, W, ACCESS
122BC  1009     IORWF 0x9, W, ACCESS
122BE  B4D8     BTFSC 0xFD8, 2, ACCESS
122C0  D004     BRA 0x22CA
122C2  5008     MOVF 0x8, W, ACCESS
122C4  1009     IORWF 0x9, W, ACCESS
122C6  A4D8     BTFSS 0xFD8, 2, ACCESS
122C8  D004     BRA 0x22D2
13:                    putch((char)c);
122CA  5006     MOVF 0x6, W, ACCESS
122CC  ECC1     CALL 0x13582, 0
122CE  F09A     NOP
14:                } else {
122D0  0012     RETURN 0
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
122D2  EE20     LFSR 2, 0x4
122D4  F004     NOP
122D6  5008     MOVF 0x8, W, ACCESS
122D8  26D9     ADDWF 0xFD9, F, ACCESS
122DA  5009     MOVF 0x9, W, ACCESS
122DC  22DA     ADDWFC 0xFDA, F, ACCESS
122DE  50DE     MOVF 0xFDE, W, ACCESS
122E0  10DE     IORWF 0xFDE, W, ACCESS
122E2  B4D8     BTFSC 0xFD8, 2, ACCESS
122E4  D016     BRA 0x2312
122E6  EE20     LFSR 2, 0x4
122E8  F004     NOP
122EA  5008     MOVF 0x8, W, ACCESS
122EC  26D9     ADDWF 0xFD9, F, ACCESS
122EE  5009     MOVF 0x9, W, ACCESS
122F0  22DA     ADDWFC 0xFDA, F, ACCESS
122F2  EE10     LFSR 1, 0x2
122F4  F002     NOP
122F6  5008     MOVF 0x8, W, ACCESS
122F8  26E1     ADDWF 0xFE1, F, ACCESS
122FA  5009     MOVF 0x9, W, ACCESS
122FC  22E2     ADDWFC 0xFE2, F, ACCESS
122FE  50DE     MOVF 0xFDE, W, ACCESS
12300  5CE6     SUBWF 0xFE6, W, ACCESS
12302  50E6     MOVF 0xFE6, W, ACCESS
12304  0A80     XORLW 0x80
12306  6E0E     MOVWF 0xE, ACCESS
12308  50DE     MOVF 0xFDE, W, ACCESS
1230A  0A80     XORLW 0x80
1230C  580E     SUBWFB 0xE, W, ACCESS
1230E  B0D8     BTFSC 0xFD8, 0, ACCESS
12310  0012     RETURN 0
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
12312  EE20     LFSR 2, 0x2
12314  F002     NOP
12316  5008     MOVF 0x8, W, ACCESS
12318  26D9     ADDWF 0xFD9, F, ACCESS
1231A  5009     MOVF 0x9, W, ACCESS
1231C  22DA     ADDWFC 0xFDA, F, ACCESS
12320  F378     NOP
12322  F50A     NOP
12326  F374     NOP
12328  F50B     NOP
1232C  F420     NOP
1232E  F4D9     NOP
12332  F424     NOP
12334  F4DA     NOP
12338  F378     NOP
1233A  F50C     NOP
1233E  F374     NOP
12340  F50D     NOP
12342  500A     MOVF 0xA, W, ACCESS
12344  240C     ADDWF 0xC, W, ACCESS
12346  6ED9     MOVWF 0xFD9, ACCESS
12348  500B     MOVF 0xB, W, ACCESS
1234A  200D     ADDWFC 0xD, W, ACCESS
1234C  6EDA     MOVWF 0xFDA, ACCESS
12350  F418     NOP
12352  F4DF     NOP
19:            #pragma warning pop
20:            			++fp->count;
12354  EE20     LFSR 2, 0x2
12356  F002     NOP
12358  5008     MOVF 0x8, W, ACCESS
1235A  26D9     ADDWF 0xFD9, F, ACCESS
1235C  5009     MOVF 0x9, W, ACCESS
1235E  22DA     ADDWFC 0xFDA, F, ACCESS
12360  2ADE     INCF 0xFDE, F, ACCESS
12362  0E00     MOVLW 0x0
12364  22DD     ADDWFC 0xFDD, F, ACCESS
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
12366  0012     RETURN 0
25:            
26:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/memset.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
118A8  C506     MOVFF InterruptHandler, arg
118AA  F510     NOP
118AC  C507     MOVFF c, fp
118AE  F511     NOP
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
118B0  500A     MOVF 0xA, W, ACCESS
118B2  100B     IORWF 0xB, W, ACCESS
118B4  A4D8     BTFSS 0xFD8, 2, ACCESS
118B6  D005     BRA 0x18C2
118B8  C506     MOVFF InterruptHandler, InterruptHandler
118BA  F506     NOP
118BC  C507     MOVFF c, c
118BE  F507     NOP
118C0  0012     RETURN 0
14:            	s[0] = (unsigned char)c;
118C4  F440     NOP
118C6  F4D9     NOP
118CA  F444     NOP
118CC  F4DA     NOP
118D0  F420     NOP
118D2  F4DF     NOP
15:            	s[n-1] = (unsigned char)c;
118D4  500A     MOVF 0xA, W, ACCESS
118D6  2410     ADDWF 0x10, W, ACCESS
118D8  6E0C     MOVWF 0xC, ACCESS
118DA  500B     MOVF 0xB, W, ACCESS
118DC  2011     ADDWFC 0x11, W, ACCESS
118DE  6E0D     MOVWF 0xD, ACCESS
118E0  0EFF     MOVLW 0xFF
118E2  240C     ADDWF 0xC, W, ACCESS
118E4  6ED9     MOVWF 0xFD9, ACCESS
118E6  0EFF     MOVLW 0xFF
118E8  200D     ADDWFC 0xD, W, ACCESS
118EA  6EDA     MOVWF 0xFDA, ACCESS
118EE  F420     NOP
118F0  F4DF     NOP
16:            	if (n <= 2) return dest;
118F2  500B     MOVF 0xB, W, ACCESS
118F4  E104     BNZ 0x18FE
118F6  0E03     MOVLW 0x3
118F8  5C0A     SUBWF 0xA, W, ACCESS
118FA  A0D8     BTFSS 0xFD8, 0, ACCESS
118FC  D7DD     BRA 0x18B8
17:            	s[1] = (unsigned char)c;
118FE  EE20     LFSR 2, 0x1
11900  F001     NOP
11902  5010     MOVF 0x10, W, ACCESS
11904  26D9     ADDWF 0xFD9, F, ACCESS
11906  5011     MOVF 0x11, W, ACCESS
11908  22DA     ADDWFC 0xFDA, F, ACCESS
1190C  F420     NOP
1190E  F4DF     NOP
18:            	s[2] = (unsigned char)c;
11910  EE20     LFSR 2, 0x2
11912  F002     NOP
11914  5010     MOVF 0x10, W, ACCESS
11916  26D9     ADDWF 0xFD9, F, ACCESS
11918  5011     MOVF 0x11, W, ACCESS
1191A  22DA     ADDWFC 0xFDA, F, ACCESS
1191E  F420     NOP
11920  F4DF     NOP
19:            	s[n-2] = (unsigned char)c;
11922  500A     MOVF 0xA, W, ACCESS
11924  2410     ADDWF 0x10, W, ACCESS
11926  6E0C     MOVWF 0xC, ACCESS
11928  500B     MOVF 0xB, W, ACCESS
1192A  2011     ADDWFC 0x11, W, ACCESS
1192C  6E0D     MOVWF 0xD, ACCESS
1192E  0EFE     MOVLW 0xFE
11930  240C     ADDWF 0xC, W, ACCESS
11932  6ED9     MOVWF 0xFD9, ACCESS
11934  0EFF     MOVLW 0xFF
11936  200D     ADDWFC 0xD, W, ACCESS
11938  6EDA     MOVWF 0xFDA, ACCESS
1193C  F420     NOP
1193E  F4DF     NOP
20:            	s[n-3] = (unsigned char)c;
11940  500A     MOVF 0xA, W, ACCESS
11942  2410     ADDWF 0x10, W, ACCESS
11944  6E0C     MOVWF 0xC, ACCESS
11946  500B     MOVF 0xB, W, ACCESS
11948  2011     ADDWFC 0x11, W, ACCESS
1194A  6E0D     MOVWF 0xD, ACCESS
1194C  0EFD     MOVLW 0xFD
1194E  240C     ADDWF 0xC, W, ACCESS
11950  6ED9     MOVWF 0xFD9, ACCESS
11952  0EFF     MOVLW 0xFF
11954  200D     ADDWFC 0xD, W, ACCESS
11956  6EDA     MOVWF 0xFDA, ACCESS
1195A  F420     NOP
1195C  F4DF     NOP
21:            	if (n <= 6) return dest;
1195E  500B     MOVF 0xB, W, ACCESS
11960  E104     BNZ 0x196A
11962  0E07     MOVLW 0x7
11964  5C0A     SUBWF 0xA, W, ACCESS
11966  A0D8     BTFSS 0xFD8, 0, ACCESS
11968  D7A7     BRA 0x18B8
22:            	s[3] = (unsigned char)c;
1196A  EE20     LFSR 2, 0x3
1196C  F003     NOP
1196E  5010     MOVF 0x10, W, ACCESS
11970  26D9     ADDWF 0xFD9, F, ACCESS
11972  5011     MOVF 0x11, W, ACCESS
11974  22DA     ADDWFC 0xFDA, F, ACCESS
11978  F420     NOP
1197A  F4DF     NOP
23:            	s[n-4] = (unsigned char)c;
1197C  500A     MOVF 0xA, W, ACCESS
1197E  2410     ADDWF 0x10, W, ACCESS
11980  6E0C     MOVWF 0xC, ACCESS
11982  500B     MOVF 0xB, W, ACCESS
11984  2011     ADDWFC 0x11, W, ACCESS
11986  6E0D     MOVWF 0xD, ACCESS
11988  0EFC     MOVLW 0xFC
1198A  240C     ADDWF 0xC, W, ACCESS
1198C  6ED9     MOVWF 0xFD9, ACCESS
1198E  0EFF     MOVLW 0xFF
11990  200D     ADDWFC 0xD, W, ACCESS
11992  6EDA     MOVWF 0xFDA, ACCESS
11996  F420     NOP
11998  F4DF     NOP
24:            	if (n <= 8) return dest;
1199A  500B     MOVF 0xB, W, ACCESS
1199C  E104     BNZ 0x19A6
1199E  0E09     MOVLW 0x9
119A0  5C0A     SUBWF 0xA, W, ACCESS
119A2  A0D8     BTFSS 0xFD8, 0, ACCESS
119A4  D789     BRA 0x18B8
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
119A6  C510     MOVFF arg, strptr
119A8  F50C     NOP
119AA  C511     MOVFF fp, d
119AC  F50D     NOP
119AE  1E0C     COMF 0xC, F, ACCESS
119B0  1E0D     COMF 0xD, F, ACCESS
119B2  4A0C     INFSNZ 0xC, F, ACCESS
119B4  2A0D     INCF 0xD, F, ACCESS
119B6  0E03     MOVLW 0x3
119B8  140C     ANDWF 0xC, W, ACCESS
119BA  6E0E     MOVWF 0xE, ACCESS
119BC  6A0F     CLRF 0xF, ACCESS
32:            	s += k;
119BE  500E     MOVF 0xE, W, ACCESS
119C0  2610     ADDWF 0x10, F, ACCESS
119C2  500F     MOVF 0xF, W, ACCESS
119C4  2211     ADDWFC 0x11, F, ACCESS
33:            	n -= k;
119C6  500E     MOVF 0xE, W, ACCESS
119C8  5E0A     SUBWF 0xA, F, ACCESS
119CA  500F     MOVF 0xF, W, ACCESS
119CC  5A0B     SUBWFB 0xB, F, ACCESS
34:            	n &= (size_t)-4;
119CE  0EFC     MOVLW 0xFC
119D0  160A     ANDWF 0xA, F, ACCESS
119D2  0EFF     MOVLW 0xFF
119D4  160B     ANDWF 0xB, F, ACCESS
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
119D6  D00E     BRA 0x19F4
119DA  F440     NOP
119DC  F4D9     NOP
119E0  F444     NOP
119E2  F4DA     NOP
119E6  F420     NOP
119E8  F4DF     NOP
119EA  060A     DECF 0xA, F, ACCESS
119EC  A0D8     BTFSS 0xFD8, 0, ACCESS
119EE  060B     DECF 0xB, F, ACCESS
119F0  4A10     INFSNZ 0x10, F, ACCESS
119F2  2A11     INCF 0x11, F, ACCESS
119F4  500A     MOVF 0xA, W, ACCESS
119F6  100B     IORWF 0xB, W, ACCESS
119F8  B4D8     BTFSC 0xFD8, 2, ACCESS
119FA  D75E     BRA 0x18B8
119FC  D7ED     BRA 0x19D8
87:            #endif
88:            
89:            	return dest;
90:            }
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/memcpy.c  ------------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
12C20  C508     MOVFF blockSize, s
12C22  F50F     NOP
12C24  C509     MOVFF td, arg
12C26  F510     NOP
12:            	d = d1;
12C28  C506     MOVFF InterruptHandler, d
12C2A  F50D     NOP
12C2C  C507     MOVFF c, elo_char
12C2E  F50E     NOP
13:            	while(n--) {
12C30  D015     BRA 0x2C5C
12C5C  060A     DECF 0xA, F, ACCESS
14:            		tmp = *s++;
12C34  F43C     NOP
12C36  F4D9     NOP
12C3A  F440     NOP
12C3C  F4DA     NOP
12C3E  50DF     MOVF 0xFDF, W, ACCESS
12C40  6E0C     MOVWF 0xC, ACCESS
12C42  4A0F     INFSNZ 0xF, F, ACCESS
12C44  2A10     INCF 0x10, F, ACCESS
15:            		*d++ = tmp;
12C48  F434     NOP
12C4A  F4D9     NOP
12C4E  F438     NOP
12C50  F4DA     NOP
12C54  F430     NOP
12C56  F4DF     NOP
12C58  4A0D     INFSNZ 0xD, F, ACCESS
12C5A  2A0E     INCF 0xE, F, ACCESS
12C5C  060A     DECF 0xA, F, ACCESS
12C5E  A0D8     BTFSS 0xFD8, 0, ACCESS
12C60  060B     DECF 0xB, F, ACCESS
12C62  280A     INCF 0xA, W, ACCESS
12C64  E1E6     BNZ 0x2C32
12C66  280B     INCF 0xB, W, ACCESS
12C68  B4D8     BTFSC 0xFD8, 2, ACCESS
12C6A  0012     RETURN 0
12C6C  D7E2     BRA 0x2C32
16:            	}
17:            	return d1;
18:            }
19:            
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/fltol.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = (unsigned char)(f1_as_mant1 >> 23)) == 0)
1214C  342F     RLCF 0x2F, W, ACCESS
1214E  3430     RLCF 0x30, W, ACCESS
12150  6E36     MOVWF 0x36, ACCESS
12152  5036     MOVF 0x36, W, ACCESS
12154  A4D8     BTFSS 0xFD8, 2, ACCESS
12156  D009     BRA 0x216A
48:            		return 0;
12158  0E00     MOVLW 0x0
1215A  6E2D     MOVWF 0x2D, ACCESS
1215C  0E00     MOVLW 0x0
1215E  6E2E     MOVWF 0x2E, ACCESS
12160  0E00     MOVLW 0x0
12162  6E2F     MOVWF 0x2F, ACCESS
12164  0E00     MOVLW 0x0
12166  6E30     MOVWF 0x30, ACCESS
12168  0012     RETURN 0
49:            	sign1 = f1_as_mant1 >> 31;
1216A  C52D     MOVFF f1, 0x531
1216C  F531     NOP
1216E  C52E     MOVFF 0x52E, 0x532
12170  F532     NOP
12172  C52F     MOVFF 0x52F, 0x533
12174  F533     NOP
12176  C530     MOVFF 0x530, 0x534
12178  F534     NOP
1217A  0E20     MOVLW 0x20
1217C  D005     BRA 0x2188
1217E  90D8     BCF 0xFD8, 0, ACCESS
12180  3234     RRCF 0x34, F, ACCESS
12182  3233     RRCF 0x33, F, ACCESS
12184  3232     RRCF 0x32, F, ACCESS
12186  3231     RRCF 0x31, F, ACCESS
12188  2EE8     DECFSZ 0xFE8, F, ACCESS
1218A  D7F9     BRA 0x217E
1218C  5031     MOVF 0x31, W, ACCESS
1218E  6E35     MOVWF 0x35, ACCESS
50:            	f1_as_mant1 |= 0x800000UL;
12190  8E2F     BSF 0x2F, 7, ACCESS
51:            	f1_as_mant1 &= 0xFFFFFFUL;
12192  0EFF     MOVLW 0xFF
12194  162D     ANDWF 0x2D, F, ACCESS
12196  0EFF     MOVLW 0xFF
12198  162E     ANDWF 0x2E, F, ACCESS
1219A  0EFF     MOVLW 0xFF
1219C  162F     ANDWF 0x2F, F, ACCESS
1219E  0E00     MOVLW 0x0
121A0  1630     ANDWF 0x30, F, ACCESS
52:            	exp1 -= 127+23;
121A2  0E96     MOVLW 0x96
121A4  5E36     SUBWF 0x36, F, ACCESS
53:            	if((signed char)exp1 < 0) {
121A6  AE36     BTFSS 0x36, 7, ACCESS
121A8  D00D     BRA 0x21C4
54:            		if((signed char)exp1 < -23)
121AA  5036     MOVF 0x36, W, ACCESS
121AC  0A80     XORLW 0x80
121AE  0F97     ADDLW 0x97
121B0  A0D8     BTFSS 0xFD8, 0, ACCESS
121B2  D7D2     BRA 0x2158
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
121B4  90D8     BCF 0xFD8, 0, ACCESS
121B6  3230     RRCF 0x30, F, ACCESS
121B8  322F     RRCF 0x2F, F, ACCESS
121BA  322E     RRCF 0x2E, F, ACCESS
121BC  322D     RRCF 0x2D, F, ACCESS
121BE  3E36     INCFSZ 0x36, F, ACCESS
121C0  D7F9     BRA 0x21B4
121C2  D00D     BRA 0x21DE
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
121C4  0E1F     MOVLW 0x1F
121C6  6436     CPFSGT 0x36, ACCESS
121C8  D007     BRA 0x21D8
121CA  D7C6     BRA 0x2158
61:            			return 00;
62:            		while(exp1 != 0) {
121D8  5036     MOVF 0x36, W, ACCESS
121DA  A4D8     BTFSS 0xFD8, 2, ACCESS
121DC  D7F7     BRA 0x21CC
63:            			f1_as_mant1 <<= 1;
121CC  90D8     BCF 0xFD8, 0, ACCESS
121CE  362D     RLCF 0x2D, F, ACCESS
121D0  362E     RLCF 0x2E, F, ACCESS
121D2  362F     RLCF 0x2F, F, ACCESS
121D4  3630     RLCF 0x30, F, ACCESS
64:            			exp1--;
121D6  0636     DECF 0x36, F, ACCESS
65:            		}
66:            	}
67:            	if(sign1)
121DE  5035     MOVF 0x35, W, ACCESS
121E0  B4D8     BTFSC 0xFD8, 2, ACCESS
121E2  D008     BRA 0x21F4
68:            		f1_as_mant1 = -f1_as_mant1;
121E4  1E30     COMF 0x30, F, ACCESS
121E6  1E2F     COMF 0x2F, F, ACCESS
121E8  1E2E     COMF 0x2E, F, ACCESS
121EA  6C2D     NEGF 0x2D, ACCESS
121EC  0E00     MOVLW 0x0
121EE  222E     ADDWFC 0x2E, F, ACCESS
121F0  222F     ADDWFC 0x2F, F, ACCESS
121F2  2230     ADDWFC 0x30, F, ACCESS
69:            	return (long) f1_as_mant1;
121F4  C52D     MOVFF f1, f1
121F6  F52D     NOP
121F8  C52E     MOVFF 0x52E, 0x52E
121FA  F52E     NOP
121FC  C52F     MOVFF 0x52F, 0x52F
121FE  F52F     NOP
12200  C530     MOVFF 0x530, 0x530
12202  F530     NOP
70:            }
12204  0012     RETURN 0
71:            #endif
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
12554  0105     MOVLB 0x5
12556  A1D3     BTFSS 0xD3, 0, BANKED
12558  D00A     BRA 0x256E
78:                    fputs((const char *)buf, fp);
1255A  C518     MOVFF a, s
1255C  F50F     NOP
1255E  C519     MOVFF len, arg
12560  F510     NOP
12562  C516     MOVFF counter, fp
12564  F511     NOP
12566  C517     MOVFF sign, sum
12568  F512     NOP
1256A  ECDF     CALL 0x12FBE, 0
1256C  F097     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
1256E  BE1B     BTFSC 0x1B, 7, ACCESS
12570  D005     BRA 0x257C
12572  C51A     MOVFF p, cp
12574  F51F     NOP
12576  C51B     MOVFF i, sign
12578  F520     NOP
1257A  D004     BRA 0x2584
1257C  0E00     MOVLW 0x0
1257E  6E20     MOVWF 0x20, ACCESS
12580  0E00     MOVLW 0x0
12582  6E1F     MOVWF 0x1F, ACCESS
83:                i = 0;
12584  0E00     MOVLW 0x0
12586  6E1E     MOVWF 0x1E, ACCESS
12588  0E00     MOVLW 0x0
1258A  6E1D     MOVWF 0x1D, ACCESS
84:                while (i < w) {
1258C  D00C     BRA 0x25A6
125A6  501F     MOVF 0x1F, W, ACCESS
125A8  5C1D     SUBWF 0x1D, W, ACCESS
125AA  501E     MOVF 0x1E, W, ACCESS
125AC  0A80     XORLW 0x80
125AE  6E1C     MOVWF 0x1C, ACCESS
125B0  5020     MOVF 0x20, W, ACCESS
125B2  0A80     XORLW 0x80
125B4  581C     SUBWFB 0x1C, W, ACCESS
125B6  A0D8     BTFSS 0xFD8, 0, ACCESS
125B8  D7EA     BRA 0x258E
85:                    fputc(' ', fp);
1258E  0E00     MOVLW 0x0
12590  6E07     MOVWF 0x7, ACCESS
12592  0E20     MOVLW 0x20
12594  6E06     MOVWF 0x6, ACCESS
12596  C516     MOVFF counter, blockSize
12598  F508     NOP
1259A  C517     MOVFF sign, td
1259C  F509     NOP
1259E  EC5D     CALL 0x122BA, 0
125A0  F091     NOP
86:                    ++i;
125A2  4A1D     INFSNZ 0x1D, F, ACCESS
125A4  2A1E     INCF 0x1E, F, ACCESS
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
125BA  0105     MOVLB 0x5
125BC  B1D3     BTFSC 0xD3, 0, BANKED
125BE  D00A     BRA 0x25D4
91:                    fputs((const char *)buf, fp);
125C0  C518     MOVFF a, s
125C2  F50F     NOP
125C4  C519     MOVFF len, arg
125C6  F510     NOP
125C8  C516     MOVFF counter, fp
125CA  F511     NOP
125CC  C517     MOVFF sign, sum
125CE  F512     NOP
125D0  ECDF     CALL 0x12FBE, 0
125D2  F097     NOP
92:                }
93:            
94:                return (int)(strlen(buf) + (size_t)w);
125D4  C518     MOVFF a, InterruptHandler
125D6  F506     NOP
125D8  C519     MOVFF len, c
125DA  F507     NOP
125DC  ECA7     CALL 0x12D4E, 0
125DE  F096     NOP
125E0  501F     MOVF 0x1F, W, ACCESS
125E2  2406     ADDWF 0x6, W, ACCESS
125E4  6E16     MOVWF 0x16, ACCESS
125E6  5020     MOVF 0x20, W, ACCESS
125E8  2007     ADDWFC 0x7, W, ACCESS
125EA  6E17     MOVWF 0x17, ACCESS
95:            }
125EC  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = (char)d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Left justify ? Put out character */
267:               if (flags & MINUS_FLAG) {
268:                   fputc(c, fp);
269:               }
270:               /* Put out padding */
271:               w = (w < 0) ? 0 : w;
272:               l = 0;
273:               while (l < w) {
274:                   fputc(' ', fp);
275:                   ++l;
276:               }
277:               /* Right justify ? Put out string */
278:               if (!(flags & MINUS_FLAG)) {
279:                   fputc(c, fp);
280:               }
281:           
282:               return l+1;
283:           }
284:           #endif
285:           
286:           #ifdef _VFPF_D
287:           static _INLINE int dtoa(FILE *fp, long long d)
288:           {
289:               int i, p, s, w;
290:               long long n;
291:           
292:               /* Record sign, get absolute value */
293:               n = d;
11660  C523     MOVFF grs, n
11662  F53B     NOP
11664  C524     MOVFF 0x524, 0x53C
11666  F53C     NOP
11668  C525     MOVFF 0x525, 0x53D
1166A  F53D     NOP
1166C  C526     MOVFF 0x526, 0x53E
1166E  F53E     NOP
11670  C527     MOVFF prod, 0x53F
11672  F53F     NOP
11674  C528     MOVFF 0x528, 0x540
11676  F540     NOP
11678  C529     MOVFF 0x529, 0x541
1167A  F541     NOP
1167C  C52A     MOVFF 0x52A, 0x542
1167E  F542     NOP
294:               s = n < 0 ? 1 : 0;
11680  AE42     BTFSS NVMLOCK, 7, ACCESS
11682  D002     BRA 0x1688
11684  0E01     MOVLW 0x1
11686  D001     BRA 0x168A
11688  0E00     MOVLW 0x0
1168A  6E39     MOVWF CLKRCON, ACCESS
1168C  6A3A     CLRF CLKRCLK, ACCESS
295:               if (s) {
1168E  5039     MOVF CLKRCON, W, ACCESS
11690  103A     IORWF CLKRCLK, W, ACCESS
11692  B4D8     BTFSC 0xFD8, 2, ACCESS
11694  D010     BRA 0x16B6
296:                   n = -n;
11696  1E42     COMF NVMLOCK, F, ACCESS
11698  1E41     COMF NVMCON1, F, ACCESS
1169A  1E40     COMF NVMCON0, F, ACCESS
1169C  1E3F     COMF 0x3F, F, ACCESS
1169E  1E3E     COMF 0x3E, F, ACCESS
116A0  1E3D     COMF 0x3D, F, ACCESS
116A2  1E3C     COMF 0x3C, F, ACCESS
116A4  6C3B     NEGF 0x3B, ACCESS
116A6  0E00     MOVLW 0x0
116A8  223C     ADDWFC 0x3C, F, ACCESS
116AA  223D     ADDWFC 0x3D, F, ACCESS
116AC  223E     ADDWFC 0x3E, F, ACCESS
116AE  223F     ADDWFC 0x3F, F, ACCESS
116B0  2240     ADDWFC NVMCON0, F, ACCESS
116B2  2241     ADDWFC NVMCON1, F, ACCESS
116B4  2242     ADDWFC NVMLOCK, F, ACCESS
297:               }
298:           
299:               /* Adjust flags, precision, width */
300:               if (!(prec < 0)) {
116B6  AFD2     BTFSS 0xD2, 7, BANKED
301:                   flags &= ~ZERO_FLAG;
116B8  93D3     BCF 0xD3, 1, BANKED
302:               }
303:               p = (0 < prec) ? prec : 1;
116BA  BFD2     BTFSC 0xD2, 7, BANKED
116BC  D005     BRA 0x16C8
116BE  51D2     MOVF 0xD2, W, BANKED
116C0  E108     BNZ 0x16D2
116C2  05D1     DECF 0xD1, W, BANKED
116C4  B0D8     BTFSC 0xFD8, 0, ACCESS
116C6  D005     BRA 0x16D2
116C8  0E00     MOVLW 0x0
116CA  6E36     MOVWF 0x36, ACCESS
116CC  0E01     MOVLW 0x1
116CE  6E35     MOVWF 0x35, ACCESS
116D0  D004     BRA 0x16DA
116D2  C5D1     MOVFF prec, sign1
116D4  F535     NOP
116D6  C5D2     MOVFF 0x5D2, exp1
116D8  F536     NOP
304:               w = width;
116DA  C5CF     MOVFF width, w
116DC  F537     NOP
116DE  C5D0     MOVFF 0x5D0, 0x538
116E0  F538     NOP
305:               if (s || (flags & PLUS_FLAG)) {
116E2  5039     MOVF CLKRCON, W, ACCESS
116E4  103A     IORWF CLKRCLK, W, ACCESS
116E6  A4D8     BTFSS 0xFD8, 2, ACCESS
116E8  D002     BRA 0x16EE
116EA  A5D3     BTFSS 0xD3, 2, BANKED
116EC  D003     BRA 0x16F4
306:                   --w;
116EE  0637     DECF 0x37, F, ACCESS
116F0  A0D8     BTFSS 0xFD8, 0, ACCESS
116F2  0638     DECF 0x38, F, ACCESS
307:               }
308:           
309:               /* Convert to decimal, possibly filling on the left with zeroes */
310:               i = sizeof(dbuf) - 1;
116F4  0E00     MOVLW 0x0
116F6  6E44     MOVWF NVMADRH, ACCESS
116F8  0E1F     MOVLW 0x1F
116FA  6E43     MOVWF NVMADR, ACCESS
311:               dbuf[i] = '\0';
116FC  0E00     MOVLW 0x0
116FE  0107     MOVLB 0x7
11700  6FDF     MOVWF CLCnGLS3, BANKED
312:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
11702  D07C     BRA 0x17FC
117FC  BE44     BTFSC NVMADRH, 7, ACCESS
117FE  D020     BRA 0x1840
11800  5044     MOVF NVMADRH, W, ACCESS
11802  E103     BNZ 0x180A
11804  0443     DECF NVMADR, W, ACCESS
11806  A0D8     BTFSS 0xFD8, 0, ACCESS
11808  D01B     BRA 0x1840
1180A  503B     MOVF 0x3B, W, ACCESS
1180C  103C     IORWF 0x3C, W, ACCESS
1180E  103D     IORWF 0x3D, W, ACCESS
11810  103E     IORWF 0x3E, W, ACCESS
11812  103F     IORWF 0x3F, W, ACCESS
11814  1040     IORWF NVMCON0, W, ACCESS
11816  1041     IORWF NVMCON1, W, ACCESS
11818  1042     IORWF NVMLOCK, W, ACCESS
1181A  A4D8     BTFSS 0xFD8, 2, ACCESS
1181C  D773     BRA 0x1704
1181E  BE36     BTFSC 0x36, 7, ACCESS
11820  D005     BRA 0x182C
11822  5036     MOVF 0x36, W, ACCESS
11824  E102     BNZ 0x182A
11826  0435     DECF 0x35, W, ACCESS
11828  B0D8     BTFSC 0xFD8, 0, ACCESS
1182A  D76C     BRA 0x1704
1182C  BE38     BTFSC 0x38, 7, ACCESS
1182E  D008     BRA 0x1840
11830  5038     MOVF 0x38, W, ACCESS
11832  E103     BNZ 0x183A
11834  0437     DECF 0x37, W, ACCESS
11836  A0D8     BTFSS 0xFD8, 0, ACCESS
11838  D003     BRA 0x1840
1183A  0105     MOVLB 0x5
1183C  B3D3     BTFSC 0xD3, 1, BANKED
1183E  D762     BRA 0x1704
313:                   --i;
11704  0643     DECF NVMADR, F, ACCESS
11706  A0D8     BTFSS 0xFD8, 0, ACCESS
11708  0644     DECF NVMADRH, F, ACCESS
314:                   dbuf[i] = (char)((int)'0' + abs(n % 10));
1170A  0EC0     MOVLW 0xC0
1170C  2443     ADDWF NVMADR, W, ACCESS
1170E  6ED9     MOVWF 0xFD9, ACCESS
11710  0E07     MOVLW 0x7
11712  2044     ADDWFC NVMADRH, W, ACCESS
11714  6EDA     MOVWF 0xFDA, ACCESS
11716  C53B     MOVFF n, InterruptHandler
11718  F506     NOP
1171A  C53C     MOVFF 0x53C, c
1171C  F507     NOP
1171E  C53D     MOVFF 0x53D, blockSize
11720  F508     NOP
11722  C53E     MOVFF 0x53E, td
11724  F509     NOP
11726  C53F     MOVFF 0x53F, data
11728  F50A     NOP
1172A  C540     MOVFF 0x540, elostr
1172C  F50B     NOP
1172E  C541     MOVFF 0x541, strptr
11730  F50C     NOP
11732  C542     MOVFF 0x542, d
11734  F50D     NOP
11736  0E0A     MOVLW 0xA
11738  6E0E     MOVWF 0xE, ACCESS
1173A  0E00     MOVLW 0x0
1173C  6E0F     MOVWF 0xF, ACCESS
1173E  0E00     MOVLW 0x0
11740  6E10     MOVWF 0x10, ACCESS
11742  0E00     MOVLW 0x0
11744  6E11     MOVWF 0x11, ACCESS
11746  0E00     MOVLW 0x0
11748  6E12     MOVWF 0x12, ACCESS
1174A  0E00     MOVLW 0x0
1174C  6E13     MOVWF 0x13, ACCESS
1174E  0E00     MOVLW 0x0
11750  6E14     MOVWF 0x14, ACCESS
11752  0E00     MOVLW 0x0
11754  6E15     MOVWF 0x15, ACCESS
11756  ECE7     CALL 0x11DCE, 0
11758  F08E     NOP
1175A  C506     MOVFF InterruptHandler, temp
1175C  F52B     NOP
1175E  C507     MOVFF c, 0x52C
11760  F52C     NOP
11762  C508     MOVFF blockSize, f1
11764  F52D     NOP
11766  C509     MOVFF td, 0x52E
11768  F52E     NOP
1176A  C50A     MOVFF data, 0x52F
1176C  F52F     NOP
1176E  C50B     MOVFF elostr, 0x530
11770  F530     NOP
11772  C50C     MOVFF strptr, 0x531
11774  F531     NOP
11776  C50D     MOVFF d, 0x532
11778  F532     NOP
1177A  C52B     MOVFF temp, a
1177C  F518     NOP
1177E  C52D     MOVFF f1, len
11780  F519     NOP
11782  EC31     CALL 0x13062, 0
11784  F098     NOP
11786  5018     MOVF 0x18, W, ACCESS
11788  0F30     ADDLW 0x30
1178A  6EDF     MOVWF 0xFDF, ACCESS
315:                   --p;
1178C  0635     DECF 0x35, F, ACCESS
1178E  A0D8     BTFSS 0xFD8, 0, ACCESS
11790  0636     DECF 0x36, F, ACCESS
316:                   --w;
11792  0637     DECF 0x37, F, ACCESS
11794  A0D8     BTFSS 0xFD8, 0, ACCESS
11796  0638     DECF 0x38, F, ACCESS
317:                   n = n / 10;
11798  C53B     MOVFF n, InterruptHandler
1179A  F506     NOP
1179C  C53C     MOVFF 0x53C, c
1179E  F507     NOP
117A0  C53D     MOVFF 0x53D, blockSize
117A2  F508     NOP
117A4  C53E     MOVFF 0x53E, td
117A6  F509     NOP
117A8  C53F     MOVFF 0x53F, data
117AA  F50A     NOP
117AC  C540     MOVFF 0x540, elostr
117AE  F50B     NOP
117B0  C541     MOVFF 0x541, strptr
117B2  F50C     NOP
117B4  C542     MOVFF 0x542, d
117B6  F50D     NOP
117B8  0E0A     MOVLW 0xA
117BA  6E0E     MOVWF 0xE, ACCESS
117BC  0E00     MOVLW 0x0
117BE  6E0F     MOVWF 0xF, ACCESS
117C0  0E00     MOVLW 0x0
117C2  6E10     MOVWF 0x10, ACCESS
117C4  0E00     MOVLW 0x0
117C6  6E11     MOVWF 0x11, ACCESS
117C8  0E00     MOVLW 0x0
117CA  6E12     MOVWF 0x12, ACCESS
117CC  0E00     MOVLW 0x0
117CE  6E13     MOVWF 0x13, ACCESS
117D0  0E00     MOVLW 0x0
117D2  6E14     MOVWF 0x14, ACCESS
117D4  0E00     MOVLW 0x0
117D6  6E15     MOVWF 0x15, ACCESS
117D8  ECA3     CALL 0x11B46, 0
117DA  F08D     NOP
117DC  C506     MOVFF InterruptHandler, n
117DE  F53B     NOP
117E0  C507     MOVFF c, 0x53C
117E2  F53C     NOP
117E4  C508     MOVFF blockSize, 0x53D
117E6  F53D     NOP
117E8  C509     MOVFF td, 0x53E
117EA  F53E     NOP
117EC  C50A     MOVFF data, 0x53F
117EE  F53F     NOP
117F0  C50B     MOVFF elostr, 0x540
117F2  F540     NOP
117F4  C50C     MOVFF strptr, 0x541
117F6  F541     NOP
117F8  C50D     MOVFF d, 0x542
117FA  F542     NOP
318:               }
319:           
320:               /* Display sign if required */
321:               if (s || (flags & PLUS_FLAG)) {
11840  5039     MOVF CLKRCON, W, ACCESS
11842  103A     IORWF CLKRCLK, W, ACCESS
11844  A4D8     BTFSS 0xFD8, 2, ACCESS
11846  D003     BRA 0x184E
11848  0105     MOVLB 0x5
1184A  A5D3     BTFSS 0xD3, 2, BANKED
1184C  D018     BRA 0x187E
322:                   --i;
1184E  0643     DECF NVMADR, F, ACCESS
11850  A0D8     BTFSS 0xFD8, 0, ACCESS
11852  0644     DECF NVMADRH, F, ACCESS
323:                   dbuf[i] = s ? '-' : '+';
11854  5039     MOVF CLKRCON, W, ACCESS
11856  103A     IORWF CLKRCLK, W, ACCESS
11858  A4D8     BTFSS 0xFD8, 2, ACCESS
1185A  D004     BRA 0x1864
1185C  0E00     MOVLW 0x0
1185E  6E34     MOVWF 0x34, ACCESS
11860  0E2B     MOVLW 0x2B
11862  D003     BRA 0x186A
11864  0E00     MOVLW 0x0
11866  6E34     MOVWF 0x34, ACCESS
11868  0E2D     MOVLW 0x2D
1186A  6E33     MOVWF 0x33, ACCESS
1186C  0EC0     MOVLW 0xC0
1186E  2443     ADDWF NVMADR, W, ACCESS
11870  6ED9     MOVWF 0xFD9, ACCESS
11872  0E07     MOVLW 0x7
11874  2044     ADDWFC NVMADRH, W, ACCESS
11876  6EDA     MOVWF 0xFDA, ACCESS
1187A  F4CC     NOP
1187C  F4DF     NOP
324:               }
325:           
326:               /* Put out padded string */
327:               return pad(fp, &dbuf[i], w);
1187E  C521     MOVFF aexp, counter
11880  F516     NOP
11882  C522     MOVFF bexp, sign
11884  F517     NOP
11886  0EC0     MOVLW 0xC0
11888  2443     ADDWF NVMADR, W, ACCESS
1188A  6E18     MOVWF 0x18, ACCESS
1188C  0E07     MOVLW 0x7
1188E  2044     ADDWFC NVMADRH, W, ACCESS
11890  6E19     MOVWF 0x19, ACCESS
11892  C537     MOVFF w, p
11894  F51A     NOP
11896  C538     MOVFF 0x538, i
11898  F51B     NOP
1189A  ECAA     CALL 0x12554, 0
1189C  F092     NOP
1189E  C516     MOVFF counter, aexp
118A0  F521     NOP
118A2  C517     MOVFF sign, bexp
118A4  F522     NOP
328:           }
118A6  0012     RETURN 0
329:           #endif
330:           
331:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
332:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
333:           {
334:               char mode, nmode;
335:               int d, e, i, m, n, ne, p, pp, sign, t, w;
336:               long double g, h, l, ou, u;
337:           
338:               /* Record sign, get absolute value */
339:               sign = 0;
340:               g = f;
341:               if (g < 0.0) {
342:                   sign = 1;
343:                   g = -g;
344:               }
345:           
346:               /* Print sign */
347:               n = 0;
348:               w = width;
349:               if (sign || (flags & PLUS_FLAG)) {
350:                   dbuf[n] = sign ? '-' : '+';
351:                   ++n;
352:                   --w;
353:               }
354:           
355:               /* Catch infinities, NaNs here */
356:               if (isinf(g)) {
357:                   if (isupper((int)c)) {
358:                       strcpy(&dbuf[n], "INF");
359:                   } else {
360:                       strcpy(&dbuf[n], "inf");
361:                   }
362:                   w -= CSTRLEN("inf");
363:                   return pad(fp, &dbuf[0], w);
364:               }
365:               if (isnan(g)) {
366:                   if (isupper((int)c)) {
367:                       strcpy(&dbuf[n], "NAN");
368:                   } else {
369:                       strcpy(&dbuf[n], "nan");
370:                   }
371:                   w -= CSTRLEN("inf");
372:                   return pad(fp, &dbuf[0], w);
373:               }
374:           
375:               /* First find the largest power of 10 not larger than number to print */
376:               u = 1.0;
377:               e = 0;
378:               if (!(g == 0.0)) {
379:                   while (!(g < (u*10.0))) {
380:                       u = u*10.0;
381:                       ++e;
382:                   }
383:                   while (g < u) {
384:                       u = u/10.0;
385:                       --e;
386:                   }
387:               }
388:           
389:               /* Get mode, precision */
390:               mode = (char)tolower((int)c);
391:               nmode = mode;
392:               if (mode == 'g') {
393:           		if (prec == 0) {
394:           			prec = 1;
395:           		}
396:                   p = (0 < prec) ? prec : 6;
397:               } else {
398:                   p = (prec < 0) ? 6 : prec;
399:               }
400:           
401:               /* Choose e or f mode from g mode */
402:               if (mode == 'g') {
403:                   if (!(e < -4) && !((p - 1) < e)) {
404:                       nmode = 'f';
405:                   } else {
406:                       nmode = 'e';
407:                   }
408:               }
409:           
410:               /* Decimal places or significant digits */
411:               m = p;
412:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
413:                   ++m;
414:               }
415:           
416:               /* Adjust starting exponent, string length for 'f' conversions */
417:               if (nmode == 'f') {
418:                   if (e < 0) {
419:                       u = 1.0;
420:                       e = 0;
421:                   }
422:                   if (!(mode == 'g')) {
423:                       m += e;
424:                   }
425:               }
426:           
427:               /* Go through the conversion once to get to the rounding step */
428:               i = 0;
429:               h = g;
430:               ou = u;
431:               while (i < m) {
432:                   l = floor(h/u);
433:                   d = (int)l;
434:                   h -= l*u;
435:                   u = u/10.0;
436:                   ++i;
437:               }
438:               
439:               /* Remainder >= halfway ? */
440:               l = u*5.0;
441:               if (h < l) {
442:                   l = 0.0;
443:               } else {
444:                   /* On tie choose even number */
445:                   if ((h == l) && !(d % 2)) {
446:                       l = 0.0;
447:                   }
448:               }
449:           
450:               /* Round */
451:               h = g + l;
452:               /* Has rounding increased the power above 10^0? */
453:           	if (h >= (ou*10.0)) {
454:           		e++;
455:           		ou *= 10.0;
456:           		if (nmode == 'f') {
457:           			// the increase in power will only affect the number of digits in 'f' mode
458:           			m++;
459:           		}
460:           	}
461:               
462:               /* Convert again, after rounding */
463:               u = ou;
464:               ne = (nmode == 'e') ? 0 : e;
465:               pp = 0;
466:               t = 0;
467:               i = 0;
468:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
469:                   l = floor(h/u);
470:                   d = (int)l;
471:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
472:                       ++t;
473:                   } else {
474:                       if (!pp && (ne < 0)) {
475:                           dbuf[n++] = '.';
476:                           --w;
477:                           pp = 1;
478:                       }
479:                       while (t) {
480:                           dbuf[n++] = '0';
481:                           --w;
482:                           --t;
483:                       }
484:                       dbuf[n++] = (char)((int)'0' + d);
485:                       --w;
486:                   }
487:                   h -= l*u;
488:                   u = u/10.0;
489:                   --ne;
490:                   ++i;
491:               }
492:               if (!pp && (flags & POUND_FLAG)) {
493:                   dbuf[n++] = '.';
494:               }
495:               dbuf[n] = '\0';
496:           
497:               /* Convert exponent */
498:               if (nmode == 'e') {
499:                   i = sizeof(dbuf) - 1;
500:                   dbuf[i] = '\0';
501:                   sign = 0;
502:                   if (e < 0) {
503:                       sign = 1;
504:                       e = -e;
505:                   }
506:                   p = 2;
507:                   while (e || (0 < p)) {
508:                       --i;
509:                       dbuf[i] = '0' + (e % 10);
510:                       e = e / 10;
511:                       --p;
512:                       --w;
513:                   }
514:                   --i;
515:                   dbuf[i] = sign ? '-' : '+';
516:                   --w;
517:                   --i;
518:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
519:                   --w;
520:                   strcpy(&dbuf[n], &dbuf[i]);
521:               }
522:           
523:               /* Put out padded string */
524:               return pad(fp, &dbuf[0], w);
525:           }
526:           #endif
527:           
528:           #ifdef _VFPF_O
529:           static _INLINE int otoa(FILE *fp, unsigned long long d)
530:           {
531:               int i, p, t, w;
532:               unsigned long long n;
533:           
534:               /* Adjust flags, precision, width */
535:               if (!(prec < 0)) {
536:                   flags &= ~ZERO_FLAG;
537:               }
538:               p = (0 < prec) ? prec : 1;
539:               w = width;
540:           
541:               /* Convert to octal, possibly filling on the left with zeroes */
542:               n = d;
543:               i = sizeof(dbuf) - 1;
544:               dbuf[i] = '\0';
545:               t = 0;
546:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
547:                   --i;
548:                   t = n & 07;
549:                   dbuf[i] = (char)((int)'0' + t);
550:                   --p;
551:                   --w;
552:                   n = n >> 3;
553:               }
554:           
555:               /* Display prefix if required */
556:               if ((flags & POUND_FLAG) && t) {
557:                   --i;
558:                   dbuf[i] = '0';
559:                   --w;
560:               }
561:           
562:               /* Put out padded string */
563:               return pad(fp, &dbuf[i], w);
564:           }
565:           #endif
566:           
567:           #ifdef _VFPF_S
568:           static _INLINE int stoa(FILE *fp, char *s)
569:           {
570:               char *cp, nuls[] = "(null)";
119FE  EE21     LFSR 2, 0x6CE
11A00  F2CE     NOP
11A02  EE11     LFSR 1, 0x514
11A04  F114     NOP
11A06  0E06     MOVLW 0x6
11A08  C4DB     MOVFF PLUSW2, PLUSW1
11A0A  F4E3     NOP
11A0C  06E8     DECF 0xFE8, F, ACCESS
11A0E  E2FC     BC 0x1A08
571:               int i, l, p, w;
572:           
573:               /* Check for null string */
574:               cp = s;
11A10  C511     MOVFF fp, cp
11A12  F51F     NOP
11A14  C512     MOVFF sum, sign
11A16  F520     NOP
575:               if (!cp) {
11A18  501F     MOVF 0x1F, W, ACCESS
11A1A  1020     IORWF 0x20, W, ACCESS
11A1C  A4D8     BTFSS 0xFD8, 2, ACCESS
11A1E  D004     BRA 0x1A28
576:                   cp = nuls;
11A20  0E14     MOVLW 0x14
11A22  6E1F     MOVWF 0x1F, ACCESS
11A24  0E05     MOVLW 0x5
11A26  6E20     MOVWF 0x20, ACCESS
577:               }
578:           
579:               /* Get length, precision, width */
580:               l = (int)strlen(cp);
11A28  C51F     MOVFF cp, InterruptHandler
11A2A  F506     NOP
11A2C  C520     MOVFF sign, c
11A2E  F507     NOP
11A30  ECA7     CALL 0x12D4E, 0
11A32  F096     NOP
11A34  C506     MOVFF InterruptHandler, grs
11A36  F523     NOP
11A38  C507     MOVFF c, 0x524
11A3A  F524     NOP
581:               p = prec;
11A3C  C5D1     MOVFF prec, aexp
11A3E  F521     NOP
11A40  C5D2     MOVFF 0x5D2, bexp
11A42  F522     NOP
582:               l = (!(p < 0) && (p < l)) ? p : l;
11A44  BE22     BTFSC 0x22, 7, ACCESS
11A46  D00E     BRA 0x1A64
11A48  5023     MOVF 0x23, W, ACCESS
11A4A  5C21     SUBWF 0x21, W, ACCESS
11A4C  5022     MOVF 0x22, W, ACCESS
11A4E  0A80     XORLW 0x80
11A50  6E13     MOVWF 0x13, ACCESS
11A52  5024     MOVF 0x24, W, ACCESS
11A54  0A80     XORLW 0x80
11A56  5813     SUBWFB 0x13, W, ACCESS
11A58  B0D8     BTFSC 0xFD8, 0, ACCESS
11A5A  D004     BRA 0x1A64
11A5C  C521     MOVFF aexp, grs
11A5E  F523     NOP
11A60  C522     MOVFF bexp, 0x524
11A62  F524     NOP
583:               p = l;
11A64  C523     MOVFF grs, aexp
11A66  F521     NOP
11A68  C524     MOVFF 0x524, bexp
11A6A  F522     NOP
584:               w = width;
11A6C  C5CF     MOVFF width, w
11A6E  F51D     NOP
11A70  C5D0     MOVFF 0x5D0, 0x51E
11A72  F51E     NOP
585:           
586:               /* Right justify, pad on left ? */
587:               if (!(flags & MINUS_FLAG)) {
11A74  0105     MOVLB 0x5
11A76  A1D3     BTFSS 0xD3, 0, BANKED
11A78  D00D     BRA 0x1A94
11A7A  D016     BRA 0x1AA8
588:                   while (l < w) {
11A94  501D     MOVF 0x1D, W, ACCESS
11A96  5C23     SUBWF 0x23, W, ACCESS
11A98  5024     MOVF 0x24, W, ACCESS
11A9A  0A80     XORLW 0x80
11A9C  6E13     MOVWF 0x13, ACCESS
11A9E  501E     MOVF 0x1E, W, ACCESS
11AA0  0A80     XORLW 0x80
11AA2  5813     SUBWFB 0x13, W, ACCESS
11AA4  A0D8     BTFSS 0xFD8, 0, ACCESS
11AA6  D7EA     BRA 0x1A7C
589:                       fputc(' ', fp);
11A7C  0E00     MOVLW 0x0
11A7E  6E07     MOVWF 0x7, ACCESS
11A80  0E20     MOVLW 0x20
11A82  6E06     MOVWF 0x6, ACCESS
11A84  C50F     MOVFF s, blockSize
11A86  F508     NOP
11A88  C510     MOVFF arg, td
11A8A  F509     NOP
11A8C  EC5D     CALL 0x122BA, 0
11A8E  F091     NOP
590:                       ++l;
11A90  4A23     INFSNZ 0x23, F, ACCESS
11A92  2A24     INCF 0x24, F, ACCESS
591:                   }
592:               }
593:           
594:               /* Put out string */
595:               i = 0;
11AA8  0E00     MOVLW 0x0
11AAA  6E1C     MOVWF 0x1C, ACCESS
11AAC  0E00     MOVLW 0x0
11AAE  6E1B     MOVWF 0x1B, ACCESS
596:               while (i < p) {
11AB0  D021     BRA 0x1AF4
11AF4  5021     MOVF 0x21, W, ACCESS
11AF6  5C1B     SUBWF 0x1B, W, ACCESS
11AF8  501C     MOVF 0x1C, W, ACCESS
11AFA  0A80     XORLW 0x80
11AFC  6E13     MOVWF 0x13, ACCESS
11AFE  5022     MOVF 0x22, W, ACCESS
11B00  0A80     XORLW 0x80
11B02  5813     SUBWFB 0x13, W, ACCESS
11B04  A0D8     BTFSS 0xFD8, 0, ACCESS
11B06  D7D5     BRA 0x1AB2
597:                   fputc(*cp, fp);
11AB4  F47C     NOP
11AB6  F4F6     NOP
11ABA  F480     NOP
11ABC  F4F7     NOP
11ABE  0E00     MOVLW 0x0
11AC0  6EF8     MOVWF 0xFF8, ACCESS
11AC2  0E25     MOVLW 0x25
11AC4  64F7     CPFSGT 0xFF7, ACCESS
11AC6  D003     BRA 0x1ACE
11AC8  0008     TBLRD*
11ACA  50F5     MOVF 0xFF5, W, ACCESS
11ACC  D005     BRA 0x1AD8
11ACE  C4F6     MOVFF TBLPTR, FSR1
11AD0  F4E1     NOP
11AD2  C4F7     MOVFF TBLPTRH, FSR1H
11AD4  F4E2     NOP
11AD6  50E7     MOVF 0xFE7, W, ACCESS
11AD8  6E13     MOVWF 0x13, ACCESS
11ADA  5013     MOVF 0x13, W, ACCESS
11ADC  6E06     MOVWF 0x6, ACCESS
11ADE  6A07     CLRF 0x7, ACCESS
11AE0  C50F     MOVFF s, blockSize
11AE2  F508     NOP
11AE4  C510     MOVFF arg, td
11AE6  F509     NOP
11AE8  EC5D     CALL 0x122BA, 0
11AEA  F091     NOP
598:                   ++cp;
11AEC  4A1F     INFSNZ 0x1F, F, ACCESS
11AEE  2A20     INCF 0x20, F, ACCESS
599:                   ++i;
11AF0  4A1B     INFSNZ 0x1B, F, ACCESS
11AF2  2A1C     INCF 0x1C, F, ACCESS
600:               }
601:           
602:               /* Left justify, pad on right ? */
603:               if (flags & MINUS_FLAG) {
11B08  0105     MOVLB 0x5
11B0A  B1D3     BTFSC 0xD3, 0, BANKED
11B0C  D00D     BRA 0x1B28
11B0E  D016     BRA 0x1B3C
604:                   while (l < w) {
11B28  501D     MOVF 0x1D, W, ACCESS
11B2A  5C23     SUBWF 0x23, W, ACCESS
11B2C  5024     MOVF 0x24, W, ACCESS
11B2E  0A80     XORLW 0x80
11B30  6E13     MOVWF 0x13, ACCESS
11B32  501E     MOVF 0x1E, W, ACCESS
11B34  0A80     XORLW 0x80
11B36  5813     SUBWFB 0x13, W, ACCESS
11B38  A0D8     BTFSS 0xFD8, 0, ACCESS
11B3A  D7EA     BRA 0x1B10
605:                       fputc(' ', fp);
11B10  0E00     MOVLW 0x0
11B12  6E07     MOVWF 0x7, ACCESS
11B14  0E20     MOVLW 0x20
11B16  6E06     MOVWF 0x6, ACCESS
11B18  C50F     MOVFF s, blockSize
11B1A  F508     NOP
11B1C  C510     MOVFF arg, td
11B1E  F509     NOP
11B20  EC5D     CALL 0x122BA, 0
11B22  F091     NOP
606:                       ++l;
11B24  4A23     INFSNZ 0x23, F, ACCESS
11B26  2A24     INCF 0x24, F, ACCESS
607:                   }
608:               }
609:           
610:               return l;
11B3C  C523     MOVFF grs, s
11B3E  F50F     NOP
11B40  C524     MOVFF 0x524, arg
11B42  F510     NOP
611:           }
11B44  0012     RETURN 0
612:           #endif
613:           
614:           #ifdef _VFPF_U
615:           static _INLINE int utoa(FILE *fp, unsigned long long d)
616:           {
617:               int i, p, w;
618:               unsigned long long n;
619:           
620:               /* Adjust flags, precision, width */
621:               if (!(prec < 0)) {
622:                   flags &= ~ZERO_FLAG;
623:               }
624:               p = (0 < prec) ? prec : 1;
625:               w = width;
626:           
627:               /* Convert to decimal, possibly filling on the left with zeroes */
628:               n = d;
629:               i = sizeof(dbuf) - 1;
630:               dbuf[i] = '\0';
631:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
632:                   --i;
633:                   dbuf[i] = '0' + (n % 10);
634:                   --p;
635:                   --w;
636:                   n = n / 10;
637:               }
638:           
639:               /* Put out padded string */
640:               return pad(fp, &dbuf[i], w);
641:           }
642:           #endif
643:           
644:           #if defined(_VFPF_X) || defined(_VFPF_P)
645:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
646:           {
647:               int c, i, p, w;
648:               unsigned long long n;
649:           
650:               /* Adjust, flags, precision, width */
651:               if (!(prec < 0)) {
652:                   flags &= ~ZERO_FLAG;
653:               }
654:               p = (0 < prec) ? prec : 1;
655:               w = width;
656:               if (flags & POUND_FLAG) {
657:                   w -= 2;
658:               }
659:           
660:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
661:               n = d;
662:               i = sizeof(dbuf) - 1;
663:               dbuf[i] = '\0';
664:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
665:                   --i;
666:                   c = n & 0x0f;
667:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
668:                   if (isupper((int)x) && isalpha(c)) {
669:                       c = toupper(c);
670:                   }
671:                   dbuf[i] = (char)c;
672:                   --p;
673:                   --w;
674:                   n = n >> 4;
675:               }
676:           
677:               /* Display prefix if required */
678:               if (flags & POUND_FLAG) {
679:                   --i;
680:                   dbuf[i] = x;
681:                   --i;
682:                   dbuf[i] = '0';
683:               }
684:           
685:               /* Put out padded string */
686:               return pad(fp, &dbuf[i], w);
687:           }
688:           #endif
689:           
690:           /* Consume and convert the next part of the format string */
691:           #ifdef _VFPF_CONVERT
692:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
693:           {
694:               char c, *cp, ct[3];
695:               int done, i;
696:               long long ll;
697:               unsigned long long llu;
698:               long double f;
699:               void *vp;
700:           
701:               /* Conversion ? */
702:               if ((*fmt)[0] == '%') {
1140C  F51C     NOP
1140E  F4D9     NOP
11412  F520     NOP
11414  F4DA     NOP
11416  C4DE     MOVFF POSTINC2, TBLPTR
11418  F4F6     NOP
1141A  C4DD     MOVFF POSTDEC2, TBLPTRH
1141C  F4F7     NOP
1141E  0E00     MOVLW 0x0
11420  6EF8     MOVWF 0xFF8, ACCESS
11422  0008     TBLRD*
11424  50F5     MOVF 0xFF5, W, ACCESS
11426  0A25     XORLW 0x25
11428  A4D8     BTFSS 0xFD8, 2, ACCESS
1142A  D0FA     BRA 0x1620
703:                   ++*fmt;
1142E  F51C     NOP
11430  F4D9     NOP
11434  F520     NOP
11436  F4DA     NOP
11438  2ADE     INCF 0xFDE, F, ACCESS
1143A  0E00     MOVLW 0x0
1143C  22DD     ADDWFC 0xFDD, F, ACCESS
704:           
705:                   flags = width = 0;
1143E  0E00     MOVLW 0x0
11440  6FD0     MOVWF 0xD0, BANKED
11442  0E00     MOVLW 0x0
11444  6FCF     MOVWF 0xCF, BANKED
11446  C5CF     MOVFF width, flags
11448  F5D3     NOP
1144A  C5D0     MOVFF 0x5D0, 0x5D4
1144C  F5D4     NOP
706:                   prec = -1;
1144E  69D1     SETF 0xD1, BANKED
11450  69D2     SETF 0xD2, BANKED
707:           
708:           #ifdef _VFPF_FLAGS
709:                   /* Get flags */
710:                   done = 0;
711:                   while (!done) {
712:                       switch ((*fmt)[0]) {
713:                           case '-' :
714:                               flags |= MINUS_FLAG;
715:                               ++*fmt;
716:                               break;
717:                           case '0' :
718:                               flags |= ZERO_FLAG;
719:                               ++*fmt;
720:                               break;
721:                           case '+' :
722:                               flags |= PLUS_FLAG;
723:                               ++*fmt;
724:                               break;
725:                           case ' ' :
726:                               flags |= SPACE_FLAG;
727:                               ++*fmt;
728:                               break;
729:                           case '#' :
730:                               flags |= POUND_FLAG;
731:                               ++*fmt;
732:                               break;
733:                           default:
734:                               done = 1;
735:                               break;
736:                       }
737:                   }
738:                   if (flags & MINUS_FLAG) {
739:                       flags &= ~ZERO_FLAG;
740:                   }
741:           #endif
742:           
743:           #ifdef _VFPF_WIDTH
744:                   /* Get field width */
745:                   if ((*fmt)[0] == '*') {
746:                       ++*fmt;
747:                       width = va_arg(ap, int);
748:                       if (width < 0) {
749:                           flags |= MINUS_FLAG;
750:                           width = -width;
751:                       }
752:                   } else {
753:                       width = atoi(*fmt);
754:                       while (isdigit((*fmt)[0])) {
755:                           ++*fmt;
756:                       }
757:                   }
758:           #endif
759:           
760:           #ifdef _VFPF_PRECISION
761:                   /* Get precision */
762:                   if ((*fmt)[0] == '.') {
763:                       prec = 0;
764:                       ++*fmt;
765:                       if ((*fmt)[0] == '*') {
766:                           ++*fmt;
767:                           prec = va_arg(ap, int);
768:                       } else {
769:                           prec = atoi(*fmt);
770:                           while (isdigit((*fmt)[0])) {
771:                               ++*fmt;
772:                           }
773:                       }
774:                   }
775:           #endif
776:           
777:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
778:                   /* Case-folded conversion types */
779:                   ct[0] = (char)tolower((int)(*fmt)[0]);
780:                   if (ct[0]) {
781:                       ct[1] = (char)tolower((int)(*fmt)[1]);
782:                       if (ct[1]) {
783:                           ct[2] = (char)tolower((int)(*fmt)[2]);
784:                       }
785:                   }
786:           #endif
787:           
788:           #ifdef _VFPF_A
789:                   /* 'a' style (hex) floating point */
790:                   if (ct[0] == 'a') {
791:           
792:                       c = (*fmt)[0];
793:                       ++*fmt;
794:                       f = (long double)va_arg(ap, double);
795:                                   
796:                       return atoa(fp, f, c);
797:                   }
798:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
799:           
800:                       c = (*fmt)[1];
801:                       if (isupper((int)(*fmt)[0])) {
802:                           f = va_arg(ap, long double);
803:                       } else {
804:                           f = (long double)va_arg(ap, double);
805:                       }
806:                       *fmt += CSTRLEN("la");
807:                                   
808:                       return atoa(fp, f, c);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_C
813:                   /* Character */
814:                   if (*fmt[0] == 'c') {
815:                       ++*fmt;
816:                       c = (unsigned char)va_arg(ap, int);
817:                       return ctoa(fp, c);
818:                   }
819:           #endif
820:           
821:           #ifdef _VFPF_D
822:           #ifdef _VFPF_HH
823:                   /* Character decimal integer */
824:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
825:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
826:           
827:                       *fmt += CSTRLEN("hhd");
828:                       ll = (long long)(signed char)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           #endif
833:           
834:           #ifdef _VFPF_H
835:                   /* Short decimal integer */
836:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
837:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
838:           
839:                       *fmt += CSTRLEN("hd");
840:                       ll = (long long)(short)va_arg(ap, int);
841:                                   
842:                       return dtoa(fp, ll);
843:                   }
844:           #endif
845:           
846:                   /* Decimal integer */
847:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
11454  F51C     NOP
11456  F4D9     NOP
1145A  F520     NOP
1145C  F4DA     NOP
1145E  C4DE     MOVFF POSTINC2, TBLPTR
11460  F4F6     NOP
11462  C4DD     MOVFF POSTDEC2, TBLPTRH
11464  F4F7     NOP
11466  0E00     MOVLW 0x0
11468  6EF8     MOVWF 0xFF8, ACCESS
1146A  0008     TBLRD*
1146C  50F5     MOVF 0xFF5, W, ACCESS
1146E  0A64     XORLW 0x64
11470  B4D8     BTFSC 0xFD8, 2, ACCESS
11472  D011     BRA 0x1496
11476  F51C     NOP
11478  F4D9     NOP
1147C  F520     NOP
1147E  F4DA     NOP
11480  C4DE     MOVFF POSTINC2, TBLPTR
11482  F4F6     NOP
11484  C4DD     MOVFF POSTDEC2, TBLPTRH
11486  F4F7     NOP
11488  0E00     MOVLW 0x0
1148A  6EF8     MOVWF 0xFF8, ACCESS
1148C  0008     TBLRD*
1148E  50F5     MOVF 0xFF5, W, ACCESS
11490  0A69     XORLW 0x69
11492  A4D8     BTFSS 0xFD8, 2, ACCESS
11494  D049     BRA 0x1528
848:           
849:                       ++*fmt;
11498  F51C     NOP
1149A  F4D9     NOP
1149E  F520     NOP
114A0  F4DA     NOP
114A2  2ADE     INCF 0xFDE, F, ACCESS
114A4  0E00     MOVLW 0x0
114A6  22DD     ADDWFC 0xFDD, F, ACCESS
850:                       ll = (long long)va_arg(ap, int);
114AA  F524     NOP
114AC  F4D9     NOP
114B0  F528     NOP
114B2  F4DA     NOP
114B6  F37C     NOP
114B8  F54B     NOP
114BA  0E02     MOVLW 0x2
114BC  26DE     ADDWF 0xFDE, F, ACCESS
114C0  F37C     NOP
114C2  F54C     NOP
114C4  0E00     MOVLW 0x0
114C6  22DD     ADDWFC 0xFDD, F, ACCESS
114CA  F52C     NOP
114CC  F4D9     NOP
114D0  F530     NOP
114D2  F4DA     NOP
114D6  F378     NOP
114D8  F560     NOP
114DC  F374     NOP
114DE  F561     NOP
114E0  0E00     MOVLW 0x0
114E2  BF61     BTFSC PMD1, 7, BANKED
114E4  0EFF     MOVLW 0xFF
114E6  6F62     MOVWF 0x62, BANKED
114E8  6F63     MOVWF PMD3, BANKED
114EA  6F64     MOVWF PMD4, BANKED
114EC  6F65     MOVWF PMD5, BANKED
114EE  6F66     MOVWF PMD6, BANKED
114F0  6F67     MOVWF PMD7, BANKED
851:                                   
852:                       return dtoa(fp, ll);
114F2  C545     MOVFF fp, aexp
114F4  F521     NOP
114F6  C546     MOVFF 0x546, bexp
114F8  F522     NOP
114FA  C560     MOVFF __pcstackBANK5, grs
114FC  F523     NOP
114FE  C561     MOVFF 0x561, 0x524
11500  F524     NOP
11502  C562     MOVFF 0x562, 0x525
11504  F525     NOP
11506  C563     MOVFF 0x563, 0x526
11508  F526     NOP
1150A  C564     MOVFF 0x564, prod
1150C  F527     NOP
1150E  C565     MOVFF 0x565, 0x528
11510  F528     NOP
11512  C566     MOVFF 0x566, 0x529
11514  F529     NOP
11516  C567     MOVFF 0x567, 0x52A
11518  F52A     NOP
1151A  EC30     CALL 0x11660, 0
1151C  F08B     NOP
1151E  C521     MOVFF aexp, fp
11520  F545     NOP
11522  C522     MOVFF bexp, 0x546
11524  F546     NOP
11526  0012     RETURN 0
853:                   }
854:           
855:           #ifdef _VFPF_L
856:                   /* Long decimal integer */
857:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
858:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
859:           
860:                       *fmt += CSTRLEN("ld");
861:                       ll = (long long)va_arg(ap, long);
862:                                   
863:                       return dtoa(fp, ll);
864:                   }
865:           #endif
866:           
867:           #ifdef _VFPF_LL
868:                   /* Long long decimal integer */
869:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
870:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
871:           
872:                       *fmt += CSTRLEN("lld");
873:                       ll = va_arg(ap, long long);
874:                                   
875:                       return dtoa(fp, ll);
876:                   }
877:           #endif
878:           
879:           #ifdef _VFPF_J
880:                   /* intmax_t decimal integer */
881:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
882:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
883:           
884:                       *fmt += CSTRLEN("jd");
885:                       ll = (long long)va_arg(ap, intmax_t);
886:                                   
887:                       return dtoa(fp, ll);
888:                   }
889:           #endif
890:           
891:           #ifdef _VFPF_T
892:                   /* ptrdiff_t decimal integer */
893:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
894:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
895:           
896:                       *fmt += CSTRLEN("td");
897:                       ll = (long long)va_arg(ap, ptrdiff_t);
898:                                   
899:                       return dtoa(fp, ll);
900:                   }
901:           #endif
902:           
903:           #ifdef _VFPF_Z
904:                   /* size_t decimal integer */
905:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
906:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
907:           
908:                       *fmt += CSTRLEN("zd");
909:                       ll = (long long)va_arg(ap, size_t);
910:                                   
911:                       return dtoa(fp, ll);
912:                   }
913:           #endif
914:           #endif
915:           
916:           #ifdef _VFPF_E
917:                   /* 'e' style floating point */
918:                   if (ct[0] == 'e') {
919:           
920:                       c = (*fmt)[0];
921:                       ++*fmt;
922:                       f = (long double)va_arg(ap, double);
923:                                   
924:                       return efgtoa(fp, f, c);
925:                   }
926:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
927:           
928:                       c = (*fmt)[1];
929:                       if (isupper((int)(*fmt)[0])) {
930:                           f = va_arg(ap, long double);
931:                       } else {
932:                           f = (long double)va_arg(ap, double);
933:                       }
934:                       *fmt += CSTRLEN("lf");
935:                                   
936:                       return efgtoa(fp, f, c);
937:                   }
938:           #endif
939:           
940:           #ifdef _VFPF_F
941:                   /* 'f' style floating point */
942:                   if (ct[0] == 'f') {
943:           
944:                       c = (*fmt)[0];
945:                       ++*fmt;
946:                       f = (long double)va_arg(ap, double);
947:                                   
948:                       return efgtoa(fp, f, c);
949:                   }
950:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
951:           
952:                       c = (*fmt)[1];
953:                       if (isupper((int)(*fmt)[0])) {
954:                           f = va_arg(ap, long double);
955:                       } else {
956:                           f = (long double)va_arg(ap, double);
957:                       }
958:                       *fmt += CSTRLEN("lf");
959:                                   
960:                       return efgtoa(fp, f, c);
961:                   }
962:           #endif
963:           
964:           #ifdef _VFPF_G
965:                   /* 'g' style floating point */
966:                   if (ct[0] == 'g') {
967:           
968:                       c = (*fmt)[0];
969:                       ++*fmt;
970:                       f = (long double)va_arg(ap, double);
971:                                   
972:                       return efgtoa(fp, f, c);
973:                   }
974:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
975:           
976:                       c = (*fmt)[1];
977:                       if (isupper((int)(*fmt)[0])) {
978:                           f = va_arg(ap, long double);
979:                       } else {
980:                           f = (long double)va_arg(ap, double);
981:                       }
982:                       *fmt += CSTRLEN("lg");
983:                                   
984:                       return efgtoa(fp, f, c);
985:                   }
986:           #endif
987:           
988:           #ifdef _VFPF_O
989:           #ifdef _VFPF_HH
990:                   /* Character octal integer */
991:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
992:           
993:                       *fmt += CSTRLEN("hho");
994:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
995:                                   
996:                       return otoa(fp, llu);
997:                   }
998:           #endif
999:           
1000:          #ifdef _VFPF_H
1001:                  /* Short octal integer */
1002:                  if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
1003:          
1004:                      *fmt += CSTRLEN("ho");
1005:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1006:                                  
1007:                      return otoa(fp, llu);
1008:                  }
1009:          #endif
1010:          
1011:                  /* Octal integer */
1012:                  if (*fmt[0] == 'o') {
1013:          
1014:                      ++*fmt;
1015:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1016:                                  
1017:                      return otoa(fp, llu);
1018:                  }
1019:          
1020:          #ifdef _VFPF_L
1021:                  /* Long octal integer */
1022:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1023:          
1024:                      *fmt += CSTRLEN("lo");
1025:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_LL
1032:                  /* Long long octal integer */
1033:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1034:          
1035:                      *fmt += CSTRLEN("llo");
1036:                      llu = va_arg(ap, unsigned long long);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_J
1043:                  /* uintmax_t octal integer */
1044:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1045:          
1046:                      *fmt += CSTRLEN("jo");
1047:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          
1053:          #ifdef _VFPF_T
1054:                  /* ptrdiff_t octal integer */
1055:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1056:          
1057:                      *fmt += CSTRLEN("to");
1058:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1059:                                  
1060:                      return otoa(fp, llu);
1061:                  }
1062:          #endif
1063:          
1064:          #ifdef _VFPF_Z
1065:                  /* size_t octal integer */
1066:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1067:          
1068:                      *fmt += CSTRLEN("zo");
1069:                      llu = (unsigned long long)va_arg(ap, size_t);
1070:                                  
1071:                      return otoa(fp, llu);
1072:                  }
1073:          #endif
1074:          #endif
1075:          
1076:                  /* Character count */
1077:          #ifdef _VFPF_N
1078:          
1079:          #ifdef _VFPF_HH
1080:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1081:          
1082:                      *fmt += CSTRLEN("hhn");
1083:                      vp = (void *)va_arg(ap, char *);
1084:                      *(char *)vp = (char)nout;
1085:                      return 0;
1086:                  }
1087:          #endif
1088:          
1089:          #ifdef _VFPF_H
1090:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1091:          
1092:                      *fmt += CSTRLEN("hn");
1093:                      vp = (void *)va_arg(ap, short *);
1094:                      *(short *)vp = (short)nout;
1095:                      return 0;
1096:                  }
1097:          #endif
1098:          
1099:                  if (*fmt[0] == 'n') {
1100:                      ++*fmt;
1101:                      vp = (void *)va_arg(ap, int *);
1102:                      *(int *)vp = nout;
1103:                      return 0;
1104:                  }
1105:          
1106:          #ifdef _VFPF_L
1107:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1108:          
1109:                      *fmt += CSTRLEN("ln");
1110:                      vp = (void *)va_arg(ap, long *);
1111:                      *(long *)vp = (long)nout;
1112:                      return 0;
1113:                  }
1114:          #endif
1115:          
1116:          #ifdef _VFPF_LL
1117:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1118:          
1119:                      *fmt += CSTRLEN("lln");
1120:                      vp = (void *)va_arg(ap, long long *);
1121:                      *(long long *)vp = (long long)nout;
1122:                      return 0;
1123:                  }
1124:          #endif
1125:          
1126:          #ifdef _VFPF_J
1127:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1128:          
1129:                      *fmt += CSTRLEN("jn");
1130:                      vp = (void *)va_arg(ap, uintmax_t *);
1131:                      *(uintmax_t *)vp = (uintmax_t)nout;
1132:                      return 0;
1133:                  }
1134:          #endif
1135:          
1136:          #ifdef _VFPF_T
1137:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1138:          
1139:                      *fmt += CSTRLEN("tn");
1140:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1141:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1142:                      return 0;
1143:                  }
1144:          #endif
1145:          
1146:          #ifdef _VFPF_Z
1147:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1148:          
1149:                      *fmt += CSTRLEN("zn");
1150:                      vp = (void *)va_arg(ap, size_t *);
1151:                      *(size_t *)vp = (size_t)nout;
1152:                      return 0;
1153:                  }
1154:          #endif
1155:          
1156:          #endif
1157:          
1158:          #ifdef _VFPF_P
1159:                  /* Pointer */
1160:                  if (*fmt[0] == 'p') {
1161:          
1162:                      ++*fmt;
1163:                      llu = (unsigned long long)(uintptr_t)va_arg(ap, void *);
1164:                                  
1165:                      return xtoa(fp, llu, 'x');
1166:                  }
1167:          #endif
1168:          
1169:          #ifdef _VFPF_S
1170:                  /* String */
1171:                  if (*fmt[0] == 's') {
1152A  F51C     NOP
1152C  F4D9     NOP
11530  F520     NOP
11532  F4DA     NOP
11534  C4DE     MOVFF POSTINC2, TBLPTR
11536  F4F6     NOP
11538  C4DD     MOVFF POSTDEC2, TBLPTRH
1153A  F4F7     NOP
1153C  0E00     MOVLW 0x0
1153E  6EF8     MOVWF 0xFF8, ACCESS
11540  0008     TBLRD*
11542  50F5     MOVF 0xFF5, W, ACCESS
11544  0A73     XORLW 0x73
11546  A4D8     BTFSS 0xFD8, 2, ACCESS
11548  D034     BRA 0x15B2
1172:          
1173:                      ++*fmt;
1154C  F51C     NOP
1154E  F4D9     NOP
11552  F520     NOP
11554  F4DA     NOP
11556  2ADE     INCF 0xFDE, F, ACCESS
11558  0E00     MOVLW 0x0
1155A  22DD     ADDWFC 0xFDD, F, ACCESS
1174:                      cp = va_arg(ap, char *);
1155E  F524     NOP
11560  F4D9     NOP
11564  F528     NOP
11566  F4DA     NOP
1156A  F37C     NOP
1156C  F54B     NOP
1156E  0E02     MOVLW 0x2
11570  26DE     ADDWF 0xFDE, F, ACCESS
11574  F37C     NOP
11576  F54C     NOP
11578  0E00     MOVLW 0x0
1157A  22DD     ADDWFC 0xFDD, F, ACCESS
1157E  F52C     NOP
11580  F4D9     NOP
11584  F530     NOP
11586  F4DA     NOP
1158A  F378     NOP
1158C  F568     NOP
11590  F374     NOP
11592  F569     NOP
1175:          
1176:                      return stoa(fp, cp);
11594  C545     MOVFF fp, s
11596  F50F     NOP
11598  C546     MOVFF 0x546, arg
1159A  F510     NOP
1159C  C568     MOVFF cp, fp
1159E  F511     NOP
115A0  C569     MOVFF 0x569, sum
115A2  F512     NOP
115A4  ECFF     CALL 0x119FE, 0
115A6  F08C     NOP
115A8  C50F     MOVFF s, fp
115AA  F545     NOP
115AC  C510     MOVFF arg, 0x546
115AE  F546     NOP
115B0  0012     RETURN 0
1177:                  }
1178:          #endif
1179:          
1180:          #ifdef _VFPF_U
1181:          #ifdef _VFPF_HH
1182:                  /* Unsigned character decimal integer */
1183:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1184:          
1185:                      *fmt += CSTRLEN("hhu");
1186:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1187:                                  
1188:                      return utoa(fp, llu);
1189:                  }
1190:          #endif
1191:          
1192:          #ifdef _VFPF_H
1193:                  /* Unsigned short decimal integer */
1194:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1195:          
1196:                      *fmt += CSTRLEN("hu");
1197:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1198:                                  
1199:                      return utoa(fp, llu);
1200:                  }
1201:          #endif
1202:          
1203:                  /* Unsigned decimal integer */
1204:                  if (*fmt[0] == 'u') {
1205:          
1206:                      ++*fmt;
1207:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1208:                                  
1209:                      return utoa(fp, llu);
1210:                  }
1211:          
1212:          #ifdef _VFPF_L
1213:                  /* Unsigned long decimal integer */
1214:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1215:          
1216:                      *fmt += CSTRLEN("lu");
1217:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_LL
1224:                  /* Unsigned long long decimal integer */
1225:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1226:          
1227:                      *fmt += CSTRLEN("llu");
1228:                      llu = va_arg(ap, unsigned long long);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_J
1235:                  /* uintmax_t decimal integer */
1236:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1237:          
1238:                      *fmt += CSTRLEN("ju");
1239:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          
1245:          #ifdef _VFPF_T
1246:                  /* ptrdiff_t decimal integer */
1247:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1248:          
1249:                      *fmt += CSTRLEN("tu");
1250:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1251:                                  
1252:                      return utoa(fp, llu);
1253:                  }
1254:          #endif
1255:          
1256:          #ifdef _VFPF_Z
1257:                  /* size_t decimal integer */
1258:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1259:          
1260:                      *fmt += CSTRLEN("zu");
1261:                      llu = (unsigned long long)va_arg(ap, size_t);
1262:                                  
1263:                      return utoa(fp, llu);
1264:                  }
1265:          #endif
1266:          #endif
1267:          
1268:          #ifdef _VFPF_X
1269:          #ifdef _VFPF_HH
1270:                  /* Character hexadecimal integer */
1271:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1272:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1273:          
1274:                      c = (*fmt)[2];
1275:                      *fmt += CSTRLEN("hhx");
1276:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1277:                                  
1278:                      return xtoa(fp, llu, c);
1279:                  }
1280:          #endif
1281:          
1282:          #ifdef _VFPF_H
1283:                  /* Short hexadecimal integer */
1284:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1285:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1286:          
1287:                      c = (*fmt)[1];
1288:                      *fmt += CSTRLEN("hx");
1289:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1290:                                  
1291:                      return xtoa(fp, llu, c);
1292:                  }
1293:          #endif
1294:          
1295:                  /* Hexadecimal integer */
1296:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1297:          
1298:                      c = (*fmt)[0];
1299:                      ++*fmt;
1300:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1301:                                  
1302:                      return xtoa(fp, llu, c);
1303:                  }
1304:          
1305:          #ifdef _VFPF_L
1306:                  /* Long hexadecimal integer */
1307:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1308:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1309:          
1310:                      c = (*fmt)[1];
1311:                      *fmt += CSTRLEN("lx");
1312:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1313:                                  
1314:                      return xtoa(fp, llu, c);
1315:                  }
1316:          #endif
1317:          
1318:          #ifdef _VFPF_LL
1319:                  /* Long long hexadecimal integer */
1320:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1321:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1322:          
1323:                      c = (*fmt)[2];
1324:                      *fmt += CSTRLEN("llx");
1325:                      llu = va_arg(ap, unsigned long long);
1326:                                  
1327:                      return xtoa(fp, llu, c);
1328:                  }
1329:          #endif
1330:          
1331:          #ifdef _VFPF_J
1332:                  /* uintmax_t hexadecimal integer */
1333:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1334:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1335:          
1336:                      c = (*fmt)[1];
1337:                      *fmt += CSTRLEN("jx");
1338:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1339:                                  
1340:                      return xtoa(fp, llu, c);
1341:                  }
1342:          #endif
1343:          
1344:          #ifdef _VFPF_T
1345:                  /* ptrdiff_t hexadecimal integer */
1346:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1347:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1348:          
1349:                      c = (*fmt)[1];
1350:                      *fmt += CSTRLEN("tx");
1351:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1352:                                  
1353:                      return xtoa(fp, llu, c);
1354:                  }
1355:          #endif
1356:          
1357:          #ifdef _VFPF_Z
1358:                  /* size_t hexadecimal integer */
1359:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1360:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1361:          
1362:                      c = (*fmt)[1];
1363:                      *fmt += CSTRLEN("zx");
1364:                      llu = (unsigned long long)va_arg(ap, size_t);
1365:                                  
1366:                      return xtoa(fp, llu, c);
1367:                  }
1368:          #endif
1369:          #endif
1370:          
1371:                  /* 'Escaped' '%' character */
1372:                  if ((*fmt)[0] == '%') {
115B4  F51C     NOP
115B6  F4D9     NOP
115BA  F520     NOP
115BC  F4DA     NOP
115BE  C4DE     MOVFF POSTINC2, TBLPTR
115C0  F4F6     NOP
115C2  C4DD     MOVFF POSTDEC2, TBLPTRH
115C4  F4F7     NOP
115C6  0E00     MOVLW 0x0
115C8  6EF8     MOVWF 0xFF8, ACCESS
115CA  0008     TBLRD*
115CC  50F5     MOVF 0xFF5, W, ACCESS
115CE  0A25     XORLW 0x25
115D0  A4D8     BTFSS 0xFD8, 2, ACCESS
115D2  D018     BRA 0x1604
1373:                      ++*fmt;
115D6  F51C     NOP
115D8  F4D9     NOP
115DC  F520     NOP
115DE  F4DA     NOP
115E0  2ADE     INCF 0xFDE, F, ACCESS
115E2  0E00     MOVLW 0x0
115E4  22DD     ADDWFC 0xFDD, F, ACCESS
1374:                      fputc((int)'%', fp);
115E6  0E00     MOVLW 0x0
115E8  6E07     MOVWF 0x7, ACCESS
115EA  0E25     MOVLW 0x25
115EC  6E06     MOVWF 0x6, ACCESS
115EE  C545     MOVFF fp, blockSize
115F0  F508     NOP
115F2  C546     MOVFF 0x546, td
115F4  F509     NOP
115F6  EC5D     CALL 0x122BA, 0
115F8  F091     NOP
1375:                      return 1;
115FA  0E00     MOVLW 0x0
115FC  6E46     MOVWF NVMDAT, ACCESS
115FE  0E01     MOVLW 0x1
11600  6E45     MOVWF NVMADRU, ACCESS
11602  0012     RETURN 0
1376:                  }
1377:          
1378:                  /* Unrecognized conversion */
1379:                  ++*fmt;
11606  F51C     NOP
11608  F4D9     NOP
1160C  F520     NOP
1160E  F4DA     NOP
11610  2ADE     INCF 0xFDE, F, ACCESS
11612  0E00     MOVLW 0x0
11614  22DD     ADDWFC 0xFDD, F, ACCESS
1380:                  return 0;
11616  0E00     MOVLW 0x0
11618  6E46     MOVWF NVMDAT, ACCESS
1161A  0E00     MOVLW 0x0
1161C  6E45     MOVWF NVMADRU, ACCESS
1161E  0012     RETURN 0
1381:              }
1382:          
1383:              /* No conversion, just intervening text */
1384:              fputc((int)(*fmt)[0], fp);
11622  F51C     NOP
11624  F4D9     NOP
11628  F520     NOP
1162A  F4DA     NOP
1162C  C4DE     MOVFF POSTINC2, TBLPTR
1162E  F4F6     NOP
11630  C4DD     MOVFF POSTDEC2, TBLPTRH
11632  F4F7     NOP
11634  0E00     MOVLW 0x0
11636  6EF8     MOVWF 0xFF8, ACCESS
11638  0008     TBLRD*
1163A  50F5     MOVF 0xFF5, W, ACCESS
1163C  6E06     MOVWF 0x6, ACCESS
1163E  6A07     CLRF 0x7, ACCESS
11640  C545     MOVFF fp, blockSize
11642  F508     NOP
11644  C546     MOVFF 0x546, td
11646  F509     NOP
11648  EC5D     CALL 0x122BA, 0
1164A  F091     NOP
1385:              ++*fmt;
1164E  F51C     NOP
11650  F4D9     NOP
11654  F520     NOP
11656  F4DA     NOP
11658  2ADE     INCF 0xFDE, F, ACCESS
1165A  0E00     MOVLW 0x0
1165C  22DD     ADDWFC 0xFDD, F, ACCESS
1165E  D7CD     BRA 0x15FA
1386:              return 1;
1387:          }
1388:          #endif
1389:          
1390:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1391:          {
1392:          #ifdef _VFPF_CONVERT
1393:              char *cfmt;
1394:          
1395:              cfmt = (char *)fmt;
12A1A  C56C     MOVFF fmt, cfmt
12A1C  F54D     NOP
12A1E  C56D     MOVFF 0x56D, 0x54E
12A20  F54E     NOP
1396:              nout = 0;
12A22  0E00     MOVLW 0x0
12A24  6FCE     MOVWF 0xCE, BANKED
12A26  0E00     MOVLW 0x0
12A28  6FCD     MOVWF 0xCD, BANKED
1397:              while (*cfmt) {
12A2A  D013     BRA 0x2A52
12A54  F534     NOP
12A56  F4F6     NOP
12A5A  F538     NOP
12A5C  F4F7     NOP
12A5E  0E00     MOVLW 0x0
12A60  6EF8     MOVWF 0xFF8, ACCESS
12A62  0008     TBLRD*
12A64  50F5     MOVF 0xFF5, W, ACCESS
12A66  0900     IORLW 0x0
12A68  A4D8     BTFSS 0xFD8, 2, ACCESS
12A6A  D7E0     BRA 0x2A2C
1398:                  nout += vfpfcnvrt(fp, &cfmt, ap);
12A2C  C56A     MOVFF fp, fp
12A2E  F545     NOP
12A30  C56B     MOVFF 0x56B, 0x546
12A32  F546     NOP
12A34  0E4D     MOVLW 0x4D
12A36  6E47     MOVWF NVMDATH, ACCESS
12A38  0E05     MOVLW 0x5
12A3A  6E48     MOVWF VREGCON, ACCESS
12A3C  C56E     MOVFF ap, ap
12A3E  F549     NOP
12A40  C56F     MOVFF 0x56F, 0x54A
12A42  F54A     NOP
12A44  EC05     CALL 0x1140A, 0
12A46  F08A     NOP
12A48  5045     MOVF NVMADRU, W, ACCESS
12A4A  0105     MOVLB 0x5
12A4C  27CD     ADDWF 0xCD, F, BANKED
12A4E  5046     MOVF NVMDAT, W, ACCESS
12A50  23CE     ADDWFC 0xCE, F, BANKED
1399:              }
1400:              return nout;
12A6C  C5CD     MOVFF nout, fp
12A6E  F56A     NOP
12A70  C5CE     MOVFF 0x5CE, 0x56B
12A72  F56B     NOP
1401:          #else
1402:              return fputs(fmt, fp);
1403:          #endif
1404:          }
12A74  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/aomod.c  -------------------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
11DCE  0E00     MOVLW 0x0
11DD0  6E17     MOVWF 0x17, ACCESS
15:            	if(dividend < 0) {
11DD2  AE0D     BTFSS 0xD, 7, ACCESS
11DD4  D012     BRA 0x1DFA
16:            		dividend = -dividend;
11DD6  1E0D     COMF 0xD, F, ACCESS
11DD8  1E0C     COMF 0xC, F, ACCESS
11DDA  1E0B     COMF 0xB, F, ACCESS
11DDC  1E0A     COMF 0xA, F, ACCESS
11DDE  1E09     COMF 0x9, F, ACCESS
11DE0  1E08     COMF 0x8, F, ACCESS
11DE2  1E07     COMF 0x7, F, ACCESS
11DE4  6C06     NEGF 0x6, ACCESS
11DE6  0E00     MOVLW 0x0
11DE8  2207     ADDWFC 0x7, F, ACCESS
11DEA  2208     ADDWFC 0x8, F, ACCESS
11DEC  2209     ADDWFC 0x9, F, ACCESS
11DEE  220A     ADDWFC 0xA, F, ACCESS
11DF0  220B     ADDWFC 0xB, F, ACCESS
11DF2  220C     ADDWFC 0xC, F, ACCESS
11DF4  220D     ADDWFC 0xD, F, ACCESS
17:            		sign = 1;
11DF6  0E01     MOVLW 0x1
11DF8  6E17     MOVWF 0x17, ACCESS
18:            	}
19:            	if(divisor < 0)
11DFA  AE15     BTFSS 0x15, 7, ACCESS
11DFC  D010     BRA 0x1E1E
20:            		divisor = -divisor;
11DFE  1E15     COMF 0x15, F, ACCESS
11E00  1E14     COMF 0x14, F, ACCESS
11E02  1E13     COMF 0x13, F, ACCESS
11E04  1E12     COMF 0x12, F, ACCESS
11E06  1E11     COMF 0x11, F, ACCESS
11E08  1E10     COMF 0x10, F, ACCESS
11E0A  1E0F     COMF 0xF, F, ACCESS
11E0C  6C0E     NEGF 0xE, ACCESS
11E0E  0E00     MOVLW 0x0
11E10  220F     ADDWFC 0xF, F, ACCESS
11E12  2210     ADDWFC 0x10, F, ACCESS
11E14  2211     ADDWFC 0x11, F, ACCESS
11E16  2212     ADDWFC 0x12, F, ACCESS
11E18  2213     ADDWFC 0x13, F, ACCESS
11E1A  2214     ADDWFC 0x14, F, ACCESS
11E1C  2215     ADDWFC 0x15, F, ACCESS
21:            	if(divisor != 0) {
11E1E  500E     MOVF 0xE, W, ACCESS
11E20  100F     IORWF 0xF, W, ACCESS
11E22  1010     IORWF 0x10, W, ACCESS
11E24  1011     IORWF 0x11, W, ACCESS
11E26  1012     IORWF 0x12, W, ACCESS
11E28  1013     IORWF 0x13, W, ACCESS
11E2A  1014     IORWF 0x14, W, ACCESS
11E2C  1015     IORWF 0x15, W, ACCESS
11E2E  B4D8     BTFSC 0xFD8, 2, ACCESS
11E30  D03C     BRA 0x1EAA
22:            		counter = 1;
11E32  0E01     MOVLW 0x1
11E34  6E16     MOVWF 0x16, ACCESS
23:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
11E36  D00A     BRA 0x1E4C
11E4C  AE15     BTFSS 0x15, 7, ACCESS
11E4E  D7F4     BRA 0x1E38
24:            			divisor <<= 1;
11E38  90D8     BCF 0xFD8, 0, ACCESS
11E3A  360E     RLCF 0xE, F, ACCESS
11E3C  360F     RLCF 0xF, F, ACCESS
11E3E  3610     RLCF 0x10, F, ACCESS
11E40  3611     RLCF 0x11, F, ACCESS
11E42  3612     RLCF 0x12, F, ACCESS
11E44  3613     RLCF 0x13, F, ACCESS
11E46  3614     RLCF 0x14, F, ACCESS
11E48  3615     RLCF 0x15, F, ACCESS
25:            			counter++;
11E4A  2A16     INCF 0x16, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
11E50  500E     MOVF 0xE, W, ACCESS
11E52  5C06     SUBWF 0x6, W, ACCESS
11E54  500F     MOVF 0xF, W, ACCESS
11E56  5807     SUBWFB 0x7, W, ACCESS
11E58  5010     MOVF 0x10, W, ACCESS
11E5A  5808     SUBWFB 0x8, W, ACCESS
11E5C  5011     MOVF 0x11, W, ACCESS
11E5E  5809     SUBWFB 0x9, W, ACCESS
11E60  5012     MOVF 0x12, W, ACCESS
11E62  580A     SUBWFB 0xA, W, ACCESS
11E64  5013     MOVF 0x13, W, ACCESS
11E66  580B     SUBWFB 0xB, W, ACCESS
11E68  5014     MOVF 0x14, W, ACCESS
11E6A  580C     SUBWFB 0xC, W, ACCESS
11E6C  5015     MOVF 0x15, W, ACCESS
11E6E  580D     SUBWFB 0xD, W, ACCESS
11E70  A0D8     BTFSS 0xFD8, 0, ACCESS
11E72  D010     BRA 0x1E94
29:            				dividend -= divisor;
11E74  500E     MOVF 0xE, W, ACCESS
11E76  5E06     SUBWF 0x6, F, ACCESS
11E78  500F     MOVF 0xF, W, ACCESS
11E7A  5A07     SUBWFB 0x7, F, ACCESS
11E7C  5010     MOVF 0x10, W, ACCESS
11E7E  5A08     SUBWFB 0x8, F, ACCESS
11E80  5011     MOVF 0x11, W, ACCESS
11E82  5A09     SUBWFB 0x9, F, ACCESS
11E84  5012     MOVF 0x12, W, ACCESS
11E86  5A0A     SUBWFB 0xA, F, ACCESS
11E88  5013     MOVF 0x13, W, ACCESS
11E8A  5A0B     SUBWFB 0xB, F, ACCESS
11E8C  5014     MOVF 0x14, W, ACCESS
11E8E  5A0C     SUBWFB 0xC, F, ACCESS
11E90  5015     MOVF 0x15, W, ACCESS
11E92  5A0D     SUBWFB 0xD, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
11E94  90D8     BCF 0xFD8, 0, ACCESS
11E96  3215     RRCF 0x15, F, ACCESS
11E98  3214     RRCF 0x14, F, ACCESS
11E9A  3213     RRCF 0x13, F, ACCESS
11E9C  3212     RRCF 0x12, F, ACCESS
11E9E  3211     RRCF 0x11, F, ACCESS
11EA0  3210     RRCF 0x10, F, ACCESS
11EA2  320F     RRCF 0xF, F, ACCESS
11EA4  320E     RRCF 0xE, F, ACCESS
31:            		} while(--counter != 0);
11EA6  2E16     DECFSZ 0x16, F, ACCESS
11EA8  D7D3     BRA 0x1E50
32:            	}
33:            	if(sign)
11EAA  5017     MOVF 0x17, W, ACCESS
11EAC  B4D8     BTFSC 0xFD8, 2, ACCESS
11EAE  D010     BRA 0x1ED0
34:            		dividend = -dividend;
11EB0  1E0D     COMF 0xD, F, ACCESS
11EB2  1E0C     COMF 0xC, F, ACCESS
11EB4  1E0B     COMF 0xB, F, ACCESS
11EB6  1E0A     COMF 0xA, F, ACCESS
11EB8  1E09     COMF 0x9, F, ACCESS
11EBA  1E08     COMF 0x8, F, ACCESS
11EBC  1E07     COMF 0x7, F, ACCESS
11EBE  6C06     NEGF 0x6, ACCESS
11EC0  0E00     MOVLW 0x0
11EC2  2207     ADDWFC 0x7, F, ACCESS
11EC4  2208     ADDWFC 0x8, F, ACCESS
11EC6  2209     ADDWFC 0x9, F, ACCESS
11EC8  220A     ADDWFC 0xA, F, ACCESS
11ECA  220B     ADDWFC 0xB, F, ACCESS
11ECC  220C     ADDWFC 0xC, F, ACCESS
11ECE  220D     ADDWFC 0xD, F, ACCESS
35:            	return dividend;
11ED0  C506     MOVFF InterruptHandler, InterruptHandler
11ED2  F506     NOP
11ED4  C507     MOVFF c, c
11ED6  F507     NOP
11ED8  C508     MOVFF blockSize, blockSize
11EDA  F508     NOP
11EDC  C509     MOVFF td, td
11EDE  F509     NOP
11EE0  C50A     MOVFF data, data
11EE2  F50A     NOP
11EE4  C50B     MOVFF elostr, elostr
11EE6  F50B     NOP
11EE8  C50C     MOVFF strptr, strptr
11EEA  F50C     NOP
11EEC  C50D     MOVFF d, d
11EEE  F50D     NOP
36:            }
11EF0  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/aodiv.c  -------------------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
11B46  0E00     MOVLW 0x0
11B48  6E17     MOVWF 0x17, ACCESS
16:            	if(divisor < 0) {
11B4A  AE15     BTFSS 0x15, 7, ACCESS
11B4C  D012     BRA 0x1B72
17:            		divisor = -divisor;
11B4E  1E15     COMF 0x15, F, ACCESS
11B50  1E14     COMF 0x14, F, ACCESS
11B52  1E13     COMF 0x13, F, ACCESS
11B54  1E12     COMF 0x12, F, ACCESS
11B56  1E11     COMF 0x11, F, ACCESS
11B58  1E10     COMF 0x10, F, ACCESS
11B5A  1E0F     COMF 0xF, F, ACCESS
11B5C  6C0E     NEGF 0xE, ACCESS
11B5E  0E00     MOVLW 0x0
11B60  220F     ADDWFC 0xF, F, ACCESS
11B62  2210     ADDWFC 0x10, F, ACCESS
11B64  2211     ADDWFC 0x11, F, ACCESS
11B66  2212     ADDWFC 0x12, F, ACCESS
11B68  2213     ADDWFC 0x13, F, ACCESS
11B6A  2214     ADDWFC 0x14, F, ACCESS
11B6C  2215     ADDWFC 0x15, F, ACCESS
18:            		sign = 1;
11B6E  0E01     MOVLW 0x1
11B70  6E17     MOVWF 0x17, ACCESS
19:            	}
20:            	if(dividend < 0) {
11B72  AE0D     BTFSS 0xD, 7, ACCESS
11B74  D012     BRA 0x1B9A
21:            		dividend = -dividend;
11B76  1E0D     COMF 0xD, F, ACCESS
11B78  1E0C     COMF 0xC, F, ACCESS
11B7A  1E0B     COMF 0xB, F, ACCESS
11B7C  1E0A     COMF 0xA, F, ACCESS
11B7E  1E09     COMF 0x9, F, ACCESS
11B80  1E08     COMF 0x8, F, ACCESS
11B82  1E07     COMF 0x7, F, ACCESS
11B84  6C06     NEGF 0x6, ACCESS
11B86  0E00     MOVLW 0x0
11B88  2207     ADDWFC 0x7, F, ACCESS
11B8A  2208     ADDWFC 0x8, F, ACCESS
11B8C  2209     ADDWFC 0x9, F, ACCESS
11B8E  220A     ADDWFC 0xA, F, ACCESS
11B90  220B     ADDWFC 0xB, F, ACCESS
11B92  220C     ADDWFC 0xC, F, ACCESS
11B94  220D     ADDWFC 0xD, F, ACCESS
22:            		sign ^= 1;
11B96  0E01     MOVLW 0x1
11B98  1A17     XORWF 0x17, F, ACCESS
23:            	}
24:            	quotient = 0;
11B9A  EE21     LFSR 2, 0x518
11B9C  F118     NOP
11B9E  0E07     MOVLW 0x7
11BA0  6ADE     CLRF 0xFDE, ACCESS
11BA2  06E8     DECF 0xFE8, F, ACCESS
11BA4  E2FD     BC 0x1BA0
25:            	if(divisor != 0) {
11BA6  500E     MOVF 0xE, W, ACCESS
11BA8  100F     IORWF 0xF, W, ACCESS
11BAA  1010     IORWF 0x10, W, ACCESS
11BAC  1011     IORWF 0x11, W, ACCESS
11BAE  1012     IORWF 0x12, W, ACCESS
11BB0  1013     IORWF 0x13, W, ACCESS
11BB2  1014     IORWF 0x14, W, ACCESS
11BB4  1015     IORWF 0x15, W, ACCESS
11BB6  B4D8     BTFSC 0xFD8, 2, ACCESS
11BB8  D046     BRA 0x1C46
26:            		counter = 1;
11BBA  0E01     MOVLW 0x1
11BBC  6E16     MOVWF 0x16, ACCESS
27:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
11BBE  D00A     BRA 0x1BD4
11BD4  AE15     BTFSS 0x15, 7, ACCESS
11BD6  D7F4     BRA 0x1BC0
28:            			divisor <<= 1;
11BC0  90D8     BCF 0xFD8, 0, ACCESS
11BC2  360E     RLCF 0xE, F, ACCESS
11BC4  360F     RLCF 0xF, F, ACCESS
11BC6  3610     RLCF 0x10, F, ACCESS
11BC8  3611     RLCF 0x11, F, ACCESS
11BCA  3612     RLCF 0x12, F, ACCESS
11BCC  3613     RLCF 0x13, F, ACCESS
11BCE  3614     RLCF 0x14, F, ACCESS
11BD0  3615     RLCF 0x15, F, ACCESS
29:            			counter++;
11BD2  2A16     INCF 0x16, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
11BD8  90D8     BCF 0xFD8, 0, ACCESS
11BDA  3618     RLCF 0x18, F, ACCESS
11BDC  3619     RLCF 0x19, F, ACCESS
11BDE  361A     RLCF 0x1A, F, ACCESS
11BE0  361B     RLCF 0x1B, F, ACCESS
11BE2  361C     RLCF 0x1C, F, ACCESS
11BE4  361D     RLCF 0x1D, F, ACCESS
11BE6  361E     RLCF 0x1E, F, ACCESS
11BE8  361F     RLCF 0x1F, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
11BEA  500E     MOVF 0xE, W, ACCESS
11BEC  5C06     SUBWF 0x6, W, ACCESS
11BEE  500F     MOVF 0xF, W, ACCESS
11BF0  5807     SUBWFB 0x7, W, ACCESS
11BF2  5010     MOVF 0x10, W, ACCESS
11BF4  5808     SUBWFB 0x8, W, ACCESS
11BF6  5011     MOVF 0x11, W, ACCESS
11BF8  5809     SUBWFB 0x9, W, ACCESS
11BFA  5012     MOVF 0x12, W, ACCESS
11BFC  580A     SUBWFB 0xA, W, ACCESS
11BFE  5013     MOVF 0x13, W, ACCESS
11C00  580B     SUBWFB 0xB, W, ACCESS
11C02  5014     MOVF 0x14, W, ACCESS
11C04  580C     SUBWFB 0xC, W, ACCESS
11C06  5015     MOVF 0x15, W, ACCESS
11C08  580D     SUBWFB 0xD, W, ACCESS
11C0A  A0D8     BTFSS 0xFD8, 0, ACCESS
11C0C  D011     BRA 0x1C30
34:            				dividend -= divisor;
11C0E  500E     MOVF 0xE, W, ACCESS
11C10  5E06     SUBWF 0x6, F, ACCESS
11C12  500F     MOVF 0xF, W, ACCESS
11C14  5A07     SUBWFB 0x7, F, ACCESS
11C16  5010     MOVF 0x10, W, ACCESS
11C18  5A08     SUBWFB 0x8, F, ACCESS
11C1A  5011     MOVF 0x11, W, ACCESS
11C1C  5A09     SUBWFB 0x9, F, ACCESS
11C1E  5012     MOVF 0x12, W, ACCESS
11C20  5A0A     SUBWFB 0xA, F, ACCESS
11C22  5013     MOVF 0x13, W, ACCESS
11C24  5A0B     SUBWFB 0xB, F, ACCESS
11C26  5014     MOVF 0x14, W, ACCESS
11C28  5A0C     SUBWFB 0xC, F, ACCESS
11C2A  5015     MOVF 0x15, W, ACCESS
11C2C  5A0D     SUBWFB 0xD, F, ACCESS
35:            				quotient |= 1;
11C2E  8018     BSF 0x18, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
11C30  90D8     BCF 0xFD8, 0, ACCESS
11C32  3215     RRCF 0x15, F, ACCESS
11C34  3214     RRCF 0x14, F, ACCESS
11C36  3213     RRCF 0x13, F, ACCESS
11C38  3212     RRCF 0x12, F, ACCESS
11C3A  3211     RRCF 0x11, F, ACCESS
11C3C  3210     RRCF 0x10, F, ACCESS
11C3E  320F     RRCF 0xF, F, ACCESS
11C40  320E     RRCF 0xE, F, ACCESS
38:            		} while(--counter != 0);
11C42  2E16     DECFSZ 0x16, F, ACCESS
11C44  D7C9     BRA 0x1BD8
39:            	}
40:            	if(sign)
11C46  5017     MOVF 0x17, W, ACCESS
11C48  B4D8     BTFSC 0xFD8, 2, ACCESS
11C4A  D010     BRA 0x1C6C
41:            		quotient = -quotient;
11C4C  1E1F     COMF 0x1F, F, ACCESS
11C4E  1E1E     COMF 0x1E, F, ACCESS
11C50  1E1D     COMF 0x1D, F, ACCESS
11C52  1E1C     COMF 0x1C, F, ACCESS
11C54  1E1B     COMF 0x1B, F, ACCESS
11C56  1E1A     COMF 0x1A, F, ACCESS
11C58  1E19     COMF 0x19, F, ACCESS
11C5A  6C18     NEGF 0x18, ACCESS
11C5C  0E00     MOVLW 0x0
11C5E  2219     ADDWFC 0x19, F, ACCESS
11C60  221A     ADDWFC 0x1A, F, ACCESS
11C62  221B     ADDWFC 0x1B, F, ACCESS
11C64  221C     ADDWFC 0x1C, F, ACCESS
11C66  221D     ADDWFC 0x1D, F, ACCESS
11C68  221E     ADDWFC 0x1E, F, ACCESS
11C6A  221F     ADDWFC 0x1F, F, ACCESS
42:            	return quotient;
11C6C  C518     MOVFF a, InterruptHandler
11C6E  F506     NOP
11C70  C519     MOVFF len, c
11C72  F507     NOP
11C74  C51A     MOVFF p, blockSize
11C76  F508     NOP
11C78  C51B     MOVFF i, td
11C7A  F509     NOP
11C7C  C51C     MOVFF 0x51C, data
11C7E  F50A     NOP
11C80  C51D     MOVFF w, elostr
11C82  F50B     NOP
11C84  C51E     MOVFF 0x51E, strptr
11C86  F50C     NOP
11C88  C51F     MOVFF cp, d
11C8A  F50D     NOP
43:            }
11C8C  0012     RETURN 0
---  /opt/microchip/xc8/v2.31/pic/sources/c99/common/abs.c  ---------------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
13062  BE19     BTFSC 0x19, 7, ACCESS
13064  D005     BRA 0x3070
13066  5019     MOVF 0x19, W, ACCESS
13068  E110     BNZ 0x308A
1306A  0418     DECF 0x18, W, ACCESS
1306C  B0D8     BTFSC 0xFD8, 0, ACCESS
1306E  D00D     BRA 0x308A
13070  C518     MOVFF a, p
13072  F51A     NOP
13074  C519     MOVFF len, i
13076  F51B     NOP
13078  1E1A     COMF 0x1A, F, ACCESS
1307A  1E1B     COMF 0x1B, F, ACCESS
1307C  4A1A     INFSNZ 0x1A, F, ACCESS
1307E  2A1B     INCF 0x1B, F, ACCESS
13080  C51A     MOVFF p, a
13082  F518     NOP
13084  C51B     MOVFF i, len
13086  F519     NOP
13088  0012     RETURN 0
1308A  C518     MOVFF a, a
1308C  F518     NOP
1308E  C519     MOVFF len, len
13090  F519     NOP
4:             }
13092  0012     RETURN 0
